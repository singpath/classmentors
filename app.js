!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], ["74","76","77","4","75","78","73","79"], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('3', ['4', '2'], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    /*! 
     * angular-loading-bar v0.8.0
     * https://chieffancypants.github.io/angular-loading-bar
     * Copyright (c) 2015 Wes Cruver
     * License: MIT
     */
    /*
     * angular-loading-bar
     *
     * intercepts XHR requests and creates a loading bar.
     * Based on the excellent nprogress work by rstacruz (more info in readme)
     *
     * (c) 2013 Wes Cruver
     * License: MIT
     */

    (function () {

      'use strict';

      // Alias the loading bar for various backwards compatibilities since the project has matured:

      angular.module('angular-loading-bar', ['cfp.loadingBarInterceptor']);
      angular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);

      /**
       * loadingBarInterceptor service
       *
       * Registers itself as an Angular interceptor and listens for XHR requests.
       */
      angular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar']).config(['$httpProvider', function ($httpProvider) {

        var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function ($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {

          /**
           * The total number of requests made
           */
          var reqsTotal = 0;

          /**
           * The number of requests completed (either successfully or not)
           */
          var reqsCompleted = 0;

          /**
           * The amount of time spent fetching before showing the loading bar
           */
          var latencyThreshold = cfpLoadingBar.latencyThreshold;

          /**
           * $timeout handle for latencyThreshold
           */
          var startTimeout;

          /**
           * calls cfpLoadingBar.complete() which removes the
           * loading bar from the DOM.
           */
          function setComplete() {
            $timeout.cancel(startTimeout);
            cfpLoadingBar.complete();
            reqsCompleted = 0;
            reqsTotal = 0;
          }

          /**
           * Determine if the response has already been cached
           * @param  {Object}  config the config option from the request
           * @return {Boolean} retrns true if cached, otherwise false
           */
          function isCached(config) {
            var cache;
            var defaultCache = $cacheFactory.get('$http');
            var defaults = $httpProvider.defaults;

            // Choose the proper cache source. Borrowed from angular: $http service
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache;
            }

            var cached = cache !== undefined ? cache.get(config.url) !== undefined : false;

            if (config.cached !== undefined && cached !== config.cached) {
              return config.cached;
            }
            config.cached = cached;
            return cached;
          }

          return {
            'request': function (config) {
              // Check to make sure this request hasn't already been cached and that
              // the requester didn't explicitly ask us to ignore this request:
              if (!config.ignoreLoadingBar && !isCached(config)) {
                $rootScope.$broadcast('cfpLoadingBar:loading', { url: config.url });
                if (reqsTotal === 0) {
                  startTimeout = $timeout(function () {
                    cfpLoadingBar.start();
                  }, latencyThreshold);
                }
                reqsTotal++;
                cfpLoadingBar.set(reqsCompleted / reqsTotal);
              }
              return config;
            },

            'response': function (response) {
              if (!response || !response.config) {
                $log.error('Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
                return response;
              }

              if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
                reqsCompleted++;
                $rootScope.$broadcast('cfpLoadingBar:loaded', { url: response.config.url, result: response });
                if (reqsCompleted >= reqsTotal) {
                  setComplete();
                } else {
                  cfpLoadingBar.set(reqsCompleted / reqsTotal);
                }
              }
              return response;
            },

            'responseError': function (rejection) {
              if (!rejection || !rejection.config) {
                $log.error('Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50');
                return $q.reject(rejection);
              }

              if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
                reqsCompleted++;
                $rootScope.$broadcast('cfpLoadingBar:loaded', { url: rejection.config.url, result: rejection });
                if (reqsCompleted >= reqsTotal) {
                  setComplete();
                } else {
                  cfpLoadingBar.set(reqsCompleted / reqsTotal);
                }
              }
              return $q.reject(rejection);
            }
          };
        }];

        $httpProvider.interceptors.push(interceptor);
      }]);

      /**
       * Loading Bar
       *
       * This service handles adding and removing the actual element in the DOM.
       * Generally, best practices for DOM manipulation is to take place in a
       * directive, but because the element itself is injected in the DOM only upon
       * XHR requests, and it's likely needed on every view, the best option is to
       * use a service.
       */
      angular.module('cfp.loadingBar', []).provider('cfpLoadingBar', function () {

        this.autoIncrement = true;
        this.includeSpinner = true;
        this.includeBar = true;
        this.latencyThreshold = 100;
        this.startSize = 0.02;
        this.parentSelector = 'body';
        this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
        this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';

        this.$get = ['$injector', '$document', '$timeout', '$rootScope', function ($injector, $document, $timeout, $rootScope) {
          var $animate;
          var $parentSelector = this.parentSelector,
              loadingBarContainer = angular.element(this.loadingBarTemplate),
              loadingBar = loadingBarContainer.find('div').eq(0),
              spinner = angular.element(this.spinnerTemplate);

          var incTimeout,
              completeTimeout,
              started = false,
              status = 0;

          var autoIncrement = this.autoIncrement;
          var includeSpinner = this.includeSpinner;
          var includeBar = this.includeBar;
          var startSize = this.startSize;

          /**
           * Inserts the loading bar element into the dom, and sets it to 2%
           */
          function _start() {
            if (!$animate) {
              $animate = $injector.get('$animate');
            }

            var $parent = $document.find($parentSelector).eq(0);
            $timeout.cancel(completeTimeout);

            // do not continually broadcast the started event:
            if (started) {
              return;
            }

            $rootScope.$broadcast('cfpLoadingBar:started');
            started = true;

            if (includeBar) {
              $animate.enter(loadingBarContainer, $parent, angular.element($parent[0].lastChild));
            }

            if (includeSpinner) {
              $animate.enter(spinner, $parent, angular.element($parent[0].lastChild));
            }

            _set(startSize);
          }

          /**
           * Set the loading bar's width to a certain percent.
           *
           * @param n any value between 0 and 1
           */
          function _set(n) {
            if (!started) {
              return;
            }
            var pct = n * 100 + '%';
            loadingBar.css('width', pct);
            status = n;

            // increment loadingbar to give the illusion that there is always
            // progress but make sure to cancel the previous timeouts so we don't
            // have multiple incs running at the same time.
            if (autoIncrement) {
              $timeout.cancel(incTimeout);
              incTimeout = $timeout(function () {
                _inc();
              }, 250);
            }
          }

          /**
           * Increments the loading bar by a random amount
           * but slows down as it progresses
           */
          function _inc() {
            if (_status() >= 1) {
              return;
            }

            var rnd = 0;

            // TODO: do this mathmatically instead of through conditions

            var stat = _status();
            if (stat >= 0 && stat < 0.25) {
              // Start out between 3 - 6% increments
              rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;
            } else if (stat >= 0.25 && stat < 0.65) {
              // increment between 0 - 3%
              rnd = Math.random() * 3 / 100;
            } else if (stat >= 0.65 && stat < 0.9) {
              // increment between 0 - 2%
              rnd = Math.random() * 2 / 100;
            } else if (stat >= 0.9 && stat < 0.99) {
              // finally, increment it .5 %
              rnd = 0.005;
            } else {
              // after 99%, don't increment:
              rnd = 0;
            }

            var pct = _status() + rnd;
            _set(pct);
          }

          function _status() {
            return status;
          }

          function _completeAnimation() {
            status = 0;
            started = false;
          }

          function _complete() {
            if (!$animate) {
              $animate = $injector.get('$animate');
            }

            $rootScope.$broadcast('cfpLoadingBar:completed');
            _set(1);

            $timeout.cancel(completeTimeout);

            // Attempt to aggregate any start/complete calls within 500ms:
            completeTimeout = $timeout(function () {
              var promise = $animate.leave(loadingBarContainer, _completeAnimation);
              if (promise && promise.then) {
                promise.then(_completeAnimation);
              }
              $animate.leave(spinner);
            }, 500);
          }

          return {
            start: _start,
            set: _set,
            status: _status,
            inc: _inc,
            complete: _complete,
            autoIncrement: this.autoIncrement,
            includeSpinner: this.includeSpinner,
            latencyThreshold: this.latencyThreshold,
            parentSelector: this.parentSelector,
            startSize: this.startSize
          };
        }]; //
      }); // wtf javascript. srsly
    })(); //
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('5', [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // HumanizeDuration.js - http://git.io/j0HgmQ

    ;(function () {
      var languages = {
        ar: {
          y: function (c) {
            return c === 1 ? 'سنة' : 'سنوات';
          },
          mo: function (c) {
            return c === 1 ? 'شهر' : 'أشهر';
          },
          w: function (c) {
            return c === 1 ? 'أسبوع' : 'أسابيع';
          },
          d: function (c) {
            return c === 1 ? 'يوم' : 'أيام';
          },
          h: function (c) {
            return c === 1 ? 'ساعة' : 'ساعات';
          },
          m: function (c) {
            return c === 1 ? 'دقيقة' : 'دقائق';
          },
          s: function (c) {
            return c === 1 ? 'ثانية' : 'ثواني';
          },
          ms: function (c) {
            return c === 1 ? 'جزء من الثانية' : 'أجزاء من الثانية';
          },
          decimal: ','
        },
        ca: {
          y: function (c) {
            return 'any' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return 'mes' + (c !== 1 ? 'os' : '');
          },
          w: function (c) {
            return 'setman' + (c !== 1 ? 'es' : 'a');
          },
          d: function (c) {
            return 'di' + (c !== 1 ? 'es' : 'a');
          },
          h: function (c) {
            return 'hor' + (c !== 1 ? 'es' : 'a');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'segon' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milisegon' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        cs: {
          y: function (c) {
            return ['rok', 'roku', 'roky', 'let'][getCzechForm(c)];
          },
          mo: function (c) {
            return ['měsíc', 'měsíce', 'měsíce', 'měsíců'][getCzechForm(c)];
          },
          w: function (c) {
            return ['týden', 'týdne', 'týdny', 'týdnů'][getCzechForm(c)];
          },
          d: function (c) {
            return ['den', 'dne', 'dny', 'dní'][getCzechForm(c)];
          },
          h: function (c) {
            return ['hodina', 'hodiny', 'hodiny', 'hodin'][getCzechForm(c)];
          },
          m: function (c) {
            return ['minuta', 'minuty', 'minuty', 'minut'][getCzechForm(c)];
          },
          s: function (c) {
            return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getCzechForm(c)];
          },
          ms: function (c) {
            return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getCzechForm(c)];
          },
          decimal: ','
        },
        da: {
          y: 'år',
          mo: function (c) {
            return 'måned' + (c !== 1 ? 'er' : '');
          },
          w: function (c) {
            return 'uge' + (c !== 1 ? 'r' : '');
          },
          d: function (c) {
            return 'dag' + (c !== 1 ? 'e' : '');
          },
          h: function (c) {
            return 'time' + (c !== 1 ? 'r' : '');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 'ter' : '');
          },
          s: function (c) {
            return 'sekund' + (c !== 1 ? 'er' : '');
          },
          ms: function (c) {
            return 'millisekund' + (c !== 1 ? 'er' : '');
          },
          decimal: ','
        },
        de: {
          y: function (c) {
            return 'Jahr' + (c !== 1 ? 'e' : '');
          },
          mo: function (c) {
            return 'Monat' + (c !== 1 ? 'e' : '');
          },
          w: function (c) {
            return 'Woche' + (c !== 1 ? 'n' : '');
          },
          d: function (c) {
            return 'Tag' + (c !== 1 ? 'e' : '');
          },
          h: function (c) {
            return 'Stunde' + (c !== 1 ? 'n' : '');
          },
          m: function (c) {
            return 'Minute' + (c !== 1 ? 'n' : '');
          },
          s: function (c) {
            return 'Sekunde' + (c !== 1 ? 'n' : '');
          },
          ms: function (c) {
            return 'Millisekunde' + (c !== 1 ? 'n' : '');
          },
          decimal: ','
        },
        en: {
          y: function (c) {
            return 'year' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return 'month' + (c !== 1 ? 's' : '');
          },
          w: function (c) {
            return 'week' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'day' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'hour' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minute' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'second' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'millisecond' + (c !== 1 ? 's' : '');
          },
          decimal: '.'
        },
        es: {
          y: function (c) {
            return 'año' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return 'mes' + (c !== 1 ? 'es' : '');
          },
          w: function (c) {
            return 'semana' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'día' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'hora' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minuto' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'segundo' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milisegundo' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        fi: {
          y: function (c) {
            return c === 1 ? 'vuosi' : 'vuotta';
          },
          mo: function (c) {
            return c === 1 ? 'kuukausi' : 'kuukautta';
          },
          w: function (c) {
            return 'viikko' + (c !== 1 ? 'a' : '');
          },
          d: function (c) {
            return 'päivä' + (c !== 1 ? 'ä' : '');
          },
          h: function (c) {
            return 'tunti' + (c !== 1 ? 'a' : '');
          },
          m: function (c) {
            return 'minuutti' + (c !== 1 ? 'a' : '');
          },
          s: function (c) {
            return 'sekunti' + (c !== 1 ? 'a' : '');
          },
          ms: function (c) {
            return 'millisekunti' + (c !== 1 ? 'a' : '');
          },
          decimal: ','
        },
        fr: {
          y: function (c) {
            return 'an' + (c !== 1 ? 's' : '');
          },
          mo: 'mois',
          w: function (c) {
            return 'semaine' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'jour' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'heure' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minute' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'seconde' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milliseconde' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        gr: {
          y: function (c) {
            return c === 1 ? 'χρόνος' : 'χρόνια';
          },
          mo: function (c) {
            return c === 1 ? 'μήνας' : 'μήνες';
          },
          w: function (c) {
            return c === 1 ? 'εβδομάδα' : 'εβδομάδες';
          },
          d: function (c) {
            return c === 1 ? 'μέρα' : 'μέρες';
          },
          h: function (c) {
            return c === 1 ? 'ώρα' : 'ώρες';
          },
          m: function (c) {
            return c === 1 ? 'λεπτό' : 'λεπτά';
          },
          s: function (c) {
            return c === 1 ? 'δευτερόλεπτο' : 'δευτερόλεπτα';
          },
          ms: function (c) {
            return c === 1 ? 'χιλιοστό του δευτερολέπτου' : 'χιλιοστά του δευτερολέπτου';
          },
          decimal: ','
        },
        hu: {
          y: 'év',
          mo: 'hónap',
          w: 'hét',
          d: 'nap',
          h: 'óra',
          m: 'perc',
          s: 'másodperc',
          ms: 'ezredmásodperc',
          decimal: ','
        },
        id: {
          y: 'tahun',
          mo: 'bulan',
          w: 'minggu',
          d: 'hari',
          h: 'jam',
          m: 'menit',
          s: 'detik',
          ms: 'milidetik',
          decimal: '.'
        },
        it: {
          y: function (c) {
            return 'ann' + (c !== 1 ? 'i' : 'o');
          },
          mo: function (c) {
            return 'mes' + (c !== 1 ? 'i' : 'e');
          },
          w: function (c) {
            return 'settiman' + (c !== 1 ? 'e' : 'a');
          },
          d: function (c) {
            return 'giorn' + (c !== 1 ? 'i' : 'o');
          },
          h: function (c) {
            return 'or' + (c !== 1 ? 'e' : 'a');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 'i' : 'o');
          },
          s: function (c) {
            return 'second' + (c !== 1 ? 'i' : 'o');
          },
          ms: function (c) {
            return 'millisecond' + (c !== 1 ? 'i' : 'o');
          },
          decimal: ','
        },
        ja: {
          y: '年',
          mo: '月',
          w: '週',
          d: '日',
          h: '時間',
          m: '分',
          s: '秒',
          ms: 'ミリ秒',
          decimal: '.'
        },
        ko: {
          y: '년',
          mo: '개월',
          w: '주일',
          d: '일',
          h: '시간',
          m: '분',
          s: '초',
          ms: '밀리 초',
          decimal: '.'
        },
        lt: {
          y: function (c) {
            return c % 10 === 0 || c % 100 >= 10 && c % 100 <= 20 ? 'metų' : 'metai';
          },
          mo: function (c) {
            return ['mėnuo', 'mėnesiai', 'mėnesių'][getLithuanianForm(c)];
          },
          w: function (c) {
            return ['savaitė', 'savaitės', 'savaičių'][getLithuanianForm(c)];
          },
          d: function (c) {
            return ['diena', 'dienos', 'dienų'][getLithuanianForm(c)];
          },
          h: function (c) {
            return ['valanda', 'valandos', 'valandų'][getLithuanianForm(c)];
          },
          m: function (c) {
            return ['minutė', 'minutės', 'minučių'][getLithuanianForm(c)];
          },
          s: function (c) {
            return ['sekundė', 'sekundės', 'sekundžių'][getLithuanianForm(c)];
          },
          ms: function (c) {
            return ['milisekundė', 'milisekundės', 'milisekundžių'][getLithuanianForm(c)];
          },
          decimal: ','
        },
        ms: {
          y: 'tahun',
          mo: 'bulan',
          w: 'minggu',
          d: 'hari',
          h: 'jam',
          m: 'minit',
          s: 'saat',
          ms: 'milisaat',
          decimal: '.'
        },
        nl: {
          y: 'jaar',
          mo: function (c) {
            return c === 1 ? 'maand' : 'maanden';
          },
          w: function (c) {
            return c === 1 ? 'week' : 'weken';
          },
          d: function (c) {
            return c === 1 ? 'dag' : 'dagen';
          },
          h: 'uur',
          m: function (c) {
            return c === 1 ? 'minuut' : 'minuten';
          },
          s: function (c) {
            return c === 1 ? 'seconde' : 'seconden';
          },
          ms: function (c) {
            return c === 1 ? 'milliseconde' : 'milliseconden';
          },
          decimal: ','
        },
        no: {
          y: 'år',
          mo: function (c) {
            return 'måned' + (c !== 1 ? 'er' : '');
          },
          w: function (c) {
            return 'uke' + (c !== 1 ? 'r' : '');
          },
          d: function (c) {
            return 'dag' + (c !== 1 ? 'er' : '');
          },
          h: function (c) {
            return 'time' + (c !== 1 ? 'r' : '');
          },
          m: function (c) {
            return 'minutt' + (c !== 1 ? 'er' : '');
          },
          s: function (c) {
            return 'sekund' + (c !== 1 ? 'er' : '');
          },
          ms: function (c) {
            return 'millisekund' + (c !== 1 ? 'er' : '');
          },
          decimal: ','
        },
        pl: {
          y: function (c) {
            return ['rok', 'roku', 'lata', 'lat'][getPolishForm(c)];
          },
          mo: function (c) {
            return ['miesiąc', 'miesiąca', 'miesiące', 'miesięcy'][getPolishForm(c)];
          },
          w: function (c) {
            return ['tydzień', 'tygodnia', 'tygodnie', 'tygodni'][getPolishForm(c)];
          },
          d: function (c) {
            return ['dzień', 'dnia', 'dni', 'dni'][getPolishForm(c)];
          },
          h: function (c) {
            return ['godzina', 'godziny', 'godziny', 'godzin'][getPolishForm(c)];
          },
          m: function (c) {
            return ['minuta', 'minuty', 'minuty', 'minut'][getPolishForm(c)];
          },
          s: function (c) {
            return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getPolishForm(c)];
          },
          ms: function (c) {
            return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getPolishForm(c)];
          },
          decimal: ','
        },
        pt: {
          y: function (c) {
            return 'ano' + (c !== 1 ? 's' : '');
          },
          mo: function (c) {
            return c !== 1 ? 'meses' : 'mês';
          },
          w: function (c) {
            return 'semana' + (c !== 1 ? 's' : '');
          },
          d: function (c) {
            return 'dia' + (c !== 1 ? 's' : '');
          },
          h: function (c) {
            return 'hora' + (c !== 1 ? 's' : '');
          },
          m: function (c) {
            return 'minuto' + (c !== 1 ? 's' : '');
          },
          s: function (c) {
            return 'segundo' + (c !== 1 ? 's' : '');
          },
          ms: function (c) {
            return 'milissegundo' + (c !== 1 ? 's' : '');
          },
          decimal: ','
        },
        ru: {
          y: function (c) {
            return ['лет', 'год', 'года'][getSlavicForm(c)];
          },
          mo: function (c) {
            return ['месяцев', 'месяц', 'месяца'][getSlavicForm(c)];
          },
          w: function (c) {
            return ['недель', 'неделя', 'недели'][getSlavicForm(c)];
          },
          d: function (c) {
            return ['дней', 'день', 'дня'][getSlavicForm(c)];
          },
          h: function (c) {
            return ['часов', 'час', 'часа'][getSlavicForm(c)];
          },
          m: function (c) {
            return ['минут', 'минута', 'минуты'][getSlavicForm(c)];
          },
          s: function (c) {
            return ['секунд', 'секунда', 'секунды'][getSlavicForm(c)];
          },
          ms: function (c) {
            return ['миллисекунд', 'миллисекунда', 'миллисекунды'][getSlavicForm(c)];
          },
          decimal: ','
        },
        uk: {
          y: function (c) {
            return ['років', 'рік', 'роки'][getSlavicForm(c)];
          },
          mo: function (c) {
            return ['місяців', 'місяць', 'місяці'][getSlavicForm(c)];
          },
          w: function (c) {
            return ['неділь', 'неділя', 'неділі'][getSlavicForm(c)];
          },
          d: function (c) {
            return ['днів', 'день', 'дні'][getSlavicForm(c)];
          },
          h: function (c) {
            return ['годин', 'година', 'години'][getSlavicForm(c)];
          },
          m: function (c) {
            return ['хвилин', 'хвилина', 'хвилини'][getSlavicForm(c)];
          },
          s: function (c) {
            return ['секунд', 'секунда', 'секунди'][getSlavicForm(c)];
          },
          ms: function (c) {
            return ['мілісекунд', 'мілісекунда', 'мілісекунди'][getSlavicForm(c)];
          },
          decimal: ','
        },
        sv: {
          y: 'år',
          mo: function (c) {
            return 'månad' + (c !== 1 ? 'er' : '');
          },
          w: function (c) {
            return 'veck' + (c !== 1 ? 'or' : 'a');
          },
          d: function (c) {
            return 'dag' + (c !== 1 ? 'ar' : '');
          },
          h: function (c) {
            return 'timm' + (c !== 1 ? 'ar' : 'e');
          },
          m: function (c) {
            return 'minut' + (c !== 1 ? 'er' : '');
          },
          s: function (c) {
            return 'sekund' + (c !== 1 ? 'er' : '');
          },
          ms: function (c) {
            return 'millisekund' + (c !== 1 ? 'er' : '');
          },
          decimal: ','
        },
        tr: {
          y: 'yıl',
          mo: 'ay',
          w: 'hafta',
          d: 'gün',
          h: 'saat',
          m: 'dakika',
          s: 'saniye',
          ms: 'milisaniye',
          decimal: ','
        },
        vi: {
          y: 'năm',
          mo: 'tháng',
          w: 'tuần',
          d: 'ngày',
          h: 'giờ',
          m: 'phút',
          s: 'giây',
          ms: 'mili giây',
          decimal: ','
        },
        zh_CN: {
          y: '年',
          mo: '个月',
          w: '周',
          d: '天',
          h: '小时',
          m: '分钟',
          s: '秒',
          ms: '毫秒',
          decimal: '.'
        },
        zh_TW: {
          y: '年',
          mo: '個月',
          w: '周',
          d: '天',
          h: '小時',
          m: '分鐘',
          s: '秒',
          ms: '毫秒',
          decimal: '.'
        }
      };

      // You can create a humanizer, which returns a function with default
      // parameters.
      function humanizer(passedOptions) {
        var result = function humanizer(ms, humanizerOptions) {
          var options = extend({}, result, humanizerOptions || {});
          return doHumanization(ms, options);
        };

        return extend(result, {
          language: 'en',
          delimiter: ', ',
          spacer: ' ',
          conjunction: '',
          serialComma: true,
          units: ['y', 'mo', 'w', 'd', 'h', 'm', 's'],
          languages: {},
          round: false,
          unitMeasures: {
            y: 31557600000,
            mo: 2629800000,
            w: 604800000,
            d: 86400000,
            h: 3600000,
            m: 60000,
            s: 1000,
            ms: 1
          }
        }, passedOptions);
      }

      // The main function is just a wrapper around a default humanizer.
      var humanizeDuration = humanizer({});

      // doHumanization does the bulk of the work.
      function doHumanization(ms, options) {
        var i, len, piece;

        // Make sure we have a positive number.
        // Has the nice sideffect of turning Number objects into primitives.
        ms = Math.abs(ms);

        var dictionary = options.languages[options.language] || languages[options.language];
        if (!dictionary) {
          throw new Error('No language ' + dictionary + '.');
        }

        var pieces = [];

        // Start at the top and keep removing units, bit by bit.
        var unitName, unitMS, unitCount;
        for (i = 0, len = options.units.length; i < len; i++) {
          unitName = options.units[i];
          unitMS = options.unitMeasures[unitName];

          // What's the number of full units we can fit?
          if (i + 1 === len) {
            unitCount = ms / unitMS;
          } else {
            unitCount = Math.floor(ms / unitMS);
          }

          // Add the string.
          pieces.push({
            unitCount: unitCount,
            unitName: unitName
          });

          // Remove what we just figured out.
          ms -= unitCount * unitMS;
        }

        var firstOccupiedUnitIndex = 0;
        for (i = 0; i < pieces.length; i++) {
          if (pieces[i].unitCount) {
            firstOccupiedUnitIndex = i;
            break;
          }
        }

        if (options.round) {
          var ratioToLargerUnit, previousPiece;
          for (i = pieces.length - 1; i >= 0; i--) {
            piece = pieces[i];
            piece.unitCount = Math.round(piece.unitCount);

            if (i === 0) {
              break;
            }

            previousPiece = pieces[i - 1];

            ratioToLargerUnit = options.unitMeasures[previousPiece.unitName] / options.unitMeasures[piece.unitName];
            if (piece.unitCount % ratioToLargerUnit === 0 || options.largest && options.largest - 1 < i - firstOccupiedUnitIndex) {
              previousPiece.unitCount += piece.unitCount / ratioToLargerUnit;
              piece.unitCount = 0;
            }
          }
        }

        var result = [];
        for (i = 0, pieces.length; i < len; i++) {
          piece = pieces[i];
          if (piece.unitCount) {
            result.push(render(piece.unitCount, piece.unitName, dictionary, options));
          }

          if (result.length === options.largest) {
            break;
          }
        }

        if (result.length) {
          if (!options.conjunction || result.length === 1) {
            return result.join(options.delimiter);
          } else if (result.length === 2) {
            return result.join(options.conjunction);
          } else if (result.length > 2) {
            return result.slice(0, -1).join(options.delimiter) + (options.serialComma ? ',' : '') + options.conjunction + result.slice(-1);
          }
        } else {
          return render(0, options.units[options.units.length - 1], dictionary, options);
        }
      }

      function render(count, type, dictionary, options) {
        var decimal;
        if (options.decimal === void 0) {
          decimal = dictionary.decimal;
        } else {
          decimal = options.decimal;
        }

        var countStr = count.toString().replace('.', decimal);

        var dictionaryValue = dictionary[type];
        var word;
        if (typeof dictionaryValue === 'function') {
          word = dictionaryValue(count);
        } else {
          word = dictionaryValue;
        }

        return countStr + options.spacer + word;
      }

      function extend(destination) {
        var source;
        for (var i = 1; i < arguments.length; i++) {
          source = arguments[i];
          for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
              destination[prop] = source[prop];
            }
          }
        }
        return destination;
      }

      // Internal helper function for Czech language.
      function getCzechForm(c) {
        if (c === 1) {
          return 0;
        } else if (Math.floor(c) !== c) {
          return 1;
        } else if (c % 10 >= 2 && c % 10 <= 4 && c % 100 < 10) {
          return 2;
        } else {
          return 3;
        }
      }

      // Internal helper function for Polish language.
      function getPolishForm(c) {
        if (c === 1) {
          return 0;
        } else if (Math.floor(c) !== c) {
          return 1;
        } else if (c % 10 >= 2 && c % 10 <= 4 && !(c % 100 > 10 && c % 100 < 20)) {
          return 2;
        } else {
          return 3;
        }
      }

      // Internal helper function for Russian and Ukranian languages.
      function getSlavicForm(c) {
        if (Math.floor(c) !== c) {
          return 2;
        } else if (c % 100 >= 5 && c % 100 <= 20 || c % 10 >= 5 && c % 10 <= 9 || c % 10 === 0) {
          return 0;
        } else if (c % 10 === 1) {
          return 1;
        } else if (c > 1) {
          return 2;
        } else {
          return 0;
        }
      }

      // Internal helper function for Lithuanian language.
      function getLithuanianForm(c) {
        if (c === 1 || c % 10 === 1 && c % 100 > 20) {
          return 0;
        } else if (Math.floor(c) !== c || c % 10 >= 2 && c % 100 > 20 || c % 10 >= 2 && c % 100 < 10) {
          return 1;
        } else {
          return 2;
        }
      }

      humanizeDuration.getSupportedLanguages = function getSupportedLanguages() {
        var result = [];
        for (var language in languages) {
          if (languages.hasOwnProperty(language)) {
            result.push(language);
          }
        }
        return result;
      };

      humanizeDuration.humanizer = humanizer;

      if (typeof define === 'function' && define.amd) {
        define(function () {
          return humanizeDuration;
        });
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = humanizeDuration;
      } else {
        this.humanizeDuration = humanizeDuration;
      }
    })(); // eslint-disable-line semi
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('6', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'moment', null);

    (function ($__global) {
        //! moment.js
        //! version : 2.15.1
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com

        ;(function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
        })(this, function () {
            'use strict';

            var hookCallback;

            function utils_hooks__hooks() {
                return hookCallback.apply(null, arguments);
            }

            // This is done to register the method called with moment()
            // without creating circular dependencies.
            function setHookCallback(callback) {
                hookCallback = callback;
            }

            function isArray(input) {
                return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
            }

            function isObject(input) {
                // IE8 will treat undefined and null as object if it wasn't for
                // input != null
                return input != null && Object.prototype.toString.call(input) === '[object Object]';
            }

            function isObjectEmpty(obj) {
                var k;
                for (k in obj) {
                    // even if its not own property I'd still call it non-empty
                    return false;
                }
                return true;
            }

            function isDate(input) {
                return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
            }

            function map(arr, fn) {
                var res = [],
                    i;
                for (i = 0; i < arr.length; ++i) {
                    res.push(fn(arr[i], i));
                }
                return res;
            }

            function hasOwnProp(a, b) {
                return Object.prototype.hasOwnProperty.call(a, b);
            }

            function extend(a, b) {
                for (var i in b) {
                    if (hasOwnProp(b, i)) {
                        a[i] = b[i];
                    }
                }

                if (hasOwnProp(b, 'toString')) {
                    a.toString = b.toString;
                }

                if (hasOwnProp(b, 'valueOf')) {
                    a.valueOf = b.valueOf;
                }

                return a;
            }

            function create_utc__createUTC(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, true).utc();
            }

            function defaultParsingFlags() {
                // We need to deep clone this object.
                return {
                    empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false,
                    parsedDateParts: [],
                    meridiem: null
                };
            }

            function getParsingFlags(m) {
                if (m._pf == null) {
                    m._pf = defaultParsingFlags();
                }
                return m._pf;
            }

            var some;
            if (Array.prototype.some) {
                some = Array.prototype.some;
            } else {
                some = function (fun) {
                    var t = Object(this);
                    var len = t.length >>> 0;

                    for (var i = 0; i < len; i++) {
                        if (i in t && fun.call(this, t[i], i, t)) {
                            return true;
                        }
                    }

                    return false;
                };
            }

            function valid__isValid(m) {
                if (m._isValid == null) {
                    var flags = getParsingFlags(m);
                    var parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    });
                    var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

                    if (m._strict) {
                        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
                    }

                    if (Object.isFrozen == null || !Object.isFrozen(m)) {
                        m._isValid = isNowValid;
                    } else {
                        return isNowValid;
                    }
                }
                return m._isValid;
            }

            function valid__createInvalid(flags) {
                var m = create_utc__createUTC(NaN);
                if (flags != null) {
                    extend(getParsingFlags(m), flags);
                } else {
                    getParsingFlags(m).userInvalidated = true;
                }

                return m;
            }

            function isUndefined(input) {
                return input === void 0;
            }

            // Plugins that add properties should also add the key here (null value),
            // so we can properly clone ourselves.
            var momentProperties = utils_hooks__hooks.momentProperties = [];

            function copyConfig(to, from) {
                var i, prop, val;

                if (!isUndefined(from._isAMomentObject)) {
                    to._isAMomentObject = from._isAMomentObject;
                }
                if (!isUndefined(from._i)) {
                    to._i = from._i;
                }
                if (!isUndefined(from._f)) {
                    to._f = from._f;
                }
                if (!isUndefined(from._l)) {
                    to._l = from._l;
                }
                if (!isUndefined(from._strict)) {
                    to._strict = from._strict;
                }
                if (!isUndefined(from._tzm)) {
                    to._tzm = from._tzm;
                }
                if (!isUndefined(from._isUTC)) {
                    to._isUTC = from._isUTC;
                }
                if (!isUndefined(from._offset)) {
                    to._offset = from._offset;
                }
                if (!isUndefined(from._pf)) {
                    to._pf = getParsingFlags(from);
                }
                if (!isUndefined(from._locale)) {
                    to._locale = from._locale;
                }

                if (momentProperties.length > 0) {
                    for (i in momentProperties) {
                        prop = momentProperties[i];
                        val = from[prop];
                        if (!isUndefined(val)) {
                            to[prop] = val;
                        }
                    }
                }

                return to;
            }

            var updateInProgress = false;

            // Moment prototype object
            function Moment(config) {
                copyConfig(this, config);
                this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                // Prevent infinite loop in case updateOffset creates new moment
                // objects.
                if (updateInProgress === false) {
                    updateInProgress = true;
                    utils_hooks__hooks.updateOffset(this);
                    updateInProgress = false;
                }
            }

            function isMoment(obj) {
                return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
            }

            function absFloor(number) {
                if (number < 0) {
                    // -0 -> 0
                    return Math.ceil(number) || 0;
                } else {
                    return Math.floor(number);
                }
            }

            function toInt(argumentForCoercion) {
                var coercedNumber = +argumentForCoercion,
                    value = 0;

                if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    value = absFloor(coercedNumber);
                }

                return value;
            }

            // compare two arrays, return the number of differences
            function compareArrays(array1, array2, dontConvert) {
                var len = Math.min(array1.length, array2.length),
                    lengthDiff = Math.abs(array1.length - array2.length),
                    diffs = 0,
                    i;
                for (i = 0; i < len; i++) {
                    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                        diffs++;
                    }
                }
                return diffs + lengthDiff;
            }

            function warn(msg) {
                if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
                    console.warn('Deprecation warning: ' + msg);
                }
            }

            function deprecate(msg, fn) {
                var firstTime = true;

                return extend(function () {
                    if (utils_hooks__hooks.deprecationHandler != null) {
                        utils_hooks__hooks.deprecationHandler(null, msg);
                    }
                    if (firstTime) {
                        var args = [];
                        var arg;
                        for (var i = 0; i < arguments.length; i++) {
                            arg = '';
                            if (typeof arguments[i] === 'object') {
                                arg += '\n[' + i + '] ';
                                for (var key in arguments[0]) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                                arg = arg.slice(0, -2); // Remove trailing comma and space
                            } else {
                                arg = arguments[i];
                            }
                            args.push(arg);
                        }
                        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
                        firstTime = false;
                    }
                    return fn.apply(this, arguments);
                }, fn);
            }

            var deprecations = {};

            function deprecateSimple(name, msg) {
                if (utils_hooks__hooks.deprecationHandler != null) {
                    utils_hooks__hooks.deprecationHandler(name, msg);
                }
                if (!deprecations[name]) {
                    warn(msg);
                    deprecations[name] = true;
                }
            }

            utils_hooks__hooks.suppressDeprecationWarnings = false;
            utils_hooks__hooks.deprecationHandler = null;

            function isFunction(input) {
                return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
            }

            function locale_set__set(config) {
                var prop, i;
                for (i in config) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
                this._config = config;
                // Lenient ordinal parsing accepts just a number in addition to
                // number + (possibly) stuff coming from _ordinalParseLenient.
                this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
            }

            function mergeConfigs(parentConfig, childConfig) {
                var res = extend({}, parentConfig),
                    prop;
                for (prop in childConfig) {
                    if (hasOwnProp(childConfig, prop)) {
                        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                            res[prop] = {};
                            extend(res[prop], parentConfig[prop]);
                            extend(res[prop], childConfig[prop]);
                        } else if (childConfig[prop] != null) {
                            res[prop] = childConfig[prop];
                        } else {
                            delete res[prop];
                        }
                    }
                }
                for (prop in parentConfig) {
                    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                        // make sure changes to properties don't modify parent config
                        res[prop] = extend({}, res[prop]);
                    }
                }
                return res;
            }

            function Locale(config) {
                if (config != null) {
                    this.set(config);
                }
            }

            var keys;

            if (Object.keys) {
                keys = Object.keys;
            } else {
                keys = function (obj) {
                    var i,
                        res = [];
                    for (i in obj) {
                        if (hasOwnProp(obj, i)) {
                            res.push(i);
                        }
                    }
                    return res;
                };
            }

            var defaultCalendar = {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L'
            };

            function locale_calendar__calendar(key, mom, now) {
                var output = this._calendar[key] || this._calendar['sameElse'];
                return isFunction(output) ? output.call(mom, now) : output;
            }

            var defaultLongDateFormat = {
                LTS: 'h:mm:ss A',
                LT: 'h:mm A',
                L: 'MM/DD/YYYY',
                LL: 'MMMM D, YYYY',
                LLL: 'MMMM D, YYYY h:mm A',
                LLLL: 'dddd, MMMM D, YYYY h:mm A'
            };

            function longDateFormat(key) {
                var format = this._longDateFormat[key],
                    formatUpper = this._longDateFormat[key.toUpperCase()];

                if (format || !formatUpper) {
                    return format;
                }

                this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });

                return this._longDateFormat[key];
            }

            var defaultInvalidDate = 'Invalid date';

            function invalidDate() {
                return this._invalidDate;
            }

            var defaultOrdinal = '%d';
            var defaultOrdinalParse = /\d{1,2}/;

            function ordinal(number) {
                return this._ordinal.replace('%d', number);
            }

            var defaultRelativeTime = {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years'
            };

            function relative__relativeTime(number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
            }

            function pastFuture(diff, output) {
                var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                return isFunction(format) ? format(output) : format.replace(/%s/i, output);
            }

            var aliases = {};

            function addUnitAlias(unit, shorthand) {
                var lowerCase = unit.toLowerCase();
                aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
            }

            function normalizeUnits(units) {
                return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
            }

            function normalizeObjectUnits(inputObject) {
                var normalizedInput = {},
                    normalizedProp,
                    prop;

                for (prop in inputObject) {
                    if (hasOwnProp(inputObject, prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) {
                            normalizedInput[normalizedProp] = inputObject[prop];
                        }
                    }
                }

                return normalizedInput;
            }

            var priorities = {};

            function addUnitPriority(unit, priority) {
                priorities[unit] = priority;
            }

            function getPrioritizedUnits(unitsObj) {
                var units = [];
                for (var u in unitsObj) {
                    units.push({ unit: u, priority: priorities[u] });
                }
                units.sort(function (a, b) {
                    return a.priority - b.priority;
                });
                return units;
            }

            function makeGetSet(unit, keepTime) {
                return function (value) {
                    if (value != null) {
                        get_set__set(this, unit, value);
                        utils_hooks__hooks.updateOffset(this, keepTime);
                        return this;
                    } else {
                        return get_set__get(this, unit);
                    }
                };
            }

            function get_set__get(mom, unit) {
                return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
            }

            function get_set__set(mom, unit, value) {
                if (mom.isValid()) {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }

            // MOMENTS

            function stringGet(units) {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units]();
                }
                return this;
            }

            function stringSet(units, value) {
                if (typeof units === 'object') {
                    units = normalizeObjectUnits(units);
                    var prioritized = getPrioritizedUnits(units);
                    for (var i = 0; i < prioritized.length; i++) {
                        this[prioritized[i].unit](units[prioritized[i].unit]);
                    }
                } else {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                        return this[units](value);
                    }
                }
                return this;
            }

            function zeroFill(number, targetLength, forceSign) {
                var absNumber = '' + Math.abs(number),
                    zerosToFill = targetLength - absNumber.length,
                    sign = number >= 0;
                return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
            }

            var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

            var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

            var formatFunctions = {};

            var formatTokenFunctions = {};

            // token:    'M'
            // padded:   ['MM', 2]
            // ordinal:  'Mo'
            // callback: function () { this.month() + 1 }
            function addFormatToken(token, padded, ordinal, callback) {
                var func = callback;
                if (typeof callback === 'string') {
                    func = function () {
                        return this[callback]();
                    };
                }
                if (token) {
                    formatTokenFunctions[token] = func;
                }
                if (padded) {
                    formatTokenFunctions[padded[0]] = function () {
                        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                }
                if (ordinal) {
                    formatTokenFunctions[ordinal] = function () {
                        return this.localeData().ordinal(func.apply(this, arguments), token);
                    };
                }
            }

            function removeFormattingTokens(input) {
                if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, '');
                }
                return input.replace(/\\/g, '');
            }

            function makeFormatFunction(format) {
                var array = format.match(formattingTokens),
                    i,
                    length;

                for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                        array[i] = formatTokenFunctions[array[i]];
                    } else {
                        array[i] = removeFormattingTokens(array[i]);
                    }
                }

                return function (mom) {
                    var output = '',
                        i;
                    for (i = 0; i < length; i++) {
                        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
                    }
                    return output;
                };
            }

            // format date using native date object
            function formatMoment(m, format) {
                if (!m.isValid()) {
                    return m.localeData().invalidDate();
                }

                format = expandFormat(format, m.localeData());
                formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

                return formatFunctions[format](m);
            }

            function expandFormat(format, locale) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return locale.longDateFormat(input) || input;
                }

                localFormattingTokens.lastIndex = 0;
                while (i >= 0 && localFormattingTokens.test(format)) {
                    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1;
                }

                return format;
            }

            var match1 = /\d/; //       0 - 9
            var match2 = /\d\d/; //      00 - 99
            var match3 = /\d{3}/; //     000 - 999
            var match4 = /\d{4}/; //    0000 - 9999
            var match6 = /[+-]?\d{6}/; // -999999 - 999999
            var match1to2 = /\d\d?/; //       0 - 99
            var match3to4 = /\d\d\d\d?/; //     999 - 9999
            var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
            var match1to3 = /\d{1,3}/; //       0 - 999
            var match1to4 = /\d{1,4}/; //       0 - 9999
            var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

            var matchUnsigned = /\d+/; //       0 - inf
            var matchSigned = /[+-]?\d+/; //    -inf - inf

            var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
            var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

            var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

            var regexes = {};

            function addRegexToken(token, regex, strictRegex) {
                regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
            }

            function getParseRegexForToken(token, config) {
                if (!hasOwnProp(regexes, token)) {
                    return new RegExp(unescapeFormat(token));
                }

                return regexes[token](config._strict, config._locale);
            }

            // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
            function unescapeFormat(s) {
                return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                }));
            }

            function regexEscape(s) {
                return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            }

            var tokens = {};

            function addParseToken(token, callback) {
                var i,
                    func = callback;
                if (typeof token === 'string') {
                    token = [token];
                }
                if (typeof callback === 'number') {
                    func = function (input, array) {
                        array[callback] = toInt(input);
                    };
                }
                for (i = 0; i < token.length; i++) {
                    tokens[token[i]] = func;
                }
            }

            function addWeekParseToken(token, callback) {
                addParseToken(token, function (input, array, config, token) {
                    config._w = config._w || {};
                    callback(input, config._w, config, token);
                });
            }

            function addTimeToArrayFromToken(token, input, config) {
                if (input != null && hasOwnProp(tokens, token)) {
                    tokens[token](input, config._a, config, token);
                }
            }

            var YEAR = 0;
            var MONTH = 1;
            var DATE = 2;
            var HOUR = 3;
            var MINUTE = 4;
            var SECOND = 5;
            var MILLISECOND = 6;
            var WEEK = 7;
            var WEEKDAY = 8;

            var indexOf;

            if (Array.prototype.indexOf) {
                indexOf = Array.prototype.indexOf;
            } else {
                indexOf = function (o) {
                    // I know
                    var i;
                    for (i = 0; i < this.length; ++i) {
                        if (this[i] === o) {
                            return i;
                        }
                    }
                    return -1;
                };
            }

            function daysInMonth(year, month) {
                return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
            }

            // FORMATTING

            addFormatToken('M', ['MM', 2], 'Mo', function () {
                return this.month() + 1;
            });

            addFormatToken('MMM', 0, 0, function (format) {
                return this.localeData().monthsShort(this, format);
            });

            addFormatToken('MMMM', 0, 0, function (format) {
                return this.localeData().months(this, format);
            });

            // ALIASES

            addUnitAlias('month', 'M');

            // PRIORITY

            addUnitPriority('month', 8);

            // PARSING

            addRegexToken('M', match1to2);
            addRegexToken('MM', match1to2, match2);
            addRegexToken('MMM', function (isStrict, locale) {
                return locale.monthsShortRegex(isStrict);
            });
            addRegexToken('MMMM', function (isStrict, locale) {
                return locale.monthsRegex(isStrict);
            });

            addParseToken(['M', 'MM'], function (input, array) {
                array[MONTH] = toInt(input) - 1;
            });

            addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
                var month = config._locale.monthsParse(input, token, config._strict);
                // if we didn't find a month name, mark the date as invalid.
                if (month != null) {
                    array[MONTH] = month;
                } else {
                    getParsingFlags(config).invalidMonth = input;
                }
            });

            // LOCALES

            var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
            var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
            function localeMonths(m, format) {
                if (!m) {
                    return this._months;
                }
                return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
            }

            var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
            function localeMonthsShort(m, format) {
                if (!m) {
                    return this._monthsShort;
                }
                return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
            }

            function units_month__handleStrictParse(monthName, format, strict) {
                var i,
                    ii,
                    mom,
                    llc = monthName.toLocaleLowerCase();
                if (!this._monthsParse) {
                    // this is not used
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                    for (i = 0; i < 12; ++i) {
                        mom = create_utc__createUTC([2000, i]);
                        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                    }
                }

                if (strict) {
                    if (format === 'MMM') {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format === 'MMM') {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }

            function localeMonthsParse(monthName, format, strict) {
                var i, mom, regex;

                if (this._monthsParseExact) {
                    return units_month__handleStrictParse.call(this, monthName, format, strict);
                }

                if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                }

                // TODO: add sorting
                // Sorting makes sure if one month (or abbr) is a prefix of another
                // see sorting in computeMonthsParse
                for (i = 0; i < 12; i++) {
                    // make the regex if we don't have it already
                    mom = create_utc__createUTC([2000, i]);
                    if (strict && !this._longMonthsParse[i]) {
                        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                    }
                    if (!strict && !this._monthsParse[i]) {
                        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                    }
                    // test the regex
                    if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                        return i;
                    } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                        return i;
                    } else if (!strict && this._monthsParse[i].test(monthName)) {
                        return i;
                    }
                }
            }

            // MOMENTS

            function setMonth(mom, value) {
                var dayOfMonth;

                if (!mom.isValid()) {
                    // No op
                    return mom;
                }

                if (typeof value === 'string') {
                    if (/^\d+$/.test(value)) {
                        value = toInt(value);
                    } else {
                        value = mom.localeData().monthsParse(value);
                        // TODO: Another silent failure?
                        if (typeof value !== 'number') {
                            return mom;
                        }
                    }
                }

                dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                return mom;
            }

            function getSetMonth(value) {
                if (value != null) {
                    setMonth(this, value);
                    utils_hooks__hooks.updateOffset(this, true);
                    return this;
                } else {
                    return get_set__get(this, 'Month');
                }
            }

            function getDaysInMonth() {
                return daysInMonth(this.year(), this.month());
            }

            var defaultMonthsShortRegex = matchWord;
            function monthsShortRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsShortStrictRegex;
                    } else {
                        return this._monthsShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_monthsShortRegex')) {
                        this._monthsShortRegex = defaultMonthsShortRegex;
                    }
                    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
                }
            }

            var defaultMonthsRegex = matchWord;
            function monthsRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsStrictRegex;
                    } else {
                        return this._monthsRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        this._monthsRegex = defaultMonthsRegex;
                    }
                    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
                }
            }

            function computeMonthsParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length;
                }

                var shortPieces = [],
                    longPieces = [],
                    mixedPieces = [],
                    i,
                    mom;
                for (i = 0; i < 12; i++) {
                    // make the regex if we don't have it already
                    mom = create_utc__createUTC([2000, i]);
                    shortPieces.push(this.monthsShort(mom, ''));
                    longPieces.push(this.months(mom, ''));
                    mixedPieces.push(this.months(mom, ''));
                    mixedPieces.push(this.monthsShort(mom, ''));
                }
                // Sorting makes sure if one month (or abbr) is a prefix of another it
                // will match the longer piece.
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                for (i = 0; i < 12; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                }
                for (i = 0; i < 24; i++) {
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                }

                this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                this._monthsShortRegex = this._monthsRegex;
                this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
            }

            // FORMATTING

            addFormatToken('Y', 0, 0, function () {
                var y = this.year();
                return y <= 9999 ? '' + y : '+' + y;
            });

            addFormatToken(0, ['YY', 2], 0, function () {
                return this.year() % 100;
            });

            addFormatToken(0, ['YYYY', 4], 0, 'year');
            addFormatToken(0, ['YYYYY', 5], 0, 'year');
            addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

            // ALIASES

            addUnitAlias('year', 'y');

            // PRIORITIES

            addUnitPriority('year', 1);

            // PARSING

            addRegexToken('Y', matchSigned);
            addRegexToken('YY', match1to2, match2);
            addRegexToken('YYYY', match1to4, match4);
            addRegexToken('YYYYY', match1to6, match6);
            addRegexToken('YYYYYY', match1to6, match6);

            addParseToken(['YYYYY', 'YYYYYY'], YEAR);
            addParseToken('YYYY', function (input, array) {
                array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
            });
            addParseToken('YY', function (input, array) {
                array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
            });
            addParseToken('Y', function (input, array) {
                array[YEAR] = parseInt(input, 10);
            });

            // HELPERS

            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365;
            }

            function isLeapYear(year) {
                return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
            }

            // HOOKS

            utils_hooks__hooks.parseTwoDigitYear = function (input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            };

            // MOMENTS

            var getSetYear = makeGetSet('FullYear', true);

            function getIsLeapYear() {
                return isLeapYear(this.year());
            }

            function createDate(y, m, d, h, M, s, ms) {
                //can't just apply() to create a date:
                //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
                var date = new Date(y, m, d, h, M, s, ms);

                //the date constructor remaps years 0-99 to 1900-1999
                if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
                return date;
            }

            function createUTCDate(y) {
                var date = new Date(Date.UTC.apply(null, arguments));

                //the Date.UTC function remaps years 0-99 to 1900-1999
                if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
                return date;
            }

            // start-of-first-week - start-of-year
            function firstWeekOffset(year, dow, doy) {
                var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,

                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

                return -fwdlw + fwd - 1;
            }

            //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
            function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                var localWeekday = (7 + weekday - dow) % 7,
                    weekOffset = firstWeekOffset(year, dow, doy),
                    dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                    resYear,
                    resDayOfYear;

                if (dayOfYear <= 0) {
                    resYear = year - 1;
                    resDayOfYear = daysInYear(resYear) + dayOfYear;
                } else if (dayOfYear > daysInYear(year)) {
                    resYear = year + 1;
                    resDayOfYear = dayOfYear - daysInYear(year);
                } else {
                    resYear = year;
                    resDayOfYear = dayOfYear;
                }

                return {
                    year: resYear,
                    dayOfYear: resDayOfYear
                };
            }

            function weekOfYear(mom, dow, doy) {
                var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                    week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                    resWeek,
                    resYear;

                if (week < 1) {
                    resYear = mom.year() - 1;
                    resWeek = week + weeksInYear(resYear, dow, doy);
                } else if (week > weeksInYear(mom.year(), dow, doy)) {
                    resWeek = week - weeksInYear(mom.year(), dow, doy);
                    resYear = mom.year() + 1;
                } else {
                    resYear = mom.year();
                    resWeek = week;
                }

                return {
                    week: resWeek,
                    year: resYear
                };
            }

            function weeksInYear(year, dow, doy) {
                var weekOffset = firstWeekOffset(year, dow, doy),
                    weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
            }

            // FORMATTING

            addFormatToken('w', ['ww', 2], 'wo', 'week');
            addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

            // ALIASES

            addUnitAlias('week', 'w');
            addUnitAlias('isoWeek', 'W');

            // PRIORITIES

            addUnitPriority('week', 5);
            addUnitPriority('isoWeek', 5);

            // PARSING

            addRegexToken('w', match1to2);
            addRegexToken('ww', match1to2, match2);
            addRegexToken('W', match1to2);
            addRegexToken('WW', match1to2, match2);

            addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
                week[token.substr(0, 1)] = toInt(input);
            });

            // HELPERS

            // LOCALES

            function localeWeek(mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week;
            }

            var defaultLocaleWeek = {
                dow: 0, // Sunday is the first day of the week.
                doy: 6 // The week that contains Jan 1st is the first week of the year.
            };

            function localeFirstDayOfWeek() {
                return this._week.dow;
            }

            function localeFirstDayOfYear() {
                return this._week.doy;
            }

            // MOMENTS

            function getSetWeek(input) {
                var week = this.localeData().week(this);
                return input == null ? week : this.add((input - week) * 7, 'd');
            }

            function getSetISOWeek(input) {
                var week = weekOfYear(this, 1, 4).week;
                return input == null ? week : this.add((input - week) * 7, 'd');
            }

            // FORMATTING

            addFormatToken('d', 0, 'do', 'day');

            addFormatToken('dd', 0, 0, function (format) {
                return this.localeData().weekdaysMin(this, format);
            });

            addFormatToken('ddd', 0, 0, function (format) {
                return this.localeData().weekdaysShort(this, format);
            });

            addFormatToken('dddd', 0, 0, function (format) {
                return this.localeData().weekdays(this, format);
            });

            addFormatToken('e', 0, 0, 'weekday');
            addFormatToken('E', 0, 0, 'isoWeekday');

            // ALIASES

            addUnitAlias('day', 'd');
            addUnitAlias('weekday', 'e');
            addUnitAlias('isoWeekday', 'E');

            // PRIORITY
            addUnitPriority('day', 11);
            addUnitPriority('weekday', 11);
            addUnitPriority('isoWeekday', 11);

            // PARSING

            addRegexToken('d', match1to2);
            addRegexToken('e', match1to2);
            addRegexToken('E', match1to2);
            addRegexToken('dd', function (isStrict, locale) {
                return locale.weekdaysMinRegex(isStrict);
            });
            addRegexToken('ddd', function (isStrict, locale) {
                return locale.weekdaysShortRegex(isStrict);
            });
            addRegexToken('dddd', function (isStrict, locale) {
                return locale.weekdaysRegex(isStrict);
            });

            addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
                var weekday = config._locale.weekdaysParse(input, token, config._strict);
                // if we didn't get a weekday name, mark the date as invalid
                if (weekday != null) {
                    week.d = weekday;
                } else {
                    getParsingFlags(config).invalidWeekday = input;
                }
            });

            addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
                week[token] = toInt(input);
            });

            // HELPERS

            function parseWeekday(input, locale) {
                if (typeof input !== 'string') {
                    return input;
                }

                if (!isNaN(input)) {
                    return parseInt(input, 10);
                }

                input = locale.weekdaysParse(input);
                if (typeof input === 'number') {
                    return input;
                }

                return null;
            }

            function parseIsoWeekday(input, locale) {
                if (typeof input === 'string') {
                    return locale.weekdaysParse(input) % 7 || 7;
                }
                return isNaN(input) ? null : input;
            }

            // LOCALES

            var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
            function localeWeekdays(m, format) {
                if (!m) {
                    return this._weekdays;
                }
                return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
            }

            var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
            function localeWeekdaysShort(m) {
                return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
            }

            var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
            function localeWeekdaysMin(m) {
                return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
            }

            function day_of_week__handleStrictParse(weekdayName, format, strict) {
                var i,
                    ii,
                    mom,
                    llc = weekdayName.toLocaleLowerCase();
                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._minWeekdaysParse = [];

                    for (i = 0; i < 7; ++i) {
                        mom = create_utc__createUTC([2000, 1]).day(i);
                        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                    }
                }

                if (strict) {
                    if (format === 'dddd') {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format === 'ddd') {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format === 'dddd') {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format === 'ddd') {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }

            function localeWeekdaysParse(weekdayName, format, strict) {
                var i, mom, regex;

                if (this._weekdaysParseExact) {
                    return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
                }

                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._minWeekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._fullWeekdaysParse = [];
                }

                for (i = 0; i < 7; i++) {
                    // make the regex if we don't have it already

                    mom = create_utc__createUTC([2000, 1]).day(i);
                    if (strict && !this._fullWeekdaysParse[i]) {
                        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
                    }
                    if (!this._weekdaysParse[i]) {
                        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                    }
                    // test the regex
                    if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                        return i;
                    }
                }
            }

            // MOMENTS

            function getSetDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, 'd');
                } else {
                    return day;
                }
            }

            function getSetLocaleDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return input == null ? weekday : this.add(input - weekday, 'd');
            }

            function getSetISODayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }

                // behaves the same as moment#day except
                // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                // as a setter, sunday should belong to the previous week.

                if (input != null) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7);
                } else {
                    return this.day() || 7;
                }
            }

            var defaultWeekdaysRegex = matchWord;
            function weekdaysRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysStrictRegex;
                    } else {
                        return this._weekdaysRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        this._weekdaysRegex = defaultWeekdaysRegex;
                    }
                    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
                }
            }

            var defaultWeekdaysShortRegex = matchWord;
            function weekdaysShortRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysShortStrictRegex;
                    } else {
                        return this._weekdaysShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                    }
                    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                }
            }

            var defaultWeekdaysMinRegex = matchWord;
            function weekdaysMinRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysMinStrictRegex;
                    } else {
                        return this._weekdaysMinRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                    }
                    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                }
            }

            function computeWeekdaysParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length;
                }

                var minPieces = [],
                    shortPieces = [],
                    longPieces = [],
                    mixedPieces = [],
                    i,
                    mom,
                    minp,
                    shortp,
                    longp;
                for (i = 0; i < 7; i++) {
                    // make the regex if we don't have it already
                    mom = create_utc__createUTC([2000, 1]).day(i);
                    minp = this.weekdaysMin(mom, '');
                    shortp = this.weekdaysShort(mom, '');
                    longp = this.weekdays(mom, '');
                    minPieces.push(minp);
                    shortPieces.push(shortp);
                    longPieces.push(longp);
                    mixedPieces.push(minp);
                    mixedPieces.push(shortp);
                    mixedPieces.push(longp);
                }
                // Sorting makes sure if one weekday (or abbr) is a prefix of another it
                // will match the longer piece.
                minPieces.sort(cmpLenRev);
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                for (i = 0; i < 7; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                }

                this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                this._weekdaysShortRegex = this._weekdaysRegex;
                this._weekdaysMinRegex = this._weekdaysRegex;

                this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
            }

            // FORMATTING

            function hFormat() {
                return this.hours() % 12 || 12;
            }

            function kFormat() {
                return this.hours() || 24;
            }

            addFormatToken('H', ['HH', 2], 0, 'hour');
            addFormatToken('h', ['hh', 2], 0, hFormat);
            addFormatToken('k', ['kk', 2], 0, kFormat);

            addFormatToken('hmm', 0, 0, function () {
                return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
            });

            addFormatToken('hmmss', 0, 0, function () {
                return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
            });

            addFormatToken('Hmm', 0, 0, function () {
                return '' + this.hours() + zeroFill(this.minutes(), 2);
            });

            addFormatToken('Hmmss', 0, 0, function () {
                return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
            });

            function meridiem(token, lowercase) {
                addFormatToken(token, 0, 0, function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                });
            }

            meridiem('a', true);
            meridiem('A', false);

            // ALIASES

            addUnitAlias('hour', 'h');

            // PRIORITY
            addUnitPriority('hour', 13);

            // PARSING

            function matchMeridiem(isStrict, locale) {
                return locale._meridiemParse;
            }

            addRegexToken('a', matchMeridiem);
            addRegexToken('A', matchMeridiem);
            addRegexToken('H', match1to2);
            addRegexToken('h', match1to2);
            addRegexToken('HH', match1to2, match2);
            addRegexToken('hh', match1to2, match2);

            addRegexToken('hmm', match3to4);
            addRegexToken('hmmss', match5to6);
            addRegexToken('Hmm', match3to4);
            addRegexToken('Hmmss', match5to6);

            addParseToken(['H', 'HH'], HOUR);
            addParseToken(['a', 'A'], function (input, array, config) {
                config._isPm = config._locale.isPM(input);
                config._meridiem = input;
            });
            addParseToken(['h', 'hh'], function (input, array, config) {
                array[HOUR] = toInt(input);
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('hmm', function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('hmmss', function (input, array, config) {
                var pos1 = input.length - 4;
                var pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('Hmm', function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
            });
            addParseToken('Hmmss', function (input, array, config) {
                var pos1 = input.length - 4;
                var pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
            });

            // LOCALES

            function localeIsPM(input) {
                // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                // Using charAt should be more compatible.
                return (input + '').toLowerCase().charAt(0) === 'p';
            }

            var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
            function localeMeridiem(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? 'pm' : 'PM';
                } else {
                    return isLower ? 'am' : 'AM';
                }
            }

            // MOMENTS

            // Setting the hour should keep the time, because the user explicitly
            // specified which hour he wants. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            var getSetHour = makeGetSet('Hours', true);

            var baseConfig = {
                calendar: defaultCalendar,
                longDateFormat: defaultLongDateFormat,
                invalidDate: defaultInvalidDate,
                ordinal: defaultOrdinal,
                ordinalParse: defaultOrdinalParse,
                relativeTime: defaultRelativeTime,

                months: defaultLocaleMonths,
                monthsShort: defaultLocaleMonthsShort,

                week: defaultLocaleWeek,

                weekdays: defaultLocaleWeekdays,
                weekdaysMin: defaultLocaleWeekdaysMin,
                weekdaysShort: defaultLocaleWeekdaysShort,

                meridiemParse: defaultLocaleMeridiemParse
            };

            // internal storage for locale config files
            var locales = {};
            var globalLocale;

            function normalizeLocale(key) {
                return key ? key.toLowerCase().replace('_', '-') : key;
            }

            // pick the locale from the array
            // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
            // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
            function chooseLocale(names) {
                var i = 0,
                    j,
                    next,
                    locale,
                    split;

                while (i < names.length) {
                    split = normalizeLocale(names[i]).split('-');
                    j = split.length;
                    next = normalizeLocale(names[i + 1]);
                    next = next ? next.split('-') : null;
                    while (j > 0) {
                        locale = loadLocale(split.slice(0, j).join('-'));
                        if (locale) {
                            return locale;
                        }
                        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                            //the next array item is better than a shallower substring of this one
                            break;
                        }
                        j--;
                    }
                    i++;
                }
                return null;
            }

            function loadLocale(name) {
                var oldLocale = null;
                // TODO: Find a better way to register and load all the locales in Node
                if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
                    try {
                        oldLocale = globalLocale._abbr;
                        require('./locale/' + name);
                        // because defineLocale currently also sets the global locale, we
                        // want to undo that for lazy loaded locales
                        locale_locales__getSetGlobalLocale(oldLocale);
                    } catch (e) {}
                }
                return locales[name];
            }

            // This function will load locale and then set the global locale.  If
            // no arguments are passed in, it will simply return the current global
            // locale key.
            function locale_locales__getSetGlobalLocale(key, values) {
                var data;
                if (key) {
                    if (isUndefined(values)) {
                        data = locale_locales__getLocale(key);
                    } else {
                        data = defineLocale(key, values);
                    }

                    if (data) {
                        // moment.duration._locale = moment._locale = data;
                        globalLocale = data;
                    }
                }

                return globalLocale._abbr;
            }

            function defineLocale(name, config) {
                if (config !== null) {
                    var parentConfig = baseConfig;
                    config.abbr = name;
                    if (locales[name] != null) {
                        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                        parentConfig = locales[name]._config;
                    } else if (config.parentLocale != null) {
                        if (locales[config.parentLocale] != null) {
                            parentConfig = locales[config.parentLocale]._config;
                        } else {
                            // treat as if there is no base config
                            deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                        }
                    }
                    locales[name] = new Locale(mergeConfigs(parentConfig, config));

                    // backwards compat for now: also set the locale
                    locale_locales__getSetGlobalLocale(name);

                    return locales[name];
                } else {
                    // useful for testing
                    delete locales[name];
                    return null;
                }
            }

            function updateLocale(name, config) {
                if (config != null) {
                    var locale,
                        parentConfig = baseConfig;
                    // MERGE
                    if (locales[name] != null) {
                        parentConfig = locales[name]._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;

                    // backwards compat for now: also set the locale
                    locale_locales__getSetGlobalLocale(name);
                } else {
                    // pass null for config to unupdate, useful for tests
                    if (locales[name] != null) {
                        if (locales[name].parentLocale != null) {
                            locales[name] = locales[name].parentLocale;
                        } else if (locales[name] != null) {
                            delete locales[name];
                        }
                    }
                }
                return locales[name];
            }

            // returns locale data
            function locale_locales__getLocale(key) {
                var locale;

                if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr;
                }

                if (!key) {
                    return globalLocale;
                }

                if (!isArray(key)) {
                    //short-circuit everything else
                    locale = loadLocale(key);
                    if (locale) {
                        return locale;
                    }
                    key = [key];
                }

                return chooseLocale(key);
            }

            function locale_locales__listLocales() {
                return keys(locales);
            }

            function checkOverflow(m) {
                var overflow;
                var a = m._a;

                if (a && getParsingFlags(m).overflow === -2) {
                    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

                    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                        overflow = DATE;
                    }
                    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                        overflow = WEEK;
                    }
                    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                        overflow = WEEKDAY;
                    }

                    getParsingFlags(m).overflow = overflow;
                }

                return m;
            }

            // iso 8601 regex
            // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
            var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
            var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

            var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

            var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/],
            // YYYYMM is NOT allowed by the standard
            ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

            // iso time formats and regexes
            var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];

            var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

            // date from iso format
            function configFromISO(config) {
                var i,
                    l,
                    string = config._i,
                    match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                    allowTime,
                    dateFormat,
                    timeFormat,
                    tzFormat;

                if (match) {
                    getParsingFlags(config).iso = true;

                    for (i = 0, l = isoDates.length; i < l; i++) {
                        if (isoDates[i][1].exec(match[1])) {
                            dateFormat = isoDates[i][0];
                            allowTime = isoDates[i][2] !== false;
                            break;
                        }
                    }
                    if (dateFormat == null) {
                        config._isValid = false;
                        return;
                    }
                    if (match[3]) {
                        for (i = 0, l = isoTimes.length; i < l; i++) {
                            if (isoTimes[i][1].exec(match[3])) {
                                // match[2] should be 'T' or space
                                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                                break;
                            }
                        }
                        if (timeFormat == null) {
                            config._isValid = false;
                            return;
                        }
                    }
                    if (!allowTime && timeFormat != null) {
                        config._isValid = false;
                        return;
                    }
                    if (match[4]) {
                        if (tzRegex.exec(match[4])) {
                            tzFormat = 'Z';
                        } else {
                            config._isValid = false;
                            return;
                        }
                    }
                    config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                    configFromStringAndFormat(config);
                } else {
                    config._isValid = false;
                }
            }

            // date from iso format or fallback
            function configFromString(config) {
                var matched = aspNetJsonRegex.exec(config._i);

                if (matched !== null) {
                    config._d = new Date(+matched[1]);
                    return;
                }

                configFromISO(config);
                if (config._isValid === false) {
                    delete config._isValid;
                    utils_hooks__hooks.createFromInputFallback(config);
                }
            }

            utils_hooks__hooks.createFromInputFallback = deprecate('value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            });

            // Pick the first defined of two or three arguments.
            function defaults(a, b, c) {
                if (a != null) {
                    return a;
                }
                if (b != null) {
                    return b;
                }
                return c;
            }

            function currentDateArray(config) {
                // hooks is actually the exported moment object
                var nowValue = new Date(utils_hooks__hooks.now());
                if (config._useUTC) {
                    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                }
                return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
            }

            // convert an array to a date.
            // the array should mirror the parameters below
            // note: all values past the year are optional and will default to the lowest possible value.
            // [year, month, day , hour, minute, second, millisecond]
            function configFromArray(config) {
                var i,
                    date,
                    input = [],
                    currentDate,
                    yearToUse;

                if (config._d) {
                    return;
                }

                currentDate = currentDateArray(config);

                //compute day of the year from weeks and weekdays
                if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config);
                }

                //if the day of the year is set, figure out what it is
                if (config._dayOfYear) {
                    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                    if (config._dayOfYear > daysInYear(yearToUse)) {
                        getParsingFlags(config)._overflowDayOfYear = true;
                    }

                    date = createUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                }

                // Default to current date.
                // * if no year, month, day of month are given, default to today
                // * if day of month is given, default month and year
                // * if month is given, default only year
                // * if year is given, don't default anything
                for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i];
                }

                // Zero out whatever was not defaulted, including time
                for (; i < 7; i++) {
                    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
                }

                // Check for 24:00:00.000
                if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
                    config._nextDay = true;
                    config._a[HOUR] = 0;
                }

                config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                // Apply timezone offset from input. The actual utcOffset can be changed
                // with parseZone.
                if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                }

                if (config._nextDay) {
                    config._a[HOUR] = 24;
                }
            }

            function dayOfYearFromWeekInfo(config) {
                var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

                w = config._w;
                if (w.GG != null || w.W != null || w.E != null) {
                    dow = 1;
                    doy = 4;

                    // TODO: We need to take the current isoWeekYear, but that depends on
                    // how we interpret now (local, utc, fixed offset). So create
                    // a now version of current config (take local/utc/offset flags, and
                    // create now).
                    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
                    week = defaults(w.W, 1);
                    weekday = defaults(w.E, 1);
                    if (weekday < 1 || weekday > 7) {
                        weekdayOverflow = true;
                    }
                } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;

                    weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
                    week = defaults(w.w, 1);

                    if (w.d != null) {
                        // weekday -- low day numbers are considered next week
                        weekday = w.d;
                        if (weekday < 0 || weekday > 6) {
                            weekdayOverflow = true;
                        }
                    } else if (w.e != null) {
                        // local weekday -- counting starts from begining of week
                        weekday = w.e + dow;
                        if (w.e < 0 || w.e > 6) {
                            weekdayOverflow = true;
                        }
                    } else {
                        // default to begining of week
                        weekday = dow;
                    }
                }
                if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                    getParsingFlags(config)._overflowWeeks = true;
                } else if (weekdayOverflow != null) {
                    getParsingFlags(config)._overflowWeekday = true;
                } else {
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                }
            }

            // constant that refers to the ISO standard
            utils_hooks__hooks.ISO_8601 = function () {};

            // date from string and format string
            function configFromStringAndFormat(config) {
                // TODO: Move this to another part of the creation flow to prevent circular deps
                if (config._f === utils_hooks__hooks.ISO_8601) {
                    configFromISO(config);
                    return;
                }

                config._a = [];
                getParsingFlags(config).empty = true;

                // This array is used to make a Date, either with `new Date` or `Date.UTC`
                var string = '' + config._i,
                    i,
                    parsedInput,
                    tokens,
                    token,
                    skipped,
                    stringLength = string.length,
                    totalParsedInputLength = 0;

                tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                    // console.log('token', token, 'parsedInput', parsedInput,
                    //         'regex', getParseRegexForToken(token, config));
                    if (parsedInput) {
                        skipped = string.substr(0, string.indexOf(parsedInput));
                        if (skipped.length > 0) {
                            getParsingFlags(config).unusedInput.push(skipped);
                        }
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                        totalParsedInputLength += parsedInput.length;
                    }
                    // don't parse if it's not a known token
                    if (formatTokenFunctions[token]) {
                        if (parsedInput) {
                            getParsingFlags(config).empty = false;
                        } else {
                            getParsingFlags(config).unusedTokens.push(token);
                        }
                        addTimeToArrayFromToken(token, parsedInput, config);
                    } else if (config._strict && !parsedInput) {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                }

                // add remaining unparsed input length to the string
                getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                if (string.length > 0) {
                    getParsingFlags(config).unusedInput.push(string);
                }

                // clear _12h flag if hour is <= 12
                if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
                    getParsingFlags(config).bigHour = undefined;
                }

                getParsingFlags(config).parsedDateParts = config._a.slice(0);
                getParsingFlags(config).meridiem = config._meridiem;
                // handle meridiem
                config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

                configFromArray(config);
                checkOverflow(config);
            }

            function meridiemFixWrap(locale, hour, meridiem) {
                var isPm;

                if (meridiem == null) {
                    // nothing to do
                    return hour;
                }
                if (locale.meridiemHour != null) {
                    return locale.meridiemHour(hour, meridiem);
                } else if (locale.isPM != null) {
                    // Fallback
                    isPm = locale.isPM(meridiem);
                    if (isPm && hour < 12) {
                        hour += 12;
                    }
                    if (!isPm && hour === 12) {
                        hour = 0;
                    }
                    return hour;
                } else {
                    // this is not supposed to happen
                    return hour;
                }
            }

            // date from string and array of format strings
            function configFromStringAndArray(config) {
                var tempConfig, bestMoment, scoreToBeat, i, currentScore;

                if (config._f.length === 0) {
                    getParsingFlags(config).invalidFormat = true;
                    config._d = new Date(NaN);
                    return;
                }

                for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = copyConfig({}, config);
                    if (config._useUTC != null) {
                        tempConfig._useUTC = config._useUTC;
                    }
                    tempConfig._f = config._f[i];
                    configFromStringAndFormat(tempConfig);

                    if (!valid__isValid(tempConfig)) {
                        continue;
                    }

                    // if there is any input that was not parsed add a penalty for that format
                    currentScore += getParsingFlags(tempConfig).charsLeftOver;

                    //or tokens
                    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                    getParsingFlags(tempConfig).score = currentScore;

                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }

                extend(config, bestMoment || tempConfig);
            }

            function configFromObject(config) {
                if (config._d) {
                    return;
                }

                var i = normalizeObjectUnits(config._i);
                config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                    return obj && parseInt(obj, 10);
                });

                configFromArray(config);
            }

            function createFromConfig(config) {
                var res = new Moment(checkOverflow(prepareConfig(config)));
                if (res._nextDay) {
                    // Adding is smart enough around DST
                    res.add(1, 'd');
                    res._nextDay = undefined;
                }

                return res;
            }

            function prepareConfig(config) {
                var input = config._i,
                    format = config._f;

                config._locale = config._locale || locale_locales__getLocale(config._l);

                if (input === null || format === undefined && input === '') {
                    return valid__createInvalid({ nullInput: true });
                }

                if (typeof input === 'string') {
                    config._i = input = config._locale.preparse(input);
                }

                if (isMoment(input)) {
                    return new Moment(checkOverflow(input));
                } else if (isArray(format)) {
                    configFromStringAndArray(config);
                } else if (isDate(input)) {
                    config._d = input;
                } else if (format) {
                    configFromStringAndFormat(config);
                } else {
                    configFromInput(config);
                }

                if (!valid__isValid(config)) {
                    config._d = null;
                }

                return config;
            }

            function configFromInput(config) {
                var input = config._i;
                if (input === undefined) {
                    config._d = new Date(utils_hooks__hooks.now());
                } else if (isDate(input)) {
                    config._d = new Date(input.valueOf());
                } else if (typeof input === 'string') {
                    configFromString(config);
                } else if (isArray(input)) {
                    config._a = map(input.slice(0), function (obj) {
                        return parseInt(obj, 10);
                    });
                    configFromArray(config);
                } else if (typeof input === 'object') {
                    configFromObject(config);
                } else if (typeof input === 'number') {
                    // from milliseconds
                    config._d = new Date(input);
                } else {
                    utils_hooks__hooks.createFromInputFallback(config);
                }
            }

            function createLocalOrUTC(input, format, locale, strict, isUTC) {
                var c = {};

                if (typeof locale === 'boolean') {
                    strict = locale;
                    locale = undefined;
                }

                if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
                    input = undefined;
                }
                // object construction must be done this way.
                // https://github.com/moment/moment/issues/1423
                c._isAMomentObject = true;
                c._useUTC = c._isUTC = isUTC;
                c._l = locale;
                c._i = input;
                c._f = format;
                c._strict = strict;

                return createFromConfig(c);
            }

            function local__createLocal(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, false);
            }

            var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
                var other = local__createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return valid__createInvalid();
                }
            });

            var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
                var other = local__createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return valid__createInvalid();
                }
            });

            // Pick a moment m from moments so that m[fn](other) is true for all
            // other. This relies on the function fn to be transitive.
            //
            // moments should either be an array of moment objects or an array, whose
            // first element is an array of moment objects.
            function pickBy(fn, moments) {
                var res, i;
                if (moments.length === 1 && isArray(moments[0])) {
                    moments = moments[0];
                }
                if (!moments.length) {
                    return local__createLocal();
                }
                res = moments[0];
                for (i = 1; i < moments.length; ++i) {
                    if (!moments[i].isValid() || moments[i][fn](res)) {
                        res = moments[i];
                    }
                }
                return res;
            }

            // TODO: Use [].sort instead?
            function min() {
                var args = [].slice.call(arguments, 0);

                return pickBy('isBefore', args);
            }

            function max() {
                var args = [].slice.call(arguments, 0);

                return pickBy('isAfter', args);
            }

            var now = function () {
                return Date.now ? Date.now() : +new Date();
            };

            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration),
                    years = normalizedInput.year || 0,
                    quarters = normalizedInput.quarter || 0,
                    months = normalizedInput.month || 0,
                    weeks = normalizedInput.week || 0,
                    days = normalizedInput.day || 0,
                    hours = normalizedInput.hour || 0,
                    minutes = normalizedInput.minute || 0,
                    seconds = normalizedInput.second || 0,
                    milliseconds = normalizedInput.millisecond || 0;

                // representation for dateAddRemove
                this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
                // Because of dateAddRemove treats 24 hours as different from a
                // day when working around DST, we need to store them separately
                this._days = +days + weeks * 7;
                // It is impossible translate months into days without knowing
                // which months you are are talking about, so we have to store
                // it separately.
                this._months = +months + quarters * 3 + years * 12;

                this._data = {};

                this._locale = locale_locales__getLocale();

                this._bubble();
            }

            function isDuration(obj) {
                return obj instanceof Duration;
            }

            function absRound(number) {
                if (number < 0) {
                    return Math.round(-1 * number) * -1;
                } else {
                    return Math.round(number);
                }
            }

            // FORMATTING

            function offset(token, separator) {
                addFormatToken(token, 0, 0, function () {
                    var offset = this.utcOffset();
                    var sign = '+';
                    if (offset < 0) {
                        offset = -offset;
                        sign = '-';
                    }
                    return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
                });
            }

            offset('Z', ':');
            offset('ZZ', '');

            // PARSING

            addRegexToken('Z', matchShortOffset);
            addRegexToken('ZZ', matchShortOffset);
            addParseToken(['Z', 'ZZ'], function (input, array, config) {
                config._useUTC = true;
                config._tzm = offsetFromString(matchShortOffset, input);
            });

            // HELPERS

            // timezone chunker
            // '+10:00' > ['10',  '00']
            // '-1530'  > ['-15', '30']
            var chunkOffset = /([\+\-]|\d\d)/gi;

            function offsetFromString(matcher, string) {
                var matches = (string || '').match(matcher) || [];
                var chunk = matches[matches.length - 1] || [];
                var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
                var minutes = +(parts[1] * 60) + toInt(parts[2]);

                return parts[0] === '+' ? minutes : -minutes;
            }

            // Return a moment from input, that is local/utc/zone equivalent to model.
            function cloneWithOffset(input, model) {
                var res, diff;
                if (model._isUTC) {
                    res = model.clone();
                    diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
                    // Use low-level api, because this fn is low-level api.
                    res._d.setTime(res._d.valueOf() + diff);
                    utils_hooks__hooks.updateOffset(res, false);
                    return res;
                } else {
                    return local__createLocal(input).local();
                }
            }

            function getDateOffset(m) {
                // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                // https://github.com/moment/moment/pull/1871
                return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
            }

            // HOOKS

            // This function will be called whenever a moment is mutated.
            // It is intended to keep the offset in sync with the timezone.
            utils_hooks__hooks.updateOffset = function () {};

            // MOMENTS

            // keepLocalTime = true means only change the timezone, without
            // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
            // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
            // +0200, so we adjust the time as needed, to be valid.
            //
            // Keeping the time actually adds/subtracts (one hour)
            // from the actual represented time. That is why we call updateOffset
            // a second time. In case it wants us to change the offset again
            // _changeInProgress == true case, then we have to adjust, because
            // there is no such time in the given timezone.
            function getSetOffset(input, keepLocalTime) {
                var offset = this._offset || 0,
                    localAdjust;
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                if (input != null) {
                    if (typeof input === 'string') {
                        input = offsetFromString(matchShortOffset, input);
                    } else if (Math.abs(input) < 16) {
                        input = input * 60;
                    }
                    if (!this._isUTC && keepLocalTime) {
                        localAdjust = getDateOffset(this);
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                        this.add(localAdjust, 'm');
                    }
                    if (offset !== input) {
                        if (!keepLocalTime || this._changeInProgress) {
                            add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                        } else if (!this._changeInProgress) {
                            this._changeInProgress = true;
                            utils_hooks__hooks.updateOffset(this, true);
                            this._changeInProgress = null;
                        }
                    }
                    return this;
                } else {
                    return this._isUTC ? offset : getDateOffset(this);
                }
            }

            function getSetZone(input, keepLocalTime) {
                if (input != null) {
                    if (typeof input !== 'string') {
                        input = -input;
                    }

                    this.utcOffset(input, keepLocalTime);

                    return this;
                } else {
                    return -this.utcOffset();
                }
            }

            function setOffsetToUTC(keepLocalTime) {
                return this.utcOffset(0, keepLocalTime);
            }

            function setOffsetToLocal(keepLocalTime) {
                if (this._isUTC) {
                    this.utcOffset(0, keepLocalTime);
                    this._isUTC = false;

                    if (keepLocalTime) {
                        this.subtract(getDateOffset(this), 'm');
                    }
                }
                return this;
            }

            function setOffsetToParsedOffset() {
                if (this._tzm) {
                    this.utcOffset(this._tzm);
                } else if (typeof this._i === 'string') {
                    var tZone = offsetFromString(matchOffset, this._i);

                    if (tZone === 0) {
                        this.utcOffset(0, true);
                    } else {
                        this.utcOffset(offsetFromString(matchOffset, this._i));
                    }
                }
                return this;
            }

            function hasAlignedHourOffset(input) {
                if (!this.isValid()) {
                    return false;
                }
                input = input ? local__createLocal(input).utcOffset() : 0;

                return (this.utcOffset() - input) % 60 === 0;
            }

            function isDaylightSavingTime() {
                return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
            }

            function isDaylightSavingTimeShifted() {
                if (!isUndefined(this._isDSTShifted)) {
                    return this._isDSTShifted;
                }

                var c = {};

                copyConfig(c, this);
                c = prepareConfig(c);

                if (c._a) {
                    var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
                    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
                } else {
                    this._isDSTShifted = false;
                }

                return this._isDSTShifted;
            }

            function isLocal() {
                return this.isValid() ? !this._isUTC : false;
            }

            function isUtcOffset() {
                return this.isValid() ? this._isUTC : false;
            }

            function isUtc() {
                return this.isValid() ? this._isUTC && this._offset === 0 : false;
            }

            // ASP.NET json date format regex
            var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

            function create__createDuration(input, key) {
                var duration = input,

                // matching against regexp is expensive, do it on demand
                match = null,
                    sign,
                    ret,
                    diffRes;

                if (isDuration(input)) {
                    duration = {
                        ms: input._milliseconds,
                        d: input._days,
                        M: input._months
                    };
                } else if (typeof input === 'number') {
                    duration = {};
                    if (key) {
                        duration[key] = input;
                    } else {
                        duration.milliseconds = input;
                    }
                } else if (!!(match = aspNetRegex.exec(input))) {
                    sign = match[1] === '-' ? -1 : 1;
                    duration = {
                        y: 0,
                        d: toInt(match[DATE]) * sign,
                        h: toInt(match[HOUR]) * sign,
                        m: toInt(match[MINUTE]) * sign,
                        s: toInt(match[SECOND]) * sign,
                        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
                    };
                } else if (!!(match = isoRegex.exec(input))) {
                    sign = match[1] === '-' ? -1 : 1;
                    duration = {
                        y: parseIso(match[2], sign),
                        M: parseIso(match[3], sign),
                        w: parseIso(match[4], sign),
                        d: parseIso(match[5], sign),
                        h: parseIso(match[6], sign),
                        m: parseIso(match[7], sign),
                        s: parseIso(match[8], sign)
                    };
                } else if (duration == null) {
                    // checks for null or undefined
                    duration = {};
                } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                    diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months;
                }

                ret = new Duration(duration);

                if (isDuration(input) && hasOwnProp(input, '_locale')) {
                    ret._locale = input._locale;
                }

                return ret;
            }

            create__createDuration.fn = Duration.prototype;

            function parseIso(inp, sign) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            }

            function positiveMomentsDifference(base, other) {
                var res = { milliseconds: 0, months: 0 };

                res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                if (base.clone().add(res.months, 'M').isAfter(other)) {
                    --res.months;
                }

                res.milliseconds = +other - +base.clone().add(res.months, 'M');

                return res;
            }

            function momentsDifference(base, other) {
                var res;
                if (!(base.isValid() && other.isValid())) {
                    return { milliseconds: 0, months: 0 };
                }

                other = cloneWithOffset(other, base);
                if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other);
                } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months;
                }

                return res;
            }

            // TODO: remove 'name' arg after deprecation is removed
            function createAdder(direction, name) {
                return function (val, period) {
                    var dur, tmp;
                    //invert the arguments, but complain about it
                    if (period !== null && !isNaN(+period)) {
                        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                        tmp = val;val = period;period = tmp;
                    }

                    val = typeof val === 'string' ? +val : val;
                    dur = create__createDuration(val, period);
                    add_subtract__addSubtract(this, dur, direction);
                    return this;
                };
            }

            function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
                var milliseconds = duration._milliseconds,
                    days = absRound(duration._days),
                    months = absRound(duration._months);

                if (!mom.isValid()) {
                    // No op
                    return;
                }

                updateOffset = updateOffset == null ? true : updateOffset;

                if (milliseconds) {
                    mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                }
                if (days) {
                    get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
                }
                if (months) {
                    setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
                }
                if (updateOffset) {
                    utils_hooks__hooks.updateOffset(mom, days || months);
                }
            }

            var add_subtract__add = createAdder(1, 'add');
            var add_subtract__subtract = createAdder(-1, 'subtract');

            function getCalendarFormat(myMoment, now) {
                var diff = myMoment.diff(now, 'days', true);
                return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
            }

            function moment_calendar__calendar(time, formats) {
                // We want to compare the start of today, vs this.
                // Getting start-of-today depends on whether we're local/utc/offset or not.
                var now = time || local__createLocal(),
                    sod = cloneWithOffset(now, this).startOf('day'),
                    format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

                var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

                return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
            }

            function clone() {
                return new Moment(this);
            }

            function isAfter(input, units) {
                var localInput = isMoment(input) ? input : local__createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() > localInput.valueOf();
                } else {
                    return localInput.valueOf() < this.clone().startOf(units).valueOf();
                }
            }

            function isBefore(input, units) {
                var localInput = isMoment(input) ? input : local__createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() < localInput.valueOf();
                } else {
                    return this.clone().endOf(units).valueOf() < localInput.valueOf();
                }
            }

            function isBetween(from, to, units, inclusivity) {
                inclusivity = inclusivity || '()';
                return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
            }

            function isSame(input, units) {
                var localInput = isMoment(input) ? input : local__createLocal(input),
                    inputMs;
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(units || 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() === localInput.valueOf();
                } else {
                    inputMs = localInput.valueOf();
                    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                }
            }

            function isSameOrAfter(input, units) {
                return this.isSame(input, units) || this.isAfter(input, units);
            }

            function isSameOrBefore(input, units) {
                return this.isSame(input, units) || this.isBefore(input, units);
            }

            function diff(input, units, asFloat) {
                var that, zoneDelta, delta, output;

                if (!this.isValid()) {
                    return NaN;
                }

                that = cloneWithOffset(input, this);

                if (!that.isValid()) {
                    return NaN;
                }

                zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

                units = normalizeUnits(units);

                if (units === 'year' || units === 'month' || units === 'quarter') {
                    output = monthDiff(this, that);
                    if (units === 'quarter') {
                        output = output / 3;
                    } else if (units === 'year') {
                        output = output / 12;
                    }
                } else {
                    delta = this - that;
                    output = units === 'second' ? delta / 1e3 : // 1000
                    units === 'minute' ? delta / 6e4 : // 1000 * 60
                    units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    delta;
                }
                return asFloat ? output : absFloor(output);
            }

            function monthDiff(a, b) {
                // difference in months
                var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),

                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                    anchor2,
                    adjust;

                if (b - anchor < 0) {
                    anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                    // linear across the month
                    adjust = (b - anchor) / (anchor - anchor2);
                } else {
                    anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                    // linear across the month
                    adjust = (b - anchor) / (anchor2 - anchor);
                }

                //check for negative zero, return zero if negative zero
                return -(wholeMonthDiff + adjust) || 0;
            }

            utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
            utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

            function toString() {
                return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
            }

            function moment_format__toISOString() {
                var m = this.clone().utc();
                if (0 < m.year() && m.year() <= 9999) {
                    if (isFunction(Date.prototype.toISOString)) {
                        // native implementation is ~50x faster, use it when we can
                        return this.toDate().toISOString();
                    } else {
                        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                    }
                } else {
                    return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            }

            function format(inputString) {
                if (!inputString) {
                    inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
                }
                var output = formatMoment(this, inputString);
                return this.localeData().postformat(output);
            }

            function from(time, withoutSuffix) {
                if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {
                    return create__createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }

            function fromNow(withoutSuffix) {
                return this.from(local__createLocal(), withoutSuffix);
            }

            function to(time, withoutSuffix) {
                if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {
                    return create__createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }

            function toNow(withoutSuffix) {
                return this.to(local__createLocal(), withoutSuffix);
            }

            // If passed a locale key, it will set the locale for this
            // instance.  Otherwise, it will return the locale configuration
            // variables for this instance.
            function locale(key) {
                var newLocaleData;

                if (key === undefined) {
                    return this._locale._abbr;
                } else {
                    newLocaleData = locale_locales__getLocale(key);
                    if (newLocaleData != null) {
                        this._locale = newLocaleData;
                    }
                    return this;
                }
            }

            var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            });

            function localeData() {
                return this._locale;
            }

            function startOf(units) {
                units = normalizeUnits(units);
                // the following switch intentionally omits break keywords
                // to utilize falling through the cases.
                switch (units) {
                    case 'year':
                        this.month(0);
                    /* falls through */
                    case 'quarter':
                    case 'month':
                        this.date(1);
                    /* falls through */
                    case 'week':
                    case 'isoWeek':
                    case 'day':
                    case 'date':
                        this.hours(0);
                    /* falls through */
                    case 'hour':
                        this.minutes(0);
                    /* falls through */
                    case 'minute':
                        this.seconds(0);
                    /* falls through */
                    case 'second':
                        this.milliseconds(0);
                }

                // weeks are a special case
                if (units === 'week') {
                    this.weekday(0);
                }
                if (units === 'isoWeek') {
                    this.isoWeekday(1);
                }

                // quarters are also special
                if (units === 'quarter') {
                    this.month(Math.floor(this.month() / 3) * 3);
                }

                return this;
            }

            function endOf(units) {
                units = normalizeUnits(units);
                if (units === undefined || units === 'millisecond') {
                    return this;
                }

                // 'date' is an alias for 'day', so it should be considered as such.
                if (units === 'date') {
                    units = 'day';
                }

                return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
            }

            function to_type__valueOf() {
                return this._d.valueOf() - (this._offset || 0) * 60000;
            }

            function unix() {
                return Math.floor(this.valueOf() / 1000);
            }

            function toDate() {
                return new Date(this.valueOf());
            }

            function toArray() {
                var m = this;
                return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
            }

            function toObject() {
                var m = this;
                return {
                    years: m.year(),
                    months: m.month(),
                    date: m.date(),
                    hours: m.hours(),
                    minutes: m.minutes(),
                    seconds: m.seconds(),
                    milliseconds: m.milliseconds()
                };
            }

            function toJSON() {
                // new Date(NaN).toJSON() === null
                return this.isValid() ? this.toISOString() : null;
            }

            function moment_valid__isValid() {
                return valid__isValid(this);
            }

            function parsingFlags() {
                return extend({}, getParsingFlags(this));
            }

            function invalidAt() {
                return getParsingFlags(this).overflow;
            }

            function creationData() {
                return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict
                };
            }

            // FORMATTING

            addFormatToken(0, ['gg', 2], 0, function () {
                return this.weekYear() % 100;
            });

            addFormatToken(0, ['GG', 2], 0, function () {
                return this.isoWeekYear() % 100;
            });

            function addWeekYearFormatToken(token, getter) {
                addFormatToken(0, [token, token.length], 0, getter);
            }

            addWeekYearFormatToken('gggg', 'weekYear');
            addWeekYearFormatToken('ggggg', 'weekYear');
            addWeekYearFormatToken('GGGG', 'isoWeekYear');
            addWeekYearFormatToken('GGGGG', 'isoWeekYear');

            // ALIASES

            addUnitAlias('weekYear', 'gg');
            addUnitAlias('isoWeekYear', 'GG');

            // PRIORITY

            addUnitPriority('weekYear', 1);
            addUnitPriority('isoWeekYear', 1);

            // PARSING

            addRegexToken('G', matchSigned);
            addRegexToken('g', matchSigned);
            addRegexToken('GG', match1to2, match2);
            addRegexToken('gg', match1to2, match2);
            addRegexToken('GGGG', match1to4, match4);
            addRegexToken('gggg', match1to4, match4);
            addRegexToken('GGGGG', match1to6, match6);
            addRegexToken('ggggg', match1to6, match6);

            addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
                week[token.substr(0, 2)] = toInt(input);
            });

            addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
                week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
            });

            // MOMENTS

            function getSetWeekYear(input) {
                return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
            }

            function getSetISOWeekYear(input) {
                return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
            }

            function getISOWeeksInYear() {
                return weeksInYear(this.year(), 1, 4);
            }

            function getWeeksInYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
            }

            function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                var weeksTarget;
                if (input == null) {
                    return weekOfYear(this, dow, doy).year;
                } else {
                    weeksTarget = weeksInYear(input, dow, doy);
                    if (week > weeksTarget) {
                        week = weeksTarget;
                    }
                    return setWeekAll.call(this, input, week, weekday, dow, doy);
                }
            }

            function setWeekAll(weekYear, week, weekday, dow, doy) {
                var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                    date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

                this.year(date.getUTCFullYear());
                this.month(date.getUTCMonth());
                this.date(date.getUTCDate());
                return this;
            }

            // FORMATTING

            addFormatToken('Q', 0, 'Qo', 'quarter');

            // ALIASES

            addUnitAlias('quarter', 'Q');

            // PRIORITY

            addUnitPriority('quarter', 7);

            // PARSING

            addRegexToken('Q', match1);
            addParseToken('Q', function (input, array) {
                array[MONTH] = (toInt(input) - 1) * 3;
            });

            // MOMENTS

            function getSetQuarter(input) {
                return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
            }

            // FORMATTING

            addFormatToken('D', ['DD', 2], 'Do', 'date');

            // ALIASES

            addUnitAlias('date', 'D');

            // PRIOROITY
            addUnitPriority('date', 9);

            // PARSING

            addRegexToken('D', match1to2);
            addRegexToken('DD', match1to2, match2);
            addRegexToken('Do', function (isStrict, locale) {
                return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
            });

            addParseToken(['D', 'DD'], DATE);
            addParseToken('Do', function (input, array) {
                array[DATE] = toInt(input.match(match1to2)[0], 10);
            });

            // MOMENTS

            var getSetDayOfMonth = makeGetSet('Date', true);

            // FORMATTING

            addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

            // ALIASES

            addUnitAlias('dayOfYear', 'DDD');

            // PRIORITY
            addUnitPriority('dayOfYear', 4);

            // PARSING

            addRegexToken('DDD', match1to3);
            addRegexToken('DDDD', match3);
            addParseToken(['DDD', 'DDDD'], function (input, array, config) {
                config._dayOfYear = toInt(input);
            });

            // HELPERS

            // MOMENTS

            function getSetDayOfYear(input) {
                var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
                return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
            }

            // FORMATTING

            addFormatToken('m', ['mm', 2], 0, 'minute');

            // ALIASES

            addUnitAlias('minute', 'm');

            // PRIORITY

            addUnitPriority('minute', 14);

            // PARSING

            addRegexToken('m', match1to2);
            addRegexToken('mm', match1to2, match2);
            addParseToken(['m', 'mm'], MINUTE);

            // MOMENTS

            var getSetMinute = makeGetSet('Minutes', false);

            // FORMATTING

            addFormatToken('s', ['ss', 2], 0, 'second');

            // ALIASES

            addUnitAlias('second', 's');

            // PRIORITY

            addUnitPriority('second', 15);

            // PARSING

            addRegexToken('s', match1to2);
            addRegexToken('ss', match1to2, match2);
            addParseToken(['s', 'ss'], SECOND);

            // MOMENTS

            var getSetSecond = makeGetSet('Seconds', false);

            // FORMATTING

            addFormatToken('S', 0, 0, function () {
                return ~~(this.millisecond() / 100);
            });

            addFormatToken(0, ['SS', 2], 0, function () {
                return ~~(this.millisecond() / 10);
            });

            addFormatToken(0, ['SSS', 3], 0, 'millisecond');
            addFormatToken(0, ['SSSS', 4], 0, function () {
                return this.millisecond() * 10;
            });
            addFormatToken(0, ['SSSSS', 5], 0, function () {
                return this.millisecond() * 100;
            });
            addFormatToken(0, ['SSSSSS', 6], 0, function () {
                return this.millisecond() * 1000;
            });
            addFormatToken(0, ['SSSSSSS', 7], 0, function () {
                return this.millisecond() * 10000;
            });
            addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
                return this.millisecond() * 100000;
            });
            addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
                return this.millisecond() * 1000000;
            });

            // ALIASES

            addUnitAlias('millisecond', 'ms');

            // PRIORITY

            addUnitPriority('millisecond', 16);

            // PARSING

            addRegexToken('S', match1to3, match1);
            addRegexToken('SS', match1to3, match2);
            addRegexToken('SSS', match1to3, match3);

            var token;
            for (token = 'SSSS'; token.length <= 9; token += 'S') {
                addRegexToken(token, matchUnsigned);
            }

            function parseMs(input, array) {
                array[MILLISECOND] = toInt(('0.' + input) * 1000);
            }

            for (token = 'S'; token.length <= 9; token += 'S') {
                addParseToken(token, parseMs);
            }
            // MOMENTS

            var getSetMillisecond = makeGetSet('Milliseconds', false);

            // FORMATTING

            addFormatToken('z', 0, 0, 'zoneAbbr');
            addFormatToken('zz', 0, 0, 'zoneName');

            // MOMENTS

            function getZoneAbbr() {
                return this._isUTC ? 'UTC' : '';
            }

            function getZoneName() {
                return this._isUTC ? 'Coordinated Universal Time' : '';
            }

            var momentPrototype__proto = Moment.prototype;

            momentPrototype__proto.add = add_subtract__add;
            momentPrototype__proto.calendar = moment_calendar__calendar;
            momentPrototype__proto.clone = clone;
            momentPrototype__proto.diff = diff;
            momentPrototype__proto.endOf = endOf;
            momentPrototype__proto.format = format;
            momentPrototype__proto.from = from;
            momentPrototype__proto.fromNow = fromNow;
            momentPrototype__proto.to = to;
            momentPrototype__proto.toNow = toNow;
            momentPrototype__proto.get = stringGet;
            momentPrototype__proto.invalidAt = invalidAt;
            momentPrototype__proto.isAfter = isAfter;
            momentPrototype__proto.isBefore = isBefore;
            momentPrototype__proto.isBetween = isBetween;
            momentPrototype__proto.isSame = isSame;
            momentPrototype__proto.isSameOrAfter = isSameOrAfter;
            momentPrototype__proto.isSameOrBefore = isSameOrBefore;
            momentPrototype__proto.isValid = moment_valid__isValid;
            momentPrototype__proto.lang = lang;
            momentPrototype__proto.locale = locale;
            momentPrototype__proto.localeData = localeData;
            momentPrototype__proto.max = prototypeMax;
            momentPrototype__proto.min = prototypeMin;
            momentPrototype__proto.parsingFlags = parsingFlags;
            momentPrototype__proto.set = stringSet;
            momentPrototype__proto.startOf = startOf;
            momentPrototype__proto.subtract = add_subtract__subtract;
            momentPrototype__proto.toArray = toArray;
            momentPrototype__proto.toObject = toObject;
            momentPrototype__proto.toDate = toDate;
            momentPrototype__proto.toISOString = moment_format__toISOString;
            momentPrototype__proto.toJSON = toJSON;
            momentPrototype__proto.toString = toString;
            momentPrototype__proto.unix = unix;
            momentPrototype__proto.valueOf = to_type__valueOf;
            momentPrototype__proto.creationData = creationData;

            // Year
            momentPrototype__proto.year = getSetYear;
            momentPrototype__proto.isLeapYear = getIsLeapYear;

            // Week Year
            momentPrototype__proto.weekYear = getSetWeekYear;
            momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

            // Quarter
            momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

            // Month
            momentPrototype__proto.month = getSetMonth;
            momentPrototype__proto.daysInMonth = getDaysInMonth;

            // Week
            momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
            momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
            momentPrototype__proto.weeksInYear = getWeeksInYear;
            momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

            // Day
            momentPrototype__proto.date = getSetDayOfMonth;
            momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
            momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
            momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
            momentPrototype__proto.dayOfYear = getSetDayOfYear;

            // Hour
            momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

            // Minute
            momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

            // Second
            momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

            // Millisecond
            momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

            // Offset
            momentPrototype__proto.utcOffset = getSetOffset;
            momentPrototype__proto.utc = setOffsetToUTC;
            momentPrototype__proto.local = setOffsetToLocal;
            momentPrototype__proto.parseZone = setOffsetToParsedOffset;
            momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
            momentPrototype__proto.isDST = isDaylightSavingTime;
            momentPrototype__proto.isLocal = isLocal;
            momentPrototype__proto.isUtcOffset = isUtcOffset;
            momentPrototype__proto.isUtc = isUtc;
            momentPrototype__proto.isUTC = isUtc;

            // Timezone
            momentPrototype__proto.zoneAbbr = getZoneAbbr;
            momentPrototype__proto.zoneName = getZoneName;

            // Deprecations
            momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
            momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
            momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
            momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
            momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

            var momentPrototype = momentPrototype__proto;

            function moment__createUnix(input) {
                return local__createLocal(input * 1000);
            }

            function moment__createInZone() {
                return local__createLocal.apply(null, arguments).parseZone();
            }

            function preParsePostFormat(string) {
                return string;
            }

            var prototype__proto = Locale.prototype;

            prototype__proto.calendar = locale_calendar__calendar;
            prototype__proto.longDateFormat = longDateFormat;
            prototype__proto.invalidDate = invalidDate;
            prototype__proto.ordinal = ordinal;
            prototype__proto.preparse = preParsePostFormat;
            prototype__proto.postformat = preParsePostFormat;
            prototype__proto.relativeTime = relative__relativeTime;
            prototype__proto.pastFuture = pastFuture;
            prototype__proto.set = locale_set__set;

            // Month
            prototype__proto.months = localeMonths;
            prototype__proto.monthsShort = localeMonthsShort;
            prototype__proto.monthsParse = localeMonthsParse;
            prototype__proto.monthsRegex = monthsRegex;
            prototype__proto.monthsShortRegex = monthsShortRegex;

            // Week
            prototype__proto.week = localeWeek;
            prototype__proto.firstDayOfYear = localeFirstDayOfYear;
            prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

            // Day of Week
            prototype__proto.weekdays = localeWeekdays;
            prototype__proto.weekdaysMin = localeWeekdaysMin;
            prototype__proto.weekdaysShort = localeWeekdaysShort;
            prototype__proto.weekdaysParse = localeWeekdaysParse;

            prototype__proto.weekdaysRegex = weekdaysRegex;
            prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
            prototype__proto.weekdaysMinRegex = weekdaysMinRegex;

            // Hours
            prototype__proto.isPM = localeIsPM;
            prototype__proto.meridiem = localeMeridiem;

            function lists__get(format, index, field, setter) {
                var locale = locale_locales__getLocale();
                var utc = create_utc__createUTC().set(setter, index);
                return locale[field](utc, format);
            }

            function listMonthsImpl(format, index, field) {
                if (typeof format === 'number') {
                    index = format;
                    format = undefined;
                }

                format = format || '';

                if (index != null) {
                    return lists__get(format, index, field, 'month');
                }

                var i;
                var out = [];
                for (i = 0; i < 12; i++) {
                    out[i] = lists__get(format, i, field, 'month');
                }
                return out;
            }

            // ()
            // (5)
            // (fmt, 5)
            // (fmt)
            // (true)
            // (true, 5)
            // (true, fmt, 5)
            // (true, fmt)
            function listWeekdaysImpl(localeSorted, format, index, field) {
                if (typeof localeSorted === 'boolean') {
                    if (typeof format === 'number') {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';
                } else {
                    format = localeSorted;
                    index = format;
                    localeSorted = false;

                    if (typeof format === 'number') {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';
                }

                var locale = locale_locales__getLocale(),
                    shift = localeSorted ? locale._week.dow : 0;

                if (index != null) {
                    return lists__get(format, (index + shift) % 7, field, 'day');
                }

                var i;
                var out = [];
                for (i = 0; i < 7; i++) {
                    out[i] = lists__get(format, (i + shift) % 7, field, 'day');
                }
                return out;
            }

            function lists__listMonths(format, index) {
                return listMonthsImpl(format, index, 'months');
            }

            function lists__listMonthsShort(format, index) {
                return listMonthsImpl(format, index, 'monthsShort');
            }

            function lists__listWeekdays(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
            }

            function lists__listWeekdaysShort(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
            }

            function lists__listWeekdaysMin(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
            }

            locale_locales__getSetGlobalLocale('en', {
                ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
                    return number + output;
                }
            });

            // Side effect imports
            utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
            utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

            var mathAbs = Math.abs;

            function duration_abs__abs() {
                var data = this._data;

                this._milliseconds = mathAbs(this._milliseconds);
                this._days = mathAbs(this._days);
                this._months = mathAbs(this._months);

                data.milliseconds = mathAbs(data.milliseconds);
                data.seconds = mathAbs(data.seconds);
                data.minutes = mathAbs(data.minutes);
                data.hours = mathAbs(data.hours);
                data.months = mathAbs(data.months);
                data.years = mathAbs(data.years);

                return this;
            }

            function duration_add_subtract__addSubtract(duration, input, value, direction) {
                var other = create__createDuration(input, value);

                duration._milliseconds += direction * other._milliseconds;
                duration._days += direction * other._days;
                duration._months += direction * other._months;

                return duration._bubble();
            }

            // supports only 2.0-style add(1, 's') or add(duration)
            function duration_add_subtract__add(input, value) {
                return duration_add_subtract__addSubtract(this, input, value, 1);
            }

            // supports only 2.0-style subtract(1, 's') or subtract(duration)
            function duration_add_subtract__subtract(input, value) {
                return duration_add_subtract__addSubtract(this, input, value, -1);
            }

            function absCeil(number) {
                if (number < 0) {
                    return Math.floor(number);
                } else {
                    return Math.ceil(number);
                }
            }

            function bubble() {
                var milliseconds = this._milliseconds;
                var days = this._days;
                var months = this._months;
                var data = this._data;
                var seconds, minutes, hours, years, monthsFromDays;

                // if we have a mix of positive and negative values, bubble down first
                // check: https://github.com/moment/moment/issues/2166
                if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
                    milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                    days = 0;
                    months = 0;
                }

                // The following code bubbles up values, see the tests for
                // examples of what that means.
                data.milliseconds = milliseconds % 1000;

                seconds = absFloor(milliseconds / 1000);
                data.seconds = seconds % 60;

                minutes = absFloor(seconds / 60);
                data.minutes = minutes % 60;

                hours = absFloor(minutes / 60);
                data.hours = hours % 24;

                days += absFloor(hours / 24);

                // convert days to months
                monthsFromDays = absFloor(daysToMonths(days));
                months += monthsFromDays;
                days -= absCeil(monthsToDays(monthsFromDays));

                // 12 months -> 1 year
                years = absFloor(months / 12);
                months %= 12;

                data.days = days;
                data.months = months;
                data.years = years;

                return this;
            }

            function daysToMonths(days) {
                // 400 years have 146097 days (taking into account leap year rules)
                // 400 years have 12 months === 4800
                return days * 4800 / 146097;
            }

            function monthsToDays(months) {
                // the reverse of daysToMonths
                return months * 146097 / 4800;
            }

            function as(units) {
                var days;
                var months;
                var milliseconds = this._milliseconds;

                units = normalizeUnits(units);

                if (units === 'month' || units === 'year') {
                    days = this._days + milliseconds / 864e5;
                    months = this._months + daysToMonths(days);
                    return units === 'month' ? months : months / 12;
                } else {
                    // handle milliseconds separately because of floating point math errors (issue #1867)
                    days = this._days + Math.round(monthsToDays(this._months));
                    switch (units) {
                        case 'week':
                            return days / 7 + milliseconds / 6048e5;
                        case 'day':
                            return days + milliseconds / 864e5;
                        case 'hour':
                            return days * 24 + milliseconds / 36e5;
                        case 'minute':
                            return days * 1440 + milliseconds / 6e4;
                        case 'second':
                            return days * 86400 + milliseconds / 1000;
                        // Math.floor prevents floating point math errors here
                        case 'millisecond':
                            return Math.floor(days * 864e5) + milliseconds;
                        default:
                            throw new Error('Unknown unit ' + units);
                    }
                }
            }

            // TODO: Use this.as('ms')?
            function duration_as__valueOf() {
                return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
            }

            function makeAs(alias) {
                return function () {
                    return this.as(alias);
                };
            }

            var asMilliseconds = makeAs('ms');
            var asSeconds = makeAs('s');
            var asMinutes = makeAs('m');
            var asHours = makeAs('h');
            var asDays = makeAs('d');
            var asWeeks = makeAs('w');
            var asMonths = makeAs('M');
            var asYears = makeAs('y');

            function duration_get__get(units) {
                units = normalizeUnits(units);
                return this[units + 's']();
            }

            function makeGetter(name) {
                return function () {
                    return this._data[name];
                };
            }

            var milliseconds = makeGetter('milliseconds');
            var seconds = makeGetter('seconds');
            var minutes = makeGetter('minutes');
            var hours = makeGetter('hours');
            var days = makeGetter('days');
            var months = makeGetter('months');
            var years = makeGetter('years');

            function weeks() {
                return absFloor(this.days() / 7);
            }

            var round = Math.round;
            var thresholds = {
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month
                M: 11 // months to year
            };

            // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
            function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
            }

            function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
                var duration = create__createDuration(posNegDuration).abs();
                var seconds = round(duration.as('s'));
                var minutes = round(duration.as('m'));
                var hours = round(duration.as('h'));
                var days = round(duration.as('d'));
                var months = round(duration.as('M'));
                var years = round(duration.as('y'));

                var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];

                a[2] = withoutSuffix;
                a[3] = +posNegDuration > 0;
                a[4] = locale;
                return substituteTimeAgo.apply(null, a);
            }

            // This function allows you to set the rounding function for relative time strings
            function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {
                if (roundingFunction === undefined) {
                    return round;
                }
                if (typeof roundingFunction === 'function') {
                    round = roundingFunction;
                    return true;
                }
                return false;
            }

            // This function allows you to set a threshold for relative time strings
            function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
                if (thresholds[threshold] === undefined) {
                    return false;
                }
                if (limit === undefined) {
                    return thresholds[threshold];
                }
                thresholds[threshold] = limit;
                return true;
            }

            function humanize(withSuffix) {
                var locale = this.localeData();
                var output = duration_humanize__relativeTime(this, !withSuffix, locale);

                if (withSuffix) {
                    output = locale.pastFuture(+this, output);
                }

                return locale.postformat(output);
            }

            var iso_string__abs = Math.abs;

            function iso_string__toISOString() {
                // for ISO strings we do not use the normal bubbling rules:
                //  * milliseconds bubble up until they become hours
                //  * days do not bubble at all
                //  * months bubble up until they become years
                // This is because there is no context-free conversion between hours and days
                // (think of clock changes)
                // and also not between days and months (28-31 days per month)
                var seconds = iso_string__abs(this._milliseconds) / 1000;
                var days = iso_string__abs(this._days);
                var months = iso_string__abs(this._months);
                var minutes, hours, years;

                // 3600 seconds -> 60 minutes -> 1 hour
                minutes = absFloor(seconds / 60);
                hours = absFloor(minutes / 60);
                seconds %= 60;
                minutes %= 60;

                // 12 months -> 1 year
                years = absFloor(months / 12);
                months %= 12;

                // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                var Y = years;
                var M = months;
                var D = days;
                var h = hours;
                var m = minutes;
                var s = seconds;
                var total = this.asSeconds();

                if (!total) {
                    // this is the same as C#'s (Noda) and python (isodate)...
                    // but not other JS (goog.date)
                    return 'P0D';
                }

                return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
            }

            var duration_prototype__proto = Duration.prototype;

            duration_prototype__proto.abs = duration_abs__abs;
            duration_prototype__proto.add = duration_add_subtract__add;
            duration_prototype__proto.subtract = duration_add_subtract__subtract;
            duration_prototype__proto.as = as;
            duration_prototype__proto.asMilliseconds = asMilliseconds;
            duration_prototype__proto.asSeconds = asSeconds;
            duration_prototype__proto.asMinutes = asMinutes;
            duration_prototype__proto.asHours = asHours;
            duration_prototype__proto.asDays = asDays;
            duration_prototype__proto.asWeeks = asWeeks;
            duration_prototype__proto.asMonths = asMonths;
            duration_prototype__proto.asYears = asYears;
            duration_prototype__proto.valueOf = duration_as__valueOf;
            duration_prototype__proto._bubble = bubble;
            duration_prototype__proto.get = duration_get__get;
            duration_prototype__proto.milliseconds = milliseconds;
            duration_prototype__proto.seconds = seconds;
            duration_prototype__proto.minutes = minutes;
            duration_prototype__proto.hours = hours;
            duration_prototype__proto.days = days;
            duration_prototype__proto.weeks = weeks;
            duration_prototype__proto.months = months;
            duration_prototype__proto.years = years;
            duration_prototype__proto.humanize = humanize;
            duration_prototype__proto.toISOString = iso_string__toISOString;
            duration_prototype__proto.toString = iso_string__toISOString;
            duration_prototype__proto.toJSON = iso_string__toISOString;
            duration_prototype__proto.locale = locale;
            duration_prototype__proto.localeData = localeData;

            // Deprecations
            duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
            duration_prototype__proto.lang = lang;

            // Side effect imports

            // FORMATTING

            addFormatToken('X', 0, 0, 'unix');
            addFormatToken('x', 0, 0, 'valueOf');

            // PARSING

            addRegexToken('x', matchSigned);
            addRegexToken('X', matchTimestamp);
            addParseToken('X', function (input, array, config) {
                config._d = new Date(parseFloat(input, 10) * 1000);
            });
            addParseToken('x', function (input, array, config) {
                config._d = new Date(toInt(input));
            });

            // Side effect imports


            utils_hooks__hooks.version = '2.15.1';

            setHookCallback(local__createLocal);

            utils_hooks__hooks.fn = momentPrototype;
            utils_hooks__hooks.min = min;
            utils_hooks__hooks.max = max;
            utils_hooks__hooks.now = now;
            utils_hooks__hooks.utc = create_utc__createUTC;
            utils_hooks__hooks.unix = moment__createUnix;
            utils_hooks__hooks.months = lists__listMonths;
            utils_hooks__hooks.isDate = isDate;
            utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
            utils_hooks__hooks.invalid = valid__createInvalid;
            utils_hooks__hooks.duration = create__createDuration;
            utils_hooks__hooks.isMoment = isMoment;
            utils_hooks__hooks.weekdays = lists__listWeekdays;
            utils_hooks__hooks.parseZone = moment__createInZone;
            utils_hooks__hooks.localeData = locale_locales__getLocale;
            utils_hooks__hooks.isDuration = isDuration;
            utils_hooks__hooks.monthsShort = lists__listMonthsShort;
            utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
            utils_hooks__hooks.defineLocale = defineLocale;
            utils_hooks__hooks.updateLocale = updateLocale;
            utils_hooks__hooks.locales = locale_locales__listLocales;
            utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
            utils_hooks__hooks.normalizeUnits = normalizeUnits;
            utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
            utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
            utils_hooks__hooks.calendarFormat = getCalendarFormat;
            utils_hooks__hooks.prototype = momentPrototype;

            var _moment = utils_hooks__hooks;

            return _moment;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('7', ['4', '5', '6'], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    var timerModule = $__global['timerModule'],
        app = $__global['app'];
    /**
     * angular-timer - v1.3.4 - 2016-05-01 9:52 PM
     * https://github.com/siddii/angular-timer
     *
     * Copyright (c) 2016 Siddique Hameed
     * Licensed MIT <https://github.com/siddii/angular-timer/blob/master/LICENSE.txt>
     */
    var timerModule = angular.module('timer', []).directive('timer', ['$compile', function ($compile) {
      return {
        restrict: 'EA',
        replace: false,
        scope: {
          interval: '=interval',
          startTimeAttr: '=startTime',
          endTimeAttr: '=endTime',
          countdownattr: '=countdown',
          finishCallback: '&finishCallback',
          autoStart: '&autoStart',
          language: '@?',
          fallback: '@?',
          maxTimeUnit: '=',
          seconds: '=?',
          minutes: '=?',
          hours: '=?',
          days: '=?',
          months: '=?',
          years: '=?',
          secondsS: '=?',
          minutesS: '=?',
          hoursS: '=?',
          daysS: '=?',
          monthsS: '=?',
          yearsS: '=?'
        },
        controller: ['$scope', '$element', '$attrs', '$timeout', 'I18nService', '$interpolate', 'progressBarService', function ($scope, $element, $attrs, $timeout, I18nService, $interpolate, progressBarService) {

          // Checking for trim function since IE8 doesn't have it
          // If not a function, create tirm with RegEx to mimic native trim
          if (typeof String.prototype.trim !== 'function') {
            String.prototype.trim = function () {
              return this.replace(/^\s+|\s+$/g, '');
            };
          }

          //angular 1.2 doesn't support attributes ending in "-start", so we're
          //supporting both "autostart" and "auto-start" as a solution for
          //backward and forward compatibility.
          $scope.autoStart = $attrs.autoStart || $attrs.autostart;

          $scope.language = $scope.language || 'en';
          $scope.fallback = $scope.fallback || 'en';

          //allow to change the language of the directive while already launched
          $scope.$watch('language', function (newVal, oldVal) {
            if (newVal !== undefined) {
              i18nService.init(newVal, $scope.fallback);
            }
          });

          //init momentJS i18n, default english
          var i18nService = new I18nService();
          i18nService.init($scope.language, $scope.fallback);

          //progress bar
          $scope.displayProgressBar = 0;
          $scope.displayProgressActive = 'active'; //Bootstrap active effect for progress bar

          if ($element.html().trim().length === 0) {
            $element.append($compile('<span>' + $interpolate.startSymbol() + 'millis' + $interpolate.endSymbol() + '</span>')($scope));
          } else {
            $element.append($compile($element.contents())($scope));
          }

          $scope.startTime = null;
          $scope.endTime = null;
          $scope.timeoutId = null;
          $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) >= 0 ? parseInt($scope.countdownattr, 10) : undefined;
          $scope.isRunning = false;

          $scope.$on('timer-start', function () {
            $scope.start();
          });

          $scope.$on('timer-resume', function () {
            $scope.resume();
          });

          $scope.$on('timer-stop', function () {
            $scope.stop();
          });

          $scope.$on('timer-clear', function () {
            $scope.clear();
          });

          $scope.$on('timer-reset', function () {
            $scope.reset();
          });

          $scope.$on('timer-set-countdown', function (e, countdown) {
            $scope.countdown = countdown;
          });

          function resetTimeout() {
            if ($scope.timeoutId) {
              clearTimeout($scope.timeoutId);
            }
          }

          $scope.$watch('startTimeAttr', function (newValue, oldValue) {
            if (newValue !== oldValue && $scope.isRunning) {
              $scope.start();
            }
          });

          $scope.$watch('endTimeAttr', function (newValue, oldValue) {
            if (newValue !== oldValue && $scope.isRunning) {
              $scope.start();
            }
          });

          $scope.start = $element[0].start = function () {
            $scope.startTime = $scope.startTimeAttr ? moment($scope.startTimeAttr) : moment();
            $scope.endTime = $scope.endTimeAttr ? moment($scope.endTimeAttr) : null;
            if (!angular.isNumber($scope.countdown)) {
              $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : undefined;
            }
            resetTimeout();
            tick();
            $scope.isRunning = true;
          };

          $scope.resume = $element[0].resume = function () {
            resetTimeout();
            if ($scope.countdownattr) {
              $scope.countdown += 1;
            }
            $scope.startTime = moment().diff(moment($scope.stoppedTime).diff(moment($scope.startTime)));
            tick();
            $scope.isRunning = true;
          };

          $scope.stop = $scope.pause = $element[0].stop = $element[0].pause = function () {
            var timeoutId = $scope.timeoutId;
            $scope.clear();
            $scope.$emit('timer-stopped', { timeoutId: timeoutId, millis: $scope.millis, seconds: $scope.seconds, minutes: $scope.minutes, hours: $scope.hours, days: $scope.days });
          };

          $scope.clear = $element[0].clear = function () {
            // same as stop but without the event being triggered
            $scope.stoppedTime = moment();
            resetTimeout();
            $scope.timeoutId = null;
            $scope.isRunning = false;
          };

          $scope.reset = $element[0].reset = function () {
            $scope.startTime = $scope.startTimeAttr ? moment($scope.startTimeAttr) : moment();
            $scope.endTime = $scope.endTimeAttr ? moment($scope.endTimeAttr) : null;
            $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : undefined;
            resetTimeout();
            tick();
            $scope.isRunning = false;
            $scope.clear();
          };

          $element.bind('$destroy', function () {
            resetTimeout();
            $scope.isRunning = false;
          });

          function calculateTimeUnits() {
            var timeUnits = {}; //will contains time with units

            if ($attrs.startTime !== undefined) {
              $scope.millis = moment().diff(moment($scope.startTimeAttr));
            }

            timeUnits = i18nService.getTimeUnits($scope.millis);

            // compute time values based on maxTimeUnit specification
            if (!$scope.maxTimeUnit || $scope.maxTimeUnit === 'day') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000 % 24);
              $scope.days = Math.floor($scope.millis / 3600000 / 24);
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'second') {
              $scope.seconds = Math.floor($scope.millis / 1000);
              $scope.minutes = 0;
              $scope.hours = 0;
              $scope.days = 0;
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'minute') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000);
              $scope.hours = 0;
              $scope.days = 0;
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'hour') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000);
              $scope.days = 0;
              $scope.months = 0;
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'month') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000 % 24);
              $scope.days = Math.floor($scope.millis / 3600000 / 24 % 30);
              $scope.months = Math.floor($scope.millis / 3600000 / 24 / 30);
              $scope.years = 0;
            } else if ($scope.maxTimeUnit === 'year') {
              $scope.seconds = Math.floor($scope.millis / 1000 % 60);
              $scope.minutes = Math.floor($scope.millis / 60000 % 60);
              $scope.hours = Math.floor($scope.millis / 3600000 % 24);
              $scope.days = Math.floor($scope.millis / 3600000 / 24 % 30);
              $scope.months = Math.floor($scope.millis / 3600000 / 24 / 30 % 12);
              $scope.years = Math.floor($scope.millis / 3600000 / 24 / 365);
            }
            // plural - singular unit decision (old syntax, for backwards compatibility and English only, could be deprecated!)
            $scope.secondsS = $scope.seconds === 1 ? '' : 's';
            $scope.minutesS = $scope.minutes === 1 ? '' : 's';
            $scope.hoursS = $scope.hours === 1 ? '' : 's';
            $scope.daysS = $scope.days === 1 ? '' : 's';
            $scope.monthsS = $scope.months === 1 ? '' : 's';
            $scope.yearsS = $scope.years === 1 ? '' : 's';

            // new plural-singular unit decision functions (for custom units and multilingual support)
            $scope.secondUnit = timeUnits.seconds;
            $scope.minuteUnit = timeUnits.minutes;
            $scope.hourUnit = timeUnits.hours;
            $scope.dayUnit = timeUnits.days;
            $scope.monthUnit = timeUnits.months;
            $scope.yearUnit = timeUnits.years;

            //add leading zero if number is smaller than 10
            $scope.sseconds = $scope.seconds < 10 ? '0' + $scope.seconds : $scope.seconds;
            $scope.mminutes = $scope.minutes < 10 ? '0' + $scope.minutes : $scope.minutes;
            $scope.hhours = $scope.hours < 10 ? '0' + $scope.hours : $scope.hours;
            $scope.ddays = $scope.days < 10 ? '0' + $scope.days : $scope.days;
            $scope.mmonths = $scope.months < 10 ? '0' + $scope.months : $scope.months;
            $scope.yyears = $scope.years < 10 ? '0' + $scope.years : $scope.years;
          }

          //determine initial values of time units and add AddSeconds functionality
          if ($scope.countdownattr) {
            $scope.millis = $scope.countdownattr * 1000;

            $scope.addCDSeconds = $element[0].addCDSeconds = function (extraSeconds) {
              $scope.countdown += extraSeconds;
              $scope.$digest();
              if (!$scope.isRunning) {
                $scope.start();
              }
            };

            $scope.$on('timer-add-cd-seconds', function (e, extraSeconds) {
              $timeout(function () {
                $scope.addCDSeconds(extraSeconds);
              });
            });

            $scope.$on('timer-set-countdown-seconds', function (e, countdownSeconds) {
              if (!$scope.isRunning) {
                $scope.clear();
              }

              $scope.countdown = countdownSeconds;
              $scope.millis = countdownSeconds * 1000;
              calculateTimeUnits();
            });
          } else {
            $scope.millis = 0;
          }
          calculateTimeUnits();

          var tick = function tick() {
            var typeTimer = null; // countdown or endTimeAttr
            $scope.millis = moment().diff($scope.startTime);
            var adjustment = $scope.millis % 1000;

            if ($scope.endTimeAttr) {
              typeTimer = $scope.endTimeAttr;
              $scope.millis = moment($scope.endTime).diff(moment());
              adjustment = $scope.interval - $scope.millis % 1000;
            }

            if ($scope.countdownattr) {
              typeTimer = $scope.countdownattr;
              $scope.millis = $scope.countdown * 1000;
            }

            if ($scope.millis < 0) {
              $scope.stop();
              $scope.millis = 0;
              calculateTimeUnits();
              if ($scope.finishCallback) {
                $scope.$eval($scope.finishCallback);
              }
              return;
            }
            calculateTimeUnits();

            //We are not using $timeout for a reason. Please read here - https://github.com/siddii/angular-timer/pull/5
            $scope.timeoutId = setTimeout(function () {
              tick();
              $scope.$digest();
            }, $scope.interval - adjustment);

            $scope.$emit('timer-tick', { timeoutId: $scope.timeoutId, millis: $scope.millis, timerElement: $element[0] });

            if ($scope.countdown > 0) {
              $scope.countdown--;
            } else if ($scope.countdown <= 0) {
              $scope.stop();
              if ($scope.finishCallback) {
                $scope.$eval($scope.finishCallback);
              }
            }

            if (typeTimer !== null) {
              //calculate progress bar
              $scope.progressBar = progressBarService.calculateProgressBar($scope.startTime, $scope.millis, $scope.endTime, $scope.countdownattr);

              if ($scope.progressBar === 100) {
                $scope.displayProgressActive = ''; //No more Bootstrap active effect
              }
            }
          };

          if ($scope.autoStart === undefined || $scope.autoStart === true) {
            $scope.start();
          }
        }]
      };
    }]);

    /* commonjs package manager support (eg componentjs) */
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = timerModule;
    }

    var app = angular.module('timer');

    app.factory('I18nService', function () {

      var I18nService = function () {};

      I18nService.prototype.language = 'en';
      I18nService.prototype.fallback = 'en';
      I18nService.prototype.timeHumanizer = {};

      I18nService.prototype.init = function init(lang, fallback) {
        var supported_languages = humanizeDuration.getSupportedLanguages();

        this.fallback = fallback !== undefined ? fallback : 'en';
        if (supported_languages.indexOf(fallback) === -1) {
          this.fallback = 'en';
        }

        this.language = lang;
        if (supported_languages.indexOf(lang) === -1) {
          this.language = this.fallback;
        }

        //moment init
        moment.locale(this.language); //@TODO maybe to remove, it should be handle by the user's application itself, and not inside the directive

        //human duration init, using it because momentjs does not allow accurate time (
        // momentJS: a few moment ago, human duration : 4 seconds ago
        this.timeHumanizer = humanizeDuration.humanizer({
          language: this.language,
          halfUnit: false
        });
      };

      /**
       * get time with units from momentJS i18n
       * @param {int} millis
       * @returns {{millis: string, seconds: string, minutes: string, hours: string, days: string, months: string, years: string}}
       */
      I18nService.prototype.getTimeUnits = function getTimeUnits(millis) {
        var diffFromAlarm = Math.round(millis / 1000) * 1000; //time in milliseconds, get rid of the last 3 ms value to avoid 2.12 seconds display

        var time = {};

        if (typeof this.timeHumanizer != 'undefined') {
          time = {
            'millis': this.timeHumanizer(diffFromAlarm, { units: ["milliseconds"] }),
            'seconds': this.timeHumanizer(diffFromAlarm, { units: ["seconds"] }),
            'minutes': this.timeHumanizer(diffFromAlarm, { units: ["minutes", "seconds"] }),
            'hours': this.timeHumanizer(diffFromAlarm, { units: ["hours", "minutes", "seconds"] }),
            'days': this.timeHumanizer(diffFromAlarm, { units: ["days", "hours", "minutes", "seconds"] }),
            'months': this.timeHumanizer(diffFromAlarm, { units: ["months", "days", "hours", "minutes", "seconds"] }),
            'years': this.timeHumanizer(diffFromAlarm, { units: ["years", "months", "days", "hours", "minutes", "seconds"] })
          };
        } else {
          console.error('i18nService has not been initialized. You must call i18nService.init("en") for example');
        }

        return time;
      };

      return I18nService;
    });

    var app = angular.module('timer');

    app.factory('progressBarService', function () {

      var ProgressBarService = function () {};

      /**
       * calculate the remaining time in a progress bar in percentage
       * @param {momentjs} startValue in seconds
       * @param {integer} currentCountdown, where are we in the countdown
       * @param {integer} remainingTime, remaining milliseconds
       * @param {integer} endTime, end time, can be undefined
       * @param {integer} coutdown, original coutdown value, can be undefined
       *
       * joke : https://www.youtube.com/watch?v=gENVB6tjq_M
       * @return {float} 0 --> 100
       */
      ProgressBarService.prototype.calculateProgressBar = function calculateProgressBar(startValue, remainingTime, endTimeAttr, coutdown) {
        var displayProgressBar = 0,
            endTimeValue,
            initialCountdown;

        remainingTime = remainingTime / 1000; //seconds


        if (endTimeAttr !== null) {
          endTimeValue = moment(endTimeAttr);
          initialCountdown = endTimeValue.diff(startValue, 'seconds');
          displayProgressBar = remainingTime * 100 / initialCountdown;
        } else {
          displayProgressBar = remainingTime * 100 / coutdown;
        }

        displayProgressBar = 100 - displayProgressBar; //To have 0 to 100 and not 100 to 0
        displayProgressBar = Math.round(displayProgressBar * 10) / 10; //learn more why : http://stackoverflow.com/questions/588004/is-floating-point-math-broken

        if (displayProgressBar > 100) {
          //security
          displayProgressBar = 100;
        }

        return displayProgressBar;
      };

      return new ProgressBarService();
    });
    $__global['timerModule'] = timerModule;
    $__global['app'] = app;
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('8', ['9', 'a', 'b', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $every = $__require('a')(4);

  $export($export.P + $export.F * !$__require('b')([].every, true), 'Array', {
    // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
    every: function every(callbackfn /* , thisArg */) {
      return $every(this, callbackfn, arguments[1]);
    }
  });
  return module.exports;
});
$__System.registerDynamic('d', ['8', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('8');
  module.exports = $__require('e').Array.every;
  return module.exports;
});
$__System.registerDynamic('f', ['9', 'a', '10', 'c'], true, function ($__require, exports, module) {
  'use strict';
  // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $find = $__require('a')(6),
      KEY = 'findIndex',
      forced = true;
  // Shouldn't skip holes
  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  $export($export.P + $export.F * forced, 'Array', {
    findIndex: function findIndex(callbackfn /*, that = undefined */) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  $__require('10')(KEY);
  return module.exports;
});
$__System.registerDynamic('11', ['f', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('f');
  module.exports = $__require('e').Array.findIndex;
  return module.exports;
});
$__System.registerDynamic('10', ['12', '13', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 22.1.3.31 Array.prototype[@@unscopables]
  var UNSCOPABLES = $__require('12')('unscopables'),
      ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined) $__require('13')(ArrayProto, UNSCOPABLES, {});
  module.exports = function (key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };
  return module.exports;
});
$__System.registerDynamic('14', ['9', 'a', '10', 'c'], true, function ($__require, exports, module) {
  'use strict';
  // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $find = $__require('a')(5),
      KEY = 'find',
      forced = true;
  // Shouldn't skip holes
  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  $export($export.P + $export.F * forced, 'Array', {
    find: function find(callbackfn /*, that = undefined */) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  $__require('10')(KEY);
  return module.exports;
});
$__System.registerDynamic('15', ['14', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('14');
  module.exports = $__require('e').Array.find;
  return module.exports;
});
$__System.registerDynamic('16', ['17', '18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var toInteger = $__require('17'),
      defined = $__require('18');
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  return module.exports;
});
$__System.registerDynamic("19", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = false;
  return module.exports;
});
$__System.registerDynamic('1a', ['1b', '1c', '1d', '1e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var dP = $__require('1b'),
      anObject = $__require('1c'),
      getKeys = $__require('1d');

  module.exports = $__require('1e') ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties),
        length = keys.length,
        i = 0,
        P;
    while (length > i) dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };
  return module.exports;
});
$__System.registerDynamic('1f', ['20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('20').document && document.documentElement;
  return module.exports;
});
$__System.registerDynamic('21', ['1c', '1a', '22', '23', '24', '1f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject = $__require('1c'),
      dPs = $__require('1a'),
      enumBugKeys = $__require('22'),
      IE_PROTO = $__require('23')('IE_PROTO'),
      Empty = function () {/* empty */},
      PROTOTYPE = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = $__require('24')('iframe'),
        i = enumBugKeys.length,
        lt = '<',
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    $__require('1f').appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };

  module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty();
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };
  return module.exports;
});
$__System.registerDynamic('25', ['21', '26', '27', '13', '12', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var create = $__require('21'),
      descriptor = $__require('26'),
      setToStringTag = $__require('27'),
      IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  $__require('13')(IteratorPrototype, $__require('12')('iterator'), function () {
    return this;
  });

  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  return module.exports;
});
$__System.registerDynamic('27', ['1b', '28', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var def = $__require('1b').f,
      has = $__require('28'),
      TAG = $__require('12')('toStringTag');

  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };
  return module.exports;
});
$__System.registerDynamic('29', ['28', '2a', '23', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has = $__require('28'),
      toObject = $__require('2a'),
      IE_PROTO = $__require('23')('IE_PROTO'),
      ObjectProto = Object.prototype;

  module.exports = Object.getPrototypeOf || function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }return O instanceof Object ? ObjectProto : null;
  };
  return module.exports;
});
$__System.registerDynamic('2b', ['19', '9', '2c', '13', '28', '2d', '25', '27', '29', '12', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var LIBRARY = $__require('19'),
      $export = $__require('9'),
      redefine = $__require('2c'),
      hide = $__require('13'),
      has = $__require('28'),
      Iterators = $__require('2d'),
      $iterCreate = $__require('25'),
      setToStringTag = $__require('27'),
      getPrototypeOf = $__require('29'),
      ITERATOR = $__require('12')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  ,
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';

  var returnThis = function () {
    return this;
  };

  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
        $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
        methods,
        key,
        IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype) {
        // Set @@toStringTag to native iterators
        setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() {
        return $native.call(this);
      };
    }
    // Define iterator
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  return module.exports;
});
$__System.registerDynamic('2e', ['16', '2b', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $at = $__require('16')(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  $__require('2b')(String, 'String', function (iterated) {
    this._t = String(iterated); // target
    this._i = 0; // next index
    // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });
  return module.exports;
});
$__System.registerDynamic('2f', ['1c', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // call something on iterator step with safe closing on error
  var anObject = $__require('1c');
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
      // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
  return module.exports;
});
$__System.registerDynamic('30', ['2d', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // check on default Array iterator
  var Iterators = $__require('2d'),
      ITERATOR = $__require('12')('iterator'),
      ArrayProto = Array.prototype;

  module.exports = function (it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return module.exports;
});
$__System.registerDynamic('31', ['1b', '26', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $defineProperty = $__require('1b'),
      createDesc = $__require('26');

  module.exports = function (object, index, value) {
    if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
  };
  return module.exports;
});
$__System.registerDynamic('32', ['33', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = $__require('33'),
      TAG = $__require('12')('toStringTag')
  // ES3 wrong here
  ,
      ARG = cof(function () {
    return arguments;
  }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {/* empty */}
  };

  module.exports = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  return module.exports;
});
$__System.registerDynamic("2d", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {};
  return module.exports;
});
$__System.registerDynamic('34', ['32', '12', '2d', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var classof = $__require('32'),
      ITERATOR = $__require('12')('iterator'),
      Iterators = $__require('2d');
  module.exports = $__require('e').getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  return module.exports;
});
$__System.registerDynamic('35', ['12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR = $__require('12')('iterator'),
      SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {/* empty */}

  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function () {
        return { done: safe = true };
      };
      arr[ITERATOR] = function () {
        return iter;
      };
      exec(arr);
    } catch (e) {/* empty */}
    return safe;
  };
  return module.exports;
});
$__System.registerDynamic('36', ['37', '9', '2a', '2f', '30', '38', '31', '34', '35', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var ctx = $__require('37'),
      $export = $__require('9'),
      toObject = $__require('2a'),
      call = $__require('2f'),
      isArrayIter = $__require('30'),
      toLength = $__require('38'),
      createProperty = $__require('31'),
      getIterFn = $__require('34');

  $export($export.S + $export.F * !$__require('35')(function (iter) {
    Array.from(iter);
  }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /*, mapfn = undefined, thisArg = undefined*/) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          aLen = arguments.length,
          mapfn = aLen > 1 ? arguments[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });
  return module.exports;
});
$__System.registerDynamic('39', ['2e', '36', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('2e');
  $__require('36');
  module.exports = $__require('e').Array.from;
  return module.exports;
});
$__System.registerDynamic('3a', ['33', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.2.2 IsArray(argument)
  var cof = $__require('33');
  module.exports = Array.isArray || function isArray(arg) {
    return cof(arg) == 'Array';
  };
  return module.exports;
});
$__System.registerDynamic('3b', ['3c', '3a', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('3c'),
      isArray = $__require('3a'),
      SPECIES = $__require('12')('species');

  module.exports = function (original) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    }return C === undefined ? Array : C;
  };
  return module.exports;
});
$__System.registerDynamic('3d', ['3b', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
  var speciesConstructor = $__require('3b');

  module.exports = function (original, length) {
    return new (speciesConstructor(original))(length);
  };
  return module.exports;
});
$__System.registerDynamic('a', ['37', '3e', '2a', '38', '3d', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex
  var ctx = $__require('37'),
      IObject = $__require('3e'),
      toObject = $__require('2a'),
      toLength = $__require('38'),
      asc = $__require('3d');
  module.exports = function (TYPE, $create) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
        create = $create || asc;
    return function ($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true; // some
              case 5:
                return val; // find
              case 6:
                return index; // findIndex
              case 2:
                result.push(val); // filter
            } else if (IS_EVERY) return false; // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  return module.exports;
});
$__System.registerDynamic('b', ['3f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var fails = $__require('3f');

  module.exports = function (method, arg) {
    return !!method && fails(function () {
      arg ? method.call(null, function () {}, 1) : method.call(null);
    });
  };
  return module.exports;
});
$__System.registerDynamic('40', ['9', 'a', 'b', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      $some = $__require('a')(3);

  $export($export.P + $export.F * !$__require('b')([].some, true), 'Array', {
    // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
    some: function some(callbackfn /* , thisArg */) {
      return $some(this, callbackfn, arguments[1]);
    }
  });
  return module.exports;
});
$__System.registerDynamic('41', ['40', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('40');
  module.exports = $__require('e').Array.some;
  return module.exports;
});
$__System.registerDynamic("42", ["c"], true, function ($__require, exports, module) {
                  var process = $__require("c");
                  var define,
                      global = this || self,
                      GLOBAL = global;
                  // fast apply, http://jsperf.lnkit.com/fast-apply/5
                  module.exports = function (fn, args, that) {
                                    var un = that === undefined;
                                    switch (args.length) {
                                                      case 0:
                                                                        return un ? fn() : fn.call(that);
                                                      case 1:
                                                                        return un ? fn(args[0]) : fn.call(that, args[0]);
                                                      case 2:
                                                                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                                      case 3:
                                                                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                                      case 4:
                                                                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                                    }return fn.apply(that, args);
                  };
                  return module.exports;
});
$__System.registerDynamic('43', ['44', '3c', '42', 'c'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var aFunction = $__require('44'),
      isObject = $__require('3c'),
      invoke = $__require('42'),
      arraySlice = [].slice,
      factories = {};

  var construct = function (F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }return factories[len](F, args);
  };

  module.exports = Function.bind || function bind(that /*, args... */) {
    var fn = aFunction(this),
        partArgs = arraySlice.call(arguments, 1);
    var bound = function () /* args... */{
      var args = partArgs.concat(arraySlice.call(arguments));
      return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
    };
    if (isObject(fn.prototype)) bound.prototype = fn.prototype;
    return bound;
  };
  return module.exports;
});
$__System.registerDynamic('45', ['9', '43', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
  var $export = $__require('9');

  $export($export.P, 'Function', { bind: $__require('43') });
  return module.exports;
});
$__System.registerDynamic('46', ['45', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('45');
  module.exports = $__require('e').Function.bind;
  return module.exports;
});
$__System.registerDynamic('47', ['3e', '18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = $__require('3e'),
      defined = $__require('18');
  module.exports = function (it) {
    return IObject(defined(it));
  };
  return module.exports;
});
$__System.registerDynamic('48', ['17', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var toInteger = $__require('17'),
      max = Math.max,
      min = Math.min;
  module.exports = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  return module.exports;
});
$__System.registerDynamic('49', ['47', '38', '48', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = $__require('47'),
      toLength = $__require('38'),
      toIndex = $__require('48');
  module.exports = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      // Array#includes uses SameValueZero equality algorithm
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
        // Array#toIndex ignores holes, Array#includes - not
      } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }return !IS_INCLUDES && -1;
    };
  };
  return module.exports;
});
$__System.registerDynamic('23', ['4a', '4b', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var shared = $__require('4a')('keys'),
      uid = $__require('4b');
  module.exports = function (key) {
    return shared[key] || (shared[key] = uid(key));
  };
  return module.exports;
});
$__System.registerDynamic('4c', ['28', '47', '49', '23', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var has = $__require('28'),
      toIObject = $__require('47'),
      arrayIndexOf = $__require('49')(false),
      IE_PROTO = $__require('23')('IE_PROTO');

  module.exports = function (object, names) {
    var O = toIObject(object),
        i = 0,
        result = [],
        key;
    for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };
  return module.exports;
});
$__System.registerDynamic('22', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // IE 8- don't enum bug keys
  module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
  return module.exports;
});
$__System.registerDynamic('1d', ['4c', '22', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys = $__require('4c'),
      enumBugKeys = $__require('22');

  module.exports = Object.keys || function keys(O) {
    return $keys(O, enumBugKeys);
  };
  return module.exports;
});
$__System.registerDynamic("4d", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.f = Object.getOwnPropertySymbols;
  return module.exports;
});
$__System.registerDynamic("4e", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.f = {}.propertyIsEnumerable;
  return module.exports;
});
$__System.registerDynamic('2a', ['18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.13 ToObject(argument)
  var defined = $__require('18');
  module.exports = function (it) {
    return Object(defined(it));
  };
  return module.exports;
});
$__System.registerDynamic('3e', ['33', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = $__require('33');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});
$__System.registerDynamic('4f', ['1d', '4d', '4e', '2a', '3e', '3f', 'c'], true, function ($__require, exports, module) {
  'use strict';
  // 19.1.2.1 Object.assign(target, source, ...)

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var getKeys = $__require('1d'),
      gOPS = $__require('4d'),
      pIE = $__require('4e'),
      toObject = $__require('2a'),
      IObject = $__require('3e'),
      $assign = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  module.exports = !$assign || $__require('3f')(function () {
    var A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars
    var T = toObject(target),
        aLen = arguments.length,
        index = 1,
        getSymbols = gOPS.f,
        isEnum = pIE.f;
    while (aLen > index) {
      var S = IObject(arguments[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }return T;
  } : $assign;
  return module.exports;
});
$__System.registerDynamic('50', ['9', '4f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 19.1.3.1 Object.assign(target, source)
  var $export = $__require('9');

  $export($export.S + $export.F, 'Object', { assign: $__require('4f') });
  return module.exports;
});
$__System.registerDynamic('51', ['50', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('50');
  module.exports = $__require('e').Object.assign;
  return module.exports;
});
$__System.registerDynamic('1c', ['3c', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('3c');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
  return module.exports;
});
$__System.registerDynamic('24', ['3c', '20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var isObject = $__require('3c'),
      document = $__require('20').document
  // in old IE typeof document.createElement is 'object'
  ,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function (it) {
    return is ? document.createElement(it) : {};
  };
  return module.exports;
});
$__System.registerDynamic('52', ['1e', '3f', '24', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = !$__require('1e') && !$__require('3f')(function () {
    return Object.defineProperty($__require('24')('div'), 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
  return module.exports;
});
$__System.registerDynamic('53', ['3c', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = $__require('3c');
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
  return module.exports;
});
$__System.registerDynamic('1b', ['1c', '52', '53', '1e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var anObject = $__require('1c'),
      IE8_DOM_DEFINE = $__require('52'),
      toPrimitive = $__require('53'),
      dP = Object.defineProperty;

  exports.f = $__require('1e') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) {/* empty */}
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  return module.exports;
});
$__System.registerDynamic("26", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  return module.exports;
});
$__System.registerDynamic("3f", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});
$__System.registerDynamic('1e', ['3f', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // Thank's IE8 for his funny defineProperty
  module.exports = !$__require('3f')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
  return module.exports;
});
$__System.registerDynamic('13', ['1b', '26', '1e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var dP = $__require('1b'),
      createDesc = $__require('26');
  module.exports = $__require('1e') ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
  return module.exports;
});
$__System.registerDynamic("28", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
  return module.exports;
});
$__System.registerDynamic('2c', ['20', '13', '28', '4b', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var global = $__require('20'),
      hide = $__require('13'),
      has = $__require('28'),
      SRC = $__require('4b')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);

  $__require('e').inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) has(val, 'name') || hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe) {
        delete O[key];
        hide(O, key, val);
      } else {
        if (O[key]) O[key] = val;else hide(O, key, val);
      }
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  return module.exports;
});
$__System.registerDynamic('44', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});
$__System.registerDynamic('37', ['44', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // optional / simple context binding
  var aFunction = $__require('44');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () /* ...args */{
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});
$__System.registerDynamic('9', ['20', 'e', '13', '2c', '37', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var global = $__require('20'),
      core = $__require('e'),
      hide = $__require('13'),
      redefine = $__require('2c'),
      ctx = $__require('37'),
      PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
        key,
        own,
        out,
        exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      // export native or passed
      out = (own ? target : source)[key];
      // bind timers to global for call from export context
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // extend global
      if (target) redefine(target, key, out, type & $export.U);
      // export
      if (exports[key] != out) hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  global.core = core;
  // type bitmap
  $export.F = 1; // forced
  $export.G = 2; // global
  $export.S = 4; // static
  $export.P = 8; // proto
  $export.B = 16; // bind
  $export.W = 32; // wrap
  $export.U = 64; // safe
  $export.R = 128; // real proto method for `library` 
  module.exports = $export;
  return module.exports;
});
$__System.registerDynamic("17", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.4 ToInteger
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  return module.exports;
});
$__System.registerDynamic('38', ['17', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.1.15 ToLength
  var toInteger = $__require('17'),
      min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };
  return module.exports;
});
$__System.registerDynamic('3c', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});
$__System.registerDynamic("33", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});
$__System.registerDynamic('54', ['3c', '33', '12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.2.8 IsRegExp(argument)
  var isObject = $__require('3c'),
      cof = $__require('33'),
      MATCH = $__require('12')('match');
  module.exports = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  return module.exports;
});
$__System.registerDynamic("18", ["c"], true, function ($__require, exports, module) {
  var process = $__require("c");
  var define,
      global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});
$__System.registerDynamic('55', ['54', '18', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // helper for String#{startsWith, endsWith, includes}
  var isRegExp = $__require('54'),
      defined = $__require('18');

  module.exports = function (that, searchString, NAME) {
    if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  return module.exports;
});
$__System.registerDynamic('4a', ['20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var global = $__require('20'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function (key) {
    return store[key] || (store[key] = {});
  };
  return module.exports;
});
$__System.registerDynamic('4b', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var id = 0,
      px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  return module.exports;
});
$__System.registerDynamic('20', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

  return module.exports;
});
$__System.registerDynamic('12', ['4a', '4b', '20', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var store = $__require('4a')('wks'),
      uid = $__require('4b'),
      Symbol = $__require('20').Symbol,
      USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };

  $exports.store = store;
  return module.exports;
});
$__System.registerDynamic('56', ['12', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var MATCH = $__require('12')('match');
  module.exports = function (KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) {/* empty */}
    }return true;
  };
  return module.exports;
});
$__System.registerDynamic('57', ['9', '38', '55', '56', 'c'], true, function ($__require, exports, module) {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  'use strict';

  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var $export = $__require('9'),
      toLength = $__require('38'),
      context = $__require('55'),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];

  $export($export.P + $export.F * $__require('56')(STARTS_WITH), 'String', {
    startsWith: function startsWith(searchString /*, position = 0 */) {
      var that = context(this, searchString, STARTS_WITH),
          index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }
  });
  return module.exports;
});
$__System.registerDynamic('e', ['c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  var core = module.exports = { version: '2.4.0' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

  return module.exports;
});
$__System.registerDynamic("@system-env", [], false, function() {
  return {
    "production": true,
    "browser": true,
    "node": false,
    "dev": false,
    "default": true
  };
});

$__System.registerDynamic('c', ['@system-env'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
    return module.exports;
});
$__System.registerDynamic('58', ['57', 'e', 'c'], true, function ($__require, exports, module) {
  var process = $__require('c');
  var define,
      global = this || self,
      GLOBAL = global;
  $__require('57');
  module.exports = $__require('e').String.startsWith;
  return module.exports;
});
$__System.registerDynamic("59", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("5a", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var Range = require("../range").Range;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/mode/css_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var supportType = exports.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|min-height|min-width|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
            var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
            var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
            var supportConstantColor = exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
            var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

            var numRe = exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
            var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
            var pseudoClasses = exports.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

            var CssHighlightRules = function () {

                var keywordMapper = this.createKeywordMapper({
                    "support.function": supportFunction,
                    "support.constant": supportConstant,
                    "support.type": supportType,
                    "support.constant.color": supportConstantColor,
                    "support.constant.fonts": supportConstantFonts
                }, "text", true);

                this.$rules = {
                    "start": [{
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        push: "comment"
                    }, {
                        token: "paren.lparen",
                        regex: "\\{",
                        push: "ruleset"
                    }, {
                        token: "string",
                        regex: "@.*?{",
                        push: "media"
                    }, {
                        token: "keyword",
                        regex: "#[a-z0-9-_]+"
                    }, {
                        token: "variable",
                        regex: "\\.[a-z0-9-_]+"
                    }, {
                        token: "string",
                        regex: ":[a-z0-9-_]+"
                    }, {
                        token: "constant",
                        regex: "[a-z0-9-_]+"
                    }, {
                        caseInsensitive: true
                    }],

                    "media": [{
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        push: "comment"
                    }, {
                        token: "paren.lparen",
                        regex: "\\{",
                        push: "ruleset"
                    }, {
                        token: "string",
                        regex: "\\}",
                        next: "pop"
                    }, {
                        token: "keyword",
                        regex: "#[a-z0-9-_]+"
                    }, {
                        token: "variable",
                        regex: "\\.[a-z0-9-_]+"
                    }, {
                        token: "string",
                        regex: ":[a-z0-9-_]+"
                    }, {
                        token: "constant",
                        regex: "[a-z0-9-_]+"
                    }, {
                        caseInsensitive: true
                    }],

                    "comment": [{
                        token: "comment",
                        regex: "\\*\\/",
                        next: "pop"
                    }, {
                        defaultToken: "comment"
                    }],

                    "ruleset": [{
                        token: "paren.rparen",
                        regex: "\\}",
                        next: "pop"
                    }, {
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        push: "comment"
                    }, {
                        token: "string", // single line
                        regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
                    }, {
                        token: "string", // single line
                        regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                    }, {
                        token: ["constant.numeric", "keyword"],
                        regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
                    }, {
                        token: "constant.numeric",
                        regex: numRe
                    }, {
                        token: "constant.numeric", // hex6 color
                        regex: "#[a-f0-9]{6}"
                    }, {
                        token: "constant.numeric", // hex3 color
                        regex: "#[a-f0-9]{3}"
                    }, {
                        token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
                        regex: pseudoElements
                    }, {
                        token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
                        regex: pseudoClasses
                    }, {
                        token: ["support.function", "string", "support.function"],
                        regex: "(url\\()(.*)(\\))"
                    }, {
                        token: keywordMapper,
                        regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
                    }, {
                        caseInsensitive: true
                    }]
                };

                this.normalizeRules();
            };

            oop.inherits(CssHighlightRules, TextHighlightRules);

            exports.CssHighlightRules = CssHighlightRules;
        });

        ace.define("ace/mode/css_completions", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var propertyMap = {
                "background": { "#$0": 1 },
                "background-color": { "#$0": 1, "transparent": 1, "fixed": 1 },
                "background-image": { "url('/$0')": 1 },
                "background-repeat": { "repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1 },
                "background-position": { "bottom": 2, "center": 2, "left": 2, "right": 2, "top": 2, "inherit": 2 },
                "background-attachment": { "scroll": 1, "fixed": 1 },
                "background-size": { "cover": 1, "contain": 1 },
                "background-clip": { "border-box": 1, "padding-box": 1, "content-box": 1 },
                "background-origin": { "border-box": 1, "padding-box": 1, "content-box": 1 },
                "border": { "solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1 },
                "border-color": { "#$0": 1 },
                "border-style": { "solid": 2, "dashed": 2, "dotted": 2, "double": 2, "groove": 2, "hidden": 2, "inherit": 2, "inset": 2, "none": 2, "outset": 2, "ridged": 2 },
                "border-collapse": { "collapse": 1, "separate": 1 },
                "bottom": { "px": 1, "em": 1, "%": 1 },
                "clear": { "left": 1, "right": 1, "both": 1, "none": 1 },
                "color": { "#$0": 1, "rgb(#$00,0,0)": 1 },
                "cursor": { "default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1 },
                "display": { "none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1 },
                "empty-cells": { "show": 1, "hide": 1 },
                "float": { "left": 1, "right": 1, "none": 1 },
                "font-family": { "Arial": 2, "Comic Sans MS": 2, "Consolas": 2, "Courier New": 2, "Courier": 2, "Georgia": 2, "Monospace": 2, "Sans-Serif": 2, "Segoe UI": 2, "Tahoma": 2, "Times New Roman": 2, "Trebuchet MS": 2, "Verdana": 1 },
                "font-size": { "px": 1, "em": 1, "%": 1 },
                "font-weight": { "bold": 1, "normal": 1 },
                "font-style": { "italic": 1, "normal": 1 },
                "font-variant": { "normal": 1, "small-caps": 1 },
                "height": { "px": 1, "em": 1, "%": 1 },
                "left": { "px": 1, "em": 1, "%": 1 },
                "letter-spacing": { "normal": 1 },
                "line-height": { "normal": 1 },
                "list-style-type": { "none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1 },
                "margin": { "px": 1, "em": 1, "%": 1 },
                "margin-right": { "px": 1, "em": 1, "%": 1 },
                "margin-left": { "px": 1, "em": 1, "%": 1 },
                "margin-top": { "px": 1, "em": 1, "%": 1 },
                "margin-bottom": { "px": 1, "em": 1, "%": 1 },
                "max-height": { "px": 1, "em": 1, "%": 1 },
                "max-width": { "px": 1, "em": 1, "%": 1 },
                "min-height": { "px": 1, "em": 1, "%": 1 },
                "min-width": { "px": 1, "em": 1, "%": 1 },
                "overflow": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
                "overflow-x": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
                "overflow-y": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
                "padding": { "px": 1, "em": 1, "%": 1 },
                "padding-top": { "px": 1, "em": 1, "%": 1 },
                "padding-right": { "px": 1, "em": 1, "%": 1 },
                "padding-bottom": { "px": 1, "em": 1, "%": 1 },
                "padding-left": { "px": 1, "em": 1, "%": 1 },
                "page-break-after": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
                "page-break-before": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
                "position": { "absolute": 1, "relative": 1, "fixed": 1, "static": 1 },
                "right": { "px": 1, "em": 1, "%": 1 },
                "table-layout": { "fixed": 1, "auto": 1 },
                "text-decoration": { "none": 1, "underline": 1, "line-through": 1, "blink": 1 },
                "text-align": { "left": 1, "right": 1, "center": 1, "justify": 1 },
                "text-transform": { "capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1 },
                "top": { "px": 1, "em": 1, "%": 1 },
                "vertical-align": { "top": 1, "bottom": 1 },
                "visibility": { "hidden": 1, "visible": 1 },
                "white-space": { "nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1 },
                "width": { "px": 1, "em": 1, "%": 1 },
                "word-spacing": { "normal": 1 },
                "filter": { "alpha(opacity=$0100)": 1 },

                "text-shadow": { "$02px 2px 2px #777": 1 },
                "text-overflow": { "ellipsis-word": 1, "clip": 1, "ellipsis": 1 },
                "-moz-border-radius": 1,
                "-moz-border-radius-topright": 1,
                "-moz-border-radius-bottomright": 1,
                "-moz-border-radius-topleft": 1,
                "-moz-border-radius-bottomleft": 1,
                "-webkit-border-radius": 1,
                "-webkit-border-top-right-radius": 1,
                "-webkit-border-top-left-radius": 1,
                "-webkit-border-bottom-right-radius": 1,
                "-webkit-border-bottom-left-radius": 1,
                "-moz-box-shadow": 1,
                "-webkit-box-shadow": 1,
                "transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
                "-moz-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
                "-webkit-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 }
            };

            var CssCompletions = function () {};

            (function () {

                this.completionsDefined = false;

                this.defineCompletions = function () {
                    if (document) {
                        var style = document.createElement('c').style;

                        for (var i in style) {
                            if (typeof style[i] !== 'string') continue;

                            var name = i.replace(/[A-Z]/g, function (x) {
                                return '-' + x.toLowerCase();
                            });

                            if (!propertyMap.hasOwnProperty(name)) propertyMap[name] = 1;
                        }
                    }

                    this.completionsDefined = true;
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    if (!this.completionsDefined) {
                        this.defineCompletions();
                    }

                    var token = session.getTokenAt(pos.row, pos.column);

                    if (!token) return [];
                    if (state === 'ruleset') {
                        var line = session.getLine(pos.row).substr(0, pos.column);
                        if (/:[^;]+$/.test(line)) {
                            /([\w\-]+):[^:]*$/.test(line);

                            return this.getPropertyValueCompletions(state, session, pos, prefix);
                        } else {
                            return this.getPropertyCompletions(state, session, pos, prefix);
                        }
                    }

                    return [];
                };

                this.getPropertyCompletions = function (state, session, pos, prefix) {
                    var properties = Object.keys(propertyMap);
                    return properties.map(function (property) {
                        return {
                            caption: property,
                            snippet: property + ': $0',
                            meta: "property",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getPropertyValueCompletions = function (state, session, pos, prefix) {
                    var line = session.getLine(pos.row).substr(0, pos.column);
                    var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];

                    if (!property) return [];
                    var values = [];
                    if (property in propertyMap && typeof propertyMap[property] === "object") {
                        values = Object.keys(propertyMap[property]);
                    }
                    return values.map(function (value) {
                        return {
                            caption: value,
                            snippet: value,
                            meta: "property value",
                            score: Number.MAX_VALUE
                        };
                    });
                };
            }).call(CssCompletions.prototype);

            exports.CssCompletions = CssCompletions;
        });

        ace.define("ace/mode/behaviour/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/mode/behaviour/cstyle", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;

            var CssBehaviour = function () {

                this.inherit(CstyleBehaviour);

                this.add("colon", "insertion", function (state, action, editor, session, text) {
                    if (text === ':') {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        if (token && token.value.match(/\s+/)) {
                            token = iterator.stepBackward();
                        }
                        if (token && token.type === 'support.type') {
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === ':') {
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                            if (!line.substring(cursor.column).match(/^\s*;/)) {
                                return {
                                    text: ':;',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("colon", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected === ':') {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        if (token && token.value.match(/\s+/)) {
                            token = iterator.stepBackward();
                        }
                        if (token && token.type === 'support.type') {
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.end.column, range.end.column + 1);
                            if (rightChar === ';') {
                                range.end.column++;
                                return range;
                            }
                        }
                    }
                });

                this.add("semicolon", "insertion", function (state, action, editor, session, text) {
                    if (text === ';') {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar === ';') {
                            return {
                                text: '',
                                selection: [1, 1]
                            };
                        }
                    }
                });
            };
            oop.inherits(CssBehaviour, CstyleBehaviour);

            exports.CssBehaviour = CssBehaviour;
        });

        ace.define("ace/mode/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/css_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/css_completions", "ace/mode/behaviour/css", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CssCompletions = require("./css_completions").CssCompletions;
            var CssBehaviour = require("./behaviour/css").CssBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = CssHighlightRules;
                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CssBehaviour();
                this.$completer = new CssCompletions();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.foldingRules = "cStyle";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);
                    var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    var match = line.match(/^.*\{\s*$/);
                    if (match) {
                        indent += tab;
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    return this.$completer.getCompletions(state, session, pos, prefix);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (e) {
                        session.setAnnotations(e.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/css";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/mode/xml_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var XmlHighlightRules = function (normalize) {
                var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";

                this.$rules = {
                    start: [{ token: "string.cdata.xml", regex: "<\\!\\[CDATA\\[", next: "cdata" }, {
                        token: ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
                        regex: "(<\\?)(xml)(?=[\\s])", next: "xml_decl", caseInsensitive: true
                    }, {
                        token: ["punctuation.instruction.xml", "keyword.instruction.xml"],
                        regex: "(<\\?)(" + tagRegex + ")", next: "processing_instruction"
                    }, { token: "comment.xml", regex: "<\\!--", next: "comment" }, {
                        token: ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                        regex: "(<\\!)(DOCTYPE)(?=[\\s])", next: "doctype", caseInsensitive: true
                    }, { include: "tag" }, { token: "text.end-tag-open.xml", regex: "</" }, { token: "text.tag-open.xml", regex: "<" }, { include: "reference" }, { defaultToken: "text.xml" }],

                    xml_decl: [{
                        token: "entity.other.attribute-name.decl-attribute-name.xml",
                        regex: "(?:" + tagRegex + ":)?" + tagRegex + ""
                    }, {
                        token: "keyword.operator.decl-attribute-equals.xml",
                        regex: "="
                    }, {
                        include: "whitespace"
                    }, {
                        include: "string"
                    }, {
                        token: "punctuation.xml-decl.xml",
                        regex: "\\?>",
                        next: "start"
                    }],

                    processing_instruction: [{ token: "punctuation.instruction.xml", regex: "\\?>", next: "start" }, { defaultToken: "instruction.xml" }],

                    doctype: [{ include: "whitespace" }, { include: "string" }, { token: "xml-pe.doctype.xml", regex: ">", next: "start" }, { token: "xml-pe.xml", regex: "[-_a-zA-Z0-9:]+" }, { token: "punctuation.int-subset", regex: "\\[", push: "int_subset" }],

                    int_subset: [{
                        token: "text.xml",
                        regex: "\\s+"
                    }, {
                        token: "punctuation.int-subset.xml",
                        regex: "]",
                        next: "pop"
                    }, {
                        token: ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
                        regex: "(<\\!)(" + tagRegex + ")",
                        push: [{
                            token: "text",
                            regex: "\\s+"
                        }, {
                            token: "punctuation.markup-decl.xml",
                            regex: ">",
                            next: "pop"
                        }, { include: "string" }]
                    }],

                    cdata: [{ token: "string.cdata.xml", regex: "\\]\\]>", next: "start" }, { token: "text.xml", regex: "\\s+" }, { token: "text.xml", regex: "(?:[^\\]]|\\](?!\\]>))+" }],

                    comment: [{ token: "comment.xml", regex: "-->", next: "start" }, { defaultToken: "comment.xml" }],

                    reference: [{
                        token: "constant.language.escape.reference.xml",
                        regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                    }],

                    attr_reference: [{
                        token: "constant.language.escape.reference.attribute-value.xml",
                        regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                    }],

                    tag: [{
                        token: ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
                        regex: "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
                        next: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }]
                    }],

                    tag_whitespace: [{ token: "text.tag-whitespace.xml", regex: "\\s+" }],
                    whitespace: [{ token: "text.whitespace.xml", regex: "\\s+" }],
                    string: [{
                        token: "string.xml",
                        regex: "'",
                        push: [{ token: "string.xml", regex: "'", next: "pop" }, { defaultToken: "string.xml" }]
                    }, {
                        token: "string.xml",
                        regex: '"',
                        push: [{ token: "string.xml", regex: '"', next: "pop" }, { defaultToken: "string.xml" }]
                    }],

                    attributes: [{
                        token: "entity.other.attribute-name.xml",
                        regex: "(?:" + tagRegex + ":)?" + tagRegex + ""
                    }, {
                        token: "keyword.operator.attribute-equals.xml",
                        regex: "="
                    }, {
                        include: "tag_whitespace"
                    }, {
                        include: "attribute_value"
                    }],

                    attribute_value: [{
                        token: "string.attribute-value.xml",
                        regex: "'",
                        push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "attr_reference" }, { defaultToken: "string.attribute-value.xml" }]
                    }, {
                        token: "string.attribute-value.xml",
                        regex: '"',
                        push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "attr_reference" }, { defaultToken: "string.attribute-value.xml" }]
                    }]
                };

                if (this.constructor === XmlHighlightRules) this.normalizeRules();
            };

            (function () {

                this.embedTagRules = function (HighlightRules, prefix, tag) {
                    this.$rules.tag.unshift({
                        token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                        regex: "(<)(" + tag + "(?=\\s|>|$))",
                        next: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: prefix + "start" }]
                    });

                    this.$rules[tag + "-end"] = [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start",
                        onMatch: function (value, currentState, stack) {
                            stack.splice(0);
                            return this.token;
                        } }];

                    this.embedRules(HighlightRules, prefix, [{
                        token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                        regex: "(</)(" + tag + "(?=\\s|>|$))",
                        next: tag + "-end"
                    }, {
                        token: "string.cdata.xml",
                        regex: "<\\!\\[CDATA\\["
                    }, {
                        token: "string.cdata.xml",
                        regex: "\\]\\]>"
                    }]);
                };
            }).call(TextHighlightRules.prototype);

            oop.inherits(XmlHighlightRules, TextHighlightRules);

            exports.XmlHighlightRules = XmlHighlightRules;
        });

        ace.define("ace/mode/html_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/css_highlight_rules", "ace/mode/javascript_highlight_rules", "ace/mode/xml_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;

            var tagMap = lang.createMap({
                a: 'anchor',
                button: 'form',
                form: 'form',
                img: 'image',
                input: 'form',
                label: 'form',
                option: 'form',
                script: 'script',
                select: 'form',
                textarea: 'form',
                style: 'style',
                table: 'table',
                tbody: 'table',
                td: 'table',
                tfoot: 'table',
                th: 'table',
                tr: 'table'
            });

            var HtmlHighlightRules = function () {
                XmlHighlightRules.call(this);

                this.addRules({
                    attributes: [{
                        include: "tag_whitespace"
                    }, {
                        token: "entity.other.attribute-name.xml",
                        regex: "[-_a-zA-Z0-9:.]+"
                    }, {
                        token: "keyword.operator.attribute-equals.xml",
                        regex: "=",
                        push: [{
                            include: "tag_whitespace"
                        }, {
                            token: "string.unquoted.attribute-value.html",
                            regex: "[^<>='\"`\\s]+",
                            next: "pop"
                        }, {
                            token: "empty",
                            regex: "",
                            next: "pop"
                        }]
                    }, {
                        include: "attribute_value"
                    }],
                    tag: [{
                        token: function (start, tag) {
                            var group = tagMap[tag];
                            return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml", "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
                        },
                        regex: "(</?)([-_a-zA-Z0-9:.]+)",
                        next: "tag_stuff"
                    }],
                    tag_stuff: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }]
                });

                this.embedTagRules(CssHighlightRules, "css-", "style");
                this.embedTagRules(new JavaScriptHighlightRules({ jsx: false }).getRules(), "js-", "script");

                if (this.constructor === HtmlHighlightRules) this.normalizeRules();
            };

            oop.inherits(HtmlHighlightRules, XmlHighlightRules);

            exports.HtmlHighlightRules = HtmlHighlightRules;
        });

        ace.define("ace/mode/behaviour/xml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;
            var lang = require("../../lib/lang");

            function is(token, type) {
                return token.type.lastIndexOf(type + ".xml") > -1;
            }

            var XmlBehaviour = function () {

                this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                    if (text == '"' || text == "'") {
                        var quote = text;
                        var selected = session.doc.getTextRange(editor.getSelectionRange());
                        if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                            return {
                                text: quote + selected + quote,
                                selection: false
                            };
                        }

                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();

                        if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                            return {
                                text: "",
                                selection: [1, 1]
                            };
                        }

                        if (!token) token = iterator.stepBackward();

                        if (!token) return;

                        while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                            token = iterator.stepBackward();
                        }
                        var rightSpace = !rightChar || rightChar.match(/\s/);
                        if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?')) {
                            return {
                                text: quote + quote,
                                selection: [1, 1]
                            };
                        }
                    }
                });

                this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == selected) {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
                    if (text == '>') {
                        var position = editor.getSelectionRange().start;
                        var iterator = new TokenIterator(session, position.row, position.column);
                        var token = iterator.getCurrentToken() || iterator.stepBackward();
                        if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value"))) return;
                        if (is(token, "reference.attribute-value")) return;
                        if (is(token, "attribute-value")) {
                            var firstChar = token.value.charAt(0);
                            if (firstChar == '"' || firstChar == "'") {
                                var lastChar = token.value.charAt(token.value.length - 1);
                                var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                                if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar) return;
                            }
                        }
                        while (!is(token, "tag-name")) {
                            token = iterator.stepBackward();
                            if (token.value == "<") {
                                token = iterator.stepForward();
                                break;
                            }
                        }

                        var tokenRow = iterator.getCurrentTokenRow();
                        var tokenColumn = iterator.getCurrentTokenColumn();
                        if (is(iterator.stepBackward(), "end-tag-open")) return;

                        var element = token.value;
                        if (tokenRow == position.row) element = element.substring(0, position.column - tokenColumn);

                        if (this.voidElements.hasOwnProperty(element.toLowerCase())) return;

                        return {
                            text: ">" + "</" + element + ">",
                            selection: [1, 1]
                        };
                    }
                });

                this.add("autoindent", "insertion", function (state, action, editor, session, text) {
                    if (text == "\n") {
                        var cursor = editor.getCursorPosition();
                        var line = session.getLine(cursor.row);
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();

                        if (token && token.type.indexOf("tag-close") !== -1) {
                            if (token.value == "/>") return;
                            while (token && token.type.indexOf("tag-name") === -1) {
                                token = iterator.stepBackward();
                            }

                            if (!token) {
                                return;
                            }

                            var tag = token.value;
                            var row = iterator.getCurrentTokenRow();
                            token = iterator.stepBackward();
                            if (!token || token.type.indexOf("end-tag") !== -1) {
                                return;
                            }

                            if (this.voidElements && !this.voidElements[tag]) {
                                var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
                                var line = session.getLine(row);
                                var nextIndent = this.$getIndent(line);
                                var indent = nextIndent + session.getTabString();

                                if (nextToken && nextToken.value === "</") {
                                    return {
                                        text: "\n" + indent + "\n" + nextIndent,
                                        selection: [1, indent.length, 1, indent.length]
                                    };
                                } else {
                                    return {
                                        text: "\n" + indent
                                    };
                                }
                            }
                        }
                    }
                });
            };

            oop.inherits(XmlBehaviour, Behaviour);

            exports.XmlBehaviour = XmlBehaviour;
        });

        ace.define("ace/mode/folding/mixed", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (defaultMode, subModes) {
                this.defaultMode = defaultMode;
                this.subModes = subModes;
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.$getMode = function (state) {
                    if (typeof state != "string") state = state[0];
                    for (var key in this.subModes) {
                        if (state.indexOf(key) === 0) return this.subModes[key];
                    }
                    return null;
                };

                this.$tryMode = function (state, session, foldStyle, row) {
                    var mode = this.$getMode(state);
                    return mode ? mode.getFoldWidget(session, foldStyle, row) : "";
                };

                this.getFoldWidget = function (session, foldStyle, row) {
                    return this.$tryMode(session.getState(row - 1), session, foldStyle, row) || this.$tryMode(session.getState(row), session, foldStyle, row) || this.defaultMode.getFoldWidget(session, foldStyle, row);
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    var mode = this.$getMode(session.getState(row - 1));

                    if (!mode || !mode.getFoldWidget(session, foldStyle, row)) mode = this.$getMode(session.getState(row));

                    if (!mode || !mode.getFoldWidget(session, foldStyle, row)) mode = this.defaultMode;

                    return mode.getFoldWidgetRange(session, foldStyle, row);
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/folding/xml", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/range", "ace/mode/folding/fold_mode", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var lang = require("../../lib/lang");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;
            var TokenIterator = require("../../token_iterator").TokenIterator;

            var FoldMode = exports.FoldMode = function (voidElements, optionalEndTags) {
                BaseFoldMode.call(this);
                this.voidElements = voidElements || {};
                this.optionalEndTags = oop.mixin({}, this.voidElements);
                if (optionalEndTags) oop.mixin(this.optionalEndTags, optionalEndTags);
            };
            oop.inherits(FoldMode, BaseFoldMode);

            var Tag = function () {
                this.tagName = "";
                this.closing = false;
                this.selfClosing = false;
                this.start = { row: 0, column: 0 };
                this.end = { row: 0, column: 0 };
            };

            function is(token, type) {
                return token.type.lastIndexOf(type + ".xml") > -1;
            }

            (function () {

                this.getFoldWidget = function (session, foldStyle, row) {
                    var tag = this._getFirstTagInLine(session, row);

                    if (!tag) return "";

                    if (tag.closing || !tag.tagName && tag.selfClosing) return foldStyle == "markbeginend" ? "end" : "";

                    if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase())) return "";

                    if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column)) return "";

                    return "start";
                };
                this._getFirstTagInLine = function (session, row) {
                    var tokens = session.getTokens(row);
                    var tag = new Tag();

                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        if (is(token, "tag-open")) {
                            tag.end.column = tag.start.column + token.value.length;
                            tag.closing = is(token, "end-tag-open");
                            token = tokens[++i];
                            if (!token) return null;
                            tag.tagName = token.value;
                            tag.end.column += token.value.length;
                            for (i++; i < tokens.length; i++) {
                                token = tokens[i];
                                tag.end.column += token.value.length;
                                if (is(token, "tag-close")) {
                                    tag.selfClosing = token.value == '/>';
                                    break;
                                }
                            }
                            return tag;
                        } else if (is(token, "tag-close")) {
                            tag.selfClosing = token.value == '/>';
                            return tag;
                        }
                        tag.start.column += token.value.length;
                    }

                    return null;
                };

                this._findEndTagInLine = function (session, row, tagName, startColumn) {
                    var tokens = session.getTokens(row);
                    var column = 0;
                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        column += token.value.length;
                        if (column < startColumn) continue;
                        if (is(token, "end-tag-open")) {
                            token = tokens[i + 1];
                            if (token && token.value == tagName) return true;
                        }
                    }
                    return false;
                };
                this._readTagForward = function (iterator) {
                    var token = iterator.getCurrentToken();
                    if (!token) return null;

                    var tag = new Tag();
                    do {
                        if (is(token, "tag-open")) {
                            tag.closing = is(token, "end-tag-open");
                            tag.start.row = iterator.getCurrentTokenRow();
                            tag.start.column = iterator.getCurrentTokenColumn();
                        } else if (is(token, "tag-name")) {
                            tag.tagName = token.value;
                        } else if (is(token, "tag-close")) {
                            tag.selfClosing = token.value == "/>";
                            tag.end.row = iterator.getCurrentTokenRow();
                            tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                            iterator.stepForward();
                            return tag;
                        }
                    } while (token = iterator.stepForward());

                    return null;
                };

                this._readTagBackward = function (iterator) {
                    var token = iterator.getCurrentToken();
                    if (!token) return null;

                    var tag = new Tag();
                    do {
                        if (is(token, "tag-open")) {
                            tag.closing = is(token, "end-tag-open");
                            tag.start.row = iterator.getCurrentTokenRow();
                            tag.start.column = iterator.getCurrentTokenColumn();
                            iterator.stepBackward();
                            return tag;
                        } else if (is(token, "tag-name")) {
                            tag.tagName = token.value;
                        } else if (is(token, "tag-close")) {
                            tag.selfClosing = token.value == "/>";
                            tag.end.row = iterator.getCurrentTokenRow();
                            tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                        }
                    } while (token = iterator.stepBackward());

                    return null;
                };

                this._pop = function (stack, tag) {
                    while (stack.length) {

                        var top = stack[stack.length - 1];
                        if (!tag || top.tagName == tag.tagName) {
                            return stack.pop();
                        } else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                            stack.pop();
                            continue;
                        } else {
                            return null;
                        }
                    }
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    var firstTag = this._getFirstTagInLine(session, row);

                    if (!firstTag) return null;

                    var isBackward = firstTag.closing || firstTag.selfClosing;
                    var stack = [];
                    var tag;

                    if (!isBackward) {
                        var iterator = new TokenIterator(session, row, firstTag.start.column);
                        var start = {
                            row: row,
                            column: firstTag.start.column + firstTag.tagName.length + 2
                        };
                        if (firstTag.start.row == firstTag.end.row) start.column = firstTag.end.column;
                        while (tag = this._readTagForward(iterator)) {
                            if (tag.selfClosing) {
                                if (!stack.length) {
                                    tag.start.column += tag.tagName.length + 2;
                                    tag.end.column -= 2;
                                    return Range.fromPoints(tag.start, tag.end);
                                } else continue;
                            }

                            if (tag.closing) {
                                this._pop(stack, tag);
                                if (stack.length == 0) return Range.fromPoints(start, tag.start);
                            } else {
                                stack.push(tag);
                            }
                        }
                    } else {
                        var iterator = new TokenIterator(session, row, firstTag.end.column);
                        var end = {
                            row: row,
                            column: firstTag.start.column
                        };

                        while (tag = this._readTagBackward(iterator)) {
                            if (tag.selfClosing) {
                                if (!stack.length) {
                                    tag.start.column += tag.tagName.length + 2;
                                    tag.end.column -= 2;
                                    return Range.fromPoints(tag.start, tag.end);
                                } else continue;
                            }

                            if (!tag.closing) {
                                this._pop(stack, tag);
                                if (stack.length == 0) {
                                    tag.start.column += tag.tagName.length + 2;
                                    if (tag.start.row == tag.end.row && tag.start.column < tag.end.column) tag.start.column = tag.end.column;
                                    return Range.fromPoints(tag.start, end);
                                }
                            } else {
                                stack.push(tag);
                            }
                        }
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/folding/html", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/mixed", "ace/mode/folding/xml", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var MixedFoldMode = require("./mixed").FoldMode;
            var XmlFoldMode = require("./xml").FoldMode;
            var CStyleFoldMode = require("./cstyle").FoldMode;

            var FoldMode = exports.FoldMode = function (voidElements, optionalTags) {
                MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
                    "js-": new CStyleFoldMode(),
                    "css-": new CStyleFoldMode()
                });
            };

            oop.inherits(FoldMode, MixedFoldMode);
        });

        ace.define("ace/mode/html_completions", ["require", "exports", "module", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var TokenIterator = require("../token_iterator").TokenIterator;

            var commonAttributes = ["accesskey", "class", "contenteditable", "contextmenu", "dir", "draggable", "dropzone", "hidden", "id", "inert", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "spellcheck", "style", "tabindex", "title", "translate"];

            var eventAttributes = ["onabort", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextmenu", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "onvolumechange", "onwaiting"];

            var globalAttributes = commonAttributes.concat(eventAttributes);

            var attributeMap = {
                "html": { "manifest": 1 },
                "head": {},
                "title": {},
                "base": { "href": 1, "target": 1 },
                "link": { "href": 1, "hreflang": 1, "rel": { "stylesheet": 1, "icon": 1 }, "media": { "all": 1, "screen": 1, "print": 1 }, "type": { "text/css": 1, "image/png": 1, "image/jpeg": 1, "image/gif": 1 }, "sizes": 1 },
                "meta": { "http-equiv": { "content-type": 1 }, "name": { "description": 1, "keywords": 1 }, "content": { "text/html; charset=UTF-8": 1 }, "charset": 1 },
                "style": { "type": 1, "media": { "all": 1, "screen": 1, "print": 1 }, "scoped": 1 },
                "script": { "charset": 1, "type": { "text/javascript": 1 }, "src": 1, "defer": 1, "async": 1 },
                "noscript": { "href": 1 },
                "body": { "onafterprint": 1, "onbeforeprint": 1, "onbeforeunload": 1, "onhashchange": 1, "onmessage": 1, "onoffline": 1, "onpopstate": 1, "onredo": 1, "onresize": 1, "onstorage": 1, "onundo": 1, "onunload": 1 },
                "section": {},
                "nav": {},
                "article": { "pubdate": 1 },
                "aside": {},
                "h1": {},
                "h2": {},
                "h3": {},
                "h4": {},
                "h5": {},
                "h6": {},
                "header": {},
                "footer": {},
                "address": {},
                "main": {},
                "p": {},
                "hr": {},
                "pre": {},
                "blockquote": { "cite": 1 },
                "ol": { "start": 1, "reversed": 1 },
                "ul": {},
                "li": { "value": 1 },
                "dl": {},
                "dt": {},
                "dd": {},
                "figure": {},
                "figcaption": {},
                "div": {},
                "a": { "href": 1, "target": { "_blank": 1, "top": 1 }, "ping": 1, "rel": { "nofollow": 1, "alternate": 1, "author": 1, "bookmark": 1, "help": 1, "license": 1, "next": 1, "noreferrer": 1, "prefetch": 1, "prev": 1, "search": 1, "tag": 1 }, "media": 1, "hreflang": 1, "type": 1 },
                "em": {},
                "strong": {},
                "small": {},
                "s": {},
                "cite": {},
                "q": { "cite": 1 },
                "dfn": {},
                "abbr": {},
                "data": {},
                "time": { "datetime": 1 },
                "code": {},
                "var": {},
                "samp": {},
                "kbd": {},
                "sub": {},
                "sup": {},
                "i": {},
                "b": {},
                "u": {},
                "mark": {},
                "ruby": {},
                "rt": {},
                "rp": {},
                "bdi": {},
                "bdo": {},
                "span": {},
                "br": {},
                "wbr": {},
                "ins": { "cite": 1, "datetime": 1 },
                "del": { "cite": 1, "datetime": 1 },
                "img": { "alt": 1, "src": 1, "height": 1, "width": 1, "usemap": 1, "ismap": 1 },
                "iframe": { "name": 1, "src": 1, "height": 1, "width": 1, "sandbox": { "allow-same-origin": 1, "allow-top-navigation": 1, "allow-forms": 1, "allow-scripts": 1 }, "seamless": { "seamless": 1 } },
                "embed": { "src": 1, "height": 1, "width": 1, "type": 1 },
                "object": { "param": 1, "data": 1, "type": 1, "height": 1, "width": 1, "usemap": 1, "name": 1, "form": 1, "classid": 1 },
                "param": { "name": 1, "value": 1 },
                "video": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "width": 1, "height": 1, "poster": 1, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
                "audio": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
                "source": { "src": 1, "type": 1, "media": 1 },
                "track": { "kind": 1, "src": 1, "srclang": 1, "label": 1, "default": 1 },
                "canvas": { "width": 1, "height": 1 },
                "map": { "name": 1 },
                "area": { "shape": 1, "coords": 1, "href": 1, "hreflang": 1, "alt": 1, "target": 1, "media": 1, "rel": 1, "ping": 1, "type": 1 },
                "svg": {},
                "math": {},
                "table": { "summary": 1 },
                "caption": {},
                "colgroup": { "span": 1 },
                "col": { "span": 1 },
                "tbody": {},
                "thead": {},
                "tfoot": {},
                "tr": {},
                "td": { "headers": 1, "rowspan": 1, "colspan": 1 },
                "th": { "headers": 1, "rowspan": 1, "colspan": 1, "scope": 1 },
                "form": { "accept-charset": 1, "action": 1, "autocomplete": 1, "enctype": { "multipart/form-data": 1, "application/x-www-form-urlencoded": 1 }, "method": { "get": 1, "post": 1 }, "name": 1, "novalidate": 1, "target": { "_blank": 1, "top": 1 } },
                "fieldset": { "disabled": 1, "form": 1, "name": 1 },
                "legend": {},
                "label": { "form": 1, "for": 1 },
                "input": {
                    "type": { "text": 1, "password": 1, "hidden": 1, "checkbox": 1, "submit": 1, "radio": 1, "file": 1, "button": 1, "reset": 1, "image": 31, "color": 1, "date": 1, "datetime": 1, "datetime-local": 1, "email": 1, "month": 1, "number": 1, "range": 1, "search": 1, "tel": 1, "time": 1, "url": 1, "week": 1 },
                    "accept": 1, "alt": 1, "autocomplete": { "on": 1, "off": 1 }, "autofocus": { "autofocus": 1 }, "checked": { "checked": 1 }, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": { "application/x-www-form-urlencoded": 1, "multipart/form-data": 1, "text/plain": 1 }, "formmethod": { "get": 1, "post": 1 }, "formnovalidate": { "formnovalidate": 1 }, "formtarget": { "_blank": 1, "_self": 1, "_parent": 1, "_top": 1 }, "height": 1, "list": 1, "max": 1, "maxlength": 1, "min": 1, "multiple": { "multiple": 1 }, "name": 1, "pattern": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "required": { "required": 1 }, "size": 1, "src": 1, "step": 1, "width": 1, "files": 1, "value": 1 },
                "button": { "autofocus": 1, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": 1, "formmethod": 1, "formnovalidate": 1, "formtarget": 1, "name": 1, "value": 1, "type": { "button": 1, "submit": 1 } },
                "select": { "autofocus": 1, "disabled": 1, "form": 1, "multiple": { "multiple": 1 }, "name": 1, "size": 1, "readonly": { "readonly": 1 } },
                "datalist": {},
                "optgroup": { "disabled": 1, "label": 1 },
                "option": { "disabled": 1, "selected": 1, "label": 1, "value": 1 },
                "textarea": { "autofocus": { "autofocus": 1 }, "disabled": { "disabled": 1 }, "form": 1, "maxlength": 1, "name": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "required": { "required": 1 }, "rows": 1, "cols": 1, "wrap": { "on": 1, "off": 1, "hard": 1, "soft": 1 } },
                "keygen": { "autofocus": 1, "challenge": { "challenge": 1 }, "disabled": { "disabled": 1 }, "form": 1, "keytype": { "rsa": 1, "dsa": 1, "ec": 1 }, "name": 1 },
                "output": { "for": 1, "form": 1, "name": 1 },
                "progress": { "value": 1, "max": 1 },
                "meter": { "value": 1, "min": 1, "max": 1, "low": 1, "high": 1, "optimum": 1 },
                "details": { "open": 1 },
                "summary": {},
                "command": { "type": 1, "label": 1, "icon": 1, "disabled": 1, "checked": 1, "radiogroup": 1, "command": 1 },
                "menu": { "type": 1, "label": 1 },
                "dialog": { "open": 1 }
            };

            var elements = Object.keys(attributeMap);

            function is(token, type) {
                return token.type.lastIndexOf(type + ".xml") > -1;
            }

            function findTagName(session, pos) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                while (token && !is(token, "tag-name")) {
                    token = iterator.stepBackward();
                }
                if (token) return token.value;
            }

            function findAttributeName(session, pos) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                while (token && !is(token, "attribute-name")) {
                    token = iterator.stepBackward();
                }
                if (token) return token.value;
            }

            var HtmlCompletions = function () {};

            (function () {

                this.getCompletions = function (state, session, pos, prefix) {
                    var token = session.getTokenAt(pos.row, pos.column);

                    if (!token) return [];
                    if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open")) return this.getTagCompletions(state, session, pos, prefix);
                    if (is(token, "tag-whitespace") || is(token, "attribute-name")) return this.getAttributeCompletions(state, session, pos, prefix);
                    if (is(token, "attribute-value")) return this.getAttributeValueCompletions(state, session, pos, prefix);
                    var line = session.getLine(pos.row).substr(0, pos.column);
                    if (/&[A-z]*$/i.test(line)) return this.getHTMLEntityCompletions(state, session, pos, prefix);

                    return [];
                };

                this.getTagCompletions = function (state, session, pos, prefix) {
                    return elements.map(function (element) {
                        return {
                            value: element,
                            meta: "tag",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getAttributeCompletions = function (state, session, pos, prefix) {
                    var tagName = findTagName(session, pos);
                    if (!tagName) return [];
                    var attributes = globalAttributes;
                    if (tagName in attributeMap) {
                        attributes = attributes.concat(Object.keys(attributeMap[tagName]));
                    }
                    return attributes.map(function (attribute) {
                        return {
                            caption: attribute,
                            snippet: attribute + '="$0"',
                            meta: "attribute",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getAttributeValueCompletions = function (state, session, pos, prefix) {
                    var tagName = findTagName(session, pos);
                    var attributeName = findAttributeName(session, pos);

                    if (!tagName) return [];
                    var values = [];
                    if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === "object") {
                        values = Object.keys(attributeMap[tagName][attributeName]);
                    }
                    return values.map(function (value) {
                        return {
                            caption: value,
                            snippet: value,
                            meta: "attribute value",
                            score: Number.MAX_VALUE
                        };
                    });
                };

                this.getHTMLEntityCompletions = function (state, session, pos, prefix) {
                    var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];

                    return values.map(function (value) {
                        return {
                            caption: value,
                            snippet: value,
                            meta: "html entity",
                            score: Number.MAX_VALUE
                        };
                    });
                };
            }).call(HtmlCompletions.prototype);

            exports.HtmlCompletions = HtmlCompletions;
        });

        ace.define("ace/mode/html", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text", "ace/mode/javascript", "ace/mode/css", "ace/mode/html_highlight_rules", "ace/mode/behaviour/xml", "ace/mode/folding/html", "ace/mode/html_completions", "ace/worker/worker_client"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var TextMode = require("./text").Mode;
            var JavaScriptMode = require("./javascript").Mode;
            var CssMode = require("./css").Mode;
            var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
            var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
            var HtmlFoldMode = require("./folding/html").FoldMode;
            var HtmlCompletions = require("./html_completions").HtmlCompletions;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
            var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

            var Mode = function (options) {
                this.fragmentContext = options && options.fragmentContext;
                this.HighlightRules = HtmlHighlightRules;
                this.$behaviour = new XmlBehaviour();
                this.$completer = new HtmlCompletions();

                this.createModeDelegates({
                    "js-": JavaScriptMode,
                    "css-": CssMode
                });

                this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.blockComment = { start: "<!--", end: "-->" };

                this.voidElements = lang.arrayToMap(voidElements);

                this.getNextLineIndent = function (state, line, tab) {
                    return this.$getIndent(line);
                };

                this.checkOutdent = function (state, line, input) {
                    return false;
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    return this.$completer.getCompletions(state, session, pos, prefix);
                };

                this.createWorker = function (session) {
                    if (this.constructor != Mode) return;
                    var worker = new WorkerClient(["ace"], "ace/mode/html_worker", "Worker");
                    worker.attachToDocument(session.getDocument());

                    if (this.fragmentContext) worker.call("setOptions", [{ context: this.fragmentContext }]);

                    worker.on("error", function (e) {
                        session.setAnnotations(e.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/html";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5c", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var Range = require("../range").Range;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/mode/java_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var JavaHighlightRules = function () {
                var keywords = "abstract|continue|for|new|switch|" + "assert|default|goto|package|synchronized|" + "boolean|do|if|private|this|" + "break|double|implements|protected|throw|" + "byte|else|import|public|throws|" + "case|enum|instanceof|return|transient|" + "catch|extends|int|short|try|" + "char|final|interface|static|void|" + "class|finally|long|strictfp|volatile|" + "const|float|native|super|while";

                var buildinConstants = "null|Infinity|NaN|undefined";

                var langClasses = "AbstractMethodError|AssertionError|ClassCircularityError|" + "ClassFormatError|Deprecated|EnumConstantNotPresentException|" + "ExceptionInInitializerError|IllegalAccessError|" + "IllegalThreadStateException|InstantiationError|InternalError|" + "NegativeArraySizeException|NoSuchFieldError|Override|Process|" + "ProcessBuilder|SecurityManager|StringIndexOutOfBoundsException|" + "SuppressWarnings|TypeNotPresentException|UnknownError|" + "UnsatisfiedLinkError|UnsupportedClassVersionError|VerifyError|" + "InstantiationException|IndexOutOfBoundsException|" + "ArrayIndexOutOfBoundsException|CloneNotSupportedException|" + "NoSuchFieldException|IllegalArgumentException|NumberFormatException|" + "SecurityException|Void|InheritableThreadLocal|IllegalStateException|" + "InterruptedException|NoSuchMethodException|IllegalAccessException|" + "UnsupportedOperationException|Enum|StrictMath|Package|Compiler|" + "Readable|Runtime|StringBuilder|Math|IncompatibleClassChangeError|" + "NoSuchMethodError|ThreadLocal|RuntimePermission|ArithmeticException|" + "NullPointerException|Long|Integer|Short|Byte|Double|Number|Float|" + "Character|Boolean|StackTraceElement|Appendable|StringBuffer|" + "Iterable|ThreadGroup|Runnable|Thread|IllegalMonitorStateException|" + "StackOverflowError|OutOfMemoryError|VirtualMachineError|" + "ArrayStoreException|ClassCastException|LinkageError|" + "NoClassDefFoundError|ClassNotFoundException|RuntimeException|" + "Exception|ThreadDeath|Error|Throwable|System|ClassLoader|" + "Cloneable|Class|CharSequence|Comparable|String|Object";

                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "this",
                    "keyword": keywords,
                    "constant.language": buildinConstants,
                    "support.function": langClasses
                }, "identifier");

                this.$rules = {
                    "start": [{
                        token: "comment",
                        regex: "\\/\\/.*$"
                    }, DocCommentHighlightRules.getStartRule("doc-start"), {
                        token: "comment", // multi line comment
                        regex: "\\/\\*",
                        next: "comment"
                    }, {
                        token: "string", // single line
                        regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
                    }, {
                        token: "string", // single line
                        regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F][0-9a-fA-F_]*|[bB][01][01_]*)[LlSsDdFfYy]?\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.[\d_]*)?(?:[eE][+-]?[\d_]+)?)?[LlSsDdFfYy]?\b/
                    }, {
                        token: "constant.language.boolean",
                        regex: "(?:true|false)\\b"
                    }, {
                        token: keywordMapper,
                        regex: "[a-zA-Z_$][a-zA-Z0-9_$]*\\b"
                    }, {
                        token: "keyword.operator",
                        regex: "!|\\$|%|&|\\*|\\-\\-|\\-|\\+\\+|\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\|\\||\\?\\:|\\*=|%=|\\+=|\\-=|&=|\\^=|\\b(?:in|instanceof|new|delete|typeof|void)"
                    }, {
                        token: "lparen",
                        regex: "[[({]"
                    }, {
                        token: "rparen",
                        regex: "[\\])}]"
                    }, {
                        token: "text",
                        regex: "\\s+"
                    }],
                    "comment": [{
                        token: "comment", // closing comment
                        regex: ".*?\\*\\/",
                        next: "start"
                    }, {
                        token: "comment", // comment spanning whole line
                        regex: ".+"
                    }]
                };

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("start")]);
            };

            oop.inherits(JavaHighlightRules, TextHighlightRules);

            exports.JavaHighlightRules = JavaHighlightRules;
        });

        ace.define("ace/mode/java", ["require", "exports", "module", "ace/lib/oop", "ace/mode/javascript", "ace/mode/java_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var JavaScriptMode = require("./javascript").Mode;
            var JavaHighlightRules = require("./java_highlight_rules").JavaHighlightRules;

            var Mode = function () {
                JavaScriptMode.call(this);
                this.HighlightRules = JavaHighlightRules;
            };
            oop.inherits(Mode, JavaScriptMode);

            (function () {

                this.createWorker = function (session) {
                    return null;
                };

                this.$id = "ace/mode/java";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5d", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var DocCommentHighlightRules = function () {
                this.$rules = {
                    "start": [{
                        token: "comment.doc.tag",
                        regex: "@[\\w\\d_]+" // TODO: fix email addresses
                    }, DocCommentHighlightRules.getTagRule(), {
                        defaultToken: "comment.doc",
                        caseInsensitive: true
                    }]
                };
            };

            oop.inherits(DocCommentHighlightRules, TextHighlightRules);

            DocCommentHighlightRules.getTagRule = function (start) {
                return {
                    token: "comment.doc.tag.storage.type",
                    regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
                };
            };

            DocCommentHighlightRules.getStartRule = function (start) {
                return {
                    token: "comment.doc", // doc comment
                    regex: "\\/\\*(?=\\*)",
                    next: start
                };
            };

            DocCommentHighlightRules.getEndRule = function (start) {
                return {
                    token: "comment.doc", // closing comment
                    regex: "\\*\\/",
                    next: start
                };
            };

            exports.DocCommentHighlightRules = DocCommentHighlightRules;
        });

        ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

            var JavaScriptHighlightRules = function (options) {
                var keywordMapper = this.createKeywordMapper({
                    "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + // Constructors
                    "Namespace|QName|XML|XMLList|" + // E4X
                    "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
                    "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
                    "isNaN|parseFloat|parseInt|" + "JSON|Math|" + // Other
                    "this|arguments|prototype|window|document", // Pseudo
                    "keyword": "const|yield|import|get|set|async|await|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                    "storage.type": "const|let|var|function",
                    "constant.language": "null|Infinity|NaN|undefined",
                    "support.function": "alert",
                    "constant.language.boolean": "true|false"
                }, "identifier");
                var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

                var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
                "u[0-9a-fA-F]{4}|" + // unicode
                "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
                "[0-2][0-7]{0,2}|" + // oct
                "3[0-7][0-7]?|" + // oct
                "[4-7][0-7]?|" + //oct
                ".)";

                this.$rules = {
                    "no_regex": [DocCommentHighlightRules.getStartRule("doc-start"), comments("no_regex"), {
                        token: "string",
                        regex: "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "constant.numeric", // hex
                        regex: /0(?:[xX][0-9a-fA-F]+|[bB][01]+)\b/
                    }, {
                        token: "constant.numeric", // float
                        regex: /[+-]?\d[\d_]*(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                        regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: ["text", "text", "storage.type", "text", "paren.lparen"],
                        regex: "(:)(\\s*)(function)(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "keyword",
                        regex: "(?:" + kwBeforeRe + ")\\b",
                        next: "start"
                    }, {
                        token: ["support.constant"],
                        regex: /that\b/
                    }, {
                        token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                        regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                    }, {
                        token: keywordMapper,
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/,
                        next: "property"
                    }, {
                        token: "keyword.operator",
                        regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                        next: "start"
                    }, {
                        token: "punctuation.operator",
                        regex: /[?:,;.]/,
                        next: "start"
                    }, {
                        token: "paren.lparen",
                        regex: /[\[({]/,
                        next: "start"
                    }, {
                        token: "paren.rparen",
                        regex: /[\])}]/
                    }, {
                        token: "comment",
                        regex: /^#!.*$/
                    }],
                    property: [{
                        token: "text",
                        regex: "\\s+"
                    }, {
                        token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                        regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                        next: "function_arguments"
                    }, {
                        token: "punctuation.operator",
                        regex: /[.](?![.])/
                    }, {
                        token: "support.function",
                        regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                    }, {
                        token: "support.function.dom",
                        regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                    }, {
                        token: "support.constant",
                        regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                    }, {
                        token: "identifier",
                        regex: identifierRe
                    }, {
                        regex: "",
                        token: "empty",
                        next: "no_regex"
                    }],
                    "start": [DocCommentHighlightRules.getStartRule("doc-start"), comments("start"), {
                        token: "string.regexp",
                        regex: "\\/",
                        next: "regex"
                    }, {
                        token: "text",
                        regex: "\\s+|^$",
                        next: "start"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "regex": [{
                        token: "regexp.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "string.regexp",
                        regex: "/[sxngimy]*",
                        next: "no_regex"
                    }, {
                        token: "invalid",
                        regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                    }, {
                        token: "constant.language.escape",
                        regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                    }, {
                        token: "constant.language.delimiter",
                        regex: /\|/
                    }, {
                        token: "constant.language.escape",
                        regex: /\[\^?/,
                        next: "regex_character_class"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp"
                    }],
                    "regex_character_class": [{
                        token: "regexp.charclass.keyword.operator",
                        regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                    }, {
                        token: "constant.language.escape",
                        regex: "]",
                        next: "regex"
                    }, {
                        token: "constant.language.escape",
                        regex: "-"
                    }, {
                        token: "empty",
                        regex: "$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string.regexp.charachterclass"
                    }],
                    "function_arguments": [{
                        token: "variable.parameter",
                        regex: identifierRe
                    }, {
                        token: "punctuation.operator",
                        regex: "[, ]+"
                    }, {
                        token: "punctuation.operator",
                        regex: "$"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "no_regex"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: escapedRe
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "no_regex"
                    }, {
                        defaultToken: "string"
                    }]
                };

                if (!options || !options.noES6) {
                    this.$rules.no_regex.unshift({
                        regex: "[{}]", onMatch: function (val, state, stack) {
                            this.next = val == "{" ? this.nextState : "";
                            if (val == "{" && stack.length) {
                                stack.unshift("start", state);
                            } else if (val == "}" && stack.length) {
                                stack.shift();
                                this.next = stack.shift();
                                if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1) return "paren.quasi.end";
                            }
                            return val == "{" ? "paren.lparen" : "paren.rparen";
                        },
                        nextState: "start"
                    }, {
                        token: "string.quasi.start",
                        regex: /`/,
                        push: [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "paren.quasi.start",
                            regex: /\${/,
                            push: "start"
                        }, {
                            token: "string.quasi.end",
                            regex: /`/,
                            next: "pop"
                        }, {
                            defaultToken: "string.quasi"
                        }]
                    });

                    if (!options || options.jsx != false) JSX.call(this);
                }

                this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);

                this.normalizeRules();
            };

            oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

            function JSX() {
                var tagRegex = identifierRe.replace("\\d", "\\d\\-");
                var jsxTag = {
                    onMatch: function (val, state, stack) {
                        var offset = val.charAt(1) == "/" ? 2 : 1;
                        if (offset == 1) {
                            if (state != this.nextState) stack.unshift(this.next, this.nextState, 0);else stack.unshift(this.next);
                            stack[2]++;
                        } else if (offset == 2) {
                            if (state == this.nextState) {
                                stack[1]--;
                                if (!stack[1] || stack[1] < 0) {
                                    stack.shift();
                                    stack.shift();
                                }
                            }
                        }
                        return [{
                            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                            value: val.slice(0, offset)
                        }, {
                            type: "meta.tag.tag-name.xml",
                            value: val.substr(offset)
                        }];
                    },
                    regex: "</?" + tagRegex + "",
                    next: "jsxAttributes",
                    nextState: "jsx"
                };
                this.$rules.start.unshift(jsxTag);
                var jsxJsRule = {
                    regex: "{",
                    token: "paren.quasi.start",
                    push: "start"
                };
                this.$rules.jsx = [jsxJsRule, jsxTag, { include: "reference" }, { defaultToken: "string" }];
                this.$rules.jsxAttributes = [{
                    token: "meta.tag.punctuation.tag-close.xml",
                    regex: "/?>",
                    onMatch: function (value, currentState, stack) {
                        if (currentState == stack[0]) stack.shift();
                        if (value.length == 2) {
                            if (stack[0] == this.nextState) stack[1]--;
                            if (!stack[1] || stack[1] < 0) {
                                stack.splice(0, 2);
                            }
                        }
                        this.next = stack[0] || "start";
                        return [{ type: this.token, value: value }];
                    },
                    nextState: "jsx"
                }, jsxJsRule, comments("jsxAttributes"), {
                    token: "entity.other.attribute-name.xml",
                    regex: tagRegex
                }, {
                    token: "keyword.operator.attribute-equals.xml",
                    regex: "="
                }, {
                    token: "text.tag-whitespace.xml",
                    regex: "\\s+"
                }, {
                    token: "string.attribute-value.xml",
                    regex: "'",
                    stateName: "jsx_attr_q",
                    push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, {
                    token: "string.attribute-value.xml",
                    regex: '"',
                    stateName: "jsx_attr_qq",
                    push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "reference" }, { defaultToken: "string.attribute-value.xml" }]
                }, jsxTag];
                this.$rules.reference = [{
                    token: "constant.language.escape.reference.xml",
                    regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                }];
            }

            function comments(next) {
                return [{
                    token: "comment", // multi line comment
                    regex: /\/\*/,
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "\\*\\/", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }, {
                    token: "comment",
                    regex: "\\/\\/",
                    next: [DocCommentHighlightRules.getTagRule(), { token: "comment", regex: "$|^", next: next || "pop" }, { defaultToken: "comment", caseInsensitive: true }]
                }];
            }
            exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
        });

        ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;

            var MatchingBraceOutdent = function () {};

            (function () {

                this.checkOutdent = function (line, input) {
                    if (!/^\s+$/.test(line)) return false;

                    return (/^\s*\}/.test(input)
                    );
                };

                this.autoOutdent = function (doc, row) {
                    var line = doc.getLine(row);
                    var match = line.match(/^(\s*\})/);

                    if (!match) return 0;

                    var column = match[1].length;
                    var openBracePos = doc.findMatchingBracket({ row: row, column: column });

                    if (!openBracePos || openBracePos.row == row) return 0;

                    var indent = this.$getIndent(doc.getLine(openBracePos.row));
                    doc.replace(new Range(row, 0, row, column - 1), indent);
                };

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };
            }).call(MatchingBraceOutdent.prototype);

            exports.MatchingBraceOutdent = MatchingBraceOutdent;
        });

        ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Range = require("../../range").Range;
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (commentRegex) {
                if (commentRegex) {
                    this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                    this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                }
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
                this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
                this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
                this._getFoldWidgetBase = this.getFoldWidget;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);

                    if (this.singleLineBlockCommentRe.test(line)) {
                        if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line)) return "";
                    }

                    var fw = this._getFoldWidgetBase(session, foldStyle, row);

                    if (!fw && this.startRegionRe.test(line)) return "start"; // lineCommentRegionStart

                    return fw;
                };

                this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
                    var line = session.getLine(row);

                    if (this.startRegionRe.test(line)) return this.getCommentRegionBlock(session, line, row);

                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        var i = match.index;

                        if (match[1]) return this.openingBracketBlock(session, match[1], row, i);

                        var range = session.getCommentFoldRange(row, i + match[0].length, 1);

                        if (range && !range.isMultiLine()) {
                            if (forceMultiline) {
                                range = this.getSectionRange(session, row);
                            } else if (foldStyle != "all") range = null;
                        }

                        return range;
                    }

                    if (foldStyle === "markbegin") return;

                    var match = line.match(this.foldingStopMarker);
                    if (match) {
                        var i = match.index + match[0].length;

                        if (match[1]) return this.closingBracketBlock(session, match[1], row, i);

                        return session.getCommentFoldRange(row, i, -1);
                    }
                };

                this.getSectionRange = function (session, row) {
                    var line = session.getLine(row);
                    var startIndent = line.search(/\S/);
                    var startRow = row;
                    var startColumn = line.length;
                    row = row + 1;
                    var endRow = row;
                    var maxRow = session.getLength();
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var indent = line.search(/\S/);
                        if (indent === -1) continue;
                        if (startIndent > indent) break;
                        var subRange = this.getFoldWidgetRange(session, "all", row);

                        if (subRange) {
                            if (subRange.start.row <= startRow) {
                                break;
                            } else if (subRange.isMultiLine()) {
                                row = subRange.end.row;
                            } else if (startIndent == indent) {
                                break;
                            }
                        }
                        endRow = row;
                    }

                    return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                };
                this.getCommentRegionBlock = function (session, line, row) {
                    var startColumn = line.search(/\s*$/);
                    var maxRow = session.getLength();
                    var startRow = row;

                    var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
                    var depth = 1;
                    while (++row < maxRow) {
                        line = session.getLine(row);
                        var m = re.exec(line);
                        if (!m) continue;
                        if (m[1]) depth--;else depth++;

                        if (!depth) break;
                    }

                    var endRow = row;
                    if (endRow > startRow) {
                        return new Range(startRow, startColumn, endRow, line.length);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/range", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
            var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
            var Range = require("../range").Range;
            var WorkerClient = require("../worker/worker_client").WorkerClient;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var CStyleFoldMode = require("./folding/cstyle").FoldMode;

            var Mode = function () {
                this.HighlightRules = JavaScriptHighlightRules;

                this.$outdent = new MatchingBraceOutdent();
                this.$behaviour = new CstyleBehaviour();
                this.foldingRules = new CStyleFoldMode();
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "//";
                this.blockComment = { start: "/*", end: "*/" };

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;
                    var endState = tokenizedLine.state;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start" || state == "no_regex") {
                        var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    } else if (state == "doc-start") {
                        if (endState == "start" || endState == "no_regex") {
                            return "";
                        }
                        var match = line.match(/^\s*(\/?)\*/);
                        if (match) {
                            if (match[1]) {
                                indent += " ";
                            }
                            indent += "* ";
                        }
                    }

                    return indent;
                };

                this.checkOutdent = function (state, line, input) {
                    return this.$outdent.checkOutdent(line, input);
                };

                this.autoOutdent = function (state, doc, row) {
                    this.$outdent.autoOutdent(doc, row);
                };

                this.createWorker = function (session) {
                    var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
                    worker.attachToDocument(session.getDocument());

                    worker.on("annotate", function (results) {
                        session.setAnnotations(results.data);
                    });

                    worker.on("terminate", function () {
                        session.clearAnnotations();
                    });

                    return worker;
                };

                this.$id = "ace/mode/javascript";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5e", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        ace.define("ace/mode/python_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

            var PythonHighlightRules = function () {

                var keywords = "and|as|assert|break|class|continue|def|del|elif|else|except|exec|" + "finally|for|from|global|if|import|in|is|lambda|not|or|pass|print|" + "raise|return|try|while|with|yield";

                var builtinConstants = "True|False|None|NotImplemented|Ellipsis|__debug__";

                var builtinFunctions = "abs|divmod|input|open|staticmethod|all|enumerate|int|ord|str|any|" + "eval|isinstance|pow|sum|basestring|execfile|issubclass|print|super|" + "binfile|iter|property|tuple|bool|filter|len|range|type|bytearray|" + "float|list|raw_input|unichr|callable|format|locals|reduce|unicode|" + "chr|frozenset|long|reload|vars|classmethod|getattr|map|repr|xrange|" + "cmp|globals|max|reversed|zip|compile|hasattr|memoryview|round|" + "__import__|complex|hash|min|set|apply|delattr|help|next|setattr|" + "buffer|dict|hex|object|slice|coerce|dir|id|oct|sorted|intern";
                var keywordMapper = this.createKeywordMapper({
                    "invalid.deprecated": "debugger",
                    "support.function": builtinFunctions,
                    "constant.language": builtinConstants,
                    "keyword": keywords
                }, "identifier");

                var strPre = "(?:r|u|ur|R|U|UR|Ur|uR)?";

                var decimalInteger = "(?:(?:[1-9]\\d*)|(?:0))";
                var octInteger = "(?:0[oO]?[0-7]+)";
                var hexInteger = "(?:0[xX][\\dA-Fa-f]+)";
                var binInteger = "(?:0[bB][01]+)";
                var integer = "(?:" + decimalInteger + "|" + octInteger + "|" + hexInteger + "|" + binInteger + ")";

                var exponent = "(?:[eE][+-]?\\d+)";
                var fraction = "(?:\\.\\d+)";
                var intPart = "(?:\\d+)";
                var pointFloat = "(?:(?:" + intPart + "?" + fraction + ")|(?:" + intPart + "\\.))";
                var exponentFloat = "(?:(?:" + pointFloat + "|" + intPart + ")" + exponent + ")";
                var floatNumber = "(?:" + exponentFloat + "|" + pointFloat + ")";

                var stringEscape = "\\\\(x[0-9A-Fa-f]{2}|[0-7]{3}|[\\\\abfnrtv'\"]|U[0-9A-Fa-f]{8}|u[0-9A-Fa-f]{4})";

                this.$rules = {
                    "start": [{
                        token: "comment",
                        regex: "#.*$"
                    }, {
                        token: "string", // multi line """ string start
                        regex: strPre + '"{3}',
                        next: "qqstring3"
                    }, {
                        token: "string", // " string
                        regex: strPre + '"(?=.)',
                        next: "qqstring"
                    }, {
                        token: "string", // multi line ''' string start
                        regex: strPre + "'{3}",
                        next: "qstring3"
                    }, {
                        token: "string", // ' string
                        regex: strPre + "'(?=.)",
                        next: "qstring"
                    }, {
                        token: "constant.numeric", // imaginary
                        regex: "(?:" + floatNumber + "|\\d+)[jJ]\\b"
                    }, {
                        token: "constant.numeric", // float
                        regex: floatNumber
                    }, {
                        token: "constant.numeric", // long integer
                        regex: integer + "[lL]\\b"
                    }, {
                        token: "constant.numeric", // integer
                        regex: integer + "\\b"
                    }, {
                        token: keywordMapper,
                        regex: "[a-zA-Z_$][a-zA-Z0-9_$]*\\b"
                    }, {
                        token: "keyword.operator",
                        regex: "\\+|\\-|\\*|\\*\\*|\\/|\\/\\/|%|<<|>>|&|\\||\\^|~|<|>|<=|=>|==|!=|<>|="
                    }, {
                        token: "paren.lparen",
                        regex: "[\\[\\(\\{]"
                    }, {
                        token: "paren.rparen",
                        regex: "[\\]\\)\\}]"
                    }, {
                        token: "text",
                        regex: "\\s+"
                    }],
                    "qqstring3": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string", // multi line """ string end
                        regex: '"{3}',
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring3": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string", // multi line ''' string end
                        regex: "'{3}",
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }],
                    "qqstring": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qqstring"
                    }, {
                        token: "string",
                        regex: '"|$',
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }],
                    "qstring": [{
                        token: "constant.language.escape",
                        regex: stringEscape
                    }, {
                        token: "string",
                        regex: "\\\\$",
                        next: "qstring"
                    }, {
                        token: "string",
                        regex: "'|$",
                        next: "start"
                    }, {
                        defaultToken: "string"
                    }]
                };
            };

            oop.inherits(PythonHighlightRules, TextHighlightRules);

            exports.PythonHighlightRules = PythonHighlightRules;
        });

        ace.define("ace/mode/folding/pythonic", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var BaseFoldMode = require("./fold_mode").FoldMode;

            var FoldMode = exports.FoldMode = function (markers) {
                this.foldingStartMarker = new RegExp("([\\[{])(?:\\s*)$|(" + markers + ")(?:\\s*)(?:#.*)?$");
            };
            oop.inherits(FoldMode, BaseFoldMode);

            (function () {

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    var line = session.getLine(row);
                    var match = line.match(this.foldingStartMarker);
                    if (match) {
                        if (match[1]) return this.openingBracketBlock(session, match[1], row, match.index);
                        if (match[2]) return this.indentationBlock(session, row, match.index + match[2].length);
                        return this.indentationBlock(session, row);
                    }
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/mode/python", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/python_highlight_rules", "ace/mode/folding/pythonic", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var TextMode = require("./text").Mode;
            var PythonHighlightRules = require("./python_highlight_rules").PythonHighlightRules;
            var PythonFoldMode = require("./folding/pythonic").FoldMode;
            var Range = require("../range").Range;

            var Mode = function () {
                this.HighlightRules = PythonHighlightRules;
                this.foldingRules = new PythonFoldMode("\\:");
            };
            oop.inherits(Mode, TextMode);

            (function () {

                this.lineCommentStart = "#";

                this.getNextLineIndent = function (state, line, tab) {
                    var indent = this.$getIndent(line);

                    var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                    var tokens = tokenizedLine.tokens;

                    if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                        return indent;
                    }

                    if (state == "start") {
                        var match = line.match(/^.*[\{\(\[:]\s*$/);
                        if (match) {
                            indent += tab;
                        }
                    }

                    return indent;
                };

                var outdents = {
                    "pass": 1,
                    "return": 1,
                    "raise": 1,
                    "break": 1,
                    "continue": 1
                };

                this.checkOutdent = function (state, line, input) {
                    if (input !== "\r\n" && input !== "\r" && input !== "\n") return false;

                    var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;

                    if (!tokens) return false;
                    do {
                        var last = tokens.pop();
                    } while (last && (last.type == "comment" || last.type == "text" && last.value.match(/^\s+$/)));

                    if (!last) return false;

                    return last.type == "keyword" && outdents[last.value];
                };

                this.autoOutdent = function (state, doc, row) {

                    row += 1;
                    var indent = this.$getIndent(doc.getLine(row));
                    var tab = doc.getTabString();
                    if (indent.slice(-tab.length) == tab) doc.remove(new Range(row, indent.length - tab.length, row, indent.length));
                };

                this.$id = "ace/mode/python";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("5f", ["5b"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    ace.define("ace/theme/twilight", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {

      exports.isDark = true;
      exports.cssClass = "ace-twilight";
      exports.cssText = ".ace-twilight .ace_gutter {\
background: #232323;\
color: #E2E2E2\
}\
.ace-twilight .ace_print-margin {\
width: 1px;\
background: #232323\
}\
.ace-twilight {\
background-color: #141414;\
color: #F8F8F8\
}\
.ace-twilight .ace_cursor {\
color: #A7A7A7\
}\
.ace-twilight .ace_marker-layer .ace_selection {\
background: rgba(221, 240, 255, 0.20)\
}\
.ace-twilight.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #141414;\
}\
.ace-twilight .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-twilight .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgba(255, 255, 255, 0.25)\
}\
.ace-twilight .ace_marker-layer .ace_active-line {\
background: rgba(255, 255, 255, 0.031)\
}\
.ace-twilight .ace_gutter-active-line {\
background-color: rgba(255, 255, 255, 0.031)\
}\
.ace-twilight .ace_marker-layer .ace_selected-word {\
border: 1px solid rgba(221, 240, 255, 0.20)\
}\
.ace-twilight .ace_invisible {\
color: rgba(255, 255, 255, 0.25)\
}\
.ace-twilight .ace_keyword,\
.ace-twilight .ace_meta {\
color: #CDA869\
}\
.ace-twilight .ace_constant,\
.ace-twilight .ace_constant.ace_character,\
.ace-twilight .ace_constant.ace_character.ace_escape,\
.ace-twilight .ace_constant.ace_other,\
.ace-twilight .ace_heading,\
.ace-twilight .ace_markup.ace_heading,\
.ace-twilight .ace_support.ace_constant {\
color: #CF6A4C\
}\
.ace-twilight .ace_invalid.ace_illegal {\
color: #F8F8F8;\
background-color: rgba(86, 45, 86, 0.75)\
}\
.ace-twilight .ace_invalid.ace_deprecated {\
text-decoration: underline;\
font-style: italic;\
color: #D2A8A1\
}\
.ace-twilight .ace_support {\
color: #9B859D\
}\
.ace-twilight .ace_fold {\
background-color: #AC885B;\
border-color: #F8F8F8\
}\
.ace-twilight .ace_support.ace_function {\
color: #DAD085\
}\
.ace-twilight .ace_list,\
.ace-twilight .ace_markup.ace_list,\
.ace-twilight .ace_storage {\
color: #F9EE98\
}\
.ace-twilight .ace_entity.ace_name.ace_function,\
.ace-twilight .ace_meta.ace_tag,\
.ace-twilight .ace_variable {\
color: #AC885B\
}\
.ace-twilight .ace_string {\
color: #8F9D6A\
}\
.ace-twilight .ace_string.ace_regexp {\
color: #E9C062\
}\
.ace-twilight .ace_comment {\
font-style: italic;\
color: #5F5A60\
}\
.ace-twilight .ace_variable {\
color: #7587A6\
}\
.ace-twilight .ace_xml-pe {\
color: #494949\
}\
.ace-twilight .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQERFpYLC1tf0PAAgOAnPnhxyiAAAAAElFTkSuQmCC) right repeat-y\
}";

      var dom = require("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("60", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("61", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("62", ["63"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.MD5", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Constants table
            var T = [];

            // Compute constants
            (function () {
                for (var i = 0; i < 64; i++) {
                    T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;
                }
            })();

            /**
             * MD5 hash algorithm.
             */
            var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
                },

                _doProcessBlock: function (M, offset) {
                    // Swap endian
                    for (var i = 0; i < 16; i++) {
                        // Shortcuts
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];

                        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
                    }

                    // Shortcuts
                    var H = this._hash.words;

                    var M_offset_0 = M[offset + 0];
                    var M_offset_1 = M[offset + 1];
                    var M_offset_2 = M[offset + 2];
                    var M_offset_3 = M[offset + 3];
                    var M_offset_4 = M[offset + 4];
                    var M_offset_5 = M[offset + 5];
                    var M_offset_6 = M[offset + 6];
                    var M_offset_7 = M[offset + 7];
                    var M_offset_8 = M[offset + 8];
                    var M_offset_9 = M[offset + 9];
                    var M_offset_10 = M[offset + 10];
                    var M_offset_11 = M[offset + 11];
                    var M_offset_12 = M[offset + 12];
                    var M_offset_13 = M[offset + 13];
                    var M_offset_14 = M[offset + 14];
                    var M_offset_15 = M[offset + 15];

                    // Working varialbes
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];

                    // Computation
                    a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                    d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                    c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                    b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                    a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                    d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                    c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                    b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                    a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                    d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                    c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                    b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                    a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                    d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                    c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                    b = FF(b, c, d, a, M_offset_15, 22, T[15]);

                    a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                    d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                    c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                    b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                    a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                    d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                    c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                    b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                    a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                    d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                    c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                    b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                    a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                    d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                    c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                    b = GG(b, c, d, a, M_offset_12, 20, T[31]);

                    a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                    d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                    c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                    b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                    a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                    d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                    c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                    b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                    a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                    d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                    c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                    b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                    a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                    d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                    c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                    b = HH(b, c, d, a, M_offset_2, 23, T[47]);

                    a = II(a, b, c, d, M_offset_0, 6, T[48]);
                    d = II(d, a, b, c, M_offset_7, 10, T[49]);
                    c = II(c, d, a, b, M_offset_14, 15, T[50]);
                    b = II(b, c, d, a, M_offset_5, 21, T[51]);
                    a = II(a, b, c, d, M_offset_12, 6, T[52]);
                    d = II(d, a, b, c, M_offset_3, 10, T[53]);
                    c = II(c, d, a, b, M_offset_10, 15, T[54]);
                    b = II(b, c, d, a, M_offset_1, 21, T[55]);
                    a = II(a, b, c, d, M_offset_8, 6, T[56]);
                    d = II(d, a, b, c, M_offset_15, 10, T[57]);
                    c = II(c, d, a, b, M_offset_6, 15, T[58]);
                    b = II(b, c, d, a, M_offset_13, 21, T[59]);
                    a = II(a, b, c, d, M_offset_4, 6, T[60]);
                    d = II(d, a, b, c, M_offset_11, 10, T[61]);
                    c = II(c, d, a, b, M_offset_2, 15, T[62]);
                    b = II(b, c, d, a, M_offset_9, 21, T[63]);

                    // Intermediate hash value
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                },

                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;

                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;

                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;

                    var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                    var nBitsTotalL = nBitsTotal;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;

                    data.sigBytes = (dataWords.length + 1) * 4;

                    // Hash final blocks
                    this._process();

                    // Shortcuts
                    var hash = this._hash;
                    var H = hash.words;

                    // Swap endian
                    for (var i = 0; i < 4; i++) {
                        // Shortcut
                        var H_i = H[i];

                        H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
                    }

                    // Return final computed hash
                    return hash;
                },

                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();

                    return clone;
                }
            });

            function FF(a, b, c, d, x, s, t) {
                var n = a + (b & c | ~b & d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            function GG(a, b, c, d, x, s, t) {
                var n = a + (b & d | c & ~d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            function HH(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            function II(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + x + t;
                return (n << s | n >>> 32 - s) + b;
            }

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.MD5('message');
             *     var hash = CryptoJS.MD5(wordArray);
             */
            C.MD5 = Hasher._createHelper(MD5);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacMD5(message, key);
             */
            C.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("64", ["63"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.SHA1", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Reusable object
            var W = [];

            /**
             * SHA-1 hash algorithm.
             */
            var SHA1 = C_algo.SHA1 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
                },

                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var H = this._hash.words;

                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];

                    // Computation
                    for (var i = 0; i < 80; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            W[i] = n << 1 | n >>> 31;
                        }

                        var t = (a << 5 | a >>> 27) + e + W[i];
                        if (i < 20) {
                            t += (b & c | ~b & d) + 0x5a827999;
                        } else if (i < 40) {
                            t += (b ^ c ^ d) + 0x6ed9eba1;
                        } else if (i < 60) {
                            t += (b & c | b & d | c & d) - 0x70e44324;
                        } else /* if (i < 80) */{
                                t += (b ^ c ^ d) - 0x359d3e2a;
                            }

                        e = d;
                        d = c;
                        c = b << 30 | b >>> 2;
                        b = a;
                        a = t;
                    }

                    // Intermediate hash value
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                    H[4] = H[4] + e | 0;
                },

                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;

                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;

                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;

                    // Hash final blocks
                    this._process();

                    // Return final computed hash
                    return this._hash;
                },

                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();

                    return clone;
                }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA1('message');
             *     var hash = CryptoJS.SHA1(wordArray);
             */
            C.SHA1 = Hasher._createHelper(SHA1);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA1(message, key);
             */
            C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('65', ['63'], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'CryptoJS.algo.HMAC', null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var C_algo = C.algo;

            /**
             * HMAC algorithm.
             */
            var HMAC = C_algo.HMAC = Base.extend({
                /**
                 * Initializes a newly created HMAC.
                 *
                 * @param {Hasher} hasher The hash algorithm to use.
                 * @param {WordArray|string} key The secret key.
                 *
                 * @example
                 *
                 *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                 */
                init: function (hasher, key) {
                    // Init hasher
                    hasher = this._hasher = new hasher.init();

                    // Convert string to WordArray, else assume WordArray already
                    if (typeof key == 'string') {
                        key = Utf8.parse(key);
                    }

                    // Shortcuts
                    var hasherBlockSize = hasher.blockSize;
                    var hasherBlockSizeBytes = hasherBlockSize * 4;

                    // Allow arbitrary length keys
                    if (key.sigBytes > hasherBlockSizeBytes) {
                        key = hasher.finalize(key);
                    }

                    // Clamp excess bits
                    key.clamp();

                    // Clone key for inner and outer pads
                    var oKey = this._oKey = key.clone();
                    var iKey = this._iKey = key.clone();

                    // Shortcuts
                    var oKeyWords = oKey.words;
                    var iKeyWords = iKey.words;

                    // XOR keys with pad constants
                    for (var i = 0; i < hasherBlockSize; i++) {
                        oKeyWords[i] ^= 0x5c5c5c5c;
                        iKeyWords[i] ^= 0x36363636;
                    }
                    oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

                    // Set initial values
                    this.reset();
                },

                /**
                 * Resets this HMAC to its initial state.
                 *
                 * @example
                 *
                 *     hmacHasher.reset();
                 */
                reset: function () {
                    // Shortcut
                    var hasher = this._hasher;

                    // Reset
                    hasher.reset();
                    hasher.update(this._iKey);
                },

                /**
                 * Updates this HMAC with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {HMAC} This HMAC instance.
                 *
                 * @example
                 *
                 *     hmacHasher.update('message');
                 *     hmacHasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    this._hasher.update(messageUpdate);

                    // Chainable
                    return this;
                },

                /**
                 * Finalizes the HMAC computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The HMAC.
                 *
                 * @example
                 *
                 *     var hmac = hmacHasher.finalize();
                 *     var hmac = hmacHasher.finalize('message');
                 *     var hmac = hmacHasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Shortcut
                    var hasher = this._hasher;

                    // Compute HMAC
                    var innerHash = hasher.finalize(messageUpdate);
                    hasher.reset();
                    var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

                    return hmac;
                }
            });
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("66", ["64", "65"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.PBKDF2", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA1 = C_algo.SHA1;
            var HMAC = C_algo.HMAC;

            /**
             * Password-Based Key Derivation Function 2 algorithm.
             */
            var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hasher to use. Default: SHA1
                 * @property {number} iterations The number of iterations to perform. Default: 1
                 */
                cfg: Base.extend({
                    keySize: 128 / 32,
                    hasher: SHA1,
                    iterations: 1
                }),

                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.PBKDF2.create();
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                 */
                init: function (cfg) {
                    this.cfg = this.cfg.extend(cfg);
                },

                /**
                 * Computes the Password-Based Key Derivation Function 2.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function (password, salt) {
                    // Shortcut
                    var cfg = this.cfg;

                    // Init HMAC
                    var hmac = HMAC.create(cfg.hasher, password);

                    // Initial values
                    var derivedKey = WordArray.create();
                    var blockIndex = WordArray.create([0x00000001]);

                    // Shortcuts
                    var derivedKeyWords = derivedKey.words;
                    var blockIndexWords = blockIndex.words;
                    var keySize = cfg.keySize;
                    var iterations = cfg.iterations;

                    // Generate key
                    while (derivedKeyWords.length < keySize) {
                        var block = hmac.update(salt).finalize(blockIndex);
                        hmac.reset();

                        // Shortcuts
                        var blockWords = block.words;
                        var blockWordsLength = blockWords.length;

                        // Iterations
                        var intermediate = block;
                        for (var i = 1; i < iterations; i++) {
                            intermediate = hmac.finalize(intermediate);
                            hmac.reset();

                            // Shortcut
                            var intermediateWords = intermediate.words;

                            // XOR intermediate with block
                            for (var j = 0; j < blockWordsLength; j++) {
                                blockWords[j] ^= intermediateWords[j];
                            }
                        }

                        derivedKey.concat(block);
                        blockIndexWords[0]++;
                    }
                    derivedKey.sigBytes = keySize * 4;

                    return derivedKey;
                }
            });

            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             * @param {Object} cfg (Optional) The configuration options to use for this computation.
             *
             * @return {WordArray} The derived key.
             *
             * @static
             *
             * @example
             *
             *     var key = CryptoJS.PBKDF2(password, salt);
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
             */
            C.PBKDF2 = function (password, salt, cfg) {
                return PBKDF2.create(cfg).compute(password, salt);
            };
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('63', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'CryptoJS', null);

    (function ($__global) {
        var CryptoJS = $__global['CryptoJS'];
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        /**
         * CryptoJS core components.
         */
        var CryptoJS = CryptoJS || function (Math, undefined) {
            /**
             * CryptoJS namespace.
             */
            var C = {};

            /**
             * Library namespace.
             */
            var C_lib = C.lib = {};

            /**
             * Base object for prototypal inheritance.
             */
            var Base = C_lib.Base = function () {
                function F() {}

                return {
                    /**
                     * Creates a new object that inherits from this object.
                     *
                     * @param {Object} overrides Properties to copy into the new object.
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         field: 'value',
                     *
                     *         method: function () {
                     *         }
                     *     });
                     */
                    extend: function (overrides) {
                        // Spawn
                        F.prototype = this;
                        var subtype = new F();

                        // Augment
                        if (overrides) {
                            subtype.mixIn(overrides);
                        }

                        // Create default initializer
                        if (!subtype.hasOwnProperty('init')) {
                            subtype.init = function () {
                                subtype.$super.init.apply(this, arguments);
                            };
                        }

                        // Initializer's prototype is the subtype object
                        subtype.init.prototype = subtype;

                        // Reference supertype
                        subtype.$super = this;

                        return subtype;
                    },

                    /**
                     * Extends this object and runs the init method.
                     * Arguments to create() will be passed to init().
                     *
                     * @return {Object} The new object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var instance = MyType.create();
                     */
                    create: function () {
                        var instance = this.extend();
                        instance.init.apply(instance, arguments);

                        return instance;
                    },

                    /**
                     * Initializes a newly created object.
                     * Override this method to add some logic when your objects are created.
                     *
                     * @example
                     *
                     *     var MyType = CryptoJS.lib.Base.extend({
                     *         init: function () {
                     *             // ...
                     *         }
                     *     });
                     */
                    init: function () {},

                    /**
                     * Copies properties into this object.
                     *
                     * @param {Object} properties The properties to mix in.
                     *
                     * @example
                     *
                     *     MyType.mixIn({
                     *         field: 'value'
                     *     });
                     */
                    mixIn: function (properties) {
                        for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                                this[propertyName] = properties[propertyName];
                            }
                        }

                        // IE won't copy toString using the loop above
                        if (properties.hasOwnProperty('toString')) {
                            this.toString = properties.toString;
                        }
                    },

                    /**
                     * Creates a copy of this object.
                     *
                     * @return {Object} The clone.
                     *
                     * @example
                     *
                     *     var clone = instance.clone();
                     */
                    clone: function () {
                        return this.init.prototype.extend(this);
                    }
                };
            }();

            /**
             * An array of 32-bit words.
             *
             * @property {Array} words The array of 32-bit words.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var WordArray = C_lib.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of 32-bit words.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.create();
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                 */
                init: function (words, sigBytes) {
                    words = this.words = words || [];

                    if (sigBytes != undefined) {
                        this.sigBytes = sigBytes;
                    } else {
                        this.sigBytes = words.length * 4;
                    }
                },

                /**
                 * Converts this word array to a string.
                 *
                 * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                 *
                 * @return {string} The stringified word array.
                 *
                 * @example
                 *
                 *     var string = wordArray + '';
                 *     var string = wordArray.toString();
                 *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                 */
                toString: function (encoder) {
                    return (encoder || Hex).stringify(this);
                },

                /**
                 * Concatenates a word array to this word array.
                 *
                 * @param {WordArray} wordArray The word array to append.
                 *
                 * @return {WordArray} This word array.
                 *
                 * @example
                 *
                 *     wordArray1.concat(wordArray2);
                 */
                concat: function (wordArray) {
                    // Shortcuts
                    var thisWords = this.words;
                    var thatWords = wordArray.words;
                    var thisSigBytes = this.sigBytes;
                    var thatSigBytes = wordArray.sigBytes;

                    // Clamp excess bits
                    this.clamp();

                    // Concat
                    if (thisSigBytes % 4) {
                        // Copy one byte at a time
                        for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                        }
                    } else if (thatWords.length > 0xffff) {
                        // Copy one word at a time
                        for (var i = 0; i < thatSigBytes; i += 4) {
                            thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
                        }
                    } else {
                        // Copy all words at once
                        thisWords.push.apply(thisWords, thatWords);
                    }
                    this.sigBytes += thatSigBytes;

                    // Chainable
                    return this;
                },

                /**
                 * Removes insignificant bits.
                 *
                 * @example
                 *
                 *     wordArray.clamp();
                 */
                clamp: function () {
                    // Shortcuts
                    var words = this.words;
                    var sigBytes = this.sigBytes;

                    // Clamp
                    words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
                    words.length = Math.ceil(sigBytes / 4);
                },

                /**
                 * Creates a copy of this word array.
                 *
                 * @return {WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = wordArray.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone.words = this.words.slice(0);

                    return clone;
                },

                /**
                 * Creates a word array filled with random bytes.
                 *
                 * @param {number} nBytes The number of random bytes to generate.
                 *
                 * @return {WordArray} The random word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.random(16);
                 */
                random: function (nBytes) {
                    var words = [];
                    for (var i = 0; i < nBytes; i += 4) {
                        words.push(Math.random() * 0x100000000 | 0);
                    }

                    return new WordArray.init(words, nBytes);
                }
            });

            /**
             * Encoder namespace.
             */
            var C_enc = C.enc = {};

            /**
             * Hex encoding strategy.
             */
            var Hex = C_enc.Hex = {
                /**
                 * Converts a word array to a hex string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The hex string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;

                    // Convert
                    var hexChars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                        hexChars.push((bite >>> 4).toString(16));
                        hexChars.push((bite & 0x0f).toString(16));
                    }

                    return hexChars.join('');
                },

                /**
                 * Converts a hex string to a word array.
                 *
                 * @param {string} hexStr The hex string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                 */
                parse: function (hexStr) {
                    // Shortcut
                    var hexStrLength = hexStr.length;

                    // Convert
                    var words = [];
                    for (var i = 0; i < hexStrLength; i += 2) {
                        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                    }

                    return new WordArray.init(words, hexStrLength / 2);
                }
            };

            /**
             * Latin1 encoding strategy.
             */
            var Latin1 = C_enc.Latin1 = {
                /**
                 * Converts a word array to a Latin1 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Latin1 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    // Shortcuts
                    var words = wordArray.words;
                    var sigBytes = wordArray.sigBytes;

                    // Convert
                    var latin1Chars = [];
                    for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                        latin1Chars.push(String.fromCharCode(bite));
                    }

                    return latin1Chars.join('');
                },

                /**
                 * Converts a Latin1 string to a word array.
                 *
                 * @param {string} latin1Str The Latin1 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                 */
                parse: function (latin1Str) {
                    // Shortcut
                    var latin1StrLength = latin1Str.length;

                    // Convert
                    var words = [];
                    for (var i = 0; i < latin1StrLength; i++) {
                        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
                    }

                    return new WordArray.init(words, latin1StrLength);
                }
            };

            /**
             * UTF-8 encoding strategy.
             */
            var Utf8 = C_enc.Utf8 = {
                /**
                 * Converts a word array to a UTF-8 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-8 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                 */
                stringify: function (wordArray) {
                    try {
                        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                    } catch (e) {
                        throw new Error('Malformed UTF-8 data');
                    }
                },

                /**
                 * Converts a UTF-8 string to a word array.
                 *
                 * @param {string} utf8Str The UTF-8 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                 */
                parse: function (utf8Str) {
                    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
            };

            /**
             * Abstract buffered block algorithm template.
             *
             * The property blockSize must be implemented in a concrete subtype.
             *
             * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
             */
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                /**
                 * Resets this block algorithm's data buffer to its initial state.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm.reset();
                 */
                reset: function () {
                    // Initial values
                    this._data = new WordArray.init();
                    this._nDataBytes = 0;
                },

                /**
                 * Adds new data to this block algorithm's buffer.
                 *
                 * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm._append('data');
                 *     bufferedBlockAlgorithm._append(wordArray);
                 */
                _append: function (data) {
                    // Convert string to WordArray, else assume WordArray already
                    if (typeof data == 'string') {
                        data = Utf8.parse(data);
                    }

                    // Append
                    this._data.concat(data);
                    this._nDataBytes += data.sigBytes;
                },

                /**
                 * Processes available data blocks.
                 *
                 * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                 *
                 * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                 *
                 * @return {WordArray} The processed data.
                 *
                 * @example
                 *
                 *     var processedData = bufferedBlockAlgorithm._process();
                 *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                 */
                _process: function (doFlush) {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;
                    var dataSigBytes = data.sigBytes;
                    var blockSize = this.blockSize;
                    var blockSizeBytes = blockSize * 4;

                    // Count blocks ready
                    var nBlocksReady = dataSigBytes / blockSizeBytes;
                    if (doFlush) {
                        // Round up to include partial blocks
                        nBlocksReady = Math.ceil(nBlocksReady);
                    } else {
                        // Round down to include only full blocks,
                        // less the number of blocks that must remain in the buffer
                        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                    }

                    // Count words ready
                    var nWordsReady = nBlocksReady * blockSize;

                    // Count bytes ready
                    var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

                    // Process blocks
                    if (nWordsReady) {
                        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            // Perform concrete-algorithm logic
                            this._doProcessBlock(dataWords, offset);
                        }

                        // Remove processed words
                        var processedWords = dataWords.splice(0, nWordsReady);
                        data.sigBytes -= nBytesReady;
                    }

                    // Return processed words
                    return new WordArray.init(processedWords, nBytesReady);
                },

                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = bufferedBlockAlgorithm.clone();
                 */
                clone: function () {
                    var clone = Base.clone.call(this);
                    clone._data = this._data.clone();

                    return clone;
                },

                _minBufferSize: 0
            });

            /**
             * Abstract hasher template.
             *
             * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
             */
            var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 */
                cfg: Base.extend(),

                /**
                 * Initializes a newly created hasher.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                 *
                 * @example
                 *
                 *     var hasher = CryptoJS.algo.SHA256.create();
                 */
                init: function (cfg) {
                    // Apply config defaults
                    this.cfg = this.cfg.extend(cfg);

                    // Set initial values
                    this.reset();
                },

                /**
                 * Resets this hasher to its initial state.
                 *
                 * @example
                 *
                 *     hasher.reset();
                 */
                reset: function () {
                    // Reset data buffer
                    BufferedBlockAlgorithm.reset.call(this);

                    // Perform concrete-hasher logic
                    this._doReset();
                },

                /**
                 * Updates this hasher with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {Hasher} This hasher.
                 *
                 * @example
                 *
                 *     hasher.update('message');
                 *     hasher.update(wordArray);
                 */
                update: function (messageUpdate) {
                    // Append
                    this._append(messageUpdate);

                    // Update the hash
                    this._process();

                    // Chainable
                    return this;
                },

                /**
                 * Finalizes the hash computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The hash.
                 *
                 * @example
                 *
                 *     var hash = hasher.finalize();
                 *     var hash = hasher.finalize('message');
                 *     var hash = hasher.finalize(wordArray);
                 */
                finalize: function (messageUpdate) {
                    // Final message update
                    if (messageUpdate) {
                        this._append(messageUpdate);
                    }

                    // Perform concrete-hasher logic
                    var hash = this._doFinalize();

                    return hash;
                },

                blockSize: 512 / 32,

                /**
                 * Creates a shortcut function to a hasher's object interface.
                 *
                 * @param {Hasher} hasher The hasher to create a helper for.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                 */
                _createHelper: function (hasher) {
                    return function (message, cfg) {
                        return new hasher.init(cfg).finalize(message);
                    };
                },

                /**
                 * Creates a shortcut function to the HMAC's object interface.
                 *
                 * @param {Hasher} hasher The hasher to use in this HMAC helper.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                 */
                _createHmacHelper: function (hasher) {
                    return function (message, key) {
                        return new C_algo.HMAC.init(hasher, key).finalize(message);
                    };
                }
            });

            /**
             * Algorithm namespace.
             */
            var C_algo = C.algo = {};

            return C;
        }(Math);
        $__global['CryptoJS'] = CryptoJS;
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("67", ["63"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "CryptoJS.SHA256", null);

    (function ($__global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Initialization and round constants tables
            var H = [];
            var K = [];

            // Compute constants
            (function () {
                function isPrime(n) {
                    var sqrtN = Math.sqrt(n);
                    for (var factor = 2; factor <= sqrtN; factor++) {
                        if (!(n % factor)) {
                            return false;
                        }
                    }

                    return true;
                }

                function getFractionalBits(n) {
                    return (n - (n | 0)) * 0x100000000 | 0;
                }

                var n = 2;
                var nPrime = 0;
                while (nPrime < 64) {
                    if (isPrime(n)) {
                        if (nPrime < 8) {
                            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                        }
                        K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                        nPrime++;
                    }

                    n++;
                }
            })();

            // Reusable object
            var W = [];

            /**
             * SHA-256 hash algorithm.
             */
            var SHA256 = C_algo.SHA256 = Hasher.extend({
                _doReset: function () {
                    this._hash = new WordArray.init(H.slice(0));
                },

                _doProcessBlock: function (M, offset) {
                    // Shortcut
                    var H = this._hash.words;

                    // Working variables
                    var a = H[0];
                    var b = H[1];
                    var c = H[2];
                    var d = H[3];
                    var e = H[4];
                    var f = H[5];
                    var g = H[6];
                    var h = H[7];

                    // Computation
                    for (var i = 0; i < 64; i++) {
                        if (i < 16) {
                            W[i] = M[offset + i] | 0;
                        } else {
                            var gamma0x = W[i - 15];
                            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;

                            var gamma1x = W[i - 2];
                            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;

                            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                        }

                        var ch = e & f ^ ~e & g;
                        var maj = a & b ^ a & c ^ b & c;

                        var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                        var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);

                        var t1 = h + sigma1 + ch + K[i] + W[i];
                        var t2 = sigma0 + maj;

                        h = g;
                        g = f;
                        f = e;
                        e = d + t1 | 0;
                        d = c;
                        c = b;
                        b = a;
                        a = t1 + t2 | 0;
                    }

                    // Intermediate hash value
                    H[0] = H[0] + a | 0;
                    H[1] = H[1] + b | 0;
                    H[2] = H[2] + c | 0;
                    H[3] = H[3] + d | 0;
                    H[4] = H[4] + e | 0;
                    H[5] = H[5] + f | 0;
                    H[6] = H[6] + g | 0;
                    H[7] = H[7] + h | 0;
                },

                _doFinalize: function () {
                    // Shortcuts
                    var data = this._data;
                    var dataWords = data.words;

                    var nBitsTotal = this._nDataBytes * 8;
                    var nBitsLeft = data.sigBytes * 8;

                    // Add padding
                    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                    data.sigBytes = dataWords.length * 4;

                    // Hash final blocks
                    this._process();

                    // Return final computed hash
                    return this._hash;
                },

                clone: function () {
                    var clone = Hasher.clone.call(this);
                    clone._hash = this._hash.clone();

                    return clone;
                }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA256('message');
             *     var hash = CryptoJS.SHA256(wordArray);
             */
            C.SHA256 = Hasher._createHelper(SHA256);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA256(message, key);
             */
            C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        })(Math);
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic('68', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
      rsComboSymbolsRange = '\\u20d0-\\u20f0',
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')', rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr, rsUpper + '+' + rsOptUpperContr, rsDigits, rsEmoji].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C', '\xe7': 'c',
    '\xd0': 'D', '\xf0': 'd',
    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N', '\xf1': 'n',
    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J', '\u0135': 'j',
    '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't', '\u0165': 't', '\u0167': 't',
    '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W', '\u0175': 'w',
    '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 'ss'
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /** Built-in value references. */
  var Symbol = root.Symbol;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function (string) {
      string = toString(string);

      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

      var chr = strSymbols ? strSymbols[0] : string.charAt(0);

      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder(callback) {
    return function (string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = createCaseFirst('toUpperCase');

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }

  module.exports = camelCase;
  return module.exports;
});
$__System.registerDynamic("69", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6a", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6b", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "d3", null);

  (function ($__global) {
    !function () {
      var d3 = {
        version: "3.5.17"
      };
      var d3_arraySlice = [].slice,
          d3_array = function (list) {
        return d3_arraySlice.call(list);
      };
      var d3_document = this.document;
      function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
      }
      function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
      }
      if (d3_document) {
        try {
          d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
          d3_array = function (list) {
            var i = list.length,
                array = new Array(i);
            while (i--) array[i] = list[i];
            return array;
          };
        }
      }
      if (!Date.now) Date.now = function () {
        return +new Date();
      };
      if (d3_document) {
        try {
          d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
          var d3_element_prototype = this.Element.prototype,
              d3_element_setAttribute = d3_element_prototype.setAttribute,
              d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
              d3_style_prototype = this.CSSStyleDeclaration.prototype,
              d3_style_setProperty = d3_style_prototype.setProperty;
          d3_element_prototype.setAttribute = function (name, value) {
            d3_element_setAttribute.call(this, name, value + "");
          };
          d3_element_prototype.setAttributeNS = function (space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
          };
          d3_style_prototype.setProperty = function (name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
          };
        }
      }
      d3.ascending = d3_ascending;
      function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      d3.descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      d3.min = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
      };
      d3.max = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
            a = b;
            break;
          }
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
      };
      d3.extent = function (array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (arguments.length === 1) {
          while (++i < n) if ((b = array[i]) != null && b >= b) {
            a = c = b;
            break;
          }
          while (++i < n) if ((b = array[i]) != null) {
            if (a > b) a = b;
            if (c < b) c = b;
          }
        } else {
          while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
            a = c = b;
            break;
          }
          while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
            if (a > b) a = b;
            if (c < b) c = b;
          }
        }
        return [a, c];
      };
      function d3_number(x) {
        return x === null ? NaN : +x;
      }
      function d3_numeric(x) {
        return !isNaN(x);
      }
      d3.sum = function (array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n) if (d3_numeric(a = +array[i])) s += a;
        } else {
          while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
      };
      d3.mean = function (array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (arguments.length === 1) {
          while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a;else --j;
        } else {
          while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;else --j;
        }
        if (j) return s / j;
      };
      d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1,
            h = Math.floor(H),
            v = +values[h - 1],
            e = H - h;
        return e ? v + e * (values[h] - v) : v;
      };
      d3.median = function (array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
        } else {
          while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
        }
        if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
      };
      d3.variance = function (array, f) {
        var n = array.length,
            m = 0,
            a,
            d,
            s = 0,
            i = -1,
            j = 0;
        if (arguments.length === 1) {
          while (++i < n) {
            if (d3_numeric(a = d3_number(array[i]))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        } else {
          while (++i < n) {
            if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
              d = a - m;
              m += d / ++j;
              s += d * (a - m);
            }
          }
        }
        if (j > 1) return s / (j - 1);
      };
      d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
      };
      function d3_bisector(compare) {
        return {
          left: function (a, x, lo, hi) {
            if (arguments.length < 3) lo = 0;
            if (arguments.length < 4) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
            }
            return lo;
          },
          right: function (a, x, lo, hi) {
            if (arguments.length < 3) lo = 0;
            if (arguments.length < 4) hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
            }
            return lo;
          }
        };
      }
      var d3_bisect = d3_bisector(d3_ascending);
      d3.bisectLeft = d3_bisect.left;
      d3.bisect = d3.bisectRight = d3_bisect.right;
      d3.bisector = function (f) {
        return d3_bisector(f.length === 1 ? function (d, x) {
          return d3_ascending(f(d), x);
        } : f);
      };
      d3.shuffle = function (array, i0, i1) {
        if ((m = arguments.length) < 3) {
          i1 = array.length;
          if (m < 2) i0 = 0;
        }
        var m = i1 - i0,
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
      };
      d3.permute = function (array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--) permutes[i] = array[indexes[i]];
        return permutes;
      };
      d3.pairs = function (array) {
        var i = 0,
            n = array.length - 1,
            p0,
            p1 = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n) pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
      };
      d3.transpose = function (matrix) {
        if (!(n = matrix.length)) return [];
        for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m;) {
          for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
            row[j] = matrix[j][i];
          }
        }
        return transpose;
      };
      function d3_transposeLength(d) {
        return d.length;
      }
      d3.zip = function () {
        return d3.transpose(arguments);
      };
      d3.keys = function (map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
      };
      d3.values = function (map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
      };
      d3.entries = function (map) {
        var entries = [];
        for (var key in map) entries.push({
          key: key,
          value: map[key]
        });
        return entries;
      };
      d3.merge = function (arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var abs = Math.abs;
      d3.range = function (start, stop, step) {
        if (arguments.length < 3) {
          step = 1;
          if (arguments.length < 2) {
            stop = start;
            start = 0;
          }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [],
            k = d3_range_integerScale(abs(step)),
            i = -1,
            j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);else while ((j = start + step * ++i) < stop) range.push(j / k);
        return range;
      };
      function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1) k *= 10;
        return k;
      }
      function d3_class(ctor, properties) {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      }
      d3.map = function (object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
          object.forEach(function (key, value) {
            map.set(key, value);
          });
        } else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (arguments.length === 1) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f.call(object, o = object[i], i), o);
        } else {
          for (var key in object) map.set(key, object[key]);
        }
        return map;
      };
      function d3_Map() {
        this._ = Object.create(null);
      }
      var d3_map_proto = "__proto__",
          d3_map_zero = "\x00";
      d3_class(d3_Map, {
        has: d3_map_has,
        get: function (key) {
          return this._[d3_map_escape(key)];
        },
        set: function (key, value) {
          return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function () {
          var values = [];
          for (var key in this._) values.push(this._[key]);
          return values;
        },
        entries: function () {
          var entries = [];
          for (var key in this._) entries.push({
            key: d3_map_unescape(key),
            value: this._[key]
          });
          return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
          for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
        }
      });
      function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
      }
      function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
      }
      function d3_map_has(key) {
        return d3_map_escape(key) in this._;
      }
      function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
      }
      function d3_map_keys() {
        var keys = [];
        for (var key in this._) keys.push(d3_map_unescape(key));
        return keys;
      }
      function d3_map_size() {
        var size = 0;
        for (var key in this._) ++size;
        return size;
      }
      function d3_map_empty() {
        for (var key in this._) return false;
        return true;
      }
      d3.nest = function () {
        var nest = {},
            keys = [],
            sortKeys = [],
            sortValues,
            rollup;
        function map(mapType, array, depth) {
          if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              object,
              setter,
              valuesByKey = new d3_Map(),
              values;
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
              values.push(object);
            } else {
              valuesByKey.set(keyValue, [object]);
            }
          }
          if (mapType) {
            object = mapType();
            setter = function (keyValue, values) {
              object.set(keyValue, map(mapType, values, depth));
            };
          } else {
            object = {};
            setter = function (keyValue, values) {
              object[keyValue] = map(mapType, values, depth);
            };
          }
          valuesByKey.forEach(setter);
          return object;
        }
        function entries(map, depth) {
          if (depth >= keys.length) return map;
          var array = [],
              sortKey = sortKeys[depth++];
          map.forEach(function (key, keyMap) {
            array.push({
              key: key,
              values: entries(keyMap, depth)
            });
          });
          return sortKey ? array.sort(function (a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        nest.map = function (array, mapType) {
          return map(mapType, array, 0);
        };
        nest.entries = function (array) {
          return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function (d) {
          keys.push(d);
          return nest;
        };
        nest.sortKeys = function (order) {
          sortKeys[keys.length - 1] = order;
          return nest;
        };
        nest.sortValues = function (order) {
          sortValues = order;
          return nest;
        };
        nest.rollup = function (f) {
          rollup = f;
          return nest;
        };
        return nest;
      };
      d3.set = function (array) {
        var set = new d3_Set();
        if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
        return set;
      };
      function d3_Set() {
        this._ = Object.create(null);
      }
      d3_class(d3_Set, {
        has: d3_map_has,
        add: function (key) {
          this._[d3_map_escape(key += "")] = true;
          return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
          for (var key in this._) f.call(this, d3_map_unescape(key));
        }
      });
      d3.behavior = {};
      function d3_identity(d) {
        return d;
      }
      d3.rebind = function (target, source) {
        var i = 1,
            n = arguments.length,
            method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
      };
      function d3_rebind(target, source, method) {
        return function () {
          var value = method.apply(source, arguments);
          return value === source ? target : value;
        };
      }
      function d3_vendorSymbol(object, name) {
        if (name in object) return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
          var prefixName = d3_vendorPrefixes[i] + name;
          if (prefixName in object) return prefixName;
        }
      }
      var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
      function d3_noop() {}
      d3.dispatch = function () {
        var dispatch = new d3_dispatch(),
            i = -1,
            n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
      };
      function d3_dispatch() {}
      d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf("."),
            name = "";
        if (i >= 0) {
          name = type.slice(i + 1);
          type = type.slice(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
          if (listener == null) for (type in this) {
            if (this.hasOwnProperty(type)) this[type].on(name, null);
          }
          return this;
        }
      };
      function d3_dispatch_event(dispatch) {
        var listeners = [],
            listenerByName = new d3_Map();
        function event() {
          var z = listeners,
              i = -1,
              n = z.length,
              l;
          while (++i < n) if (l = z[i].on) l.apply(this, arguments);
          return dispatch;
        }
        event.on = function (name, listener) {
          var l = listenerByName.get(name),
              i;
          if (arguments.length < 2) return l && l.on;
          if (l) {
            l.on = null;
            listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
            listenerByName.remove(name);
          }
          if (listener) listeners.push(listenerByName.set(name, {
            on: listener
          }));
          return dispatch;
        };
        return event;
      }
      d3.event = null;
      function d3_eventPreventDefault() {
        d3.event.preventDefault();
      }
      function d3_eventSource() {
        var e = d3.event,
            s;
        while (s = e.sourceEvent) e = s;
        return e;
      }
      function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(),
            i = 0,
            n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function (thiz, argumentz) {
          return function (e1) {
            try {
              var e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
      d3.requote = function (s) {
        return s.replace(d3_requote_re, "\\$&");
      };
      var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype;
      } : function (object, prototype) {
        for (var property in prototype) object[property] = prototype[property];
      };
      function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
      }
      var d3_select = function (s, n) {
        return n.querySelector(s);
      },
          d3_selectAll = function (s, n) {
        return n.querySelectorAll(s);
      },
          d3_selectMatches = function (n, s) {
        var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
        d3_selectMatches = function (n, s) {
          return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n, s);
      };
      if (typeof Sizzle === "function") {
        d3_select = function (s, n) {
          return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
      }
      d3.selection = function () {
        return d3.select(d3_document.documentElement);
      };
      var d3_selectionPrototype = d3.selection.prototype = [];
      d3_selectionPrototype.select = function (selector) {
        var subgroups = [],
            subgroup,
            subnode,
            group,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              subgroup.push(subnode = selector.call(node, node.__data__, i, j));
              if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function () {
          return d3_select(selector, this);
        };
      }
      d3_selectionPrototype.selectAll = function (selector) {
        var subgroups = [],
            subgroup,
            node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
              subgroup.parentNode = node;
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function () {
          return d3_selectAll(selector, this);
        };
      }
      var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
      var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: d3_nsXhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function (name) {
          var i = name.indexOf(":"),
              prefix = name;
          if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
          return d3_nsPrefix.hasOwnProperty(prefix) ? {
            space: d3_nsPrefix[prefix],
            local: name
          } : name;
        }
      };
      d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node();
            name = d3.ns.qualify(name);
            return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
          }
          for (value in name) this.each(d3_selection_attr(value, name[value]));
          return this;
        }
        return this.each(d3_selection_attr(name, value));
      };
      function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
          this.setAttribute(name, value);
        }
        function attrConstantNS() {
          this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
          var x = value.apply(this, arguments);
          if (x == null) this.removeAttribute(name);else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
          var x = value.apply(this, arguments);
          if (x == null) this.removeAttributeNS(name.space, name.local);else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
      }
      function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
      }
      d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node(),
                n = (name = d3_selection_classes(name)).length,
                i = -1;
            if (value = node.classList) {
              while (++i < n) if (!value.contains(name[i])) return false;
            } else {
              value = node.getAttribute("class");
              while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
            }
            return true;
          }
          for (value in name) this.each(d3_selection_classed(value, name[value]));
          return this;
        }
        return this.each(d3_selection_classed(name, value));
      };
      function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
      }
      function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
      }
      function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
          var i = -1;
          while (++i < n) name[i](this, value);
        }
        function classedFunction() {
          var i = -1,
              x = value.apply(this, arguments);
          while (++i < n) name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
      }
      function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
          if (c = node.classList) return value ? c.add(name) : c.remove(name);
          var c = node.getAttribute("class") || "";
          if (value) {
            re.lastIndex = 0;
            if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
          } else {
            node.setAttribute("class", d3_collapse(c.replace(re, " ")));
          }
        };
      }
      d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2) value = "";
            for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
            return this;
          }
          if (n < 2) {
            var node = this.node();
            return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
          }
          priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
      };
      function d3_selection_style(name, value, priority) {
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleConstant() {
          this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
          var x = value.apply(this, arguments);
          if (x == null) this.style.removeProperty(name);else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
      }
      d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") return this.node()[name];
          for (value in name) this.each(d3_selection_property(value, name[value]));
          return this;
        }
        return this.each(d3_selection_property(name, value));
      };
      function d3_selection_property(name, value) {
        function propertyNull() {
          delete this[name];
        }
        function propertyConstant() {
          this[name] = value;
        }
        function propertyFunction() {
          var x = value.apply(this, arguments);
          if (x == null) delete this[name];else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
      }
      d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each(typeof value === "function" ? function () {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        } : value == null ? function () {
          this.textContent = "";
        } : function () {
          this.textContent = value;
        }) : this.node().textContent;
      };
      d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each(typeof value === "function" ? function () {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        } : value == null ? function () {
          this.innerHTML = "";
        } : function () {
          this.innerHTML = value;
        }) : this.node().innerHTML;
      };
      d3_selectionPrototype.append = function (name) {
        name = d3_selection_creator(name);
        return this.select(function () {
          return this.appendChild(name.apply(this, arguments));
        });
      };
      function d3_selection_creator(name) {
        function create() {
          var document = this.ownerDocument,
              namespace = this.namespaceURI;
          return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
          return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
      }
      d3_selectionPrototype.insert = function (name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function () {
          return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
      };
      d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove);
      };
      function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
      }
      d3_selectionPrototype.data = function (value, key) {
        var i = -1,
            n = this.length,
            group,
            node;
        if (!arguments.length) {
          value = new Array(n = (group = this[0]).length);
          while (++i < n) {
            if (node = group[i]) {
              value[i] = node.__data__;
            }
          }
          return value;
        }
        function bind(group, groupData) {
          var i,
              n = group.length,
              m = groupData.length,
              n0 = Math.min(n, m),
              updateNodes = new Array(m),
              enterNodes = new Array(m),
              exitNodes = new Array(n),
              node,
              nodeData;
          if (key) {
            var nodeByKeyValue = new d3_Map(),
                keyValues = new Array(n),
                keyValue;
            for (i = -1; ++i < n;) {
              if (node = group[i]) {
                if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                  exitNodes[i] = node;
                } else {
                  nodeByKeyValue.set(keyValue, node);
                }
                keyValues[i] = keyValue;
              }
            }
            for (i = -1; ++i < m;) {
              if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              } else if (node !== true) {
                updateNodes[i] = node;
                node.__data__ = nodeData;
              }
              nodeByKeyValue.set(keyValue, true);
            }
            for (i = -1; ++i < n;) {
              if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                exitNodes[i] = group[i];
              }
            }
          } else {
            for (i = -1; ++i < n0;) {
              node = group[i];
              nodeData = groupData[i];
              if (node) {
                node.__data__ = nodeData;
                updateNodes[i] = node;
              } else {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              }
            }
            for (; i < m; ++i) {
              enterNodes[i] = d3_selection_dataNode(groupData[i]);
            }
            for (; i < n; ++i) {
              exitNodes[i] = group[i];
            }
          }
          enterNodes.update = updateNodes;
          enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
          enter.push(enterNodes);
          update.push(updateNodes);
          exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]),
            update = d3_selection([]),
            exit = d3_selection([]);
        if (typeof value === "function") {
          while (++i < n) {
            bind(group = this[i], value.call(group, group.parentNode.__data__, i));
          }
        } else {
          while (++i < n) {
            bind(group = this[i], value);
          }
        }
        update.enter = function () {
          return enter;
        };
        update.exit = function () {
          return exit;
        };
        return update;
      };
      function d3_selection_dataNode(data) {
        return {
          __data__: data
        };
      }
      d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
      };
      d3_selectionPrototype.filter = function (filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = 0, n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_filter(selector) {
        return function () {
          return d3_selectMatches(this, selector);
        };
      }
      d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m;) {
          for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);
        return this.order();
      };
      function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3_ascending;
        return function (a, b) {
          return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
      }
      d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
          callback.call(node, node.__data__, i, j);
        });
      };
      function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
          for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
            if (node = group[i]) callback(node, i, j);
          }
        }
        return groups;
      }
      d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
      };
      d3_selectionPrototype.empty = function () {
        return !this.node();
      };
      d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; j < m; j++) {
          for (var group = this[j], i = 0, n = group.length; i < n; i++) {
            var node = group[i];
            if (node) return node;
          }
        }
        return null;
      };
      d3_selectionPrototype.size = function () {
        var n = 0;
        d3_selection_each(this, function () {
          ++n;
        });
        return n;
      };
      function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
      }
      var d3_selection_enterPrototype = [];
      d3.selection.enter = d3_selection_enter;
      d3.selection.enter.prototype = d3_selection_enterPrototype;
      d3_selection_enterPrototype.append = d3_selectionPrototype.append;
      d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
      d3_selection_enterPrototype.node = d3_selectionPrototype.node;
      d3_selection_enterPrototype.call = d3_selectionPrototype.call;
      d3_selection_enterPrototype.size = d3_selectionPrototype.size;
      d3_selection_enterPrototype.select = function (selector) {
        var subgroups = [],
            subgroup,
            subnode,
            upgroup,
            group,
            node;
        for (var j = -1, m = this.length; ++j < m;) {
          upgroup = (group = this[j]).update;
          subgroups.push(subgroup = []);
          subgroup.parentNode = group.parentNode;
          for (var i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
              subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      d3_selection_enterPrototype.insert = function (name, before) {
        if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
      };
      function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
          var group = enter[j].update,
              n = group.length,
              node;
          if (j != j0) j0 = j, i0 = 0;
          if (i >= i0) i0 = i + 1;
          while (!(node = group[i0]) && ++i0 < n);
          return node;
        };
      }
      d3.select = function (node) {
        var group;
        if (typeof node === "string") {
          group = [d3_select(node, d3_document)];
          group.parentNode = d3_document.documentElement;
        } else {
          group = [node];
          group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
      };
      d3.selectAll = function (nodes) {
        var group;
        if (typeof nodes === "string") {
          group = d3_array(d3_selectAll(nodes, d3_document));
          group.parentNode = d3_document.documentElement;
        } else {
          group = d3_array(nodes);
          group.parentNode = null;
        }
        return d3_selection([group]);
      };
      d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof type !== "string") {
            if (n < 2) listener = false;
            for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
            return this;
          }
          if (n < 2) return (n = this.node()["__on" + type]) && n._;
          capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
      };
      function d3_selection_on(type, listener, capture) {
        var name = "__on" + type,
            i = type.indexOf("."),
            wrap = d3_selection_onListener;
        if (i > 0) type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
          var l = this[name];
          if (l) {
            this.removeEventListener(type, l, l.$);
            delete this[name];
          }
        }
        function onAdd() {
          var l = wrap(listener, d3_array(arguments));
          onRemove.call(this);
          this.addEventListener(type, this[name] = l, l.$ = capture);
          l._ = listener;
        }
        function removeAll() {
          var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
              match;
          for (var name in this) {
            if (match = name.match(re)) {
              var l = this[name];
              this.removeEventListener(match[1], l, l.$);
              delete this[name];
            }
          }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
      }
      var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      });
      if (d3_document) {
        d3_selection_onFilters.forEach(function (k) {
          if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
        });
      }
      function d3_selection_onListener(listener, argumentz) {
        return function (e) {
          var o = d3.event;
          d3.event = e;
          argumentz[0] = this.__data__;
          try {
            listener.apply(this, argumentz);
          } finally {
            d3.event = o;
          }
        };
      }
      function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
          var target = this,
              related = e.relatedTarget;
          if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
            l.call(target, e);
          }
        };
      }
      var d3_event_dragSelect,
          d3_event_dragId = 0;
      function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId,
            click = "click" + name,
            w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
          d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
          var style = d3_documentElement(node).style,
              select = style[d3_event_dragSelect];
          style[d3_event_dragSelect] = "none";
        }
        return function (suppressClick) {
          w.on(name, null);
          if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
          if (suppressClick) {
            var off = function () {
              w.on(click, null);
            };
            w.on(click, function () {
              d3_eventPreventDefault();
              off();
            }, true);
            setTimeout(off, 0);
          }
        };
      }
      d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource());
      };
      var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
      function d3_mousePoint(container, e) {
        if (e.changedTouches) e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          if (d3_mouse_bug44083 < 0) {
            var window = d3_window(container);
            if (window.scrollX || window.scrollY) {
              svg = d3.select("body").append("svg").style({
                position: "absolute",
                top: 0,
                left: 0,
                margin: 0,
                padding: 0,
                border: "none"
              }, "important");
              var ctm = svg[0][0].getScreenCTM();
              d3_mouse_bug44083 = !(ctm.f || ctm.e);
              svg.remove();
            }
          }
          if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;else point.x = e.clientX, point.y = e.clientY;
          point = point.matrixTransform(container.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
      }
      d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
          if ((touch = touches[i]).identifier === identifier) {
            return d3_mousePoint(container, touch);
          }
        }
      };
      d3.behavior.drag = function () {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
            origin = null,
            mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"),
            touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
          this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
          return function () {
            var that = this,
                target = d3.event.target.correspondingElement || d3.event.target,
                parent = that.parentNode,
                dispatch = event.of(that, arguments),
                dragged = 0,
                dragId = id(),
                dragName = ".drag" + (dragId == null ? "" : "-" + dragId),
                dragOffset,
                dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended),
                dragRestore = d3_event_dragSuppress(target),
                position0 = position(parent, dragId);
            if (origin) {
              dragOffset = origin.apply(that, arguments);
              dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
            } else {
              dragOffset = [0, 0];
            }
            dispatch({
              type: "dragstart"
            });
            function moved() {
              var position1 = position(parent, dragId),
                  dx,
                  dy;
              if (!position1) return;
              dx = position1[0] - position0[0];
              dy = position1[1] - position0[1];
              dragged |= dx | dy;
              position0 = position1;
              dispatch({
                type: "drag",
                x: position1[0] + dragOffset[0],
                y: position1[1] + dragOffset[1],
                dx: dx,
                dy: dy
              });
            }
            function ended() {
              if (!position(parent, dragId)) return;
              dragSubject.on(move + dragName, null).on(end + dragName, null);
              dragRestore(dragged);
              dispatch({
                type: "dragend"
              });
            }
          };
        }
        drag.origin = function (x) {
          if (!arguments.length) return origin;
          origin = x;
          return drag;
        };
        return d3.rebind(drag, event, "on");
      };
      function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
      }
      d3.touches = function (container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function (touch) {
          var point = d3_mousePoint(container, touch);
          point.identifier = touch.identifier;
          return point;
        }) : [];
      };
      var ε = 1e-6,
          ε2 = ε * ε,
          π = Math.PI,
          τ = 2 * π,
          τε = τ - ε,
          halfπ = π / 2,
          d3_radians = π / 180,
          d3_degrees = 180 / π;
      function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      }
      function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      }
      function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
      }
      function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
      }
      function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
      }
      var ρ = Math.SQRT2,
          ρ2 = 2,
          ρ4 = 4;
      d3.interpolateZoom = function (p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;
        if (d2 < ε2) {
          S = Math.log(w1 / w0) / ρ;
          i = function (t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S)];
          };
        } else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),
              b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / ρ;
          i = function (t) {
            var s = t * S,
                coshr0 = d3_cosh(r0),
                u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
          };
        }
        i.duration = S * 1e3;
        return i;
      };
      d3.behavior.zoom = function () {
        var view = {
          x: 0,
          y: 0,
          k: 1
        },
            translate0,
            center0,
            center,
            size = [960, 500],
            scaleExtent = d3_behavior_zoomInfinity,
            duration = 250,
            zooming = 0,
            mousedown = "mousedown.zoom",
            mousemove = "mousemove.zoom",
            mouseup = "mouseup.zoom",
            mousewheelTimer,
            touchstart = "touchstart.zoom",
            touchtime,
            event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"),
            x0,
            x1,
            y0,
            y1;
        if (!d3_behavior_zoomWheel) {
          d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function () {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
          }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function () {
            return d3.event.wheelDelta;
          }, "mousewheel") : (d3_behavior_zoomDelta = function () {
            return -d3.event.detail;
          }, "MozMousePixelScroll");
        }
        function zoom(g) {
          g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function (g) {
          g.each(function () {
            var dispatch = event.of(this, arguments),
                view1 = view;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.zoom", function () {
                view = this.__chart__ || {
                  x: 0,
                  y: 0,
                  k: 1
                };
                zoomstarted(dispatch);
              }).tween("zoom:zoom", function () {
                var dx = size[0],
                    dy = size[1],
                    cx = center0 ? center0[0] : dx / 2,
                    cy = center0 ? center0[1] : dy / 2,
                    i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                return function (t) {
                  var l = i(t),
                      k = dx / l[2];
                  this.__chart__ = view = {
                    x: cx - l[0] * k,
                    y: cy - l[1] * k,
                    k: k
                  };
                  zoomed(dispatch);
                };
              }).each("interrupt.zoom", function () {
                zoomended(dispatch);
              }).each("end.zoom", function () {
                zoomended(dispatch);
              });
            } else {
              this.__chart__ = view;
              zoomstarted(dispatch);
              zoomed(dispatch);
              zoomended(dispatch);
            }
          });
        };
        zoom.translate = function (_) {
          if (!arguments.length) return [view.x, view.y];
          view = {
            x: +_[0],
            y: +_[1],
            k: view.k
          };
          rescale();
          return zoom;
        };
        zoom.scale = function (_) {
          if (!arguments.length) return view.k;
          view = {
            x: view.x,
            y: view.y,
            k: null
          };
          scaleTo(+_);
          rescale();
          return zoom;
        };
        zoom.scaleExtent = function (_) {
          if (!arguments.length) return scaleExtent;
          scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
          return zoom;
        };
        zoom.center = function (_) {
          if (!arguments.length) return center;
          center = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.size = function (_) {
          if (!arguments.length) return size;
          size = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.duration = function (_) {
          if (!arguments.length) return duration;
          duration = +_;
          return zoom;
        };
        zoom.x = function (z) {
          if (!arguments.length) return x1;
          x1 = z;
          x0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        zoom.y = function (z) {
          if (!arguments.length) return y1;
          y1 = z;
          y0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        function location(p) {
          return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
          return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
          view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
          l = point(l);
          view.x += p[0] - l[0];
          view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
          that.__chart__ = {
            x: view.x,
            y: view.y,
            k: view.k
          };
          scaleTo(Math.pow(2, k));
          translateTo(center0 = p, l);
          that = d3.select(that);
          if (duration > 0) that = that.transition().duration(duration);
          that.call(zoom.event);
        }
        function rescale() {
          if (x1) x1.domain(x0.range().map(function (x) {
            return (x - view.x) / view.k;
          }).map(x0.invert));
          if (y1) y1.domain(y0.range().map(function (y) {
            return (y - view.y) / view.k;
          }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
          if (!zooming++) dispatch({
            type: "zoomstart"
          });
        }
        function zoomed(dispatch) {
          rescale();
          dispatch({
            type: "zoom",
            scale: view.k,
            translate: [view.x, view.y]
          });
        }
        function zoomended(dispatch) {
          if (! --zooming) dispatch({
            type: "zoomend"
          }), center0 = null;
        }
        function mousedowned() {
          var that = this,
              dispatch = event.of(that, arguments),
              dragged = 0,
              subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended),
              location0 = location(d3.mouse(that)),
              dragRestore = d3_event_dragSuppress(that);
          d3_selection_interrupt.call(that);
          zoomstarted(dispatch);
          function moved() {
            dragged = 1;
            translateTo(d3.mouse(that), location0);
            zoomed(dispatch);
          }
          function ended() {
            subject.on(mousemove, null).on(mouseup, null);
            dragRestore(dragged);
            zoomended(dispatch);
          }
        }
        function touchstarted() {
          var that = this,
              dispatch = event.of(that, arguments),
              locations0 = {},
              distance0 = 0,
              scale0,
              zoomName = ".zoom-" + d3.event.changedTouches[0].identifier,
              touchmove = "touchmove" + zoomName,
              touchend = "touchend" + zoomName,
              targets = [],
              subject = d3.select(that),
              dragRestore = d3_event_dragSuppress(that);
          started();
          zoomstarted(dispatch);
          subject.on(mousedown, null).on(touchstart, started);
          function relocate() {
            var touches = d3.touches(that);
            scale0 = view.k;
            touches.forEach(function (t) {
              if (t.identifier in locations0) locations0[t.identifier] = location(t);
            });
            return touches;
          }
          function started() {
            var target = d3.event.target;
            d3.select(target).on(touchmove, moved).on(touchend, ended);
            targets.push(target);
            var changed = d3.event.changedTouches;
            for (var i = 0, n = changed.length; i < n; ++i) {
              locations0[changed[i].identifier] = null;
            }
            var touches = relocate(),
                now = Date.now();
            if (touches.length === 1) {
              if (now - touchtime < 500) {
                var p = touches[0];
                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                d3_eventPreventDefault();
              }
              touchtime = now;
            } else if (touches.length > 1) {
              var p = touches[0],
                  q = touches[1],
                  dx = p[0] - q[0],
                  dy = p[1] - q[1];
              distance0 = dx * dx + dy * dy;
            }
          }
          function moved() {
            var touches = d3.touches(that),
                p0,
                l0,
                p1,
                l1;
            d3_selection_interrupt.call(that);
            for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
              p1 = touches[i];
              if (l1 = locations0[p1.identifier]) {
                if (l0) break;
                p0 = p1, l0 = l1;
              }
            }
            if (l1) {
              var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,
                  scale1 = distance0 && Math.sqrt(distance1 / distance0);
              p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
              scaleTo(scale1 * scale0);
            }
            touchtime = null;
            translateTo(p0, l0);
            zoomed(dispatch);
          }
          function ended() {
            if (d3.event.touches.length) {
              var changed = d3.event.changedTouches;
              for (var i = 0, n = changed.length; i < n; ++i) {
                delete locations0[changed[i].identifier];
              }
              for (var identifier in locations0) {
                return void relocate();
              }
            }
            d3.selectAll(targets).on(zoomName, null);
            subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
            dragRestore();
            zoomended(dispatch);
          }
        }
        function mousewheeled() {
          var dispatch = event.of(this, arguments);
          if (mousewheelTimer) clearTimeout(mousewheelTimer);else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
          mousewheelTimer = setTimeout(function () {
            mousewheelTimer = null;
            zoomended(dispatch);
          }, 50);
          d3_eventPreventDefault();
          scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
          translateTo(center0, translate0);
          zoomed(dispatch);
        }
        function dblclicked() {
          var p = d3.mouse(this),
              k = Math.log(view.k) / Math.LN2;
          zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
      };
      var d3_behavior_zoomInfinity = [0, Infinity],
          d3_behavior_zoomDelta,
          d3_behavior_zoomWheel;
      d3.color = d3_color;
      function d3_color() {}
      d3_color.prototype.toString = function () {
        return this.rgb() + "";
      };
      d3.hsl = d3_hsl;
      function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
      }
      var d3_hslPrototype = d3_hsl.prototype = new d3_color();
      d3_hslPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
      };
      d3_hslPrototype.darker = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
      };
      d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l);
      };
      function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
          if (h > 360) h -= 360;else if (h < 0) h += 360;
          if (h < 60) return m1 + (m2 - m1) * h / 60;
          if (h < 180) return m2;
          if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
          return m1;
        }
        function vv(h) {
          return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
      }
      d3.hcl = d3_hcl;
      function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
      }
      var d3_hclPrototype = d3_hcl.prototype = new d3_color();
      d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
      };
      function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
      }
      d3.lab = d3_lab;
      function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
      }
      var d3_lab_K = 18;
      var d3_lab_X = .95047,
          d3_lab_Y = 1,
          d3_lab_Z = 1.08883;
      var d3_labPrototype = d3_lab.prototype = new d3_color();
      d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b);
      };
      function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116,
            x = y + a / 500,
            z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
      }
      function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
      }
      function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
      }
      function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
      }
      function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
      }
      d3.rgb = d3_rgb;
      function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
      }
      function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
      }
      function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
      }
      var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
      d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r,
            g = this.g,
            b = this.b,
            i = 30;
        if (!r && !g && !b) return new d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
      };
      d3_rgbPrototype.darker = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
      };
      d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b);
      };
      d3_rgbPrototype.toString = function () {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
      };
      function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
      }
      function d3_rgb_parse(format, rgb, hsl) {
        var r = 0,
            g = 0,
            b = 0,
            m1,
            m2,
            color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
          m2 = m1[2].split(",");
          switch (m1[1]) {
            case "hsl":
              {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }

            case "rgb":
              {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
          }
        }
        if (color = d3_rgb_names.get(format)) {
          return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
          if (format.length === 4) {
            r = (color & 3840) >> 4;
            r = r >> 4 | r;
            g = color & 240;
            g = g >> 4 | g;
            b = color & 15;
            b = b << 4 | b;
          } else if (format.length === 7) {
            r = (color & 16711680) >> 16;
            g = (color & 65280) >> 8;
            b = color & 255;
          }
        }
        return rgb(r, g, b);
      }
      function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255),
            max = Math.max(r, g, b),
            d = max - min,
            h,
            s,
            l = (max + min) / 2;
        if (d) {
          s = l < .5 ? d / (max + min) : d / (2 - max - min);
          if (r == max) h = (g - b) / d + (g < b ? 6 : 0);else if (g == max) h = (b - r) / d + 2;else h = (r - g) / d + 4;
          h *= 60;
        } else {
          h = NaN;
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
      }
      function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
            y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
            z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
      }
      function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
      }
      function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
      }
      var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      });
      d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
      });
      function d3_functor(v) {
        return typeof v === "function" ? v : function () {
          return v;
        };
      }
      d3.functor = d3_functor;
      d3.xhr = d3_xhrType(d3_identity);
      function d3_xhrType(response) {
        return function (url, mimeType, callback) {
          if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, mimeType = null;
          return d3_xhr(url, mimeType, response, callback);
        };
      }
      function d3_xhr(url, mimeType, response, callback) {
        var xhr = {},
            dispatch = d3.dispatch("beforesend", "progress", "load", "error"),
            headers = {},
            request = new XMLHttpRequest(),
            responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
          request.readyState > 3 && respond();
        };
        function respond() {
          var status = request.status,
              result;
          if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
            try {
              result = response.call(xhr, request);
            } catch (e) {
              dispatch.error.call(xhr, e);
              return;
            }
            dispatch.load.call(xhr, result);
          } else {
            dispatch.error.call(xhr, request);
          }
        }
        request.onprogress = function (event) {
          var o = d3.event;
          d3.event = event;
          try {
            dispatch.progress.call(xhr, request);
          } finally {
            d3.event = o;
          }
        };
        xhr.header = function (name, value) {
          name = (name + "").toLowerCase();
          if (arguments.length < 2) return headers[name];
          if (value == null) delete headers[name];else headers[name] = value + "";
          return xhr;
        };
        xhr.mimeType = function (value) {
          if (!arguments.length) return mimeType;
          mimeType = value == null ? null : value + "";
          return xhr;
        };
        xhr.responseType = function (value) {
          if (!arguments.length) return responseType;
          responseType = value;
          return xhr;
        };
        xhr.response = function (value) {
          response = value;
          return xhr;
        };
        ["get", "post"].forEach(function (method) {
          xhr[method] = function () {
            return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
          };
        });
        xhr.send = function (method, data, callback) {
          if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
          request.open(method, url, true);
          if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
          if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
          if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
          if (responseType != null) request.responseType = responseType;
          if (callback != null) xhr.on("error", callback).on("load", function (request) {
            callback(null, request);
          });
          dispatch.beforesend.call(xhr, request);
          request.send(data == null ? null : data);
          return xhr;
        };
        xhr.abort = function () {
          request.abort();
          return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
      }
      function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function (error, request) {
          callback(error == null ? request : null);
        } : callback;
      }
      function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
      }
      d3.dsv = function (delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
          if (arguments.length < 3) callback = row, row = null;
          var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
          xhr.row = function (_) {
            return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
          };
          return xhr;
        }
        function response(request) {
          return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
          return function (request) {
            return dsv.parse(request.responseText, f);
          };
        }
        dsv.parse = function (text, f) {
          var o;
          return dsv.parseRows(text, function (row, i) {
            if (o) return o(row, i - 1);
            var a = new Function("d", "return {" + row.map(function (name, i) {
              return JSON.stringify(name) + ": d[" + i + "]";
            }).join(",") + "}");
            o = f ? function (row, i) {
              return f(a(row), i);
            } : a;
          });
        };
        dsv.parseRows = function (text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N) return EOF;
            if (eol) return eol = false, EOL;
            var j = I;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34) break;
                  ++i;
                }
              }
              I = i + 2;
              var c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10) ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, '"');
            }
            while (I < N) {
              var c = text.charCodeAt(I++),
                  k = 1;
              if (c === 10) eol = true;else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10) ++I, ++k;
              } else if (c !== delimiterCode) continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null) continue;
            rows.push(a);
          }
          return rows;
        };
        dsv.format = function (rows) {
          if (Array.isArray(rows[0])) return dsv.formatRows(rows);
          var fieldSet = new d3_Set(),
              fields = [];
          rows.forEach(function (row) {
            for (var field in row) {
              if (!fieldSet.has(field)) {
                fields.push(fieldSet.add(field));
              }
            }
          });
          return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
            return fields.map(function (field) {
              return formatValue(row[field]);
            }).join(delimiter);
          })).join("\n");
        };
        dsv.formatRows = function (rows) {
          return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
      };
      d3.csv = d3.dsv(",", "text/csv");
      d3.tsv = d3.dsv("	", "text/tab-separated-values");
      var d3_timer_queueHead,
          d3_timer_queueTail,
          d3_timer_interval,
          d3_timer_timeout,
          d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function (callback) {
        setTimeout(callback, 17);
      };
      d3.timer = function () {
        d3_timer.apply(this, arguments);
      };
      function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) delay = 0;
        if (n < 3) then = Date.now();
        var time = then + delay,
            timer = {
          c: callback,
          t: time,
          n: null
        };
        if (d3_timer_queueTail) d3_timer_queueTail.n = timer;else d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
          d3_timer_timeout = clearTimeout(d3_timer_timeout);
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
        return timer;
      }
      function d3_timer_step() {
        var now = d3_timer_mark(),
            delay = d3_timer_sweep() - now;
        if (delay > 24) {
          if (isFinite(delay)) {
            clearTimeout(d3_timer_timeout);
            d3_timer_timeout = setTimeout(d3_timer_step, delay);
          }
          d3_timer_interval = 0;
        } else {
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      }
      d3.timer.flush = function () {
        d3_timer_mark();
        d3_timer_sweep();
      };
      function d3_timer_mark() {
        var now = Date.now(),
            timer = d3_timer_queueHead;
        while (timer) {
          if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
          timer = timer.n;
        }
        return now;
      }
      function d3_timer_sweep() {
        var t0,
            t1 = d3_timer_queueHead,
            time = Infinity;
        while (t1) {
          if (t1.c) {
            if (t1.t < time) time = t1.t;
            t1 = (t0 = t1).n;
          } else {
            t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
          }
        }
        d3_timer_queueTail = t0;
        return time;
      }
      function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
      }
      d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
      };
      var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
      d3.formatPrefix = function (value, precision) {
        var i = 0;
        if (value = +value) {
          if (value < 0) value *= -1;
          if (precision) value = d3.round(value, d3_format_precision(value, precision));
          i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
          i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
      };
      function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
          scale: i > 8 ? function (d) {
            return d / k;
          } : function (d) {
            return d * k;
          },
          symbol: d
        };
      }
      function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal,
            locale_thousands = locale.thousands,
            locale_grouping = locale.grouping,
            locale_currency = locale.currency,
            formatGroup = locale_grouping && locale_thousands ? function (value, width) {
          var i = value.length,
              t = [],
              j = 0,
              g = locale_grouping[0],
              length = 0;
          while (i > 0 && g > 0) {
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = locale_grouping[j = (j + 1) % locale_grouping.length];
          }
          return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function (specifier) {
          var match = d3_format_re.exec(specifier),
              fill = match[1] || " ",
              align = match[2] || ">",
              sign = match[3] || "-",
              symbol = match[4] || "",
              zfill = match[5],
              width = +match[6],
              comma = match[7],
              precision = match[8],
              type = match[9],
              scale = 1,
              prefix = "",
              suffix = "",
              integer = false,
              exponent = true;
          if (precision) precision = +precision.substring(1);
          if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;

            case "%":
              scale = 100;
              suffix = "%";
              type = "f";
              break;

            case "p":
              scale = 100;
              suffix = "%";
              type = "r";
              break;

            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#") prefix = "0" + type.toLowerCase();

            case "c":
              exponent = false;

            case "d":
              integer = true;
              precision = 0;
              break;

            case "s":
              scale = -1;
              type = "r";
              break;
          }
          if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
          if (type == "r" && !precision) type = "g";
          if (precision != null) {
            if (type == "g") precision = Math.max(1, Math.min(21, precision));else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
          }
          type = d3_format_types.get(type) || d3_format_typeDefault;
          var zcomma = zfill && comma;
          return function (value) {
            var fullSuffix = suffix;
            if (integer && value % 1) return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
            if (scale < 0) {
              var unit = d3.formatPrefix(value, precision);
              value = unit.scale(value);
              fullSuffix = unit.symbol + suffix;
            } else {
              value *= scale;
            }
            value = type(value, precision);
            var i = value.lastIndexOf("."),
                before,
                after;
            if (i < 0) {
              var j = exponent ? value.lastIndexOf("e") : -1;
              if (j < 0) before = value, after = "";else before = value.substring(0, j), after = value.substring(j);
            } else {
              before = value.substring(0, i);
              after = locale_decimal + value.substring(i + 1);
            }
            if (!zfill && comma) before = formatGroup(before, Infinity);
            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),
                padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
            negative += prefix;
            value = before + after;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
          };
        };
      }
      var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
      var d3_format_types = d3.map({
        b: function (x) {
          return x.toString(2);
        },
        c: function (x) {
          return String.fromCharCode(x);
        },
        o: function (x) {
          return x.toString(8);
        },
        x: function (x) {
          return x.toString(16);
        },
        X: function (x) {
          return x.toString(16).toUpperCase();
        },
        g: function (x, p) {
          return x.toPrecision(p);
        },
        e: function (x, p) {
          return x.toExponential(p);
        },
        f: function (x, p) {
          return x.toFixed(p);
        },
        r: function (x, p) {
          return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
      });
      function d3_format_typeDefault(x) {
        return x + "";
      }
      var d3_time = d3.time = {},
          d3_date = Date;
      function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
      }
      d3_date_utc.prototype = {
        getDate: function () {
          return this._.getUTCDate();
        },
        getDay: function () {
          return this._.getUTCDay();
        },
        getFullYear: function () {
          return this._.getUTCFullYear();
        },
        getHours: function () {
          return this._.getUTCHours();
        },
        getMilliseconds: function () {
          return this._.getUTCMilliseconds();
        },
        getMinutes: function () {
          return this._.getUTCMinutes();
        },
        getMonth: function () {
          return this._.getUTCMonth();
        },
        getSeconds: function () {
          return this._.getUTCSeconds();
        },
        getTime: function () {
          return this._.getTime();
        },
        getTimezoneOffset: function () {
          return 0;
        },
        valueOf: function () {
          return this._.valueOf();
        },
        setDate: function () {
          d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function () {
          d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function () {
          d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function () {
          d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function () {
          d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function () {
          d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function () {
          d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function () {
          d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function () {
          d3_time_prototype.setTime.apply(this._, arguments);
        }
      };
      var d3_time_prototype = Date.prototype;
      function d3_time_interval(local, step, number) {
        function round(date) {
          var d0 = local(date),
              d1 = offset(d0, 1);
          return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
          step(date = local(new d3_date(date - 1)), 1);
          return date;
        }
        function offset(date, k) {
          step(date = new d3_date(+date), k);
          return date;
        }
        function range(t0, t1, dt) {
          var time = ceil(t0),
              times = [];
          if (dt > 1) {
            while (time < t1) {
              if (!(number(time) % dt)) times.push(new Date(+time));
              step(time, 1);
            }
          } else {
            while (time < t1) times.push(new Date(+time)), step(time, 1);
          }
          return times;
        }
        function range_utc(t0, t1, dt) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = t0;
            return range(utc, t1, dt);
          } finally {
            d3_date = Date;
          }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
      }
      function d3_time_interval_utc(method) {
        return function (date, k) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = date;
            return method(utc, k)._;
          } finally {
            d3_date = Date;
          }
        };
      }
      d3_time.year = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
      }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset);
      }, function (date) {
        return date.getFullYear();
      });
      d3_time.years = d3_time.year.range;
      d3_time.years.utc = d3_time.year.utc.range;
      d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
      }, function (date, offset) {
        date.setDate(date.getDate() + offset);
      }, function (date) {
        return date.getDate() - 1;
      });
      d3_time.days = d3_time.day.range;
      d3_time.days.utc = d3_time.day.utc.range;
      d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
      };
      ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
          (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
          return date;
        }, function (date, offset) {
          date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function (date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function (date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
      });
      d3_time.week = d3_time.sunday;
      d3_time.weeks = d3_time.sunday.range;
      d3_time.weeks.utc = d3_time.sunday.utc.range;
      d3_time.weekOfYear = d3_time.sundayOfYear;
      function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_days = locale.days,
            locale_shortDays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
          var n = template.length;
          function format(date) {
            var string = [],
                i = -1,
                j = 0,
                c,
                p,
                f;
            while (++i < n) {
              if (template.charCodeAt(i) === 37) {
                string.push(template.slice(j, i));
                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(template.slice(j, i));
            return string.join("");
          }
          format.parse = function (string) {
            var d = {
              y: 1900,
              m: 0,
              d: 1,
              H: 0,
              M: 0,
              S: 0,
              L: 0,
              Z: null
            },
                i = d3_time_parse(d, template, string, 0);
            if (i != string.length) return null;
            if ("p" in d) d.H = d.H % 12 + d.p * 12;
            var localZ = d.Z != null && d3_date !== d3_date_utc,
                date = new (localZ ? d3_date_utc : d3_date)();
            if ("j" in d) date.setFullYear(d.y, 0, d.j);else if ("W" in d || "U" in d) {
              if (!("w" in d)) d.w = "W" in d ? 1 : 0;
              date.setFullYear(d.y, 0, 1);
              date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
            } else date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
            return localZ ? date._ : date;
          };
          format.toString = function () {
            return template;
          };
          return format;
        }
        function d3_time_parse(date, template, string, j) {
          var c,
              p,
              t,
              i = 0,
              n = template.length,
              m = string.length;
          while (i < n) {
            if (j >= m) return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
              t = template.charAt(i++);
              p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
              if (!p || (j = p(date, string, j)) < 0) return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        d3_time_format.utc = function (template) {
          var local = d3_time_format(template);
          function format(date) {
            try {
              d3_date = d3_date_utc;
              var utc = new d3_date();
              utc._ = date;
              return local(utc);
            } finally {
              d3_date = Date;
            }
          }
          format.parse = function (string) {
            try {
              d3_date = d3_date_utc;
              var date = local.parse(string);
              return date && date._;
            } finally {
              d3_date = Date;
            }
          };
          format.toString = local.toString;
          return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(),
            d3_time_dayRe = d3_time_formatRe(locale_days),
            d3_time_dayLookup = d3_time_formatLookup(locale_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),
            d3_time_monthRe = d3_time_formatRe(locale_months),
            d3_time_monthLookup = d3_time_formatLookup(locale_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
          d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
          a: function (d) {
            return locale_shortDays[d.getDay()];
          },
          A: function (d) {
            return locale_days[d.getDay()];
          },
          b: function (d) {
            return locale_shortMonths[d.getMonth()];
          },
          B: function (d) {
            return locale_months[d.getMonth()];
          },
          c: d3_time_format(locale_dateTime),
          d: function (d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          e: function (d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          H: function (d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
          },
          I: function (d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
          },
          j: function (d, p) {
            return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
          },
          L: function (d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
          },
          m: function (d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
          },
          M: function (d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
          },
          p: function (d) {
            return locale_periods[+(d.getHours() >= 12)];
          },
          S: function (d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
          },
          U: function (d, p) {
            return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
          },
          w: function (d) {
            return d.getDay();
          },
          W: function (d, p) {
            return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
          },
          x: d3_time_format(locale_date),
          X: d3_time_format(locale_time),
          y: function (d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
          },
          Y: function (d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
          },
          Z: d3_time_zone,
          "%": function () {
            return "%";
          }
        };
        var d3_time_parsers = {
          a: d3_time_parseWeekdayAbbrev,
          A: d3_time_parseWeekday,
          b: d3_time_parseMonthAbbrev,
          B: d3_time_parseMonth,
          c: d3_time_parseLocaleFull,
          d: d3_time_parseDay,
          e: d3_time_parseDay,
          H: d3_time_parseHour24,
          I: d3_time_parseHour24,
          j: d3_time_parseDayOfYear,
          L: d3_time_parseMilliseconds,
          m: d3_time_parseMonthNumber,
          M: d3_time_parseMinutes,
          p: d3_time_parseAmPm,
          S: d3_time_parseSeconds,
          U: d3_time_parseWeekNumberSunday,
          w: d3_time_parseWeekdayNumber,
          W: d3_time_parseWeekNumberMonday,
          x: d3_time_parseLocaleDate,
          X: d3_time_parseLocaleTime,
          y: d3_time_parseYear,
          Y: d3_time_parseFullYear,
          Z: d3_time_parseZone,
          "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
          d3_time_dayAbbrevRe.lastIndex = 0;
          var n = d3_time_dayAbbrevRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
          d3_time_dayRe.lastIndex = 0;
          var n = d3_time_dayRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
          d3_time_monthAbbrevRe.lastIndex = 0;
          var n = d3_time_monthAbbrevRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
          d3_time_monthRe.lastIndex = 0;
          var n = d3_time_monthRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
          return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
          return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
          return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
          var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
          return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
      }
      var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
      },
          d3_time_numberRe = /^\s*\d+/,
          d3_time_percentRe = /^%/;
      function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
      }
      function d3_time_formatLookup(names) {
        var map = new d3_Map(),
            i = -1,
            n = names.length;
        while (++i < n) map.set(names[i].toLowerCase(), i);
        return map;
      }
      function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
      }
      function d3_time_parseZone(date, string, i) {
        return (/^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1
        );
      }
      function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
      }
      function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
      }
      function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
      }
      function d3_time_zone(d) {
        var z = d.getTimezoneOffset(),
            zs = z > 0 ? "-" : "+",
            zh = abs(z) / 60 | 0,
            zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
      }
      function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function d3_time_formatMulti(formats) {
        var n = formats.length,
            i = -1;
        while (++i < n) formats[i][0] = this(formats[i][0]);
        return function (date) {
          var i = 0,
              f = formats[i];
          while (!f[1](date)) f = formats[++i];
          return f[0](date);
        };
      }
      d3.locale = function (locale) {
        return {
          numberFormat: d3_locale_numberFormat(locale),
          timeFormat: d3_locale_timeFormat(locale)
        };
      };
      var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      d3.format = d3_locale_enUS.numberFormat;
      d3.geo = {};
      function d3_adder() {}
      d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function (y) {
          d3_adderSum(y, this.t, d3_adderTemp);
          d3_adderSum(d3_adderTemp.s, this.s, this);
          if (this.s) this.t += d3_adderTemp.t;else this.s = d3_adderTemp.t;
        },
        reset: function () {
          this.s = this.t = 0;
        },
        valueOf: function () {
          return this.s;
        }
      };
      var d3_adderTemp = new d3_adder();
      function d3_adderSum(a, b, o) {
        var x = o.s = a + b,
            bv = x - a,
            av = x - bv;
        o.t = a - av + (b - bv);
      }
      d3.geo.stream = function (object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
          d3_geo_streamObjectType[object.type](object, listener);
        } else {
          d3_geo_streamGeometry(object, listener);
        }
      };
      function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
          d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
      }
      var d3_geo_streamObjectType = {
        Feature: function (feature, listener) {
          d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function (object, listener) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
        }
      };
      var d3_geo_streamGeometryType = {
        Sphere: function (object, listener) {
          listener.sphere();
        },
        Point: function (object, listener) {
          object = object.coordinates;
          listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function (object, listener) {
          d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function (object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function (object, listener) {
          d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function (object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function (object, listener) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
        }
      };
      function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        listener.lineStart();
        while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
      }
      function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1,
            n = coordinates.length;
        listener.polygonStart();
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
      }
      d3.geo.area = function (object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
      };
      var d3_geo_areaSum,
          d3_geo_areaRingSum = new d3_adder();
      var d3_geo_area = {
        sphere: function () {
          d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
          d3_geo_areaRingSum.reset();
          d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function () {
          var area = 2 * d3_geo_areaRingSum;
          d3_geo_areaSum += area < 0 ? 4 * π + area : area;
          d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
      };
      function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function (λ, φ) {
          d3_geo_area.point = nextPoint;
          λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          φ = φ * d3_radians / 2 + π / 4;
          var dλ = λ - λ0,
              sdλ = dλ >= 0 ? 1 : -1,
              adλ = sdλ * dλ,
              cosφ = Math.cos(φ),
              sinφ = Math.sin(φ),
              k = sinφ0 * sinφ,
              u = cosφ0 * cosφ + k * Math.cos(adλ),
              v = k * sdλ * Math.sin(adλ);
          d3_geo_areaRingSum.add(Math.atan2(v, u));
          λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function () {
          nextPoint(λ00, φ00);
        };
      }
      function d3_geo_cartesian(spherical) {
        var λ = spherical[0],
            φ = spherical[1],
            cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
      }
      function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
      }
      function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
      }
      function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
      }
      function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
      }
      d3.geo.bounds = function () {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function () {
            bound.point = ringPoint;
            bound.lineStart = ringStart;
            bound.lineEnd = ringEnd;
            dλSum = 0;
            d3_geo_area.polygonStart();
          },
          polygonEnd: function () {
            d3_geo_area.polygonEnd();
            bound.point = point;
            bound.lineStart = lineStart;
            bound.lineEnd = lineEnd;
            if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);else if (dλSum > ε) φ1 = 90;else if (dλSum < -ε) φ0 = -90;
            range[0] = λ0, range[1] = λ1;
          }
        };
        function point(λ, φ) {
          ranges.push(range = [λ0 = λ, λ1 = λ]);
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        function linePoint(λ, φ) {
          var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
          if (p0) {
            var normal = d3_geo_cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = d3_geo_cartesianCross(equatorial, normal);
            d3_geo_cartesianNormalize(inflection);
            inflection = d3_geo_spherical(inflection);
            var dλ = λ - λ_,
                s = dλ > 0 ? 1 : -1,
                λi = inflection[0] * d3_degrees * s,
                antimeridian = abs(dλ) > 180;
            if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = inflection[1] * d3_degrees;
              if (φi > φ1) φ1 = φi;
            } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = -inflection[1] * d3_degrees;
              if (φi < φ0) φ0 = φi;
            } else {
              if (φ < φ0) φ0 = φ;
              if (φ > φ1) φ1 = φ;
            }
            if (antimeridian) {
              if (λ < λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
              }
            } else {
              if (λ1 >= λ0) {
                if (λ < λ0) λ0 = λ;
                if (λ > λ1) λ1 = λ;
              } else {
                if (λ > λ_) {
                  if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                } else {
                  if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                }
              }
            }
          } else {
            point(λ, φ);
          }
          p0 = p, λ_ = λ;
        }
        function lineStart() {
          bound.point = linePoint;
        }
        function lineEnd() {
          range[0] = λ0, range[1] = λ1;
          bound.point = point;
          p0 = null;
        }
        function ringPoint(λ, φ) {
          if (p0) {
            var dλ = λ - λ_;
            dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
          } else λ__ = λ, φ__ = φ;
          d3_geo_area.point(λ, φ);
          linePoint(λ, φ);
        }
        function ringStart() {
          d3_geo_area.lineStart();
        }
        function ringEnd() {
          ringPoint(λ__, φ__);
          d3_geo_area.lineEnd();
          if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
          range[0] = λ0, range[1] = λ1;
          p0 = null;
        }
        function angle(λ0, λ1) {
          return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
          return a[0] - b[0];
        }
        function withinRange(x, range) {
          return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function (feature) {
          φ1 = λ1 = -(λ0 = φ0 = Infinity);
          ranges = [];
          d3.geo.stream(feature, bound);
          var n = ranges.length;
          if (n) {
            ranges.sort(compareRanges);
            for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (withinRange(b[0], a) || withinRange(b[1], a)) {
                if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            var best = -Infinity,
                dλ;
            for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
              b = merged[i];
              if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
            }
          }
          ranges = range = null;
          return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        };
      }();
      d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2,
            y = d3_geo_centroidY2,
            z = d3_geo_centroidZ2,
            m = x * x + y * y + z * z;
        if (m < ε2) {
          x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
          if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
          m = x * x + y * y + z * z;
          if (m < ε2) return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
      };
      var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
      var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function () {
          d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function () {
          d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
      };
      function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
      }
      function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
      }
      function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function (λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroid.point = nextPoint;
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
      }
      function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function (λ, φ) {
          λ00 = λ, φ00 = φ;
          d3_geo_centroid.point = nextPoint;
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function () {
          nextPoint(λ00, φ00);
          d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
          d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              cx = y0 * z - z0 * y,
              cy = z0 * x - x0 * z,
              cz = x0 * y - y0 * x,
              m = Math.sqrt(cx * cx + cy * cy + cz * cz),
              u = x0 * x + y0 * y + z0 * z,
              v = m && -d3_acos(u) / m,
              w = Math.atan2(m, u);
          d3_geo_centroidX2 += v * cx;
          d3_geo_centroidY2 += v * cy;
          d3_geo_centroidZ2 += v * cz;
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_compose(a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function (x, y) {
          return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
      }
      function d3_true() {
        return true;
      }
      function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [],
            clip = [];
        segments.forEach(function (segment) {
          if ((n = segment.length - 1) <= 0) return;
          var n,
              p0 = segment[0],
              p1 = segment[n];
          if (d3_geo_sphericalEqual(p0, p1)) {
            listener.lineStart();
            for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
            listener.lineEnd();
            return;
          }
          var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),
              b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
          a.o = b;
          subject.push(a);
          clip.push(b);
          a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
          b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
          a.o = b;
          subject.push(a);
          clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
          clip[i].e = entry = !entry;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v) if ((current = current.n) === start) return;
          points = current.z;
          listener.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, listener);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, listener);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          listener.lineEnd();
        }
      }
      function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
          var line = clipLine(listener),
              rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function () {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = d3.merge(segments);
              var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
              if (segments.length) {
                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
              } else if (clipStartInside) {
                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function () {
              listener.polygonStart();
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
              listener.polygonEnd();
            }
          };
          function point(λ, φ) {
            var point = rotate(λ, φ);
            if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
          }
          function pointLine(λ, φ) {
            var point = rotate(λ, φ);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          var segments;
          var buffer = d3_geo_clipBufferListener(),
              ringListener = clipLine(buffer),
              polygonStarted = false,
              polygon,
              ring;
          function pointRing(λ, φ) {
            ring.push([λ, φ]);
            var point = rotate(λ, φ);
            ringListener.point(point[0], point[1]);
          }
          function ringStart() {
            ringListener.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringListener.lineEnd();
            var clean = ringListener.clean(),
                ringSegments = buffer.buffer(),
                segment,
                n = ringSegments.length;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n) return;
            if (clean & 1) {
              segment = ringSegments[0];
              var n = segment.length - 1,
                  i = -1,
                  point;
              if (n > 0) {
                if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                while (++i < n) listener.point((point = segment[i])[0], point[1]);
                listener.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
          }
          return clip;
        };
      }
      function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
      }
      function d3_geo_clipBufferListener() {
        var lines = [],
            line;
        return {
          lineStart: function () {
            lines.push(line = []);
          },
          point: function (λ, φ) {
            line.push([λ, φ]);
          },
          lineEnd: d3_noop,
          buffer: function () {
            var buffer = lines;
            lines = [];
            line = null;
            return buffer;
          },
          rejoin: function () {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
          }
        };
      }
      function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
      }
      var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
      function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN,
            φ0 = NaN,
            sλ0 = NaN,
            clean;
        return {
          lineStart: function () {
            listener.lineStart();
            clean = 1;
          },
          point: function (λ1, φ1) {
            var sλ1 = λ1 > 0 ? π : -π,
                dλ = abs(λ1 - λ0);
            if (abs(dλ - π) < ε) {
              listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              listener.point(λ1, φ0);
              clean = 0;
            } else if (sλ0 !== sλ1 && dλ >= π) {
              if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
              if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
              φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              clean = 0;
            }
            listener.point(λ0 = λ1, φ0 = φ1);
            sλ0 = sλ1;
          },
          lineEnd: function () {
            listener.lineEnd();
            λ0 = φ0 = NaN;
          },
          clean: function () {
            return 2 - clean;
          }
        };
      }
      function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0,
            cosφ1,
            sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
      }
      function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
          φ = direction * halfπ;
          listener.point(-π, φ);
          listener.point(0, φ);
          listener.point(π, φ);
          listener.point(π, 0);
          listener.point(π, -φ);
          listener.point(0, -φ);
          listener.point(-π, -φ);
          listener.point(-π, 0);
          listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
          var s = from[0] < to[0] ? π : -π;
          φ = direction * s / 2;
          listener.point(-s, φ);
          listener.point(0, φ);
          listener.point(s, φ);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0],
            parallel = point[1],
            meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
            polarAngle = 0,
            winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
          var ring = polygon[i],
              m = ring.length;
          if (!m) continue;
          var point0 = ring[0],
              λ0 = point0[0],
              φ0 = point0[1] / 2 + π / 4,
              sinφ0 = Math.sin(φ0),
              cosφ0 = Math.cos(φ0),
              j = 1;
          while (true) {
            if (j === m) j = 0;
            point = ring[j];
            var λ = point[0],
                φ = point[1] / 2 + π / 4,
                sinφ = Math.sin(φ),
                cosφ = Math.cos(φ),
                dλ = λ - λ0,
                sdλ = dλ >= 0 ? 1 : -1,
                adλ = sdλ * dλ,
                antimeridian = adλ > π,
                k = sinφ0 * sinφ;
            d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
            polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
            if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
              var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
              d3_geo_cartesianNormalize(arc);
              var intersection = d3_geo_cartesianCross(meridianNormal, arc);
              d3_geo_cartesianNormalize(intersection);
              var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
              if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
              }
            }
            if (!j++) break;
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
          }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
      }
      function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > ε,
            interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
          return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
          var point0, c0, v0, v00, clean;
          return {
            lineStart: function () {
              v00 = v0 = false;
              clean = 1;
            },
            point: function (λ, φ) {
              var point1 = [λ, φ],
                  point2,
                  v = visible(λ, φ),
                  c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
              if (!point0 && (v00 = v0 = v)) listener.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                  point1[0] += ε;
                  point1[1] += ε;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  listener.lineStart();
                  point2 = intersect(point1, point0);
                  listener.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  listener.point(point2[0], point2[1]);
                  listener.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                  } else {
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                listener.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function () {
              if (v0) listener.lineEnd();
              point0 = null;
            },
            clean: function () {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = d3_geo_cartesian(a),
              pb = d3_geo_cartesian(b);
          var n1 = [1, 0, 0],
              n2 = d3_geo_cartesianCross(pa, pb),
              n2n2 = d3_geo_cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant) return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = d3_geo_cartesianCross(n1, n2),
              A = d3_geo_cartesianScale(n1, c1),
              B = d3_geo_cartesianScale(n2, c2);
          d3_geo_cartesianAdd(A, B);
          var u = n1xn2,
              w = d3_geo_cartesianDot(A, u),
              uu = d3_geo_cartesianDot(u, u),
              t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
          if (t2 < 0) return;
          var t = Math.sqrt(t2),
              q = d3_geo_cartesianScale(u, (-w - t) / uu);
          d3_geo_cartesianAdd(q, A);
          q = d3_geo_spherical(q);
          if (!two) return q;
          var λ0 = a[0],
              λ1 = b[0],
              φ0 = a[1],
              φ1 = b[1],
              z;
          if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
          var δλ = λ1 - λ0,
              polar = abs(δλ - π) < ε,
              meridian = polar || δλ < ε;
          if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
          if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
            var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
            d3_geo_cartesianAdd(q1, A);
            return [q, d3_geo_spherical(q1)];
          }
        }
        function code(λ, φ) {
          var r = smallRadius ? radius : π - radius,
              code = 0;
          if (λ < -r) code |= 1;else if (λ > r) code |= 2;
          if (φ < -r) code |= 4;else if (φ > r) code |= 8;
          return code;
        }
      }
      function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
          var a = line.a,
              b = line.b,
              ax = a.x,
              ay = a.y,
              bx = b.x,
              by = b.y,
              t0 = 0,
              t1 = 1,
              dx = bx - ax,
              dy = by - ay,
              r;
          r = x0 - ax;
          if (!dx && r > 0) return;
          r /= dx;
          if (dx < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          } else if (dx > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0) return;
          r /= dx;
          if (dx < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          } else if (dx > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0) return;
          r /= dy;
          if (dy < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          } else if (dy > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0) return;
          r /= dy;
          if (dy < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          } else if (dy > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          }
          if (t0 > 0) line.a = {
            x: ax + t0 * dx,
            y: ay + t0 * dy
          };
          if (t1 < 1) line.b = {
            x: ax + t1 * dx,
            y: ay + t1 * dy
          };
          return line;
        };
      }
      var d3_geo_clipExtentMAX = 1e9;
      d3.geo.clipExtent = function () {
        var x0,
            y0,
            x1,
            y1,
            stream,
            clip,
            clipExtent = {
          stream: function (output) {
            if (stream) stream.valid = false;
            stream = clip(output);
            stream.valid = true;
            return stream;
          },
          extent: function (_) {
            if (!arguments.length) return [[x0, y0], [x1, y1]];
            clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
            if (stream) stream.valid = false, stream = null;
            return clipExtent;
          }
        };
        return clipExtent.extent([[0, 0], [960, 500]]);
      };
      function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function (listener) {
          var listener_ = listener,
              bufferListener = d3_geo_clipBufferListener(),
              clipLine = d3_geom_clipLine(x0, y0, x1, y1),
              segments,
              polygon,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              listener = bufferListener;
              segments = [];
              polygon = [];
              clean = true;
            },
            polygonEnd: function () {
              listener = listener_;
              segments = d3.merge(segments);
              var clipStartInside = insidePolygon([x0, y1]),
                  inside = clean && clipStartInside,
                  visible = segments.length;
              if (inside || visible) {
                listener.polygonStart();
                if (inside) {
                  listener.lineStart();
                  interpolate(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (visible) {
                  d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                }
                listener.polygonEnd();
              }
              segments = polygon = ring = null;
            }
          };
          function insidePolygon(p) {
            var wn = 0,
                n = polygon.length,
                y = p[1];
            for (var i = 0; i < n; ++i) {
              for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                b = v[j];
                if (a[1] <= y) {
                  if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                } else {
                  if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                }
                a = b;
              }
            }
            return wn !== 0;
          }
          function interpolate(from, to, direction, listener) {
            var a = 0,
                a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
              do {
                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
              } while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              listener.point(to[0], to[1]);
            }
          }
          function pointVisible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
          }
          function point(x, y) {
            if (pointVisible(x, y)) listener.point(x, y);
          }
          var x__, y__, v__, x_, y_, v_, first, clean;
          function lineStart() {
            clip.point = linePoint;
            if (polygon) polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_) bufferListener.rejoin();
              segments.push(bufferListener.buffer());
            }
            clip.point = point;
            if (v_) listener.lineEnd();
          }
          function linePoint(x, y) {
            x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
            y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
            var v = pointVisible(x, y);
            if (polygon) ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                listener.lineStart();
                listener.point(x, y);
              }
            } else {
              if (v && v_) listener.point(x, y);else {
                var l = {
                  a: {
                    x: x_,
                    y: y_
                  },
                  b: {
                    x: x,
                    y: y
                  }
                };
                if (clipLine(l)) {
                  if (!v_) {
                    listener.lineStart();
                    listener.point(l.a.x, l.a.y);
                  }
                  listener.point(l.b.x, l.b.y);
                  if (!v) listener.lineEnd();
                  clean = false;
                } else if (v) {
                  listener.lineStart();
                  listener.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clip;
        };
        function corner(p, direction) {
          return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
          return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
      }
      function d3_geo_conic(projectAt) {
        var φ0 = 0,
            φ1 = π / 3,
            m = d3_geo_projectionMutator(projectAt),
            p = m(φ0, φ1);
        p.parallels = function (_) {
          if (!arguments.length) return [φ0 / π * 180, φ1 / π * 180];
          return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
      }
      function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0),
            n = (sinφ0 + Math.sin(φ1)) / 2,
            C = 1 + sinφ0 * (2 * n - sinφ0),
            ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
          var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
          return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function (x, y) {
          var ρ0_y = ρ0 - y;
          return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        };
        return forward;
      }
      (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea);
      }).raw = d3_geo_conicEqualArea;
      d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
      };
      d3.geo.albersUsa = function () {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point,
            pointStream = {
          point: function (x, y) {
            point = [x, y];
          }
        },
            lower48Point,
            alaskaPoint,
            hawaiiPoint;
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          point = null;
          (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
          return point;
        }
        albersUsa.invert = function (coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
          var lower48Stream = lower48.stream(stream),
              alaskaStream = alaska.stream(stream),
              hawaiiStream = hawaii.stream(stream);
          return {
            point: function (x, y) {
              lower48Stream.point(x, y);
              alaskaStream.point(x, y);
              hawaiiStream.point(x, y);
            },
            sphere: function () {
              lower48Stream.sphere();
              alaskaStream.sphere();
              hawaiiStream.sphere();
            },
            lineStart: function () {
              lower48Stream.lineStart();
              alaskaStream.lineStart();
              hawaiiStream.lineStart();
            },
            lineEnd: function () {
              lower48Stream.lineEnd();
              alaskaStream.lineEnd();
              hawaiiStream.lineEnd();
            },
            polygonStart: function () {
              lower48Stream.polygonStart();
              alaskaStream.polygonStart();
              hawaiiStream.polygonStart();
            },
            polygonEnd: function () {
              lower48Stream.polygonEnd();
              alaskaStream.polygonEnd();
              hawaiiStream.polygonEnd();
            }
          };
        };
        albersUsa.precision = function (_) {
          if (!arguments.length) return lower48.precision();
          lower48.precision(_);
          alaska.precision(_);
          hawaii.precision(_);
          return albersUsa;
        };
        albersUsa.scale = function (_) {
          if (!arguments.length) return lower48.scale();
          lower48.scale(_);
          alaska.scale(_ * .35);
          hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
          if (!arguments.length) return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
          alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          return albersUsa;
        };
        return albersUsa.scale(1070);
      };
      var d3_geo_pathAreaSum,
          d3_geo_pathAreaPolygon,
          d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
          d3_geo_pathAreaPolygon = 0;
          d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function () {
          d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
          d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
      };
      function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
          d3_geo_pathArea.point = nextPoint;
          x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
          d3_geo_pathAreaPolygon += y0 * x - x0 * y;
          x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function () {
          nextPoint(x00, y00);
        };
      }
      var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
      var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
      }
      function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5),
            buffer = [];
        var stream = {
          point: point,
          lineStart: function () {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function () {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function () {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function (_) {
            pointCircle = d3_geo_pathBufferCircle(_);
            return stream;
          },
          result: function () {
            if (buffer.length) {
              var result = buffer.join("");
              buffer = [];
              return result;
            }
          }
        };
        function point(x, y) {
          buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
          buffer.push("M", x, ",", y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          buffer.push("L", x, ",", y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          buffer.push("Z");
        }
        return stream;
      }
      function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function () {
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function () {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
          d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
      };
      function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
      }
      function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
      }
      function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      }
      function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          z = y0 * x - x0 * y;
          d3_geo_centroidX2 += z * (x0 + x);
          d3_geo_centroidY2 += z * (y0 + y);
          d3_geo_centroidZ2 += z * 3;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function () {
          nextPoint(x00, y00);
        };
      }
      function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
          point: point,
          lineStart: function () {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function () {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function () {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function (_) {
            pointRadius = _;
            return stream;
          },
          result: d3_noop
        };
        function point(x, y) {
          context.moveTo(x + pointRadius, y);
          context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
          context.moveTo(x, y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          context.lineTo(x, y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          context.closePath();
        }
        return stream;
      }
      function d3_geo_resample(project) {
        var δ2 = .5,
            cosMinDistance = Math.cos(30 * d3_radians),
            maxDepth = 16;
        function resample(stream) {
          return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
          return d3_geo_transformPoint(stream, function (x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          });
        }
        function resampleRecursive(stream) {
          var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
          var resample = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
              stream.polygonStart();
              resample.lineStart = ringStart;
            },
            polygonEnd: function () {
              stream.polygonEnd();
              resample.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resample.point = linePoint;
            stream.lineStart();
          }
          function linePoint(λ, φ) {
            var c = d3_geo_cartesian([λ, φ]),
                p = project(λ, φ);
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resample.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resample.point = ringPoint;
            resample.lineEnd = ringEnd;
          }
          function ringPoint(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resample.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
            resample.lineEnd = lineEnd;
            lineEnd();
          }
          return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * δ2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = Math.sqrt(a * a + b * b + c * c),
                φ2 = Math.asin(c /= m),
                λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                p = project(λ2, φ2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
            }
          }
        }
        resample.precision = function (_) {
          if (!arguments.length) return Math.sqrt(δ2);
          maxDepth = (δ2 = _ * _) > 0 && 16;
          return resample;
        };
        return resample;
      }
      d3.geo.path = function () {
        var pointRadius = 4.5,
            projection,
            context,
            projectStream,
            contextStream,
            cacheStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
            if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
            d3.geo.stream(object, cacheStream);
          }
          return contextStream.result();
        }
        path.area = function (object) {
          d3_geo_pathAreaSum = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathArea));
          return d3_geo_pathAreaSum;
        };
        path.centroid = function (object) {
          d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
          return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function (object) {
          d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
          d3.geo.stream(object, projectStream(d3_geo_pathBounds));
          return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function (_) {
          if (!arguments.length) return projection;
          projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
          return reset();
        };
        path.context = function (_) {
          if (!arguments.length) return context;
          contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
          if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
          return reset();
        };
        path.pointRadius = function (_) {
          if (!arguments.length) return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        function reset() {
          cacheStream = null;
          return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
      };
      function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
          return project([x * d3_degrees, y * d3_degrees]);
        });
        return function (stream) {
          return d3_geo_projectionRadians(resample(stream));
        };
      }
      d3.geo.transform = function (methods) {
        return {
          stream: function (stream) {
            var transform = new d3_geo_transform(stream);
            for (var k in methods) transform[k] = methods[k];
            return transform;
          }
        };
      };
      function d3_geo_transform(stream) {
        this.stream = stream;
      }
      d3_geo_transform.prototype = {
        point: function (x, y) {
          this.stream.point(x, y);
        },
        sphere: function () {
          this.stream.sphere();
        },
        lineStart: function () {
          this.stream.lineStart();
        },
        lineEnd: function () {
          this.stream.lineEnd();
        },
        polygonStart: function () {
          this.stream.polygonStart();
        },
        polygonEnd: function () {
          this.stream.polygonEnd();
        }
      };
      function d3_geo_transformPoint(stream, point) {
        return {
          point: point,
          sphere: function () {
            stream.sphere();
          },
          lineStart: function () {
            stream.lineStart();
          },
          lineEnd: function () {
            stream.lineEnd();
          },
          polygonStart: function () {
            stream.polygonStart();
          },
          polygonEnd: function () {
            stream.polygonEnd();
          }
        };
      }
      d3.geo.projection = d3_geo_projection;
      d3.geo.projectionMutator = d3_geo_projectionMutator;
      function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
          return project;
        })();
      }
      function d3_geo_projectionMutator(projectAt) {
        var project,
            rotate,
            projectRotate,
            projectResample = d3_geo_resample(function (x, y) {
          x = project(x, y);
          return [x[0] * k + δx, δy - x[1] * k];
        }),
            k = 150,
            x = 480,
            y = 250,
            λ = 0,
            φ = 0,
            δλ = 0,
            δφ = 0,
            δγ = 0,
            δx,
            δy,
            preclip = d3_geo_clipAntimeridian,
            postclip = d3_identity,
            clipAngle = null,
            clipExtent = null,
            stream;
        function projection(point) {
          point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
          return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
          return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function (output) {
          if (stream) stream.valid = false;
          stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
          stream.valid = true;
          return stream;
        };
        projection.clipAngle = function (_) {
          if (!arguments.length) return clipAngle;
          preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
          return invalidate();
        };
        projection.clipExtent = function (_) {
          if (!arguments.length) return clipExtent;
          clipExtent = _;
          postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
          return invalidate();
        };
        projection.scale = function (_) {
          if (!arguments.length) return k;
          k = +_;
          return reset();
        };
        projection.translate = function (_) {
          if (!arguments.length) return [x, y];
          x = +_[0];
          y = +_[1];
          return reset();
        };
        projection.center = function (_) {
          if (!arguments.length) return [λ * d3_degrees, φ * d3_degrees];
          λ = _[0] % 360 * d3_radians;
          φ = _[1] % 360 * d3_radians;
          return reset();
        };
        projection.rotate = function (_) {
          if (!arguments.length) return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
          δλ = _[0] % 360 * d3_radians;
          δφ = _[1] % 360 * d3_radians;
          δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
          return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
          projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
          var center = project(λ, φ);
          δx = x - center[0] * k;
          δy = y + center[1] * k;
          return invalidate();
        }
        function invalidate() {
          if (stream) stream.valid = false, stream = null;
          return projection;
        }
        return function () {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return reset();
        };
      }
      function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
          stream.point(x * d3_radians, y * d3_radians);
        });
      }
      function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
      }
      (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular);
      }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
      d3.geo.rotation = function (rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function (coordinates) {
          coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
      };
      function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
      }
      d3_geo_identityRotation.invert = d3_geo_equirectangular;
      function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
      }
      function d3_geo_forwardRotationλ(δλ) {
        return function (λ, φ) {
          return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        };
      }
      function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
      }
      function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ),
            sinδφ = Math.sin(δφ),
            cosδγ = Math.cos(δγ),
            sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδφ + x * sinδφ;
          return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function (λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδγ - y * sinδγ;
          return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        };
        return rotation;
      }
      d3.geo.circle = function () {
        var origin = [0, 0],
            angle,
            precision = 6,
            interpolate;
        function circle() {
          var center = typeof origin === "function" ? origin.apply(this, arguments) : origin,
              rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
              ring = [];
          interpolate(null, null, 1, {
            point: function (x, y) {
              ring.push(x = rotate(x, y));
              x[0] *= d3_degrees, x[1] *= d3_degrees;
            }
          });
          return {
            type: "Polygon",
            coordinates: [ring]
          };
        }
        circle.origin = function (x) {
          if (!arguments.length) return origin;
          origin = x;
          return circle;
        };
        circle.angle = function (x) {
          if (!arguments.length) return angle;
          interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
          return circle;
        };
        circle.precision = function (_) {
          if (!arguments.length) return precision;
          interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
          return circle;
        };
        return circle.angle(90);
      };
      function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius),
            sr = Math.sin(radius);
        return function (from, to, direction, listener) {
          var step = direction * precision;
          if (from != null) {
            from = d3_geo_circleAngle(cr, from);
            to = d3_geo_circleAngle(cr, to);
            if (direction > 0 ? from < to : from > to) from += direction * τ;
          } else {
            from = radius + direction * τ;
            to = radius - .5 * step;
          }
          for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
            listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
          }
        };
      }
      function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
      }
      d3.geo.distance = function (a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians,
            φ0 = a[1] * d3_radians,
            φ1 = b[1] * d3_radians,
            sinΔλ = Math.sin(Δλ),
            cosΔλ = Math.cos(Δλ),
            sinφ0 = Math.sin(φ0),
            cosφ0 = Math.cos(φ0),
            sinφ1 = Math.sin(φ1),
            cosφ1 = Math.cos(φ1),
            t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
      };
      d3.geo.graticule = function () {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
            return abs(x % DX) > ε;
          }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
            return abs(y % DY) > ε;
          }).map(y));
        }
        graticule.lines = function () {
          return lines().map(function (coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function () {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function (_) {
          if (!arguments.length) return graticule.minorExtent();
          return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function (_) {
          if (!arguments.length) return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1) _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.minorExtent = function (_) {
          if (!arguments.length) return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1) _ = x0, x0 = x1, x1 = _;
          if (y0 > y1) _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function (_) {
          if (!arguments.length) return graticule.minorStep();
          return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function (_) {
          if (!arguments.length) return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.minorStep = function (_) {
          if (!arguments.length) return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function (_) {
          if (!arguments.length) return precision;
          precision = +_;
          x = d3_geo_graticuleX(y0, y1, 90);
          y = d3_geo_graticuleY(x0, x1, precision);
          X = d3_geo_graticuleX(Y0, Y1, 90);
          Y = d3_geo_graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
      };
      function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function (x) {
          return y.map(function (y) {
            return [x, y];
          });
        };
      }
      function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function (y) {
          return x.map(function (x) {
            return [x, y];
          });
        };
      }
      function d3_source(d) {
        return d.source;
      }
      function d3_target(d) {
        return d.target;
      }
      d3.geo.greatArc = function () {
        var source = d3_source,
            source_,
            target = d3_target,
            target_;
        function greatArc() {
          return {
            type: "LineString",
            coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
          };
        }
        greatArc.distance = function () {
          return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function (_) {
          if (!arguments.length) return source;
          source = _, source_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.target = function (_) {
          if (!arguments.length) return target;
          target = _, target_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.precision = function () {
          return arguments.length ? greatArc : 0;
        };
        return greatArc;
      };
      d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
      };
      function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0),
            sy0 = Math.sin(y0),
            cy1 = Math.cos(y1),
            sy1 = Math.sin(y1),
            kx0 = cy0 * Math.cos(x0),
            ky0 = cy0 * Math.sin(x0),
            kx1 = cy1 * Math.cos(x1),
            ky1 = cy1 * Math.sin(x1),
            d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
            k = 1 / Math.sin(d);
        var interpolate = d ? function (t) {
          var B = Math.sin(t *= d) * k,
              A = Math.sin(d - t) * k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function () {
          return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
      }
      d3.geo.length = function (object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
      };
      var d3_geo_lengthSum;
      var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function (λ, φ) {
          λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
          d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function () {
          d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
          var sinφ = Math.sin(φ *= d3_radians),
              cosφ = Math.cos(φ),
              t = abs((λ *= d3_radians) - λ0),
              cosΔλ = Math.cos(t);
          d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
      }
      function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
          var cosλ = Math.cos(λ),
              cosφ = Math.cos(φ),
              k = scale(cosλ * cosφ);
          return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function (x, y) {
          var ρ = Math.sqrt(x * x + y * y),
              c = angle(ρ),
              sinc = Math.sin(c),
              cosc = Math.cos(c);
          return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        };
        return azimuthal;
      }
      var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
      }, function (ρ) {
        return 2 * Math.asin(ρ / 2);
      });
      (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
      }).raw = d3_geo_azimuthalEqualArea;
      var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
      }, d3_identity);
      (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
      }).raw = d3_geo_azimuthalEquidistant;
      function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            t = function (φ) {
          return Math.tan(π / 4 + φ / 2);
        },
            n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
            F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(λ, φ) {
          if (F > 0) {
            if (φ < -halfπ + ε) φ = -halfπ + ε;
          } else {
            if (φ > halfπ - ε) φ = halfπ - ε;
          }
          var ρ = F / Math.pow(t(φ), n);
          return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function (x, y) {
          var ρ0_y = F - y,
              ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
          return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        };
        return forward;
      }
      (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal);
      }).raw = d3_geo_conicConformal;
      function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
            G = cosφ0 / n + φ0;
        if (abs(n) < ε) return d3_geo_equirectangular;
        function forward(λ, φ) {
          var ρ = G - φ;
          return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function (x, y) {
          var ρ0_y = G - y;
          return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        };
        return forward;
      }
      (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant);
      }).raw = d3_geo_conicEquidistant;
      var d3_geo_gnomonic = d3_geo_azimuthal(function (cosλcosφ) {
        return 1 / cosλcosφ;
      }, Math.atan);
      (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic);
      }).raw = d3_geo_gnomonic;
      function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
      }
      d3_geo_mercator.invert = function (x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      };
      function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function () {
          var v = scale.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function () {
          var v = translate.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function (_) {
          var v = clipExtent.apply(m, arguments);
          if (v === m) {
            if (clipAuto = _ == null) {
              var k = π * scale(),
                  t = translate();
              clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
            }
          } else if (clipAuto) {
            v = null;
          }
          return v;
        };
        return m.clipExtent(null);
      }
      (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator);
      }).raw = d3_geo_mercator;
      var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1;
      }, Math.asin);
      (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic);
      }).raw = d3_geo_orthographic;
      var d3_geo_stereographic = d3_geo_azimuthal(function (cosλcosφ) {
        return 1 / (1 + cosλcosφ);
      }, function (ρ) {
        return 2 * Math.atan(ρ);
      });
      (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic);
      }).raw = d3_geo_stereographic;
      function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
      }
      d3_geo_transverseMercator.invert = function (x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
      };
      (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),
            center = projection.center,
            rotate = projection.rotate;
        projection.center = function (_) {
          return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function (_) {
          return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
      }).raw = d3_geo_transverseMercator;
      d3.geom = {};
      function d3_geom_pointX(d) {
        return d[0];
      }
      function d3_geom_pointY(d) {
        return d[1];
      }
      d3.geom.hull = function (vertices) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
          if (data.length < 3) return [];
          var fx = d3_functor(x),
              fy = d3_functor(y),
              i,
              n = data.length,
              points = [],
              flippedPoints = [];
          for (i = 0; i < n; i++) {
            points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
          }
          points.sort(d3_geom_hullOrder);
          for (i = 0; i < n; i++) flippedPoints.push([points[i][0], -points[i][1]]);
          var upper = d3_geom_hullUpper(points),
              lower = d3_geom_hullUpper(flippedPoints);
          var skipLeft = lower[0] === upper[0],
              skipRight = lower[lower.length - 1] === upper[upper.length - 1],
              polygon = [];
          for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
          for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
          return polygon;
        }
        hull.x = function (_) {
          return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function (_) {
          return arguments.length ? (y = _, hull) : y;
        };
        return hull;
      };
      function d3_geom_hullUpper(points) {
        var n = points.length,
            hull = [0, 1],
            hs = 2;
        for (var i = 2; i < n; i++) {
          while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
          hull[hs++] = i;
        }
        return hull.slice(0, hs);
      }
      function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      d3.geom.polygon = function (coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
      };
      var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
      d3_geom_polygonPrototype.area = function () {
        var i = -1,
            n = this.length,
            a,
            b = this[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = this[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
      };
      d3_geom_polygonPrototype.centroid = function (k) {
        var i = -1,
            n = this.length,
            x = 0,
            y = 0,
            a,
            b = this[n - 1],
            c;
        if (!arguments.length) k = -1 / (6 * this.area());
        while (++i < n) {
          a = b;
          b = this[i];
          c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
      };
      d3_geom_polygonPrototype.clip = function (subject) {
        var input,
            closed = d3_geom_polygonClosed(subject),
            i = -1,
            n = this.length - d3_geom_polygonClosed(this),
            j,
            m,
            a = this[n - 1],
            b,
            c,
            d;
        while (++i < n) {
          input = subject.slice();
          subject.length = 0;
          b = this[i];
          c = input[(m = input.length - closed) - 1];
          j = -1;
          while (++j < m) {
            d = input[j];
            if (d3_geom_polygonInside(d, a, b)) {
              if (!d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              subject.push(d);
            } else if (d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            c = d;
          }
          if (closed) subject.push(subject[0]);
          a = b;
        }
        return subject;
      };
      function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
      }
      function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0],
            x3 = a[0],
            x21 = d[0] - x1,
            x43 = b[0] - x3,
            y1 = c[1],
            y3 = a[1],
            y21 = d[1] - y1,
            y43 = b[1] - y3,
            ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
      }
      function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0],
            b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
      }
      var d3_geom_voronoiEdges,
          d3_geom_voronoiCells,
          d3_geom_voronoiBeaches,
          d3_geom_voronoiBeachPool = [],
          d3_geom_voronoiFirstCircle,
          d3_geom_voronoiCircles,
          d3_geom_voronoiCirclePool = [];
      function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
      }
      function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
      }
      function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = {
          x: x,
          y: y
        },
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
          next = rArc.N;
          disappearing.push(rArc);
          d3_geom_voronoiDetachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiAddBeach(site) {
        var x = site.x,
            directrix = site.y,
            lArc,
            rArc,
            dxl,
            dxr,
            node = d3_geom_voronoiBeaches._;
        while (node) {
          dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
          if (dxl > ε) node = node.L;else {
            dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
            if (dxr > ε) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -ε) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -ε) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
          d3_geom_voronoiDetachCircle(lArc);
          rArc = d3_geom_voronoiCreateBeach(lArc.site);
          d3_geom_voronoiBeaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite.x,
            ay = lSite.y,
            bx = site.x - ax,
            by = site.y - ay,
            rSite = rArc.site,
            cx = rSite.x - ax,
            cy = rSite.y - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = {
          x: (cy * hb - by * hc) / d + ax,
          y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site.x,
            rfocy = site.y,
            pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site.x,
            lfocy = site.y,
            plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
      }
      function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
      }
      d3_geom_voronoiCell.prototype.prepare = function () {
        var halfEdges = this.edges,
            iHalfEdge = halfEdges.length,
            edge;
        while (iHalfEdge--) {
          edge = halfEdges[iHalfEdge].edge;
          if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
      };
      function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            x2,
            y2,
            x3,
            y3,
            cells = d3_geom_voronoiCells,
            iCell = cells.length,
            cell,
            iHalfEdge,
            halfEdges,
            nHalfEdges,
            start,
            end;
        while (iCell--) {
          cell = cells[iCell];
          if (!cell || !cell.prepare()) continue;
          halfEdges = cell.edges;
          nHalfEdges = halfEdges.length;
          iHalfEdge = 0;
          while (iHalfEdge < nHalfEdges) {
            end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
            start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
            if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
              halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                x: x0,
                y: abs(x2 - x0) < ε ? y2 : y1
              } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                x: abs(y2 - y1) < ε ? x2 : x1,
                y: y1
              } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                x: x1,
                y: abs(x2 - x1) < ε ? y2 : y0
              } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                x: abs(y2 - y0) < ε ? x2 : x0,
                y: y0
              } : null), cell.site, null));
              ++nHalfEdges;
            }
          }
        }
      }
      function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
      }
      function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite.x,
            by = cSite.y,
            ax = lSite.x - bx,
            ay = lSite.y - by,
            cx = rSite.x - bx,
            cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2) return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d,
            cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null,
            node = d3_geom_voronoiCircles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;else {
              before = node.P;
              break;
            }
          } else {
            if (node.R) node = node.R;else {
              before = node;
              break;
            }
          }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before) d3_geom_voronoiFirstCircle = circle;
      }
      function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
          d3_geom_voronoiCircles.remove(circle);
          d3_geom_voronoiCirclePool.push(circle);
          d3_geom_voronoiRedBlackNode(circle);
          arc.circle = null;
        }
      }
      function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges,
            clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),
            i = edges.length,
            e;
        while (i--) {
          e = edges[i];
          if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
            e.a = e.b = null;
            edges.splice(i, 1);
          }
        }
      }
      function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb) return true;
        var va = edge.a,
            x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            lSite = edge.l,
            rSite = edge.r,
            lx = lSite.x,
            ly = lSite.y,
            rx = rSite.x,
            ry = rSite.y,
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1) return;
          if (lx > rx) {
            if (!va) va = {
              x: fx,
              y: y0
            };else if (va.y >= y1) return;
            vb = {
              x: fx,
              y: y1
            };
          } else {
            if (!va) va = {
              x: fx,
              y: y1
            };else if (va.y < y0) return;
            vb = {
              x: fx,
              y: y0
            };
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!va) va = {
                x: (y0 - fb) / fm,
                y: y0
              };else if (va.y >= y1) return;
              vb = {
                x: (y1 - fb) / fm,
                y: y1
              };
            } else {
              if (!va) va = {
                x: (y1 - fb) / fm,
                y: y1
              };else if (va.y < y0) return;
              vb = {
                x: (y0 - fb) / fm,
                y: y0
              };
            }
          } else {
            if (ly < ry) {
              if (!va) va = {
                x: x0,
                y: fm * x0 + fb
              };else if (va.x >= x1) return;
              vb = {
                x: x1,
                y: fm * x1 + fb
              };
            } else {
              if (!va) va = {
                x: x1,
                y: fm * x1 + fb
              };else if (va.x < x0) return;
              vb = {
                x: x0,
                y: fm * x0 + fb
              };
            }
          }
        }
        edge.a = va;
        edge.b = vb;
        return true;
      }
      function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
      }
      function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
      }
      function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
      }
      function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
          edge.a = vertex;
          edge.l = lSite;
          edge.r = rSite;
        } else if (edge.l === rSite) {
          edge.b = vertex;
        } else {
          edge.a = vertex;
        }
      }
      function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a,
            vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
      }
      d3_geom_voronoiHalfEdge.prototype = {
        start: function () {
          return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function () {
          return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
      };
      function d3_geom_voronoiRedBlackTree() {
        this._ = null;
      }
      function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      d3_geom_voronoiRedBlackTree.prototype = {
        insert: function (after, node) {
          var parent, grandpa, uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N) after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L) after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = d3_geom_voronoiRedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function (node) {
          if (node.N) node.N.P = node.P;
          if (node.P) node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left) next = right;else if (!right) next = left;else next = d3_geom_voronoiRedBlackFirst(right);
          if (parent) {
            if (parent.L === node) parent.L = next;else parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node) node.U = parent;
          if (red) return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._) break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node) node.C = false;
        }
      };
      function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
      }
      function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p) parent.L = q;else parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
      }
      function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
      }
      function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),
            x0,
            y0,
            circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
          circle = d3_geom_voronoiFirstCircle;
          if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
            if (site.x !== x0 || site.y !== y0) {
              d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
              d3_geom_voronoiAddBeach(site);
              x0 = site.x, y0 = site.y;
            }
            site = sites.pop();
          } else if (circle) {
            d3_geom_voronoiRemoveBeach(circle.arc);
          } else {
            break;
          }
        }
        if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
          cells: d3_geom_voronoiCells,
          edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
      }
      function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
      }
      d3.geom.voronoi = function (points) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            fx = x,
            fy = y,
            clipExtent = d3_geom_voronoiClipExtent;
        if (points) return voronoi(points);
        function voronoi(data) {
          var polygons = new Array(data.length),
              x0 = clipExtent[0][0],
              y0 = clipExtent[0][1],
              x1 = clipExtent[1][0],
              y1 = clipExtent[1][1];
          d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
            var edges = cell.edges,
                site = cell.site,
                polygon = polygons[i] = edges.length ? edges.map(function (e) {
              var s = e.start();
              return [s.x, s.y];
            }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
            polygon.point = data[i];
          });
          return polygons;
        }
        function sites(data) {
          return data.map(function (d, i) {
            return {
              x: Math.round(fx(d, i) / ε) * ε,
              y: Math.round(fy(d, i) / ε) * ε,
              i: i
            };
          });
        }
        voronoi.links = function (data) {
          return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
            return edge.l && edge.r;
          }).map(function (edge) {
            return {
              source: data[edge.l.i],
              target: data[edge.r.i]
            };
          });
        };
        voronoi.triangles = function (data) {
          var triangles = [];
          d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
            var site = cell.site,
                edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),
                j = -1,
                m = edges.length,
                e0,
                s0,
                e1 = edges[m - 1].edge,
                s1 = e1.l === site ? e1.r : e1.l;
            while (++j < m) {
              e0 = e1;
              s0 = s1;
              e1 = edges[j].edge;
              s1 = e1.l === site ? e1.r : e1.l;
              if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                triangles.push([data[i], data[s0.i], data[s1.i]]);
              }
            }
          });
          return triangles;
        };
        voronoi.x = function (_) {
          return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function (_) {
          return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function (_) {
          if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
          clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
          return voronoi;
        };
        voronoi.size = function (_) {
          if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
          return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
      };
      var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
      function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
      }
      d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices);
      };
      d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            compat;
        if (compat = arguments.length) {
          x = d3_geom_quadtreeCompatX;
          y = d3_geom_quadtreeCompatY;
          if (compat === 3) {
            y2 = y1;
            x2 = x1;
            y1 = x1 = 0;
          }
          return quadtree(points);
        }
        function quadtree(data) {
          var d,
              fx = d3_functor(x),
              fy = d3_functor(y),
              xs,
              ys,
              i,
              n,
              x1_,
              y1_,
              x2_,
              y2_;
          if (x1 != null) {
            x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
          } else {
            x2_ = y2_ = -(x1_ = y1_ = Infinity);
            xs = [], ys = [];
            n = data.length;
            if (compat) for (i = 0; i < n; ++i) {
              d = data[i];
              if (d.x < x1_) x1_ = d.x;
              if (d.y < y1_) y1_ = d.y;
              if (d.x > x2_) x2_ = d.x;
              if (d.y > y2_) y2_ = d.y;
              xs.push(d.x);
              ys.push(d.y);
            } else for (i = 0; i < n; ++i) {
              var x_ = +fx(d = data[i], i),
                  y_ = +fy(d, i);
              if (x_ < x1_) x1_ = x_;
              if (y_ < y1_) y1_ = y_;
              if (x_ > x2_) x2_ = x_;
              if (y_ > y2_) y2_ = y_;
              xs.push(x_);
              ys.push(y_);
            }
          }
          var dx = x2_ - x1_,
              dy = y2_ - y1_;
          if (dx > dy) y2_ = y1_ + dx;else x2_ = x1_ + dy;
          function insert(n, d, x, y, x1, y1, x2, y2) {
            if (isNaN(x) || isNaN(y)) return;
            if (n.leaf) {
              var nx = n.x,
                  ny = n.y;
              if (nx != null) {
                if (abs(nx - x) + abs(ny - y) < .01) {
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                } else {
                  var nPoint = n.point;
                  n.x = n.y = n.point = null;
                  insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                }
              } else {
                n.x = x, n.y = y, n.point = d;
              }
            } else {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          }
          function insertChild(n, d, x, y, x1, y1, x2, y2) {
            var xm = (x1 + x2) * .5,
                ym = (y1 + y2) * .5,
                right = x >= xm,
                below = y >= ym,
                i = below << 1 | right;
            n.leaf = false;
            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
            if (right) x1 = xm;else x2 = xm;
            if (below) y1 = ym;else y2 = ym;
            insert(n, d, x, y, x1, y1, x2, y2);
          }
          var root = d3_geom_quadtreeNode();
          root.add = function (d) {
            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
          };
          root.visit = function (f) {
            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
          };
          root.find = function (point) {
            return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
          };
          i = -1;
          if (x1 == null) {
            while (++i < n) {
              insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
            }
            --i;
          } else data.forEach(root.add);
          xs = ys = data = d = null;
          return root;
        }
        quadtree.x = function (_) {
          return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function (_) {
          return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function (_) {
          if (!arguments.length) return x1 == null ? null : [[x1, y1], [x2, y2]];
          if (_ == null) x1 = y1 = x2 = y2 = null;else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
          return quadtree;
        };
        quadtree.size = function (_) {
          if (!arguments.length) return x1 == null ? null : [x2 - x1, y2 - y1];
          if (_ == null) x1 = y1 = x2 = y2 = null;else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
          return quadtree;
        };
        return quadtree;
      };
      function d3_geom_quadtreeCompatX(d) {
        return d.x;
      }
      function d3_geom_quadtreeCompatY(d) {
        return d.y;
      }
      function d3_geom_quadtreeNode() {
        return {
          leaf: true,
          nodes: [],
          point: null,
          x: null,
          y: null
        };
      }
      function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
          var sx = (x1 + x2) * .5,
              sy = (y1 + y2) * .5,
              children = node.nodes;
          if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
          if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
          if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
          if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
      }
      function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity,
            closestPoint;
        (function find(node, x1, y1, x2, y2) {
          if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
          if (point = node.point) {
            var point,
                dx = x - node.x,
                dy = y - node.y,
                distance2 = dx * dx + dy * dy;
            if (distance2 < minDistance2) {
              var distance = Math.sqrt(minDistance2 = distance2);
              x0 = x - distance, y0 = y - distance;
              x3 = x + distance, y3 = y + distance;
              closestPoint = point;
            }
          }
          var children = node.nodes,
              xm = (x1 + x2) * .5,
              ym = (y1 + y2) * .5,
              right = x >= xm,
              below = y >= ym;
          for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
            if (node = children[i & 3]) switch (i & 3) {
              case 0:
                find(node, x1, y1, xm, ym);
                break;

              case 1:
                find(node, xm, y1, x2, ym);
                break;

              case 2:
                find(node, x1, ym, xm, y2);
                break;

              case 3:
                find(node, xm, ym, x2, y2);
                break;
            }
          }
        })(root, x0, y0, x3, y3);
        return closestPoint;
      }
      d3.interpolateRgb = d3_interpolateRgb;
      function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r,
            ag = a.g,
            ab = a.b,
            br = b.r - ar,
            bg = b.g - ag,
            bb = b.b - ab;
        return function (t) {
          return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
      }
      d3.interpolateObject = d3_interpolateObject;
      function d3_interpolateObject(a, b) {
        var i = {},
            c = {},
            k;
        for (k in a) {
          if (k in b) {
            i[k] = d3_interpolate(a[k], b[k]);
          } else {
            c[k] = a[k];
          }
        }
        for (k in b) {
          if (!(k in a)) {
            c[k] = b[k];
          }
        }
        return function (t) {
          for (k in i) c[k] = i[k](t);
          return c;
        };
      }
      d3.interpolateNumber = d3_interpolateNumber;
      function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function (t) {
          return a * (1 - t) + b * t;
        };
      }
      d3.interpolateString = d3_interpolateString;
      function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs;else s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i]) s[i] += bm;else s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: d3_interpolateNumber(am, bm)
            });
          }
          bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i]) s[i] += bs;else s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
          return b(t) + "";
        }) : function () {
          return b;
        } : (b = q.length, function (t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      }
      var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
      d3.interpolate = d3_interpolate;
      function d3_interpolate(a, b) {
        var i = d3.interpolators.length,
            f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
        return f;
      }
      d3.interpolators = [function (a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
      }];
      d3.interpolateArray = d3_interpolateArray;
      function d3_interpolateArray(a, b) {
        var x = [],
            c = [],
            na = a.length,
            nb = b.length,
            n0 = Math.min(a.length, b.length),
            i;
        for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i) c[i] = a[i];
        for (; i < nb; ++i) c[i] = b[i];
        return function (t) {
          for (i = 0; i < n0; ++i) c[i] = x[i](t);
          return c;
        };
      }
      var d3_ease_default = function () {
        return d3_identity;
      };
      var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function () {
          return d3_ease_quad;
        },
        cubic: function () {
          return d3_ease_cubic;
        },
        sin: function () {
          return d3_ease_sin;
        },
        exp: function () {
          return d3_ease_exp;
        },
        circle: function () {
          return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function () {
          return d3_ease_bounce;
        }
      });
      var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function (f) {
          return d3_ease_reflect(d3_ease_reverse(f));
        }
      });
      d3.ease = function (name) {
        var i = name.indexOf("-"),
            t = i >= 0 ? name.slice(0, i) : name,
            m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
      };
      function d3_ease_clamp(f) {
        return function (t) {
          return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
      }
      function d3_ease_reverse(f) {
        return function (t) {
          return 1 - f(1 - t);
        };
      }
      function d3_ease_reflect(f) {
        return function (t) {
          return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
      }
      function d3_ease_quad(t) {
        return t * t;
      }
      function d3_ease_cubic(t) {
        return t * t * t;
      }
      function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
      }
      function d3_ease_poly(e) {
        return function (t) {
          return Math.pow(t, e);
        };
      }
      function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
      }
      function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
      function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = .45;
        if (arguments.length) s = p / τ * Math.asin(1 / a);else a = 1, s = p / 4;
        return function (t) {
          return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
      }
      function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function (t) {
          return t * t * ((s + 1) * t - s);
        };
      }
      function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      d3.interpolateHcl = d3_interpolateHcl;
      function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h,
            ac = a.c,
            al = a.l,
            bh = b.h - ah,
            bc = b.c - ac,
            bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;else if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;
        return function (t) {
          return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
      }
      d3.interpolateHsl = d3_interpolateHsl;
      function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h,
            as = a.s,
            al = a.l,
            bh = b.h - ah,
            bs = b.s - as,
            bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;else if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;
        return function (t) {
          return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
      }
      d3.interpolateLab = d3_interpolateLab;
      function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l,
            aa = a.a,
            ab = a.b,
            bl = b.l - al,
            ba = b.a - aa,
            bb = b.b - ab;
        return function (t) {
          return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
      }
      d3.interpolateRound = d3_interpolateRound;
      function d3_interpolateRound(a, b) {
        b -= a;
        return function (t) {
          return Math.round(a + b * t);
        };
      }
      d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function (string) {
          if (string != null) {
            g.setAttribute("transform", string);
            var t = g.transform.baseVal.consolidate();
          }
          return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
      };
      function d3_transform(m) {
        var r0 = [m.a, m.b],
            r1 = [m.c, m.d],
            kx = d3_transformNormalize(r0),
            kz = d3_transformDot(r0, r1),
            ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
          r0[0] *= -1;
          r0[1] *= -1;
          kx *= -1;
          kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
      }
      d3_transform.prototype.toString = function () {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
      };
      function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
          a[0] /= k;
          a[1] /= k;
        }
        return k;
      }
      function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
      }
      var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      d3.interpolateTransform = d3_interpolateTransform;
      function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + "," : "";
      }
      function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
          var i = s.push("translate(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: d3_interpolateNumber(ta[0], tb[0])
          }, {
            i: i - 2,
            x: d3_interpolateNumber(ta[1], tb[1])
          });
        } else if (tb[0] || tb[1]) {
          s.push("translate(" + tb + ")");
        }
      }
      function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
          if (ra - rb > 180) rb += 360;else if (rb - ra > 180) ra += 360;
          q.push({
            i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
            x: d3_interpolateNumber(ra, rb)
          });
        } else if (rb) {
          s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
        }
      }
      function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
          q.push({
            i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
          });
        } else if (wb) {
          s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
        }
      }
      function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
          var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: d3_interpolateNumber(ka[0], kb[0])
          }, {
            i: i - 2,
            x: d3_interpolateNumber(ka[1], kb[1])
          });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
          s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
        }
      }
      function d3_interpolateTransform(a, b) {
        var s = [],
            q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function (t) {
          var i = -1,
              n = q.length,
              o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      }
      function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
          return (x - a) / b;
        };
      }
      function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
          return Math.max(0, Math.min(1, (x - a) / b));
        };
      }
      d3.layout = {};
      d3.layout.bundle = function () {
        return function (links) {
          var paths = [],
              i = -1,
              n = links.length;
          while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
          return paths;
        };
      };
      function d3_layout_bundlePath(link) {
        var start = link.source,
            end = link.target,
            lca = d3_layout_bundleLeastCommonAncestor(start, end),
            points = [start];
        while (start !== lca) {
          start = start.parent;
          points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
          points.splice(k, 0, end);
          end = end.parent;
        }
        return points;
      }
      function d3_layout_bundleAncestors(node) {
        var ancestors = [],
            parent = node.parent;
        while (parent != null) {
          ancestors.push(node);
          node = parent;
          parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
      }
      function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a),
            bNodes = d3_layout_bundleAncestors(b),
            aNode = aNodes.pop(),
            bNode = bNodes.pop(),
            sharedNode = null;
        while (aNode === bNode) {
          sharedNode = aNode;
          aNode = aNodes.pop();
          bNode = bNodes.pop();
        }
        return sharedNode;
      }
      d3.layout.chord = function () {
        var chord = {},
            chords,
            groups,
            matrix,
            n,
            padding = 0,
            sortGroups,
            sortSubgroups,
            sortChords;
        function relayout() {
          var subgroups = {},
              groupSums = [],
              groupIndex = d3.range(n),
              subgroupIndex = [],
              k,
              x,
              x0,
              i,
              j;
          chords = [];
          groups = [];
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(d3.range(n));
            k += x;
          }
          if (sortGroups) {
            groupIndex.sort(function (a, b) {
              return sortGroups(groupSums[a], groupSums[b]);
            });
          }
          if (sortSubgroups) {
            subgroupIndex.forEach(function (d, i) {
              d.sort(function (a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
              });
            });
          }
          k = (τ - padding * n) / k;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[di + "-" + dj] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: groupSums[di]
            };
            x += padding;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[i + "-" + j],
                  target = subgroups[j + "-" + i];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          if (sortChords) resort();
        }
        function resort() {
          chords.sort(function (a, b) {
            return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
          });
        }
        chord.matrix = function (x) {
          if (!arguments.length) return matrix;
          n = (matrix = x) && matrix.length;
          chords = groups = null;
          return chord;
        };
        chord.padding = function (x) {
          if (!arguments.length) return padding;
          padding = x;
          chords = groups = null;
          return chord;
        };
        chord.sortGroups = function (x) {
          if (!arguments.length) return sortGroups;
          sortGroups = x;
          chords = groups = null;
          return chord;
        };
        chord.sortSubgroups = function (x) {
          if (!arguments.length) return sortSubgroups;
          sortSubgroups = x;
          chords = null;
          return chord;
        };
        chord.sortChords = function (x) {
          if (!arguments.length) return sortChords;
          sortChords = x;
          if (chords) resort();
          return chord;
        };
        chord.chords = function () {
          if (!chords) relayout();
          return chords;
        };
        chord.groups = function () {
          if (!groups) relayout();
          return groups;
        };
        return chord;
      };
      d3.layout.force = function () {
        var force = {},
            event = d3.dispatch("start", "tick", "end"),
            timer,
            size = [1, 1],
            drag,
            alpha,
            friction = .9,
            linkDistance = d3_layout_forceLinkDistance,
            linkStrength = d3_layout_forceLinkStrength,
            charge = -30,
            chargeDistance2 = d3_layout_forceChargeDistance2,
            gravity = .1,
            theta2 = .64,
            nodes = [],
            links = [],
            distances,
            strengths,
            charges;
        function repulse(node) {
          return function (quad, x1, _, x2) {
            if (quad.point !== node) {
              var dx = quad.cx - node.x,
                  dy = quad.cy - node.y,
                  dw = x2 - x1,
                  dn = dx * dx + dy * dy;
              if (dw * dw / theta2 < dn) {
                if (dn < chargeDistance2) {
                  var k = quad.charge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
                return true;
              }
              if (quad.point && dn && dn < chargeDistance2) {
                var k = quad.pointCharge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
            }
            return !quad.charge;
          };
        }
        force.tick = function () {
          if ((alpha *= .99) < .005) {
            timer = null;
            event.end({
              type: "end",
              alpha: alpha = 0
            });
            return true;
          }
          var n = nodes.length,
              m = links.length,
              q,
              i,
              o,
              s,
              t,
              l,
              k,
              x,
              y;
          for (i = 0; i < m; ++i) {
            o = links[i];
            s = o.source;
            t = o.target;
            x = t.x - s.x;
            y = t.y - s.y;
            if (l = x * x + y * y) {
              l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
              x *= l;
              y *= l;
              t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
              t.y -= y * k;
              s.x += x * (k = 1 - k);
              s.y += y * k;
            }
          }
          if (k = alpha * gravity) {
            x = size[0] / 2;
            y = size[1] / 2;
            i = -1;
            if (k) while (++i < n) {
              o = nodes[i];
              o.x += (x - o.x) * k;
              o.y += (y - o.y) * k;
            }
          }
          if (charge) {
            d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
            i = -1;
            while (++i < n) {
              if (!(o = nodes[i]).fixed) {
                q.visit(repulse(o));
              }
            }
          }
          i = -1;
          while (++i < n) {
            o = nodes[i];
            if (o.fixed) {
              o.x = o.px;
              o.y = o.py;
            } else {
              o.x -= (o.px - (o.px = o.x)) * friction;
              o.y -= (o.py - (o.py = o.y)) * friction;
            }
          }
          event.tick({
            type: "tick",
            alpha: alpha
          });
        };
        force.nodes = function (x) {
          if (!arguments.length) return nodes;
          nodes = x;
          return force;
        };
        force.links = function (x) {
          if (!arguments.length) return links;
          links = x;
          return force;
        };
        force.size = function (x) {
          if (!arguments.length) return size;
          size = x;
          return force;
        };
        force.linkDistance = function (x) {
          if (!arguments.length) return linkDistance;
          linkDistance = typeof x === "function" ? x : +x;
          return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function (x) {
          if (!arguments.length) return linkStrength;
          linkStrength = typeof x === "function" ? x : +x;
          return force;
        };
        force.friction = function (x) {
          if (!arguments.length) return friction;
          friction = +x;
          return force;
        };
        force.charge = function (x) {
          if (!arguments.length) return charge;
          charge = typeof x === "function" ? x : +x;
          return force;
        };
        force.chargeDistance = function (x) {
          if (!arguments.length) return Math.sqrt(chargeDistance2);
          chargeDistance2 = x * x;
          return force;
        };
        force.gravity = function (x) {
          if (!arguments.length) return gravity;
          gravity = +x;
          return force;
        };
        force.theta = function (x) {
          if (!arguments.length) return Math.sqrt(theta2);
          theta2 = x * x;
          return force;
        };
        force.alpha = function (x) {
          if (!arguments.length) return alpha;
          x = +x;
          if (alpha) {
            if (x > 0) {
              alpha = x;
            } else {
              timer.c = null, timer.t = NaN, timer = null;
              event.end({
                type: "end",
                alpha: alpha = 0
              });
            }
          } else if (x > 0) {
            event.start({
              type: "start",
              alpha: alpha = x
            });
            timer = d3_timer(force.tick);
          }
          return force;
        };
        force.start = function () {
          var i,
              n = nodes.length,
              m = links.length,
              w = size[0],
              h = size[1],
              neighbors,
              o;
          for (i = 0; i < n; ++i) {
            (o = nodes[i]).index = i;
            o.weight = 0;
          }
          for (i = 0; i < m; ++i) {
            o = links[i];
            if (typeof o.source == "number") o.source = nodes[o.source];
            if (typeof o.target == "number") o.target = nodes[o.target];
            ++o.source.weight;
            ++o.target.weight;
          }
          for (i = 0; i < n; ++i) {
            o = nodes[i];
            if (isNaN(o.x)) o.x = position("x", w);
            if (isNaN(o.y)) o.y = position("y", h);
            if (isNaN(o.px)) o.px = o.x;
            if (isNaN(o.py)) o.py = o.y;
          }
          distances = [];
          if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i);else for (i = 0; i < m; ++i) distances[i] = linkDistance;
          strengths = [];
          if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i);else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
          charges = [];
          if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i);else for (i = 0; i < n; ++i) charges[i] = charge;
          function position(dimension, size) {
            if (!neighbors) {
              neighbors = new Array(n);
              for (j = 0; j < n; ++j) {
                neighbors[j] = [];
              }
              for (j = 0; j < m; ++j) {
                var o = links[j];
                neighbors[o.source.index].push(o.target);
                neighbors[o.target.index].push(o.source);
              }
            }
            var candidates = neighbors[i],
                j = -1,
                l = candidates.length,
                x;
            while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
            return Math.random() * size;
          }
          return force.resume();
        };
        force.resume = function () {
          return force.alpha(.1);
        };
        force.stop = function () {
          return force.alpha(0);
        };
        force.drag = function () {
          if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
          if (!arguments.length) return drag;
          this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
          d.px = d3.event.x, d.py = d3.event.y;
          force.resume();
        }
        return d3.rebind(force, event, "on");
      };
      function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
      }
      function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
      }
      function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      }
      function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
      }
      function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0,
            cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
          var nodes = quad.nodes,
              n = nodes.length,
              i = -1,
              c;
          while (++i < n) {
            c = nodes[i];
            if (c == null) continue;
            d3_layout_forceAccumulate(c, alpha, charges);
            quad.charge += c.charge;
            cx += c.charge * c.cx;
            cy += c.charge * c.cy;
          }
        }
        if (quad.point) {
          if (!quad.leaf) {
            quad.point.x += Math.random() - .5;
            quad.point.y += Math.random() - .5;
          }
          var k = alpha * charges[quad.point.index];
          quad.charge += quad.pointCharge = k;
          cx += k * quad.point.x;
          cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
      }
      var d3_layout_forceLinkDistance = 20,
          d3_layout_forceLinkStrength = 1,
          d3_layout_forceChargeDistance2 = Infinity;
      d3.layout.hierarchy = function () {
        var sort = d3_layout_hierarchySort,
            children = d3_layout_hierarchyChildren,
            value = d3_layout_hierarchyValue;
        function hierarchy(root) {
          var stack = [root],
              nodes = [],
              node;
          root.depth = 0;
          while ((node = stack.pop()) != null) {
            nodes.push(node);
            if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
              var n, childs, child;
              while (--n >= 0) {
                stack.push(child = childs[n]);
                child.parent = node;
                child.depth = node.depth + 1;
              }
              if (value) node.value = 0;
              node.children = childs;
            } else {
              if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
              delete node.children;
            }
          }
          d3_layout_hierarchyVisitAfter(root, function (node) {
            var childs, parent;
            if (sort && (childs = node.children)) childs.sort(sort);
            if (value && (parent = node.parent)) parent.value += node.value;
          });
          return nodes;
        }
        hierarchy.sort = function (x) {
          if (!arguments.length) return sort;
          sort = x;
          return hierarchy;
        };
        hierarchy.children = function (x) {
          if (!arguments.length) return children;
          children = x;
          return hierarchy;
        };
        hierarchy.value = function (x) {
          if (!arguments.length) return value;
          value = x;
          return hierarchy;
        };
        hierarchy.revalue = function (root) {
          if (value) {
            d3_layout_hierarchyVisitBefore(root, function (node) {
              if (node.children) node.value = 0;
            });
            d3_layout_hierarchyVisitAfter(root, function (node) {
              var parent;
              if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
              if (parent = node.parent) parent.value += node.value;
            });
          }
          return root;
        };
        return hierarchy;
      };
      function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
      }
      function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
          callback(node);
          if ((children = node.children) && (n = children.length)) {
            var n, children;
            while (--n >= 0) nodes.push(children[n]);
          }
        }
      }
      function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node],
            nodes2 = [];
        while ((node = nodes.pop()) != null) {
          nodes2.push(node);
          if ((children = node.children) && (n = children.length)) {
            var i = -1,
                n,
                children;
            while (++i < n) nodes.push(children[i]);
          }
        }
        while ((node = nodes2.pop()) != null) {
          callback(node);
        }
      }
      function d3_layout_hierarchyChildren(d) {
        return d.children;
      }
      function d3_layout_hierarchyValue(d) {
        return d.value;
      }
      function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
      }
      function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
          return (parent.children || []).map(function (child) {
            return {
              source: parent,
              target: child
            };
          });
        }));
      }
      d3.layout.partition = function () {
        var hierarchy = d3.layout.hierarchy(),
            size = [1, 1];
        function position(node, x, dx, dy) {
          var children = node.children;
          node.x = x;
          node.y = node.depth * dy;
          node.dx = dx;
          node.dy = dy;
          if (children && (n = children.length)) {
            var i = -1,
                n,
                c,
                d;
            dx = node.value ? dx / node.value : 0;
            while (++i < n) {
              position(c = children[i], x, d = c.value * dx, dy);
              x += d;
            }
          }
        }
        function depth(node) {
          var children = node.children,
              d = 0;
          if (children && (n = children.length)) {
            var i = -1,
                n;
            while (++i < n) d = Math.max(d, depth(children[i]));
          }
          return 1 + d;
        }
        function partition(d, i) {
          var nodes = hierarchy.call(this, d, i);
          position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
          return nodes;
        }
        partition.size = function (x) {
          if (!arguments.length) return size;
          size = x;
          return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
      };
      d3.layout.pie = function () {
        var value = Number,
            sort = d3_layout_pieSortByValue,
            startAngle = 0,
            endAngle = τ,
            padAngle = 0;
        function pie(data) {
          var n = data.length,
              values = data.map(function (d, i) {
            return +value.call(pie, d, i);
          }),
              a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle),
              da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a,
              p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)),
              pa = p * (da < 0 ? -1 : 1),
              sum = d3.sum(values),
              k = sum ? (da - n * pa) / sum : 0,
              index = d3.range(n),
              arcs = [],
              v;
          if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
            return values[j] - values[i];
          } : function (i, j) {
            return sort(data[i], data[j]);
          });
          index.forEach(function (i) {
            arcs[i] = {
              data: data[i],
              value: v = values[i],
              startAngle: a,
              endAngle: a += v * k + pa,
              padAngle: p
            };
          });
          return arcs;
        }
        pie.value = function (_) {
          if (!arguments.length) return value;
          value = _;
          return pie;
        };
        pie.sort = function (_) {
          if (!arguments.length) return sort;
          sort = _;
          return pie;
        };
        pie.startAngle = function (_) {
          if (!arguments.length) return startAngle;
          startAngle = _;
          return pie;
        };
        pie.endAngle = function (_) {
          if (!arguments.length) return endAngle;
          endAngle = _;
          return pie;
        };
        pie.padAngle = function (_) {
          if (!arguments.length) return padAngle;
          padAngle = _;
          return pie;
        };
        return pie;
      };
      var d3_layout_pieSortByValue = {};
      d3.layout.stack = function () {
        var values = d3_identity,
            order = d3_layout_stackOrderDefault,
            offset = d3_layout_stackOffsetZero,
            out = d3_layout_stackOut,
            x = d3_layout_stackX,
            y = d3_layout_stackY;
        function stack(data, index) {
          if (!(n = data.length)) return data;
          var series = data.map(function (d, i) {
            return values.call(stack, d, i);
          });
          var points = series.map(function (d) {
            return d.map(function (v, i) {
              return [x.call(stack, v, i), y.call(stack, v, i)];
            });
          });
          var orders = order.call(stack, points, index);
          series = d3.permute(series, orders);
          points = d3.permute(points, orders);
          var offsets = offset.call(stack, points, index);
          var m = series[0].length,
              n,
              i,
              j,
              o;
          for (j = 0; j < m; ++j) {
            out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
            for (i = 1; i < n; ++i) {
              out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            }
          }
          return data;
        }
        stack.values = function (x) {
          if (!arguments.length) return values;
          values = x;
          return stack;
        };
        stack.order = function (x) {
          if (!arguments.length) return order;
          order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
          return stack;
        };
        stack.offset = function (x) {
          if (!arguments.length) return offset;
          offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
          return stack;
        };
        stack.x = function (z) {
          if (!arguments.length) return x;
          x = z;
          return stack;
        };
        stack.y = function (z) {
          if (!arguments.length) return y;
          y = z;
          return stack;
        };
        stack.out = function (z) {
          if (!arguments.length) return out;
          out = z;
          return stack;
        };
        return stack;
      };
      function d3_layout_stackX(d) {
        return d.x;
      }
      function d3_layout_stackY(d) {
        return d.y;
      }
      function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
      }
      var d3_layout_stackOrders = d3.map({
        "inside-out": function (data) {
          var n = data.length,
              i,
              j,
              max = data.map(d3_layout_stackMaxIndex),
              sums = data.map(d3_layout_stackReduceSum),
              index = d3.range(n).sort(function (a, b) {
            return max[a] - max[b];
          }),
              top = 0,
              bottom = 0,
              tops = [],
              bottoms = [];
          for (i = 0; i < n; ++i) {
            j = index[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        },
        reverse: function (data) {
          return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
      });
      var d3_layout_stackOffsets = d3.map({
        silhouette: function (data) {
          var n = data.length,
              m = data[0].length,
              sums = [],
              max = 0,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
            if (o > max) max = o;
            sums.push(o);
          }
          for (j = 0; j < m; ++j) {
            y0[j] = (max - sums[j]) / 2;
          }
          return y0;
        },
        wiggle: function (data) {
          var n = data.length,
              x = data[0],
              m = x.length,
              i,
              j,
              k,
              s1,
              s2,
              s3,
              dx,
              o,
              o0,
              y0 = [];
          y0[0] = o = o0 = 0;
          for (j = 1; j < m; ++j) {
            for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
            for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
              for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
              }
              s2 += s3 * data[i][j][1];
            }
            y0[j] = o -= s1 ? s2 / s1 * dx : 0;
            if (o < o0) o0 = o;
          }
          for (j = 0; j < m; ++j) y0[j] -= o0;
          return y0;
        },
        expand: function (data) {
          var n = data.length,
              m = data[0].length,
              k = 1 / n,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
            if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;else for (i = 0; i < n; i++) data[i][j][1] = k;
          }
          for (j = 0; j < m; ++j) y0[j] = 0;
          return y0;
        },
        zero: d3_layout_stackOffsetZero
      });
      function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
      }
      function d3_layout_stackOffsetZero(data) {
        var j = -1,
            m = data[0].length,
            y0 = [];
        while (++j < m) y0[j] = 0;
        return y0;
      }
      function d3_layout_stackMaxIndex(array) {
        var i = 1,
            j = 0,
            v = array[0][1],
            k,
            n = array.length;
        for (; i < n; ++i) {
          if ((k = array[i][1]) > v) {
            j = i;
            v = k;
          }
        }
        return j;
      }
      function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
      }
      function d3_layout_stackSum(p, d) {
        return p + d[1];
      }
      d3.layout.histogram = function () {
        var frequency = true,
            valuer = Number,
            ranger = d3_layout_histogramRange,
            binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
          var bins = [],
              values = data.map(valuer, this),
              range = ranger.call(this, values, i),
              thresholds = binner.call(this, range, values, i),
              bin,
              i = -1,
              n = values.length,
              m = thresholds.length - 1,
              k = frequency ? 1 : 1 / n,
              x;
          while (++i < m) {
            bin = bins[i] = [];
            bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
            bin.y = 0;
          }
          if (m > 0) {
            i = -1;
            while (++i < n) {
              x = values[i];
              if (x >= range[0] && x <= range[1]) {
                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                bin.y += k;
                bin.push(data[i]);
              }
            }
          }
          return bins;
        }
        histogram.value = function (x) {
          if (!arguments.length) return valuer;
          valuer = x;
          return histogram;
        };
        histogram.range = function (x) {
          if (!arguments.length) return ranger;
          ranger = d3_functor(x);
          return histogram;
        };
        histogram.bins = function (x) {
          if (!arguments.length) return binner;
          binner = typeof x === "number" ? function (range) {
            return d3_layout_histogramBinFixed(range, x);
          } : d3_functor(x);
          return histogram;
        };
        histogram.frequency = function (x) {
          if (!arguments.length) return frequency;
          frequency = !!x;
          return histogram;
        };
        return histogram;
      };
      function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
      }
      function d3_layout_histogramBinFixed(range, n) {
        var x = -1,
            b = +range[0],
            m = (range[1] - b) / n,
            f = [];
        while (++x <= n) f[x] = m * x + b;
        return f;
      }
      function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
      }
      d3.layout.pack = function () {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
            padding = 0,
            size = [1, 1],
            radius;
        function pack(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              w = size[0],
              h = size[1],
              r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function () {
            return radius;
          };
          root.x = root.y = 0;
          d3_layout_hierarchyVisitAfter(root, function (d) {
            d.r = +r(d.value);
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          if (padding) {
            var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
            d3_layout_hierarchyVisitAfter(root, function (d) {
              d.r += dr;
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            d3_layout_hierarchyVisitAfter(root, function (d) {
              d.r -= dr;
            });
          }
          d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
          return nodes;
        }
        pack.size = function (_) {
          if (!arguments.length) return size;
          size = _;
          return pack;
        };
        pack.radius = function (_) {
          if (!arguments.length) return radius;
          radius = _ == null || typeof _ === "function" ? _ : +_;
          return pack;
        };
        pack.padding = function (_) {
          if (!arguments.length) return padding;
          padding = +_;
          return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
      };
      function d3_layout_packSort(a, b) {
        return a.value - b.value;
      }
      function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
      }
      function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
      }
      function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
      }
      function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length)) return;
        var nodes,
            xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            a,
            b,
            c,
            i,
            j,
            k,
            n;
        function bound(node) {
          xMin = Math.min(node.x - node.r, xMin);
          xMax = Math.max(node.x + node.r, xMax);
          yMin = Math.min(node.y - node.r, yMin);
          yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
          b = nodes[1];
          b.x = b.r;
          b.y = 0;
          bound(b);
          if (n > 2) {
            c = nodes[2];
            d3_layout_packPlace(a, b, c);
            bound(c);
            d3_layout_packInsert(a, c);
            a._pack_prev = c;
            d3_layout_packInsert(c, b);
            b = a._pack_next;
            for (i = 3; i < n; i++) {
              d3_layout_packPlace(a, b, c = nodes[i]);
              var isect = 0,
                  s1 = 1,
                  s2 = 1;
              for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                if (d3_layout_packIntersects(j, c)) {
                  isect = 1;
                  break;
                }
              }
              if (isect == 1) {
                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                  if (d3_layout_packIntersects(k, c)) {
                    break;
                  }
                }
              }
              if (isect) {
                if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);else d3_layout_packSplice(a = k, b);
                i--;
              } else {
                d3_layout_packInsert(a, c);
                b = c;
                bound(c);
              }
            }
          }
        }
        var cx = (xMin + xMax) / 2,
            cy = (yMin + yMax) / 2,
            cr = 0;
        for (i = 0; i < n; i++) {
          c = nodes[i];
          c.x -= cx;
          c.y -= cy;
          cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
      }
      function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
      }
      function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
      }
      function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
          var i = -1,
              n = children.length;
          while (++i < n) d3_layout_packTransform(children[i], x, y, k);
        }
      }
      function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r,
            dx = b.x - a.x,
            dy = b.y - a.y;
        if (db && (dx || dy)) {
          var da = b.r + c.r,
              dc = dx * dx + dy * dy;
          da *= da;
          db *= db;
          var x = .5 + (db - da) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = a.x + x * dx + y * dy;
          c.y = a.y + x * dy - y * dx;
        } else {
          c.x = a.x + db;
          c.y = a.y;
        }
      }
      d3.layout.tree = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = null;
        function tree(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root0 = nodes[0],
              root1 = wrapTree(root0);
          d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
          d3_layout_hierarchyVisitBefore(root1, secondWalk);
          if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);else {
            var left = root0,
                right = root0,
                bottom = root0;
            d3_layout_hierarchyVisitBefore(root0, function (node) {
              if (node.x < left.x) left = node;
              if (node.x > right.x) right = node;
              if (node.depth > bottom.depth) bottom = node;
            });
            var tx = separation(left, right) / 2 - left.x,
                kx = size[0] / (right.x + separation(right, left) / 2 + tx),
                ky = size[1] / (bottom.depth || 1);
            d3_layout_hierarchyVisitBefore(root0, function (node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return nodes;
        }
        function wrapTree(root0) {
          var root1 = {
            A: null,
            children: [root0]
          },
              queue = [root1],
              node1;
          while ((node1 = queue.pop()) != null) {
            for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
              queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
              }).a = child);
            }
          }
          return root1.children[0];
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children.length) {
            d3_layout_treeShift(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
              vom = d3_layout_treeLeft(vom);
              vop = d3_layout_treeRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !d3_layout_treeRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !d3_layout_treeLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= size[0];
          node.y = node.depth * size[1];
        }
        tree.separation = function (x) {
          if (!arguments.length) return separation;
          separation = x;
          return tree;
        };
        tree.size = function (x) {
          if (!arguments.length) return nodeSize ? null : size;
          nodeSize = (size = x) == null ? sizeNode : null;
          return tree;
        };
        tree.nodeSize = function (x) {
          if (!arguments.length) return nodeSize ? size : null;
          nodeSize = (size = x) == null ? null : sizeNode;
          return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
      };
      function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
      }
      function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
      }
      function d3_layout_treeRight(v) {
        var children = v.children,
            n;
        return (n = children.length) ? children[n - 1] : v.t;
      }
      function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function d3_layout_treeShift(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      d3.layout.cluster = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = false;
        function cluster(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              previousNode,
              x = 0;
          d3_layout_hierarchyVisitAfter(root, function (node) {
            var children = node.children;
            if (children && children.length) {
              node.x = d3_layout_clusterX(children);
              node.y = d3_layout_clusterY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = d3_layout_clusterLeft(root),
              right = d3_layout_clusterRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
            node.x = (node.x - root.x) * size[0];
            node.y = (root.y - node.y) * size[1];
          } : function (node) {
            node.x = (node.x - x0) / (x1 - x0) * size[0];
            node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
          });
          return nodes;
        }
        cluster.separation = function (x) {
          if (!arguments.length) return separation;
          separation = x;
          return cluster;
        };
        cluster.size = function (x) {
          if (!arguments.length) return nodeSize ? null : size;
          nodeSize = (size = x) == null;
          return cluster;
        };
        cluster.nodeSize = function (x) {
          if (!arguments.length) return nodeSize ? size : null;
          nodeSize = (size = x) != null;
          return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
      };
      function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
          return child.y;
        });
      }
      function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
          return x + child.x;
        }, 0) / children.length;
      }
      function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
      }
      function d3_layout_clusterRight(node) {
        var children = node.children,
            n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
      }
      d3.layout.treemap = function () {
        var hierarchy = d3.layout.hierarchy(),
            round = Math.round,
            size = [1, 1],
            padding = null,
            pad = d3_layout_treemapPadNull,
            sticky = false,
            stickies,
            mode = "squarify",
            ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
          var i = -1,
              n = children.length,
              child,
              area;
          while (++i < n) {
            area = (child = children[i]).value * (k < 0 ? 0 : k);
            child.area = isNaN(area) || area <= 0 ? 0 : area;
          }
        }
        function squarify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                row = [],
                remaining = children.slice(),
                child,
                best = Infinity,
                score,
                u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),
                n;
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while ((n = remaining.length) > 0) {
              row.push(child = remaining[n - 1]);
              row.area += child.area;
              if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                remaining.pop();
                best = score;
              } else {
                row.area -= row.pop().area;
                position(row, u, rect, false);
                u = Math.min(rect.dx, rect.dy);
                row.length = row.area = 0;
                best = Infinity;
              }
            }
            if (row.length) {
              position(row, u, rect, true);
              row.length = row.area = 0;
            }
            children.forEach(squarify);
          }
        }
        function stickify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                remaining = children.slice(),
                child,
                row = [];
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while (child = remaining.pop()) {
              row.push(child);
              row.area += child.area;
              if (child.z != null) {
                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                row.length = row.area = 0;
              }
            }
            children.forEach(stickify);
          }
        }
        function worst(row, u) {
          var s = row.area,
              r,
              rmax = 0,
              rmin = Infinity,
              i = -1,
              n = row.length;
          while (++i < n) {
            if (!(r = row[i].area)) continue;
            if (r < rmin) rmin = r;
            if (r > rmax) rmax = r;
          }
          s *= s;
          u *= u;
          return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
          var i = -1,
              n = row.length,
              x = rect.x,
              y = rect.y,
              v = u ? round(row.area / u) : 0,
              o;
          if (u == rect.dx) {
            if (flush || v > rect.dy) v = rect.dy;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dy = v;
              x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
            }
            o.z = true;
            o.dx += rect.x + rect.dx - x;
            rect.y += v;
            rect.dy -= v;
          } else {
            if (flush || v > rect.dx) v = rect.dx;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dx = v;
              y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
            }
            o.z = false;
            o.dy += rect.y + rect.dy - y;
            rect.x += v;
            rect.dx -= v;
          }
        }
        function treemap(d) {
          var nodes = stickies || hierarchy(d),
              root = nodes[0];
          root.x = root.y = 0;
          if (root.value) root.dx = size[0], root.dy = size[1];else root.dx = root.dy = 0;
          if (stickies) hierarchy.revalue(root);
          scale([root], root.dx * root.dy / root.value);
          (stickies ? stickify : squarify)(root);
          if (sticky) stickies = nodes;
          return nodes;
        }
        treemap.size = function (x) {
          if (!arguments.length) return size;
          size = x;
          return treemap;
        };
        treemap.padding = function (x) {
          if (!arguments.length) return padding;
          function padFunction(node) {
            var p = x.call(treemap, node, node.depth);
            return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
          }
          function padConstant(node) {
            return d3_layout_treemapPad(node, x);
          }
          var type;
          pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
          return treemap;
        };
        treemap.round = function (x) {
          if (!arguments.length) return round != Number;
          round = x ? Math.round : Number;
          return treemap;
        };
        treemap.sticky = function (x) {
          if (!arguments.length) return sticky;
          sticky = x;
          stickies = null;
          return treemap;
        };
        treemap.ratio = function (x) {
          if (!arguments.length) return ratio;
          ratio = x;
          return treemap;
        };
        treemap.mode = function (x) {
          if (!arguments.length) return mode;
          mode = x + "";
          return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
      };
      function d3_layout_treemapPadNull(node) {
        return {
          x: node.x,
          y: node.y,
          dx: node.dx,
          dy: node.dy
        };
      }
      function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3],
            y = node.y + padding[0],
            dx = node.dx - padding[1] - padding[3],
            dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
          x += dx / 2;
          dx = 0;
        }
        if (dy < 0) {
          y += dy / 2;
          dy = 0;
        }
        return {
          x: x,
          y: y,
          dx: dx,
          dy: dy
        };
      }
      d3.random = {
        normal: function (µ, σ) {
          var n = arguments.length;
          if (n < 2) σ = 1;
          if (n < 1) µ = 0;
          return function () {
            var x, y, r;
            do {
              x = Math.random() * 2 - 1;
              y = Math.random() * 2 - 1;
              r = x * x + y * y;
            } while (!r || r > 1);
            return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
          };
        },
        logNormal: function () {
          var random = d3.random.normal.apply(d3, arguments);
          return function () {
            return Math.exp(random());
          };
        },
        bates: function (m) {
          var random = d3.random.irwinHall(m);
          return function () {
            return random() / m;
          };
        },
        irwinHall: function (m) {
          return function () {
            for (var s = 0, j = 0; j < m; j++) s += Math.random();
            return s;
          };
        }
      };
      d3.scale = {};
      function d3_scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
      }
      function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]),
            i = interpolate(range[0], range[1]);
        return function (x) {
          return i(u(x));
        };
      }
      function d3_scale_nice(domain, nice) {
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            dx;
        if (x1 < x0) {
          dx = i0, i0 = i1, i1 = dx;
          dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
      }
      function d3_scale_niceStep(step) {
        return step ? {
          floor: function (x) {
            return Math.floor(x / step) * step;
          },
          ceil: function (x) {
            return Math.ceil(x / step) * step;
          }
        } : d3_scale_niceIdentity;
      }
      var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
      };
      function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [],
            i = [],
            j = 0,
            k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
        }
        while (++j <= k) {
          u.push(uninterpolate(domain[j - 1], domain[j]));
          i.push(interpolate(range[j - 1], range[j]));
        }
        return function (x) {
          var j = d3.bisect(domain, x, 1, k) - 1;
          return i[j](u[j](x));
        };
      }
      d3.scale.linear = function () {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
      };
      function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
          var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
              uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
          output = linear(domain, range, uninterpolate, interpolate);
          input = linear(range, domain, uninterpolate, d3_interpolate);
          return scale;
        }
        function scale(x) {
          return output(x);
        }
        scale.invert = function (y) {
          return input(y);
        };
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          domain = x.map(Number);
          return rescale();
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          return rescale();
        };
        scale.rangeRound = function (x) {
          return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function (x) {
          if (!arguments.length) return clamp;
          clamp = x;
          return rescale();
        };
        scale.interpolate = function (x) {
          if (!arguments.length) return interpolate;
          interpolate = x;
          return rescale();
        };
        scale.ticks = function (m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
          d3_scale_linearNice(domain, m);
          return rescale();
        };
        scale.copy = function () {
          return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
      }
      function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
      }
      function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
      }
      function d3_scale_linearTickRange(domain, m) {
        if (m == null) m = 10;
        var extent = d3_scaleExtent(domain),
            span = extent[1] - extent[0],
            step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
            err = m / span * step;
        if (err <= .15) step *= 10;else if (err <= .35) step *= 5;else if (err <= .75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
      }
      function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
      }
      function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
          var match = d3_format_re.exec(format);
          match.shift();
          if (match[8] === "s") {
            var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
            if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
            match[8] = "f";
            format = d3.format(match.join(""));
            return function (d) {
              return format(prefix.scale(d)) + prefix.symbol;
            };
          }
          if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
          format = match.join("");
        } else {
          format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
      }
      var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
      };
      function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
      }
      function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
      }
      d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
      };
      function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
          return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
          return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
          return linear(log(x));
        }
        scale.invert = function (x) {
          return pow(linear.invert(x));
        };
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          positive = x[0] >= 0;
          linear.domain((domain = x.map(Number)).map(log));
          return scale;
        };
        scale.base = function (_) {
          if (!arguments.length) return base;
          base = +_;
          linear.domain(domain.map(log));
          return scale;
        };
        scale.nice = function () {
          var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
          linear.domain(niced);
          domain = niced.map(pow);
          return scale;
        };
        scale.ticks = function () {
          var extent = d3_scaleExtent(domain),
              ticks = [],
              u = extent[0],
              v = extent[1],
              i = Math.floor(log(u)),
              j = Math.ceil(log(v)),
              n = base % 1 ? 2 : base;
          if (isFinite(j - i)) {
            if (positive) {
              for (; i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
              ticks.push(pow(i));
            } else {
              ticks.push(pow(i));
              for (; i++ < j;) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
            }
            for (i = 0; ticks[i] < u; i++) {}
            for (j = ticks.length; ticks[j - 1] > v; j--) {}
            ticks = ticks.slice(i, j);
          }
          return ticks;
        };
        scale.tickFormat = function (n, format) {
          if (!arguments.length) return d3_scale_logFormat;
          if (arguments.length < 2) format = d3_scale_logFormat;else if (typeof format !== "function") format = d3.format(format);
          var k = Math.max(1, base * n / scale.ticks().length);
          return function (d) {
            var i = d / pow(Math.round(log(d)));
            if (i * base < base - .5) i *= base;
            return i <= k ? format(d) : "";
          };
        };
        scale.copy = function () {
          return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      var d3_scale_logFormat = d3.format(".0e"),
          d3_scale_logNiceNegative = {
        floor: function (x) {
          return -Math.ceil(-x);
        },
        ceil: function (x) {
          return -Math.floor(-x);
        }
      };
      d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
      };
      function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent),
            powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
          return linear(powp(x));
        }
        scale.invert = function (x) {
          return powb(linear.invert(x));
        };
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          linear.domain((domain = x.map(Number)).map(powp));
          return scale;
        };
        scale.ticks = function (m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
          return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function (x) {
          if (!arguments.length) return exponent;
          powp = d3_scale_powPow(exponent = x);
          powb = d3_scale_powPow(1 / exponent);
          linear.domain(domain.map(powp));
          return scale;
        };
        scale.copy = function () {
          return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_scale_powPow(e) {
        return function (x) {
          return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
      }
      d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(.5);
      };
      d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {
          t: "range",
          a: [[]]
        });
      };
      function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
          return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
          return d3.range(domain.length).map(function (i) {
            return start + step * i;
          });
        }
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          domain = [];
          index = new d3_Map();
          var i = -1,
              n = x.length,
              xi;
          while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
          return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          rangeBand = 0;
          ranger = {
            t: "range",
            a: arguments
          };
          return scale;
        };
        scale.rangePoints = function (x, padding) {
          if (arguments.length < 2) padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
          range = steps(start + step * padding / 2, step);
          rangeBand = 0;
          ranger = {
            t: "rangePoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundPoints = function (x, padding) {
          if (arguments.length < 2) padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
          range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
          rangeBand = 0;
          ranger = {
            t: "rangeRoundPoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeBands = function (x, padding, outerPadding) {
          if (arguments.length < 2) padding = 0;
          if (arguments.length < 3) outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = (stop - start) / (domain.length - padding + 2 * outerPadding);
          range = steps(start + step * outerPadding, step);
          if (reverse) range.reverse();
          rangeBand = step * (1 - padding);
          ranger = {
            t: "rangeBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundBands = function (x, padding, outerPadding) {
          if (arguments.length < 2) padding = 0;
          if (arguments.length < 3) outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
          range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
          if (reverse) range.reverse();
          rangeBand = Math.round(step * (1 - padding));
          ranger = {
            t: "rangeRoundBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeBand = function () {
          return rangeBand;
        };
        scale.rangeExtent = function () {
          return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function () {
          return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
      }
      d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10);
      };
      d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20);
      };
      d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b);
      };
      d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c);
      };
      var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
      var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
      var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
      var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
      d3.scale.quantile = function () {
        return d3_scale_quantile([], []);
      };
      function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
          var k = 0,
              q = range.length;
          thresholds = [];
          while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function (x) {
          if (!arguments.length) return domain;
          domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
          return rescale();
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          return rescale();
        };
        scale.quantiles = function () {
          return thresholds;
        };
        scale.invertExtent = function (y) {
          y = range.indexOf(y);
          return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function () {
          return d3_scale_quantile(domain, range);
        };
        return rescale();
      }
      d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [0, 1]);
      };
      function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
          return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
          kx = range.length / (x1 - x0);
          i = range.length - 1;
          return scale;
        }
        scale.domain = function (x) {
          if (!arguments.length) return [x0, x1];
          x0 = +x[0];
          x1 = +x[x.length - 1];
          return rescale();
        };
        scale.range = function (x) {
          if (!arguments.length) return range;
          range = x;
          return rescale();
        };
        scale.invertExtent = function (y) {
          y = range.indexOf(y);
          y = y < 0 ? NaN : y / kx + x0;
          return [y, y + 1 / kx];
        };
        scale.copy = function () {
          return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
      }
      d3.scale.threshold = function () {
        return d3_scale_threshold([.5], [0, 1]);
      };
      function d3_scale_threshold(domain, range) {
        function scale(x) {
          if (x <= x) return range[d3.bisect(domain, x)];
        }
        scale.domain = function (_) {
          if (!arguments.length) return domain;
          domain = _;
          return scale;
        };
        scale.range = function (_) {
          if (!arguments.length) return range;
          range = _;
          return scale;
        };
        scale.invertExtent = function (y) {
          y = range.indexOf(y);
          return [domain[y - 1], domain[y]];
        };
        scale.copy = function () {
          return d3_scale_threshold(domain, range);
        };
        return scale;
      }
      d3.scale.identity = function () {
        return d3_scale_identity([0, 1]);
      };
      function d3_scale_identity(domain) {
        function identity(x) {
          return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function (x) {
          if (!arguments.length) return domain;
          domain = x.map(identity);
          return identity;
        };
        identity.ticks = function (m) {
          return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function (m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function () {
          return d3_scale_identity(domain);
        };
        return identity;
      }
      d3.svg = {};
      function d3_zero() {
        return 0;
      }
      d3.svg.arc = function () {
        var innerRadius = d3_svg_arcInnerRadius,
            outerRadius = d3_svg_arcOuterRadius,
            cornerRadius = d3_zero,
            padRadius = d3_svg_arcAuto,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle,
            padAngle = d3_svg_arcPadAngle;
        function arc() {
          var r0 = Math.max(0, +innerRadius.apply(this, arguments)),
              r1 = Math.max(0, +outerRadius.apply(this, arguments)),
              a0 = startAngle.apply(this, arguments) - halfπ,
              a1 = endAngle.apply(this, arguments) - halfπ,
              da = Math.abs(a1 - a0),
              cw = a0 > a1 ? 0 : 1;
          if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
          if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
          var rc,
              cr,
              rp,
              ap,
              p0 = 0,
              p1 = 0,
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x3,
              y3,
              path = [];
          if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
            rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
            if (!cw) p1 *= -1;
            if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
            if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
          }
          if (r1) {
            x0 = r1 * Math.cos(a0 + p1);
            y0 = r1 * Math.sin(a0 + p1);
            x1 = r1 * Math.cos(a1 - p1);
            y1 = r1 * Math.sin(a1 - p1);
            var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
            if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
              var h1 = (a0 + a1) / 2;
              x0 = r1 * Math.cos(h1);
              y0 = r1 * Math.sin(h1);
              x1 = y1 = null;
            }
          } else {
            x0 = y0 = 0;
          }
          if (r0) {
            x2 = r0 * Math.cos(a1 - p0);
            y2 = r0 * Math.sin(a1 - p0);
            x3 = r0 * Math.cos(a0 + p0);
            y3 = r0 * Math.sin(a0 + p0);
            var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
            if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
              var h0 = (a0 + a1) / 2;
              x2 = r0 * Math.cos(h0);
              y2 = r0 * Math.sin(h0);
              x3 = y3 = null;
            }
          } else {
            x2 = y2 = 0;
          }
          if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
            cr = r0 < r1 ^ cw ? 0 : 1;
            var rc1 = rc,
                rc0 = rc;
            if (da < π) {
              var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),
                  ax = x0 - oc[0],
                  ay = y0 - oc[1],
                  bx = x1 - oc[0],
                  by = y1 - oc[1],
                  kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                  lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
              rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
            }
            if (x1 != null) {
              var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),
                  t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
              if (rc === rc1) {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
              } else {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
              }
            } else {
              path.push("M", x0, ",", y0);
            }
            if (x3 != null) {
              var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),
                  t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
              if (rc === rc0) {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              } else {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              }
            } else {
              path.push("L", x2, ",", y2);
            }
          } else {
            path.push("M", x0, ",", y0);
            if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
            path.push("L", x2, ",", y2);
            if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
          }
          path.push("Z");
          return path.join("");
        }
        function circleSegment(r1, cw) {
          return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function (v) {
          if (!arguments.length) return innerRadius;
          innerRadius = d3_functor(v);
          return arc;
        };
        arc.outerRadius = function (v) {
          if (!arguments.length) return outerRadius;
          outerRadius = d3_functor(v);
          return arc;
        };
        arc.cornerRadius = function (v) {
          if (!arguments.length) return cornerRadius;
          cornerRadius = d3_functor(v);
          return arc;
        };
        arc.padRadius = function (v) {
          if (!arguments.length) return padRadius;
          padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
          return arc;
        };
        arc.startAngle = function (v) {
          if (!arguments.length) return startAngle;
          startAngle = d3_functor(v);
          return arc;
        };
        arc.endAngle = function (v) {
          if (!arguments.length) return endAngle;
          endAngle = d3_functor(v);
          return arc;
        };
        arc.padAngle = function (v) {
          if (!arguments.length) return padAngle;
          padAngle = d3_functor(v);
          return arc;
        };
        arc.centroid = function () {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
      };
      var d3_svg_arcAuto = "auto";
      function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
      }
      function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
      }
      function d3_svg_arcStartAngle(d) {
        return d.startAngle;
      }
      function d3_svg_arcEndAngle(d) {
        return d.endAngle;
      }
      function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
      }
      function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
      }
      function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0],
            y01 = p0[1] - p1[1],
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x1 = p0[0] + ox,
            y1 = p0[1] + oy,
            x2 = p1[0] + ox,
            y2 = p1[1] + oy,
            x3 = (x1 + x2) / 2,
            y3 = (y1 + y2) / 2,
            dx = x2 - x1,
            dy = y2 - y1,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x1 * y2 - x2 * y1,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x3,
            dy0 = cy0 - y3,
            dx1 = cx1 - x3,
            dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
      }
      function d3_svg_line(projection) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            tension = .7;
        function line(data) {
          var segments = [],
              points = [],
              i = -1,
              n = data.length,
              d,
              fx = d3_functor(x),
              fy = d3_functor(y);
          function segment() {
            segments.push("M", interpolate(projection(points), tension));
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
            } else if (points.length) {
              segment();
              points = [];
            }
          }
          if (points.length) segment();
          return segments.length ? segments.join("") : null;
        }
        line.x = function (_) {
          if (!arguments.length) return x;
          x = _;
          return line;
        };
        line.y = function (_) {
          if (!arguments.length) return y;
          y = _;
          return line;
        };
        line.defined = function (_) {
          if (!arguments.length) return defined;
          defined = _;
          return line;
        };
        line.interpolate = function (_) {
          if (!arguments.length) return interpolateKey;
          if (typeof _ === "function") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          return line;
        };
        line.tension = function (_) {
          if (!arguments.length) return tension;
          tension = _;
          return line;
        };
        return line;
      }
      d3.svg.line = function () {
        return d3_svg_line(d3_identity);
      };
      var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
      });
      d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
      });
      function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join("L") : points + "Z";
      }
      function d3_svg_lineLinearClosed(points) {
        return points.join("L") + "Z";
      }
      function d3_svg_lineStep(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1) path.push("H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepBefore(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepAfter(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
      }
      function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
      }
      function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
          return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length,
            path = "",
            p0 = points[0],
            p = points[1],
            t0 = tangents[0],
            t = t0,
            pi = 1;
        if (quad) {
          path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
          p0 = points[1];
          pi = 2;
        }
        if (tangents.length > 1) {
          t = tangents[1];
          p = points[pi];
          pi++;
          path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          for (var i = 2; i < tangents.length; i++, pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          }
        }
        if (quad) {
          var lp = points[pi];
          path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
      }
      function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [],
            a = (1 - tension) / 2,
            p0,
            p1 = points[0],
            p2 = points[1],
            i = 1,
            n = points.length;
        while (++i < n) {
          p0 = p1;
          p1 = p2;
          p2 = points[i];
          tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
      }
      function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1,
            n = points.length,
            pi = points[0],
            x0 = pi[0],
            y0 = pi[1],
            px = [x0, x0, x0, (pi = points[1])[0]],
            py = [y0, y0, y0, pi[1]],
            path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
      }
      function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [],
            i = -1,
            n = points.length,
            pi,
            px = [0],
            py = [0];
        while (++i < 3) {
          pi = points[i];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBasisClosed(points) {
        var path,
            i = -1,
            n = points.length,
            m = n + 4,
            pi,
            px = [],
            py = [];
        while (++i < 4) {
          pi = points[i % n];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
          pi = points[i % n];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
          var x0 = points[0][0],
              y0 = points[0][1],
              dx = points[n][0] - x0,
              dy = points[n][1] - y0,
              i = -1,
              p,
              t;
          while (++i <= n) {
            p = points[i];
            t = i / n;
            p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
            p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
          }
        }
        return d3_svg_lineBasis(points);
      }
      function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      }
      var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
          d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
          d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
      function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
      }
      function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
      }
      function d3_svg_lineFiniteDifferences(points) {
        var i = 0,
            j = points.length - 1,
            m = [],
            p0 = points[0],
            p1 = points[1],
            d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
          m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
      }
      function d3_svg_lineMonotoneTangents(points) {
        var tangents = [],
            d,
            a,
            b,
            s,
            m = d3_svg_lineFiniteDifferences(points),
            i = -1,
            j = points.length - 1;
        while (++i < j) {
          d = d3_svg_lineSlope(points[i], points[i + 1]);
          if (abs(d) < ε) {
            m[i] = m[i + 1] = 0;
          } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
              s = d * 3 / Math.sqrt(s);
              m[i] = s * a;
              m[i + 1] = s * b;
            }
          }
        }
        i = -1;
        while (++i <= j) {
          s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
          tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
      }
      function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
      }
      d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
      };
      function d3_svg_lineRadial(points) {
        var point,
            i = -1,
            n = points.length,
            r,
            a;
        while (++i < n) {
          point = points[i];
          r = point[0];
          a = point[1] - halfπ;
          point[0] = r * Math.cos(a);
          point[1] = r * Math.sin(a);
        }
        return points;
      }
      function d3_svg_area(projection) {
        var x0 = d3_geom_pointX,
            x1 = d3_geom_pointX,
            y0 = 0,
            y1 = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            interpolateReverse = interpolate,
            L = "L",
            tension = .7;
        function area(data) {
          var segments = [],
              points0 = [],
              points1 = [],
              i = -1,
              n = data.length,
              d,
              fx0 = d3_functor(x0),
              fy0 = d3_functor(y0),
              fx1 = x0 === x1 ? function () {
            return x;
          } : d3_functor(x1),
              fy1 = y0 === y1 ? function () {
            return y;
          } : d3_functor(y1),
              x,
              y;
          function segment() {
            segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
              points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
            } else if (points0.length) {
              segment();
              points0 = [];
              points1 = [];
            }
          }
          if (points0.length) segment();
          return segments.length ? segments.join("") : null;
        }
        area.x = function (_) {
          if (!arguments.length) return x1;
          x0 = x1 = _;
          return area;
        };
        area.x0 = function (_) {
          if (!arguments.length) return x0;
          x0 = _;
          return area;
        };
        area.x1 = function (_) {
          if (!arguments.length) return x1;
          x1 = _;
          return area;
        };
        area.y = function (_) {
          if (!arguments.length) return y1;
          y0 = y1 = _;
          return area;
        };
        area.y0 = function (_) {
          if (!arguments.length) return y0;
          y0 = _;
          return area;
        };
        area.y1 = function (_) {
          if (!arguments.length) return y1;
          y1 = _;
          return area;
        };
        area.defined = function (_) {
          if (!arguments.length) return defined;
          defined = _;
          return area;
        };
        area.interpolate = function (_) {
          if (!arguments.length) return interpolateKey;
          if (typeof _ === "function") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          interpolateReverse = interpolate.reverse || interpolate;
          L = interpolate.closed ? "M" : "L";
          return area;
        };
        area.tension = function (_) {
          if (!arguments.length) return tension;
          tension = _;
          return area;
        };
        return area;
      }
      d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
      d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
      d3.svg.area = function () {
        return d3_svg_area(d3_identity);
      };
      d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
      };
      d3.svg.chord = function () {
        var source = d3_source,
            target = d3_target,
            radius = d3_svg_chordRadius,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
          var s = subgroup(this, source, d, i),
              t = subgroup(this, target, d, i);
          return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
          var subgroup = f.call(self, d, i),
              r = radius.call(self, subgroup, i),
              a0 = startAngle.call(self, subgroup, i) - halfπ,
              a1 = endAngle.call(self, subgroup, i) - halfπ;
          return {
            r: r,
            a0: a0,
            a1: a1,
            p0: [r * Math.cos(a0), r * Math.sin(a0)],
            p1: [r * Math.cos(a1), r * Math.sin(a1)]
          };
        }
        function equals(a, b) {
          return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
          return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
          return "Q 0,0 " + p1;
        }
        chord.radius = function (v) {
          if (!arguments.length) return radius;
          radius = d3_functor(v);
          return chord;
        };
        chord.source = function (v) {
          if (!arguments.length) return source;
          source = d3_functor(v);
          return chord;
        };
        chord.target = function (v) {
          if (!arguments.length) return target;
          target = d3_functor(v);
          return chord;
        };
        chord.startAngle = function (v) {
          if (!arguments.length) return startAngle;
          startAngle = d3_functor(v);
          return chord;
        };
        chord.endAngle = function (v) {
          if (!arguments.length) return endAngle;
          endAngle = d3_functor(v);
          return chord;
        };
        return chord;
      };
      function d3_svg_chordRadius(d) {
        return d.radius;
      }
      d3.svg.diagonal = function () {
        var source = d3_source,
            target = d3_target,
            projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
          var p0 = source.call(this, d, i),
              p3 = target.call(this, d, i),
              m = (p0.y + p3.y) / 2,
              p = [p0, {
            x: p0.x,
            y: m
          }, {
            x: p3.x,
            y: m
          }, p3];
          p = p.map(projection);
          return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function (x) {
          if (!arguments.length) return source;
          source = d3_functor(x);
          return diagonal;
        };
        diagonal.target = function (x) {
          if (!arguments.length) return target;
          target = d3_functor(x);
          return diagonal;
        };
        diagonal.projection = function (x) {
          if (!arguments.length) return projection;
          projection = x;
          return diagonal;
        };
        return diagonal;
      };
      function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
      }
      d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(),
            projection = d3_svg_diagonalProjection,
            projection_ = diagonal.projection;
        diagonal.projection = function (x) {
          return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
      };
      function d3_svg_diagonalRadialProjection(projection) {
        return function () {
          var d = projection.apply(this, arguments),
              r = d[0],
              a = d[1] - halfπ;
          return [r * Math.cos(a), r * Math.sin(a)];
        };
      }
      d3.svg.symbol = function () {
        var type = d3_svg_symbolType,
            size = d3_svg_symbolSize;
        function symbol(d, i) {
          return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function (x) {
          if (!arguments.length) return type;
          type = d3_functor(x);
          return symbol;
        };
        symbol.size = function (x) {
          if (!arguments.length) return size;
          size = d3_functor(x);
          return symbol;
        };
        return symbol;
      };
      function d3_svg_symbolSize() {
        return 64;
      }
      function d3_svg_symbolType() {
        return "circle";
      }
      function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
      }
      var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function (size) {
          var r = Math.sqrt(size / 5) / 2;
          return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function (size) {
          var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
              rx = ry * d3_svg_symbolTan30;
          return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function (size) {
          var r = Math.sqrt(size) / 2;
          return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function (size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function (size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
      });
      d3.svg.symbolTypes = d3_svg_symbols.keys();
      var d3_svg_symbolSqrt3 = Math.sqrt(3),
          d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
      d3_selectionPrototype.transition = function (name) {
        var id = d3_transitionInheritId || ++d3_transitionId,
            ns = d3_transitionNamespace(name),
            subgroups = [],
            subgroup,
            node,
            transition = d3_transitionInherit || {
          time: Date.now(),
          ease: d3_ease_cubicInOut,
          delay: 0,
          duration: 250
        };
        for (var j = -1, m = this.length; ++j < m;) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_selectionPrototype.interrupt = function (name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
      };
      var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
      function d3_selection_interruptNS(ns) {
        return function () {
          var lock, activeId, active;
          if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
            active.timer.c = null;
            active.timer.t = NaN;
            if (--lock.count) delete lock[activeId];else delete this[ns];
            lock.active += .5;
            active.event && active.event.interrupt.call(this, this.__data__, active.index);
          }
        };
      }
      function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
      }
      var d3_transitionPrototype = [],
          d3_transitionId = 0,
          d3_transitionInheritId,
          d3_transitionInherit;
      d3_transitionPrototype.call = d3_selectionPrototype.call;
      d3_transitionPrototype.empty = d3_selectionPrototype.empty;
      d3_transitionPrototype.node = d3_selectionPrototype.node;
      d3_transitionPrototype.size = d3_selectionPrototype.size;
      d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
      };
      d3.transition.prototype = d3_transitionPrototype;
      d3_transitionPrototype.select = function (selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnode,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
              if ("__data__" in node) subnode.__data__ = node.__data__;
              d3_transitionNode(subnode, i, ns, id, node[ns][id]);
              subgroup.push(subnode);
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.selectAll = function (selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnodes,
            node,
            subnode,
            transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
          for (var group = this[j], i = -1, n = group.length; ++i < n;) {
            if (node = group[i]) {
              transition = node[ns][id];
              subnodes = selector.call(node, node.__data__, i, j);
              subgroups.push(subgroup = []);
              for (var k = -1, o = subnodes.length; ++k < o;) {
                if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                subgroup.push(subnode);
              }
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.filter = function (filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = 0, n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_transition(subgroups, this.namespace, this.id);
      };
      d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function (node) {
          node[ns][id].tween.remove(name);
        } : function (node) {
          node[ns][id].tween.set(name, tween);
        });
      };
      function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id,
            ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function (node, i, j) {
          node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function (node) {
          node[ns][id].tween.set(name, value);
        }));
      }
      d3_transitionPrototype.attr = function (nameNS, value) {
        if (arguments.length < 2) {
          for (value in nameNS) this.attr(value, nameNS[value]);
          return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate,
            name = d3.ns.qualify(nameNS);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
          return b == null ? attrNull : (b += "", function () {
            var a = this.getAttribute(name),
                i;
            return a !== b && (i = interpolate(a, b), function (t) {
              this.setAttribute(name, i(t));
            });
          });
        }
        function attrTweenNS(b) {
          return b == null ? attrNullNS : (b += "", function () {
            var a = this.getAttributeNS(name.space, name.local),
                i;
            return a !== b && (i = interpolate(a, b), function (t) {
              this.setAttributeNS(name.space, name.local, i(t));
            });
          });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.attrTween = function (nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
          var f = tween.call(this, d, i, this.getAttribute(name));
          return f && function (t) {
            this.setAttribute(name, f(t));
          };
        }
        function attrTweenNS(d, i) {
          var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
          return f && function (t) {
            this.setAttributeNS(name.space, name.local, f(t));
          };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2) value = "";
            for (priority in name) this.style(priority, name[priority], value);
            return this;
          }
          priority = "";
        }
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleString(b) {
          return b == null ? styleNull : (b += "", function () {
            var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name),
                i;
            return a !== b && (i = d3_interpolate(a, b), function (t) {
              this.style.setProperty(name, i(t), priority);
            });
          });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
      };
      d3_transitionPrototype.styleTween = function (name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
          var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
          return f && function (t) {
            this.style.setProperty(name, f(t), priority);
          };
        }
        return this.tween("style." + name, styleTween);
      };
      d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
      };
      function d3_transition_text(b) {
        if (b == null) b = "";
        return function () {
          this.textContent = b;
        };
      }
      d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each("end.transition", function () {
          var p;
          if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
        });
      };
      d3_transitionPrototype.ease = function (value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function (node) {
          node[ns][id].ease = value;
        });
      };
      d3_transitionPrototype.delay = function (value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function (node, i, j) {
          node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function (node) {
          node[ns][id].delay = value;
        }));
      };
      d3_transitionPrototype.duration = function (value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function (node, i, j) {
          node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function (node) {
          node[ns][id].duration = value;
        }));
      };
      d3_transitionPrototype.each = function (type, listener) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) {
          var inherit = d3_transitionInherit,
              inheritId = d3_transitionInheritId;
          try {
            d3_transitionInheritId = id;
            d3_selection_each(this, function (node, i, j) {
              d3_transitionInherit = node[ns][id];
              type.call(node, node.__data__, i, j);
            });
          } finally {
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
          }
        } else {
          d3_selection_each(this, function (node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
          });
        }
        return this;
      };
      d3_transitionPrototype.transition = function () {
        var id0 = this.id,
            id1 = ++d3_transitionId,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            group,
            node,
            transition;
        for (var j = 0, m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j], i = 0, n = group.length; i < n; i++) {
            if (node = group[i]) {
              transition = node[ns][id0];
              d3_transitionNode(node, i, ns, id1, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
              });
            }
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id1);
      };
      function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
      }
      function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
          active: 0,
          count: 0
        }),
            transition = lock[id],
            time,
            timer,
            duration,
            ease,
            tweens;
        function schedule(elapsed) {
          var delay = transition.delay;
          timer.t = delay + time;
          if (delay <= elapsed) return start(elapsed - delay);
          timer.c = start;
        }
        function start(elapsed) {
          var activeId = lock.active,
              active = lock[activeId];
          if (active) {
            active.timer.c = null;
            active.timer.t = NaN;
            --lock.count;
            delete lock[activeId];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          for (var cancelId in lock) {
            if (+cancelId < id) {
              var cancel = lock[cancelId];
              cancel.timer.c = null;
              cancel.timer.t = NaN;
              --lock.count;
              delete lock[cancelId];
            }
          }
          timer.c = tick;
          d3_timer(function () {
            if (timer.c && tick(elapsed || 1)) {
              timer.c = null;
              timer.t = NaN;
            }
            return 1;
          }, 0, time);
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          tweens = [];
          transition.tween.forEach(function (key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweens.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
        }
        function tick(elapsed) {
          var t = elapsed / duration,
              e = ease(t),
              n = tweens.length;
          while (n > 0) {
            tweens[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            if (--lock.count) delete lock[id];else delete node[ns];
            return 1;
          }
        }
        if (!transition) {
          time = inherit.time;
          timer = d3_timer(schedule, 0, time);
          transition = lock[id] = {
            tween: new d3_Map(),
            time: time,
            timer: timer,
            delay: inherit.delay,
            duration: inherit.duration,
            ease: inherit.ease,
            index: i
          };
          inherit = null;
          ++lock.count;
        }
      }
      d3.svg.axis = function () {
        var scale = d3.scale.linear(),
            orient = d3_svg_axisDefaultOrient,
            innerTickSize = 6,
            outerTickSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickValues = null,
            tickFormat_;
        function axis(g) {
          g.each(function () {
            var g = d3.select(this);
            var scale0 = this.__chart__ || scale,
                scale1 = this.__chart__ = scale.copy();
            var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,
                tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,
                tick = g.selectAll(".tick").data(ticks, scale1),
                tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε),
                tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(),
                tickUpdate = d3.transition(tick.order()).style("opacity", 1),
                tickSpacing = Math.max(innerTickSize, 0) + tickPadding,
                tickTransform;
            var range = d3_scaleRange(scale1),
                path = g.selectAll(".domain").data([0]),
                pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
            tickEnter.append("line");
            tickEnter.append("text");
            var lineEnter = tickEnter.select("line"),
                lineUpdate = tickUpdate.select("line"),
                text = tick.select("text").text(tickFormat),
                textEnter = tickEnter.select("text"),
                textUpdate = tickUpdate.select("text"),
                sign = orient === "top" || orient === "left" ? -1 : 1,
                x1,
                x2,
                y1,
                y2;
            if (orient === "bottom" || orient === "top") {
              tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
              text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
            } else {
              tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
              text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
              pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
            }
            lineEnter.attr(y2, sign * innerTickSize);
            textEnter.attr(y1, sign * tickSpacing);
            lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
            textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
            if (scale1.rangeBand) {
              var x = scale1,
                  dx = x.rangeBand() / 2;
              scale0 = scale1 = function (d) {
                return x(d) + dx;
              };
            } else if (scale0.rangeBand) {
              scale0 = scale1;
            } else {
              tickExit.call(tickTransform, scale1, scale0);
            }
            tickEnter.call(tickTransform, scale0, scale1);
            tickUpdate.call(tickTransform, scale1, scale1);
          });
        }
        axis.scale = function (x) {
          if (!arguments.length) return scale;
          scale = x;
          return axis;
        };
        axis.orient = function (x) {
          if (!arguments.length) return orient;
          orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
          return axis;
        };
        axis.ticks = function () {
          if (!arguments.length) return tickArguments_;
          tickArguments_ = d3_array(arguments);
          return axis;
        };
        axis.tickValues = function (x) {
          if (!arguments.length) return tickValues;
          tickValues = x;
          return axis;
        };
        axis.tickFormat = function (x) {
          if (!arguments.length) return tickFormat_;
          tickFormat_ = x;
          return axis;
        };
        axis.tickSize = function (x) {
          var n = arguments.length;
          if (!n) return innerTickSize;
          innerTickSize = +x;
          outerTickSize = +arguments[n - 1];
          return axis;
        };
        axis.innerTickSize = function (x) {
          if (!arguments.length) return innerTickSize;
          innerTickSize = +x;
          return axis;
        };
        axis.outerTickSize = function (x) {
          if (!arguments.length) return outerTickSize;
          outerTickSize = +x;
          return axis;
        };
        axis.tickPadding = function (x) {
          if (!arguments.length) return tickPadding;
          tickPadding = +x;
          return axis;
        };
        axis.tickSubdivide = function () {
          return arguments.length && axis;
        };
        return axis;
      };
      var d3_svg_axisDefaultOrient = "bottom",
          d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      };
      function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function (d) {
          var v0 = x0(d);
          return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
      }
      function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function (d) {
          var v0 = y0(d);
          return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
      }
      d3.svg.brush = function () {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
            x = null,
            y = null,
            xExtent = [0, 0],
            yExtent = [0, 0],
            xExtentDomain,
            yExtentDomain,
            xClamp = true,
            yClamp = true,
            resizes = d3_svg_brushResizes[0];
        function brush(g) {
          g.each(function () {
            var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
            var background = g.selectAll(".background").data([0]);
            background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
            g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
            var resize = g.selectAll(".resize").data(resizes, d3_identity);
            resize.exit().remove();
            resize.enter().append("g").attr("class", function (d) {
              return "resize " + d;
            }).style("cursor", function (d) {
              return d3_svg_brushCursor[d];
            }).append("rect").attr("x", function (d) {
              return (/[ew]$/.test(d) ? -3 : null
              );
            }).attr("y", function (d) {
              return (/^[ns]/.test(d) ? -3 : null
              );
            }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
            resize.style("display", brush.empty() ? "none" : null);
            var gUpdate = d3.transition(g),
                backgroundUpdate = d3.transition(background),
                range;
            if (x) {
              range = d3_scaleRange(x);
              backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
              redrawX(gUpdate);
            }
            if (y) {
              range = d3_scaleRange(y);
              backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
              redrawY(gUpdate);
            }
            redraw(gUpdate);
          });
        }
        brush.event = function (g) {
          g.each(function () {
            var event_ = event.of(this, arguments),
                extent1 = {
              x: xExtent,
              y: yExtent,
              i: xExtentDomain,
              j: yExtentDomain
            },
                extent0 = this.__chart__ || extent1;
            this.__chart__ = extent1;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.brush", function () {
                xExtentDomain = extent0.i;
                yExtentDomain = extent0.j;
                xExtent = extent0.x;
                yExtent = extent0.y;
                event_({
                  type: "brushstart"
                });
              }).tween("brush:brush", function () {
                var xi = d3_interpolateArray(xExtent, extent1.x),
                    yi = d3_interpolateArray(yExtent, extent1.y);
                xExtentDomain = yExtentDomain = null;
                return function (t) {
                  xExtent = extent1.x = xi(t);
                  yExtent = extent1.y = yi(t);
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                };
              }).each("end.brush", function () {
                xExtentDomain = extent1.i;
                yExtentDomain = extent1.j;
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({
                  type: "brushend"
                });
              });
            } else {
              event_({
                type: "brushstart"
              });
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({
                type: "brushend"
              });
            }
          });
        };
        function redraw(g) {
          g.selectAll(".resize").attr("transform", function (d) {
            return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
          });
        }
        function redrawX(g) {
          g.select(".extent").attr("x", xExtent[0]);
          g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
          g.select(".extent").attr("y", yExtent[0]);
          g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
          var target = this,
              eventTarget = d3.select(d3.event.target),
              event_ = event.of(target, arguments),
              g = d3.select(target),
              resizing = eventTarget.datum(),
              resizingX = !/^(n|s)$/.test(resizing) && x,
              resizingY = !/^(e|w)$/.test(resizing) && y,
              dragging = eventTarget.classed("extent"),
              dragRestore = d3_event_dragSuppress(target),
              center,
              origin = d3.mouse(target),
              offset;
          var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
          if (d3.event.changedTouches) {
            w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
          } else {
            w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
          }
          g.interrupt().selectAll("*").interrupt();
          if (dragging) {
            origin[0] = xExtent[0] - origin[0];
            origin[1] = yExtent[0] - origin[1];
          } else if (resizing) {
            var ex = +/w$/.test(resizing),
                ey = +/^n/.test(resizing);
            offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
            origin[0] = xExtent[ex];
            origin[1] = yExtent[ey];
          } else if (d3.event.altKey) center = origin.slice();
          g.style("pointer-events", "none").selectAll(".resize").style("display", null);
          d3.select("body").style("cursor", eventTarget.style("cursor"));
          event_({
            type: "brushstart"
          });
          brushmove();
          function keydown() {
            if (d3.event.keyCode == 32) {
              if (!dragging) {
                center = null;
                origin[0] -= xExtent[1];
                origin[1] -= yExtent[1];
                dragging = 2;
              }
              d3_eventPreventDefault();
            }
          }
          function keyup() {
            if (d3.event.keyCode == 32 && dragging == 2) {
              origin[0] += xExtent[1];
              origin[1] += yExtent[1];
              dragging = 0;
              d3_eventPreventDefault();
            }
          }
          function brushmove() {
            var point = d3.mouse(target),
                moved = false;
            if (offset) {
              point[0] += offset[0];
              point[1] += offset[1];
            }
            if (!dragging) {
              if (d3.event.altKey) {
                if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                origin[0] = xExtent[+(point[0] < center[0])];
                origin[1] = yExtent[+(point[1] < center[1])];
              } else center = null;
            }
            if (resizingX && move1(point, x, 0)) {
              redrawX(g);
              moved = true;
            }
            if (resizingY && move1(point, y, 1)) {
              redrawY(g);
              moved = true;
            }
            if (moved) {
              redraw(g);
              event_({
                type: "brush",
                mode: dragging ? "move" : "resize"
              });
            }
          }
          function move1(point, scale, i) {
            var range = d3_scaleRange(scale),
                r0 = range[0],
                r1 = range[1],
                position = origin[i],
                extent = i ? yExtent : xExtent,
                size = extent[1] - extent[0],
                min,
                max;
            if (dragging) {
              r0 -= position;
              r1 -= size + position;
            }
            min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
            if (dragging) {
              max = (min += position) + size;
            } else {
              if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
              if (position < min) {
                max = min;
                min = position;
              } else {
                max = position;
              }
            }
            if (extent[0] != min || extent[1] != max) {
              if (i) yExtentDomain = null;else xExtentDomain = null;
              extent[0] = min;
              extent[1] = max;
              return true;
            }
          }
          function brushend() {
            brushmove();
            g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
            d3.select("body").style("cursor", null);
            w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
            dragRestore();
            event_({
              type: "brushend"
            });
          }
        }
        brush.x = function (z) {
          if (!arguments.length) return x;
          x = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.y = function (z) {
          if (!arguments.length) return y;
          y = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.clamp = function (z) {
          if (!arguments.length) return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
          if (x && y) xClamp = !!z[0], yClamp = !!z[1];else if (x) xClamp = !!z;else if (y) yClamp = !!z;
          return brush;
        };
        brush.extent = function (z) {
          var x0, x1, y0, y1, t;
          if (!arguments.length) {
            if (x) {
              if (xExtentDomain) {
                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
              } else {
                x0 = xExtent[0], x1 = xExtent[1];
                if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
              }
            }
            if (y) {
              if (yExtentDomain) {
                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
              } else {
                y0 = yExtent[0], y1 = yExtent[1];
                if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
              }
            }
            return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
          }
          if (x) {
            x0 = z[0], x1 = z[1];
            if (y) x0 = x0[0], x1 = x1[0];
            xExtentDomain = [x0, x1];
            if (x.invert) x0 = x(x0), x1 = x(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
            if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];
          }
          if (y) {
            y0 = z[0], y1 = z[1];
            if (x) y0 = y0[1], y1 = y1[1];
            yExtentDomain = [y0, y1];
            if (y.invert) y0 = y(y0), y1 = y(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
            if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];
          }
          return brush;
        };
        brush.clear = function () {
          if (!brush.empty()) {
            xExtent = [0, 0], yExtent = [0, 0];
            xExtentDomain = yExtentDomain = null;
          }
          return brush;
        };
        brush.empty = function () {
          return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
      };
      var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
      var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
      var d3_time_formatUtc = d3_time_format.utc;
      var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
      d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
      function d3_time_formatIsoNative(date) {
        return date.toISOString();
      }
      d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };
      d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
      d3_time.second = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
      }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
      }, function (date) {
        return date.getSeconds();
      });
      d3_time.seconds = d3_time.second.range;
      d3_time.seconds.utc = d3_time.second.utc.range;
      d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
      }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
      }, function (date) {
        return date.getMinutes();
      });
      d3_time.minutes = d3_time.minute.range;
      d3_time.minutes.utc = d3_time.minute.utc.range;
      d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
      }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
      }, function (date) {
        return date.getHours();
      });
      d3_time.hours = d3_time.hour.range;
      d3_time.hours.utc = d3_time.hour.utc.range;
      d3_time.month = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
      }, function (date, offset) {
        date.setMonth(date.getMonth() + offset);
      }, function (date) {
        return date.getMonth();
      });
      d3_time.months = d3_time.month.range;
      d3_time.months.utc = d3_time.month.utc.range;
      function d3_time_scale(linear, methods, format) {
        function scale(x) {
          return linear(x);
        }
        scale.invert = function (x) {
          return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function (x) {
          if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
          linear.domain(x);
          return scale;
        };
        function tickMethod(extent, count) {
          var span = extent[1] - extent[0],
              target = span / count,
              i = d3.bisect(d3_time_scaleSteps, target);
          return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function (d) {
            return d / 31536e6;
          }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function (interval, skip) {
          var domain = scale.domain(),
              extent = d3_scaleExtent(domain),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
          if (method) interval = method[0], skip = method[1];
          function skipped(date) {
            return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
          }
          return scale.domain(d3_scale_nice(domain, skip > 1 ? {
            floor: function (date) {
              while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
              return date;
            },
            ceil: function (date) {
              while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
              return date;
            }
          } : interval));
        };
        scale.ticks = function (interval, skip) {
          var extent = d3_scaleExtent(scale.domain()),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{
            range: interval
          }, skip];
          if (method) interval = method[0], skip = method[1];
          return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function () {
          return format;
        };
        scale.copy = function () {
          return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_time_scaleDate(t) {
        return new Date(t);
      }
      var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
      var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
      var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function (d) {
        return d.getMilliseconds();
      }], [":%S", function (d) {
        return d.getSeconds();
      }], ["%I:%M", function (d) {
        return d.getMinutes();
      }], ["%I %p", function (d) {
        return d.getHours();
      }], ["%a %d", function (d) {
        return d.getDay() && d.getDate() != 1;
      }], ["%b %d", function (d) {
        return d.getDate() != 1;
      }], ["%B", function (d) {
        return d.getMonth();
      }], ["%Y", d3_true]]);
      var d3_time_scaleMilliseconds = {
        range: function (start, stop, step) {
          return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
      };
      d3_time_scaleLocalMethods.year = d3_time.year;
      d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
      };
      var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return [m[0].utc, m[1]];
      });
      var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function (d) {
        return d.getUTCMilliseconds();
      }], [":%S", function (d) {
        return d.getUTCSeconds();
      }], ["%I:%M", function (d) {
        return d.getUTCMinutes();
      }], ["%I %p", function (d) {
        return d.getUTCHours();
      }], ["%a %d", function (d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
      }], ["%b %d", function (d) {
        return d.getUTCDate() != 1;
      }], ["%B", function (d) {
        return d.getUTCMonth();
      }], ["%Y", d3_true]]);
      d3_time_scaleUtcMethods.year = d3_time.year.utc;
      d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
      };
      d3.text = d3_xhrType(function (request) {
        return request.responseText;
      });
      d3.json = function (url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
      };
      function d3_json(request) {
        return JSON.parse(request.responseText);
      }
      d3.html = function (url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
      };
      function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
      }
      d3.xml = d3_xhrType(function (request) {
        return request.responseXML;
      });
      if (typeof define === "function" && define.amd) this.d3 = d3, define(d3);else if (typeof module === "object" && module.exports) module.exports = d3;else this.d3 = d3;
    }();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6c", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('6d', ['6b', '6c'], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, 'c3', null);

    (function ($__global) {
        (function (window) {
            'use strict';

            /*global define, module, exports, require */

            var c3 = { version: "0.4.11" };

            var c3_chart_fn, c3_chart_internal_fn, c3_chart_internal_axis_fn;

            function API(owner) {
                this.owner = owner;
            }

            function inherit(base, derived) {

                if (Object.create) {
                    derived.prototype = Object.create(base.prototype);
                } else {
                    var f = function f() {};
                    f.prototype = base.prototype;
                    derived.prototype = new f();
                }

                derived.prototype.constructor = derived;

                return derived;
            }

            function Chart(config) {
                var $$ = this.internal = new ChartInternal(this);
                $$.loadConfig(config);

                $$.beforeInit(config);
                $$.init();
                $$.afterInit(config);

                // bind "this" to nested API
                (function bindThis(fn, target, argThis) {
                    Object.keys(fn).forEach(function (key) {
                        target[key] = fn[key].bind(argThis);
                        if (Object.keys(fn[key]).length > 0) {
                            bindThis(fn[key], target[key], argThis);
                        }
                    });
                })(c3_chart_fn, this, this);
            }

            function ChartInternal(api) {
                var $$ = this;
                $$.d3 = window.d3 ? window.d3 : typeof require !== 'undefined' ? require("d3") : undefined;
                $$.api = api;
                $$.config = $$.getDefaultConfig();
                $$.data = {};
                $$.cache = {};
                $$.axes = {};
            }

            c3.generate = function (config) {
                return new Chart(config);
            };

            c3.chart = {
                fn: Chart.prototype,
                internal: {
                    fn: ChartInternal.prototype,
                    axis: {
                        fn: Axis.prototype
                    }
                }
            };
            c3_chart_fn = c3.chart.fn;
            c3_chart_internal_fn = c3.chart.internal.fn;
            c3_chart_internal_axis_fn = c3.chart.internal.axis.fn;

            c3_chart_internal_fn.beforeInit = function () {
                // can do something
            };
            c3_chart_internal_fn.afterInit = function () {
                // can do something
            };
            c3_chart_internal_fn.init = function () {
                var $$ = this,
                    config = $$.config;

                $$.initParams();

                if (config.data_url) {
                    $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);
                } else if (config.data_json) {
                    $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
                } else if (config.data_rows) {
                    $$.initWithData($$.convertRowsToData(config.data_rows));
                } else if (config.data_columns) {
                    $$.initWithData($$.convertColumnsToData(config.data_columns));
                } else {
                    throw Error('url or json or rows or columns is required.');
                }
            };

            c3_chart_internal_fn.initParams = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;

                // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
                $$.clipId = "c3-" + +new Date() + '-clip', $$.clipIdForXAxis = $$.clipId + '-xaxis', $$.clipIdForYAxis = $$.clipId + '-yaxis', $$.clipIdForGrid = $$.clipId + '-grid', $$.clipIdForSubchart = $$.clipId + '-subchart', $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
                $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null;
                $$.dragging = false;
                $$.flowing = false;
                $$.cancelClick = false;
                $$.mouseover = false;
                $$.transiting = false;

                $$.color = $$.generateColor();
                $$.levelColor = $$.generateLevelColor();

                $$.dataTimeFormat = config.data_xLocaltime ? d3.time.format : d3.time.format.utc;
                $$.axisTimeFormat = config.axis_x_localtime ? d3.time.format : d3.time.format.utc;
                $$.defaultAxisTimeFormat = $$.axisTimeFormat.multi([[".%L", function (d) {
                    return d.getMilliseconds();
                }], [":%S", function (d) {
                    return d.getSeconds();
                }], ["%I:%M", function (d) {
                    return d.getMinutes();
                }], ["%I %p", function (d) {
                    return d.getHours();
                }], ["%-m/%-d", function (d) {
                    return d.getDay() && d.getDate() !== 1;
                }], ["%-m/%-d", function (d) {
                    return d.getDate() !== 1;
                }], ["%-m/%-d", function (d) {
                    return d.getMonth();
                }], ["%Y/%-m/%-d", function () {
                    return true;
                }]]);

                $$.hiddenTargetIds = [];
                $$.hiddenLegendIds = [];
                $$.focusedTargetIds = [];
                $$.defocusedTargetIds = [];

                $$.xOrient = config.axis_rotated ? "left" : "bottom";
                $$.yOrient = config.axis_rotated ? config.axis_y_inner ? "top" : "bottom" : config.axis_y_inner ? "right" : "left";
                $$.y2Orient = config.axis_rotated ? config.axis_y2_inner ? "bottom" : "top" : config.axis_y2_inner ? "left" : "right";
                $$.subXOrient = config.axis_rotated ? "left" : "bottom";

                $$.isLegendRight = config.legend_position === 'right';
                $$.isLegendInset = config.legend_position === 'inset';
                $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right';
                $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left';
                $$.legendStep = 0;
                $$.legendItemWidth = 0;
                $$.legendItemHeight = 0;

                $$.currentMaxTickWidths = {
                    x: 0,
                    y: 0,
                    y2: 0
                };

                $$.rotated_padding_left = 30;
                $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
                $$.rotated_padding_top = 5;

                $$.withoutFadeIn = {};

                $$.intervalForObserveInserted = undefined;

                $$.axes.subx = d3.selectAll([]); // needs when excluding subchart.js
            };

            c3_chart_internal_fn.initChartElements = function () {
                if (this.initBar) {
                    this.initBar();
                }
                if (this.initLine) {
                    this.initLine();
                }
                if (this.initArc) {
                    this.initArc();
                }
                if (this.initGauge) {
                    this.initGauge();
                }
                if (this.initText) {
                    this.initText();
                }
            };

            c3_chart_internal_fn.initWithData = function (data) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;
                var defs,
                    main,
                    binding = true;

                $$.axis = new Axis($$);

                if ($$.initPie) {
                    $$.initPie();
                }
                if ($$.initBrush) {
                    $$.initBrush();
                }
                if ($$.initZoom) {
                    $$.initZoom();
                }

                if (!config.bindto) {
                    $$.selectChart = d3.selectAll([]);
                } else if (typeof config.bindto.node === 'function') {
                    $$.selectChart = config.bindto;
                } else {
                    $$.selectChart = d3.select(config.bindto);
                }
                if ($$.selectChart.empty()) {
                    $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0);
                    $$.observeInserted($$.selectChart);
                    binding = false;
                }
                $$.selectChart.html("").classed("c3", true);

                // Init data as targets
                $$.data.xs = {};
                $$.data.targets = $$.convertDataToTargets(data);

                if (config.data_filter) {
                    $$.data.targets = $$.data.targets.filter(config.data_filter);
                }

                // Set targets to hide if needed
                if (config.data_hide) {
                    $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide);
                }
                if (config.legend_hide) {
                    $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide);
                }

                // when gauge, hide legend // TODO: fix
                if ($$.hasType('gauge')) {
                    config.legend_show = false;
                }

                // Init sizes and scales
                $$.updateSizes();
                $$.updateScales();

                // Set domains for each scale
                $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
                $$.y.domain($$.getYDomain($$.data.targets, 'y'));
                $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
                $$.subX.domain($$.x.domain());
                $$.subY.domain($$.y.domain());
                $$.subY2.domain($$.y2.domain());

                // Save original x domain for zoom update
                $$.orgXDomain = $$.x.domain();

                // Set initialized scales to brush and zoom
                if ($$.brush) {
                    $$.brush.scale($$.subX);
                }
                if (config.zoom_enabled) {
                    $$.zoom.scale($$.x);
                }

                /*-- Basic Elements --*/

                // Define svgs
                $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").on('mouseenter', function () {
                    return config.onmouseover.call($$);
                }).on('mouseleave', function () {
                    return config.onmouseout.call($$);
                });

                if ($$.config.svg_classname) {
                    $$.svg.attr('class', $$.config.svg_classname);
                }

                // Define defs
                defs = $$.svg.append("defs");
                $$.clipChart = $$.appendClip(defs, $$.clipId);
                $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
                $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
                $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
                $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
                $$.updateSvgSize();

                // Define regions
                main = $$.main = $$.svg.append("g").attr("transform", $$.getTranslate('main'));

                if ($$.initSubchart) {
                    $$.initSubchart();
                }
                if ($$.initTooltip) {
                    $$.initTooltip();
                }
                if ($$.initLegend) {
                    $$.initLegend();
                }
                if ($$.initTitle) {
                    $$.initTitle();
                }

                /*-- Main Region --*/

                // text when empty
                main.append("text").attr("class", CLASS.text + ' ' + CLASS.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
                .attr("dominant-baseline", "middle"); // vertical centering of text at y position in all browsers, except IE.

                // Regions
                $$.initRegion();

                // Grids
                $$.initGrid();

                // Define g for chart area
                main.append('g').attr("clip-path", $$.clipPath).attr('class', CLASS.chart);

                // Grid lines
                if (config.grid_lines_front) {
                    $$.initGridLines();
                }

                // Cover whole with rects for events
                $$.initEventRect();

                // Define g for chart
                $$.initChartElements();

                // if zoom privileged, insert rect to forefront
                // TODO: is this needed?
                main.insert('rect', config.zoom_privileged ? null : 'g.' + CLASS.regions).attr('class', CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height).style('opacity', 0).on("dblclick.zoom", null);

                // Set default extent if defined
                if (config.axis_x_extent) {
                    $$.brush.extent($$.getDefaultExtent());
                }

                // Add Axis
                $$.axis.init();

                // Set targets
                $$.updateTargets($$.data.targets);

                // Draw with targets
                if (binding) {
                    $$.updateDimension();
                    $$.config.oninit.call($$);
                    $$.redraw({
                        withTransition: false,
                        withTransform: true,
                        withUpdateXDomain: true,
                        withUpdateOrgXDomain: true,
                        withTransitionForAxis: false
                    });
                }

                // Bind resize event
                $$.bindResize();

                // export element of the chart
                $$.api.element = $$.selectChart.node();
            };

            c3_chart_internal_fn.smoothLines = function (el, type) {
                var $$ = this;
                if (type === 'grid') {
                    el.each(function () {
                        var g = $$.d3.select(this),
                            x1 = g.attr('x1'),
                            x2 = g.attr('x2'),
                            y1 = g.attr('y1'),
                            y2 = g.attr('y2');
                        g.attr({
                            'x1': Math.ceil(x1),
                            'x2': Math.ceil(x2),
                            'y1': Math.ceil(y1),
                            'y2': Math.ceil(y2)
                        });
                    });
                }
            };

            c3_chart_internal_fn.updateSizes = function () {
                var $$ = this,
                    config = $$.config;
                var legendHeight = $$.legend ? $$.getLegendHeight() : 0,
                    legendWidth = $$.legend ? $$.getLegendWidth() : 0,
                    legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,
                    hasArc = $$.hasArcType(),
                    xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),
                    subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0;

                $$.currentWidth = $$.getCurrentWidth();
                $$.currentHeight = $$.getCurrentHeight();

                // for main
                $$.margin = config.axis_rotated ? {
                    top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
                    right: hasArc ? 0 : $$.getCurrentPaddingRight(),
                    bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),
                    left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
                } : {
                    top: 4 + $$.getCurrentPaddingTop(), // for top tick text
                    right: hasArc ? 0 : $$.getCurrentPaddingRight(),
                    bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
                    left: hasArc ? 0 : $$.getCurrentPaddingLeft()
                };

                // for subchart
                $$.margin2 = config.axis_rotated ? {
                    top: $$.margin.top,
                    right: NaN,
                    bottom: 20 + legendHeightForBottom,
                    left: $$.rotated_padding_left
                } : {
                    top: $$.currentHeight - subchartHeight - legendHeightForBottom,
                    right: NaN,
                    bottom: xAxisHeight + legendHeightForBottom,
                    left: $$.margin.left
                };

                // for legend
                $$.margin3 = {
                    top: 0,
                    right: NaN,
                    bottom: 0,
                    left: 0
                };
                if ($$.updateSizeForLegend) {
                    $$.updateSizeForLegend(legendHeight, legendWidth);
                }

                $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
                $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
                if ($$.width < 0) {
                    $$.width = 0;
                }
                if ($$.height < 0) {
                    $$.height = 0;
                }

                $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width;
                $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
                if ($$.width2 < 0) {
                    $$.width2 = 0;
                }
                if ($$.height2 < 0) {
                    $$.height2 = 0;
                }

                // for arc
                $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
                $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
                if ($$.hasType('gauge') && !config.gauge_fullCircle) {
                    $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
                }
                if ($$.updateRadius) {
                    $$.updateRadius();
                }

                if ($$.isLegendRight && hasArc) {
                    $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
                }
            };

            c3_chart_internal_fn.updateTargets = function (targets) {
                var $$ = this;

                /*-- Main --*/

                //-- Text --//
                $$.updateTargetsForText(targets);

                //-- Bar --//
                $$.updateTargetsForBar(targets);

                //-- Line --//
                $$.updateTargetsForLine(targets);

                //-- Arc --//
                if ($$.hasArcType() && $$.updateTargetsForArc) {
                    $$.updateTargetsForArc(targets);
                }

                /*-- Sub --*/

                if ($$.updateTargetsForSubchart) {
                    $$.updateTargetsForSubchart(targets);
                }

                // Fade-in each chart
                $$.showTargets();
            };
            c3_chart_internal_fn.showTargets = function () {
                var $$ = this;
                $$.svg.selectAll('.' + CLASS.target).filter(function (d) {
                    return $$.isTargetToShow(d.id);
                }).transition().duration($$.config.transition_duration).style("opacity", 1);
            };

            c3_chart_internal_fn.redraw = function (options, transitions) {
                var $$ = this,
                    main = $$.main,
                    d3 = $$.d3,
                    config = $$.config;
                var areaIndices = $$.getShapeIndices($$.isAreaType),
                    barIndices = $$.getShapeIndices($$.isBarType),
                    lineIndices = $$.getShapeIndices($$.isLineType);
                var withY, withSubchart, withTransition, withTransitionForExit, withTransitionForAxis, withTransform, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain, withLegend, withEventRect, withDimension, withUpdateXAxis;
                var hideAxis = $$.hasArcType();
                var drawArea, drawBar, drawLine, xForText, yForText;
                var duration, durationForExit, durationForAxis;
                var waitForDraw, flow;
                var targetsToShow = $$.filterTargetsToShow($$.data.targets),
                    tickValues,
                    i,
                    intervalForCulling,
                    xDomainForZoom;
                var xv = $$.xv.bind($$),
                    cx,
                    cy;

                options = options || {};
                withY = getOption(options, "withY", true);
                withSubchart = getOption(options, "withSubchart", true);
                withTransition = getOption(options, "withTransition", true);
                withTransform = getOption(options, "withTransform", false);
                withUpdateXDomain = getOption(options, "withUpdateXDomain", false);
                withUpdateOrgXDomain = getOption(options, "withUpdateOrgXDomain", false);
                withTrimXDomain = getOption(options, "withTrimXDomain", true);
                withUpdateXAxis = getOption(options, "withUpdateXAxis", withUpdateXDomain);
                withLegend = getOption(options, "withLegend", false);
                withEventRect = getOption(options, "withEventRect", true);
                withDimension = getOption(options, "withDimension", true);
                withTransitionForExit = getOption(options, "withTransitionForExit", withTransition);
                withTransitionForAxis = getOption(options, "withTransitionForAxis", withTransition);

                duration = withTransition ? config.transition_duration : 0;
                durationForExit = withTransitionForExit ? duration : 0;
                durationForAxis = withTransitionForAxis ? duration : 0;

                transitions = transitions || $$.axis.generateTransitions(durationForAxis);

                // update legend and transform each g
                if (withLegend && config.legend_show) {
                    $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
                } else if (withDimension) {
                    // need to update dimension (e.g. axis.y.tick.values) because y tick values should change
                    // no need to update axis in it because they will be updated in redraw()
                    $$.updateDimension(true);
                }

                // MEMO: needed for grids calculation
                if ($$.isCategorized() && targetsToShow.length === 0) {
                    $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
                }

                if (targetsToShow.length) {
                    $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
                    if (!config.axis_x_tick_values) {
                        tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
                    }
                } else {
                    $$.xAxis.tickValues([]);
                    $$.subXAxis.tickValues([]);
                }

                if (config.zoom_rescale && !options.flow) {
                    xDomainForZoom = $$.x.orgDomain();
                }

                $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
                $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));

                if (!config.axis_y_tick_values && config.axis_y_tick_count) {
                    $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
                }
                if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
                    $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
                }

                // axes
                $$.axis.redraw(transitions, hideAxis);

                // Update axis label
                $$.axis.updateLabels(withTransition);

                // show/hide if manual culling needed
                if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
                    if (config.axis_x_tick_culling && tickValues) {
                        for (i = 1; i < tickValues.length; i++) {
                            if (tickValues.length / i < config.axis_x_tick_culling_max) {
                                intervalForCulling = i;
                                break;
                            }
                        }
                        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {
                            var index = tickValues.indexOf(e);
                            if (index >= 0) {
                                d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
                            }
                        });
                    } else {
                        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block');
                    }
                }

                // setup drawer - MEMO: these must be called after axis updated
                drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined;
                drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
                drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined;
                xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
                yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);

                // Update sub domain
                if (withY) {
                    $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
                    $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
                }

                // xgrid focus
                $$.updateXgridFocus();

                // Data empty label positioning and text.
                main.select("text." + CLASS.text + '.' + CLASS.empty).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).transition().style('opacity', targetsToShow.length ? 0 : 1);

                // grid
                $$.updateGrid(duration);

                // rect for regions
                $$.updateRegion(duration);

                // bars
                $$.updateBar(durationForExit);

                // lines, areas and cricles
                $$.updateLine(durationForExit);
                $$.updateArea(durationForExit);
                $$.updateCircle();

                // text
                if ($$.hasDataLabel()) {
                    $$.updateText(durationForExit);
                }

                // title
                if ($$.redrawTitle) {
                    $$.redrawTitle();
                }

                // arc
                if ($$.redrawArc) {
                    $$.redrawArc(duration, durationForExit, withTransform);
                }

                // subchart
                if ($$.redrawSubchart) {
                    $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
                }

                // circles for select
                main.selectAll('.' + CLASS.selectedCircles).filter($$.isBarType.bind($$)).selectAll('circle').remove();

                // event rects will redrawn when flow called
                if (config.interaction_enabled && !options.flow && withEventRect) {
                    $$.redrawEventRect();
                    if ($$.updateZoom) {
                        $$.updateZoom();
                    }
                }

                // update circleY based on updated parameters
                $$.updateCircleY();

                // generate circle x/y functions depending on updated params
                cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
                cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);

                if (options.flow) {
                    flow = $$.generateFlow({
                        targets: targetsToShow,
                        flow: options.flow,
                        duration: options.flow.duration,
                        drawBar: drawBar,
                        drawLine: drawLine,
                        drawArea: drawArea,
                        cx: cx,
                        cy: cy,
                        xv: xv,
                        xForText: xForText,
                        yForText: yForText
                    });
                }

                if ((duration || flow) && $$.isTabVisible()) {
                    // Only use transition if tab visible. See #938.
                    // transition should be derived from one transition
                    d3.transition().duration(duration).each(function () {
                        var transitionsToWait = [];

                        // redraw and gather transitions
                        [$$.redrawBar(drawBar, true), $$.redrawLine(drawLine, true), $$.redrawArea(drawArea, true), $$.redrawCircle(cx, cy, true), $$.redrawText(xForText, yForText, options.flow, true), $$.redrawRegion(true), $$.redrawGrid(true)].forEach(function (transitions) {
                            transitions.forEach(function (transition) {
                                transitionsToWait.push(transition);
                            });
                        });

                        // Wait for end of transitions to call flow and onrendered callback
                        waitForDraw = $$.generateWait();
                        transitionsToWait.forEach(function (t) {
                            waitForDraw.add(t);
                        });
                    }).call(waitForDraw, function () {
                        if (flow) {
                            flow();
                        }
                        if (config.onrendered) {
                            config.onrendered.call($$);
                        }
                    });
                } else {
                    $$.redrawBar(drawBar);
                    $$.redrawLine(drawLine);
                    $$.redrawArea(drawArea);
                    $$.redrawCircle(cx, cy);
                    $$.redrawText(xForText, yForText, options.flow);
                    $$.redrawRegion();
                    $$.redrawGrid();
                    if (config.onrendered) {
                        config.onrendered.call($$);
                    }
                }

                // update fadein condition
                $$.mapToIds($$.data.targets).forEach(function (id) {
                    $$.withoutFadeIn[id] = true;
                });
            };

            c3_chart_internal_fn.updateAndRedraw = function (options) {
                var $$ = this,
                    config = $$.config,
                    transitions;
                options = options || {};
                // same with redraw
                options.withTransition = getOption(options, "withTransition", true);
                options.withTransform = getOption(options, "withTransform", false);
                options.withLegend = getOption(options, "withLegend", false);
                // NOT same with redraw
                options.withUpdateXDomain = true;
                options.withUpdateOrgXDomain = true;
                options.withTransitionForExit = false;
                options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition);
                // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)
                $$.updateSizes();
                // MEMO: called in updateLegend in redraw if withLegend
                if (!(options.withLegend && config.legend_show)) {
                    transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
                    // Update scales
                    $$.updateScales();
                    $$.updateSvgSize();
                    // Update g positions
                    $$.transformAll(options.withTransitionForTransform, transitions);
                }
                // Draw with new sizes & scales
                $$.redraw(options, transitions);
            };
            c3_chart_internal_fn.redrawWithoutRescale = function () {
                this.redraw({
                    withY: false,
                    withSubchart: false,
                    withEventRect: false,
                    withTransitionForAxis: false
                });
            };

            c3_chart_internal_fn.isTimeSeries = function () {
                return this.config.axis_x_type === 'timeseries';
            };
            c3_chart_internal_fn.isCategorized = function () {
                return this.config.axis_x_type.indexOf('categor') >= 0;
            };
            c3_chart_internal_fn.isCustomX = function () {
                var $$ = this,
                    config = $$.config;
                return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
            };

            c3_chart_internal_fn.isTimeSeriesY = function () {
                return this.config.axis_y_type === 'timeseries';
            };

            c3_chart_internal_fn.getTranslate = function (target) {
                var $$ = this,
                    config = $$.config,
                    x,
                    y;
                if (target === 'main') {
                    x = asHalfPixel($$.margin.left);
                    y = asHalfPixel($$.margin.top);
                } else if (target === 'context') {
                    x = asHalfPixel($$.margin2.left);
                    y = asHalfPixel($$.margin2.top);
                } else if (target === 'legend') {
                    x = $$.margin3.left;
                    y = $$.margin3.top;
                } else if (target === 'x') {
                    x = 0;
                    y = config.axis_rotated ? 0 : $$.height;
                } else if (target === 'y') {
                    x = 0;
                    y = config.axis_rotated ? $$.height : 0;
                } else if (target === 'y2') {
                    x = config.axis_rotated ? 0 : $$.width;
                    y = config.axis_rotated ? 1 : 0;
                } else if (target === 'subx') {
                    x = 0;
                    y = config.axis_rotated ? 0 : $$.height2;
                } else if (target === 'arc') {
                    x = $$.arcWidth / 2;
                    y = $$.arcHeight / 2;
                }
                return "translate(" + x + "," + y + ")";
            };
            c3_chart_internal_fn.initialOpacity = function (d) {
                return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
            };
            c3_chart_internal_fn.initialOpacityForCircle = function (d) {
                return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0;
            };
            c3_chart_internal_fn.opacityForCircle = function (d) {
                var opacity = this.config.point_show ? 1 : 0;
                return isValue(d.value) ? this.isScatterType(d) ? 0.5 : opacity : 0;
            };
            c3_chart_internal_fn.opacityForText = function () {
                return this.hasDataLabel() ? 1 : 0;
            };
            c3_chart_internal_fn.xx = function (d) {
                return d ? this.x(d.x) : null;
            };
            c3_chart_internal_fn.xv = function (d) {
                var $$ = this,
                    value = d.value;
                if ($$.isTimeSeries()) {
                    value = $$.parseDate(d.value);
                } else if ($$.isCategorized() && typeof d.value === 'string') {
                    value = $$.config.axis_x_categories.indexOf(d.value);
                }
                return Math.ceil($$.x(value));
            };
            c3_chart_internal_fn.yv = function (d) {
                var $$ = this,
                    yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
                return Math.ceil(yScale(d.value));
            };
            c3_chart_internal_fn.subxx = function (d) {
                return d ? this.subX(d.x) : null;
            };

            c3_chart_internal_fn.transformMain = function (withTransition, transitions) {
                var $$ = this,
                    xAxis,
                    yAxis,
                    y2Axis;
                if (transitions && transitions.axisX) {
                    xAxis = transitions.axisX;
                } else {
                    xAxis = $$.main.select('.' + CLASS.axisX);
                    if (withTransition) {
                        xAxis = xAxis.transition();
                    }
                }
                if (transitions && transitions.axisY) {
                    yAxis = transitions.axisY;
                } else {
                    yAxis = $$.main.select('.' + CLASS.axisY);
                    if (withTransition) {
                        yAxis = yAxis.transition();
                    }
                }
                if (transitions && transitions.axisY2) {
                    y2Axis = transitions.axisY2;
                } else {
                    y2Axis = $$.main.select('.' + CLASS.axisY2);
                    if (withTransition) {
                        y2Axis = y2Axis.transition();
                    }
                }
                (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate('main'));
                xAxis.attr("transform", $$.getTranslate('x'));
                yAxis.attr("transform", $$.getTranslate('y'));
                y2Axis.attr("transform", $$.getTranslate('y2'));
                $$.main.select('.' + CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
            };
            c3_chart_internal_fn.transformAll = function (withTransition, transitions) {
                var $$ = this;
                $$.transformMain(withTransition, transitions);
                if ($$.config.subchart_show) {
                    $$.transformContext(withTransition, transitions);
                }
                if ($$.legend) {
                    $$.transformLegend(withTransition);
                }
            };

            c3_chart_internal_fn.updateSvgSize = function () {
                var $$ = this,
                    brush = $$.svg.select(".c3-brush .background");
                $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
                $$.svg.selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid]).select('rect').attr('width', $$.width).attr('height', $$.height);
                $$.svg.select('#' + $$.clipIdForXAxis).select('rect').attr('x', $$.getXAxisClipX.bind($$)).attr('y', $$.getXAxisClipY.bind($$)).attr('width', $$.getXAxisClipWidth.bind($$)).attr('height', $$.getXAxisClipHeight.bind($$));
                $$.svg.select('#' + $$.clipIdForYAxis).select('rect').attr('x', $$.getYAxisClipX.bind($$)).attr('y', $$.getYAxisClipY.bind($$)).attr('width', $$.getYAxisClipWidth.bind($$)).attr('height', $$.getYAxisClipHeight.bind($$));
                $$.svg.select('#' + $$.clipIdForSubchart).select('rect').attr('width', $$.width).attr('height', brush.size() ? brush.attr('height') : 0);
                $$.svg.select('.' + CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height);
                // MEMO: parent div's height will be bigger than svg when <!DOCTYPE html>
                $$.selectChart.style('max-height', $$.currentHeight + "px");
            };

            c3_chart_internal_fn.updateDimension = function (withoutAxis) {
                var $$ = this;
                if (!withoutAxis) {
                    if ($$.config.axis_rotated) {
                        $$.axes.x.call($$.xAxis);
                        $$.axes.subx.call($$.subXAxis);
                    } else {
                        $$.axes.y.call($$.yAxis);
                        $$.axes.y2.call($$.y2Axis);
                    }
                }
                $$.updateSizes();
                $$.updateScales();
                $$.updateSvgSize();
                $$.transformAll(false);
            };

            c3_chart_internal_fn.observeInserted = function (selection) {
                var $$ = this,
                    observer;
                if (typeof MutationObserver === 'undefined') {
                    window.console.error("MutationObserver not defined.");
                    return;
                }
                observer = new MutationObserver(function (mutations) {
                    mutations.forEach(function (mutation) {
                        if (mutation.type === 'childList' && mutation.previousSibling) {
                            observer.disconnect();
                            // need to wait for completion of load because size calculation requires the actual sizes determined after that completion
                            $$.intervalForObserveInserted = window.setInterval(function () {
                                // parentNode will NOT be null when completed
                                if (selection.node().parentNode) {
                                    window.clearInterval($$.intervalForObserveInserted);
                                    $$.updateDimension();
                                    if ($$.brush) {
                                        $$.brush.update();
                                    }
                                    $$.config.oninit.call($$);
                                    $$.redraw({
                                        withTransform: true,
                                        withUpdateXDomain: true,
                                        withUpdateOrgXDomain: true,
                                        withTransition: false,
                                        withTransitionForTransform: false,
                                        withLegend: true
                                    });
                                    selection.transition().style('opacity', 1);
                                }
                            }, 10);
                        }
                    });
                });
                observer.observe(selection.node(), { attributes: true, childList: true, characterData: true });
            };

            c3_chart_internal_fn.bindResize = function () {
                var $$ = this,
                    config = $$.config;

                $$.resizeFunction = $$.generateResize();

                $$.resizeFunction.add(function () {
                    config.onresize.call($$);
                });
                if (config.resize_auto) {
                    $$.resizeFunction.add(function () {
                        if ($$.resizeTimeout !== undefined) {
                            window.clearTimeout($$.resizeTimeout);
                        }
                        $$.resizeTimeout = window.setTimeout(function () {
                            delete $$.resizeTimeout;
                            $$.api.flush();
                        }, 100);
                    });
                }
                $$.resizeFunction.add(function () {
                    config.onresized.call($$);
                });

                if (window.attachEvent) {
                    window.attachEvent('onresize', $$.resizeFunction);
                } else if (window.addEventListener) {
                    window.addEventListener('resize', $$.resizeFunction, false);
                } else {
                    // fallback to this, if this is a very old browser
                    var wrapper = window.onresize;
                    if (!wrapper) {
                        // create a wrapper that will call all charts
                        wrapper = $$.generateResize();
                    } else if (!wrapper.add || !wrapper.remove) {
                        // there is already a handler registered, make sure we call it too
                        wrapper = $$.generateResize();
                        wrapper.add(window.onresize);
                    }
                    // add this graph to the wrapper, we will be removed if the user calls destroy
                    wrapper.add($$.resizeFunction);
                    window.onresize = wrapper;
                }
            };

            c3_chart_internal_fn.generateResize = function () {
                var resizeFunctions = [];
                function callResizeFunctions() {
                    resizeFunctions.forEach(function (f) {
                        f();
                    });
                }
                callResizeFunctions.add = function (f) {
                    resizeFunctions.push(f);
                };
                callResizeFunctions.remove = function (f) {
                    for (var i = 0; i < resizeFunctions.length; i++) {
                        if (resizeFunctions[i] === f) {
                            resizeFunctions.splice(i, 1);
                            break;
                        }
                    }
                };
                return callResizeFunctions;
            };

            c3_chart_internal_fn.endall = function (transition, callback) {
                var n = 0;
                transition.each(function () {
                    ++n;
                }).each("end", function () {
                    if (! --n) {
                        callback.apply(this, arguments);
                    }
                });
            };
            c3_chart_internal_fn.generateWait = function () {
                var transitionsToWait = [],
                    f = function (transition, callback) {
                    var timer = setInterval(function () {
                        var done = 0;
                        transitionsToWait.forEach(function (t) {
                            if (t.empty()) {
                                done += 1;
                                return;
                            }
                            try {
                                t.transition();
                            } catch (e) {
                                done += 1;
                            }
                        });
                        if (done === transitionsToWait.length) {
                            clearInterval(timer);
                            if (callback) {
                                callback();
                            }
                        }
                    }, 10);
                };
                f.add = function (transition) {
                    transitionsToWait.push(transition);
                };
                return f;
            };

            c3_chart_internal_fn.parseDate = function (date) {
                var $$ = this,
                    parsedDate;
                if (date instanceof Date) {
                    parsedDate = date;
                } else if (typeof date === 'string') {
                    parsedDate = $$.dataTimeFormat($$.config.data_xFormat).parse(date);
                } else if (typeof date === 'number' && !isNaN(date)) {
                    parsedDate = new Date(+date);
                }
                if (!parsedDate || isNaN(+parsedDate)) {
                    window.console.error("Failed to parse x '" + date + "' to Date object");
                }
                return parsedDate;
            };

            c3_chart_internal_fn.isTabVisible = function () {
                var hidden;
                if (typeof document.hidden !== "undefined") {
                    // Opera 12.10 and Firefox 18 and later support
                    hidden = "hidden";
                } else if (typeof document.mozHidden !== "undefined") {
                    hidden = "mozHidden";
                } else if (typeof document.msHidden !== "undefined") {
                    hidden = "msHidden";
                } else if (typeof document.webkitHidden !== "undefined") {
                    hidden = "webkitHidden";
                }

                return document[hidden] ? false : true;
            };

            c3_chart_internal_fn.getDefaultConfig = function () {
                var config = {
                    bindto: '#chart',
                    svg_classname: undefined,
                    size_width: undefined,
                    size_height: undefined,
                    padding_left: undefined,
                    padding_right: undefined,
                    padding_top: undefined,
                    padding_bottom: undefined,
                    resize_auto: true,
                    zoom_enabled: false,
                    zoom_extent: undefined,
                    zoom_privileged: false,
                    zoom_rescale: false,
                    zoom_onzoom: function () {},
                    zoom_onzoomstart: function () {},
                    zoom_onzoomend: function () {},
                    zoom_x_min: undefined,
                    zoom_x_max: undefined,
                    interaction_brighten: true,
                    interaction_enabled: true,
                    onmouseover: function () {},
                    onmouseout: function () {},
                    onresize: function () {},
                    onresized: function () {},
                    oninit: function () {},
                    onrendered: function () {},
                    transition_duration: 350,
                    data_x: undefined,
                    data_xs: {},
                    data_xFormat: '%Y-%m-%d',
                    data_xLocaltime: true,
                    data_xSort: true,
                    data_idConverter: function (id) {
                        return id;
                    },
                    data_names: {},
                    data_classes: {},
                    data_groups: [],
                    data_axes: {},
                    data_type: undefined,
                    data_types: {},
                    data_labels: {},
                    data_order: 'desc',
                    data_regions: {},
                    data_color: undefined,
                    data_colors: {},
                    data_hide: false,
                    data_filter: undefined,
                    data_selection_enabled: false,
                    data_selection_grouped: false,
                    data_selection_isselectable: function () {
                        return true;
                    },
                    data_selection_multiple: true,
                    data_selection_draggable: false,
                    data_onclick: function () {},
                    data_onmouseover: function () {},
                    data_onmouseout: function () {},
                    data_onselected: function () {},
                    data_onunselected: function () {},
                    data_url: undefined,
                    data_headers: undefined,
                    data_json: undefined,
                    data_rows: undefined,
                    data_columns: undefined,
                    data_mimeType: undefined,
                    data_keys: undefined,
                    // configuration for no plot-able data supplied.
                    data_empty_label_text: "",
                    // subchart
                    subchart_show: false,
                    subchart_size_height: 60,
                    subchart_axis_x_show: true,
                    subchart_onbrush: function () {},
                    // color
                    color_pattern: [],
                    color_threshold: {},
                    // legend
                    legend_show: true,
                    legend_hide: false,
                    legend_position: 'bottom',
                    legend_inset_anchor: 'top-left',
                    legend_inset_x: 10,
                    legend_inset_y: 0,
                    legend_inset_step: undefined,
                    legend_item_onclick: undefined,
                    legend_item_onmouseover: undefined,
                    legend_item_onmouseout: undefined,
                    legend_equally: false,
                    legend_padding: 0,
                    legend_item_tile_width: 10,
                    legend_item_tile_height: 10,
                    // axis
                    axis_rotated: false,
                    axis_x_show: true,
                    axis_x_type: 'indexed',
                    axis_x_localtime: true,
                    axis_x_categories: [],
                    axis_x_tick_centered: false,
                    axis_x_tick_format: undefined,
                    axis_x_tick_culling: {},
                    axis_x_tick_culling_max: 10,
                    axis_x_tick_count: undefined,
                    axis_x_tick_fit: true,
                    axis_x_tick_values: null,
                    axis_x_tick_rotate: 0,
                    axis_x_tick_outer: true,
                    axis_x_tick_multiline: true,
                    axis_x_tick_width: null,
                    axis_x_max: undefined,
                    axis_x_min: undefined,
                    axis_x_padding: {},
                    axis_x_height: undefined,
                    axis_x_extent: undefined,
                    axis_x_label: {},
                    axis_y_show: true,
                    axis_y_type: undefined,
                    axis_y_max: undefined,
                    axis_y_min: undefined,
                    axis_y_inverted: false,
                    axis_y_center: undefined,
                    axis_y_inner: undefined,
                    axis_y_label: {},
                    axis_y_tick_format: undefined,
                    axis_y_tick_outer: true,
                    axis_y_tick_values: null,
                    axis_y_tick_rotate: 0,
                    axis_y_tick_count: undefined,
                    axis_y_tick_time_value: undefined,
                    axis_y_tick_time_interval: undefined,
                    axis_y_padding: {},
                    axis_y_default: undefined,
                    axis_y2_show: false,
                    axis_y2_max: undefined,
                    axis_y2_min: undefined,
                    axis_y2_inverted: false,
                    axis_y2_center: undefined,
                    axis_y2_inner: undefined,
                    axis_y2_label: {},
                    axis_y2_tick_format: undefined,
                    axis_y2_tick_outer: true,
                    axis_y2_tick_values: null,
                    axis_y2_tick_count: undefined,
                    axis_y2_padding: {},
                    axis_y2_default: undefined,
                    // grid
                    grid_x_show: false,
                    grid_x_type: 'tick',
                    grid_x_lines: [],
                    grid_y_show: false,
                    // not used
                    // grid_y_type: 'tick',
                    grid_y_lines: [],
                    grid_y_ticks: 10,
                    grid_focus_show: true,
                    grid_lines_front: true,
                    // point - point of each data
                    point_show: true,
                    point_r: 2.5,
                    point_sensitivity: 10,
                    point_focus_expand_enabled: true,
                    point_focus_expand_r: undefined,
                    point_select_r: undefined,
                    // line
                    line_connectNull: false,
                    line_step_type: 'step',
                    // bar
                    bar_width: undefined,
                    bar_width_ratio: 0.6,
                    bar_width_max: undefined,
                    bar_zerobased: true,
                    // area
                    area_zerobased: true,
                    area_above: false,
                    // pie
                    pie_label_show: true,
                    pie_label_format: undefined,
                    pie_label_threshold: 0.05,
                    pie_label_ratio: undefined,
                    pie_expand: {},
                    pie_expand_duration: 50,
                    // gauge
                    gauge_fullCircle: false,
                    gauge_label_show: true,
                    gauge_label_format: undefined,
                    gauge_min: 0,
                    gauge_max: 100,
                    gauge_startingAngle: -1 * Math.PI / 2,
                    gauge_units: undefined,
                    gauge_width: undefined,
                    gauge_expand: {},
                    gauge_expand_duration: 50,
                    // donut
                    donut_label_show: true,
                    donut_label_format: undefined,
                    donut_label_threshold: 0.05,
                    donut_label_ratio: undefined,
                    donut_width: undefined,
                    donut_title: "",
                    donut_expand: {},
                    donut_expand_duration: 50,
                    // spline
                    spline_interpolation_type: 'cardinal',
                    // region - region to change style
                    regions: [],
                    // tooltip - show when mouseover on each data
                    tooltip_show: true,
                    tooltip_grouped: true,
                    tooltip_format_title: undefined,
                    tooltip_format_name: undefined,
                    tooltip_format_value: undefined,
                    tooltip_position: undefined,
                    tooltip_contents: function (d, defaultTitleFormat, defaultValueFormat, color) {
                        return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : '';
                    },
                    tooltip_init_show: false,
                    tooltip_init_x: 0,
                    tooltip_init_position: { top: '0px', left: '50px' },
                    tooltip_onshow: function () {},
                    tooltip_onhide: function () {},
                    // title
                    title_text: undefined,
                    title_padding: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    },
                    title_position: 'top-center'
                };

                Object.keys(this.additionalConfig).forEach(function (key) {
                    config[key] = this.additionalConfig[key];
                }, this);

                return config;
            };
            c3_chart_internal_fn.additionalConfig = {};

            c3_chart_internal_fn.loadConfig = function (config) {
                var this_config = this.config,
                    target,
                    keys,
                    read;
                function find() {
                    var key = keys.shift();
                    //        console.log("key =>", key, ", target =>", target);
                    if (key && target && typeof target === 'object' && key in target) {
                        target = target[key];
                        return find();
                    } else if (!key) {
                        return target;
                    } else {
                        return undefined;
                    }
                }
                Object.keys(this_config).forEach(function (key) {
                    target = config;
                    keys = key.split('_');
                    read = find();
                    //        console.log("CONFIG : ", key, read);
                    if (isDefined(read)) {
                        this_config[key] = read;
                    }
                });
            };

            c3_chart_internal_fn.getScale = function (min, max, forTimeseries) {
                return (forTimeseries ? this.d3.time.scale() : this.d3.scale.linear()).range([min, max]);
            };
            c3_chart_internal_fn.getX = function (min, max, domain, offset) {
                var $$ = this,
                    scale = $$.getScale(min, max, $$.isTimeSeries()),
                    _scale = domain ? scale.domain(domain) : scale,
                    key;
                // Define customized scale if categorized axis
                if ($$.isCategorized()) {
                    offset = offset || function () {
                        return 0;
                    };
                    scale = function (d, raw) {
                        var v = _scale(d) + offset(d);
                        return raw ? v : Math.ceil(v);
                    };
                } else {
                    scale = function (d, raw) {
                        var v = _scale(d);
                        return raw ? v : Math.ceil(v);
                    };
                }
                // define functions
                for (key in _scale) {
                    scale[key] = _scale[key];
                }
                scale.orgDomain = function () {
                    return _scale.domain();
                };
                // define custom domain() for categorized axis
                if ($$.isCategorized()) {
                    scale.domain = function (domain) {
                        if (!arguments.length) {
                            domain = this.orgDomain();
                            return [domain[0], domain[1] + 1];
                        }
                        _scale.domain(domain);
                        return scale;
                    };
                }
                return scale;
            };
            c3_chart_internal_fn.getY = function (min, max, domain) {
                var scale = this.getScale(min, max, this.isTimeSeriesY());
                if (domain) {
                    scale.domain(domain);
                }
                return scale;
            };
            c3_chart_internal_fn.getYScale = function (id) {
                return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
            };
            c3_chart_internal_fn.getSubYScale = function (id) {
                return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
            };
            c3_chart_internal_fn.updateScales = function () {
                var $$ = this,
                    config = $$.config,
                    forInit = !$$.x;
                // update edges
                $$.xMin = config.axis_rotated ? 1 : 0;
                $$.xMax = config.axis_rotated ? $$.height : $$.width;
                $$.yMin = config.axis_rotated ? 0 : $$.height;
                $$.yMax = config.axis_rotated ? $$.width : 1;
                $$.subXMin = $$.xMin;
                $$.subXMax = $$.xMax;
                $$.subYMin = config.axis_rotated ? 0 : $$.height2;
                $$.subYMax = config.axis_rotated ? $$.width2 : 1;
                // update scales
                $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {
                    return $$.xAxis.tickOffset();
                });
                $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain());
                $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain());
                $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {
                    return d % 1 ? 0 : $$.subXAxis.tickOffset();
                });
                $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain());
                $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain());
                // update axes
                $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
                $$.xAxisTickValues = $$.axis.getXAxisTickValues();
                $$.yAxisTickValues = $$.axis.getYAxisTickValues();
                $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();

                $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
                $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
                $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer);
                $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer);

                // Set initialized scales to brush and zoom
                if (!forInit) {
                    if ($$.brush) {
                        $$.brush.scale($$.subX);
                    }
                    if (config.zoom_enabled) {
                        $$.zoom.scale($$.x);
                    }
                }
                // update for arc
                if ($$.updateArc) {
                    $$.updateArc();
                }
            };

            c3_chart_internal_fn.getYDomainMin = function (targets) {
                var $$ = this,
                    config = $$.config,
                    ids = $$.mapToIds(targets),
                    ys = $$.getValuesAsIdKeyed(targets),
                    j,
                    k,
                    baseId,
                    idsInGroup,
                    id,
                    hasNegativeValue;
                if (config.data_groups.length > 0) {
                    hasNegativeValue = $$.hasNegativeValueInTargets(targets);
                    for (j = 0; j < config.data_groups.length; j++) {
                        // Determine baseId
                        idsInGroup = config.data_groups[j].filter(function (id) {
                            return ids.indexOf(id) >= 0;
                        });
                        if (idsInGroup.length === 0) {
                            continue;
                        }
                        baseId = idsInGroup[0];
                        // Consider negative values
                        if (hasNegativeValue && ys[baseId]) {
                            ys[baseId].forEach(function (v, i) {
                                ys[baseId][i] = v < 0 ? v : 0;
                            });
                        }
                        // Compute min
                        for (k = 1; k < idsInGroup.length; k++) {
                            id = idsInGroup[k];
                            if (!ys[id]) {
                                continue;
                            }
                            ys[id].forEach(function (v, i) {
                                if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {
                                    ys[baseId][i] += +v;
                                }
                            });
                        }
                    }
                }
                return $$.d3.min(Object.keys(ys).map(function (key) {
                    return $$.d3.min(ys[key]);
                }));
            };
            c3_chart_internal_fn.getYDomainMax = function (targets) {
                var $$ = this,
                    config = $$.config,
                    ids = $$.mapToIds(targets),
                    ys = $$.getValuesAsIdKeyed(targets),
                    j,
                    k,
                    baseId,
                    idsInGroup,
                    id,
                    hasPositiveValue;
                if (config.data_groups.length > 0) {
                    hasPositiveValue = $$.hasPositiveValueInTargets(targets);
                    for (j = 0; j < config.data_groups.length; j++) {
                        // Determine baseId
                        idsInGroup = config.data_groups[j].filter(function (id) {
                            return ids.indexOf(id) >= 0;
                        });
                        if (idsInGroup.length === 0) {
                            continue;
                        }
                        baseId = idsInGroup[0];
                        // Consider positive values
                        if (hasPositiveValue && ys[baseId]) {
                            ys[baseId].forEach(function (v, i) {
                                ys[baseId][i] = v > 0 ? v : 0;
                            });
                        }
                        // Compute max
                        for (k = 1; k < idsInGroup.length; k++) {
                            id = idsInGroup[k];
                            if (!ys[id]) {
                                continue;
                            }
                            ys[id].forEach(function (v, i) {
                                if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {
                                    ys[baseId][i] += +v;
                                }
                            });
                        }
                    }
                }
                return $$.d3.max(Object.keys(ys).map(function (key) {
                    return $$.d3.max(ys[key]);
                }));
            };
            c3_chart_internal_fn.getYDomain = function (targets, axisId, xDomain) {
                var $$ = this,
                    config = $$.config,
                    targetsByAxisId = targets.filter(function (t) {
                    return $$.axis.getId(t.id) === axisId;
                }),
                    yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
                    yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,
                    yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,
                    yDomainMin = $$.getYDomainMin(yTargets),
                    yDomainMax = $$.getYDomainMax(yTargets),
                    domain,
                    domainLength,
                    padding,
                    padding_top,
                    padding_bottom,
                    center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,
                    yDomainAbs,
                    lengths,
                    diff,
                    ratio,
                    isAllPositive,
                    isAllNegative,
                    isZeroBased = $$.hasType('bar', yTargets) && config.bar_zerobased || $$.hasType('area', yTargets) && config.area_zerobased,
                    isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,
                    showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
                    showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;

                // MEMO: avoid inverting domain unexpectedly
                yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin;
                yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax;

                if (yTargets.length === 0) {
                    // use current domain if target of axisId is none
                    return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
                }
                if (isNaN(yDomainMin)) {
                    // set minimum to zero when not number
                    yDomainMin = 0;
                }
                if (isNaN(yDomainMax)) {
                    // set maximum to have same value as yDomainMin
                    yDomainMax = yDomainMin;
                }
                if (yDomainMin === yDomainMax) {
                    yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;
                }
                isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
                isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;

                // Cancel zerobased if axis_*_min / axis_*_max specified
                if (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) {
                    isZeroBased = false;
                }

                // Bar/Area chart should be 0-based if all positive|negative
                if (isZeroBased) {
                    if (isAllPositive) {
                        yDomainMin = 0;
                    }
                    if (isAllNegative) {
                        yDomainMax = 0;
                    }
                }

                domainLength = Math.abs(yDomainMax - yDomainMin);
                padding = padding_top = padding_bottom = domainLength * 0.1;

                if (typeof center !== 'undefined') {
                    yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
                    yDomainMax = center + yDomainAbs;
                    yDomainMin = center - yDomainAbs;
                }
                // add padding for data label
                if (showHorizontalDataLabel) {
                    lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
                    diff = diffDomain($$.y.range());
                    ratio = [lengths[0] / diff, lengths[1] / diff];
                    padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
                    padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
                } else if (showVerticalDataLabel) {
                    lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
                    padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength);
                    padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength);
                }
                if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
                    padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
                    padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
                }
                if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
                    padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
                    padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
                }
                // Bar/Area chart should be 0-based if all positive|negative
                if (isZeroBased) {
                    if (isAllPositive) {
                        padding_bottom = yDomainMin;
                    }
                    if (isAllNegative) {
                        padding_top = -yDomainMax;
                    }
                }
                domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
                return isInverted ? domain.reverse() : domain;
            };
            c3_chart_internal_fn.getXDomainMin = function (targets) {
                var $$ = this,
                    config = $$.config;
                return isDefined(config.axis_x_min) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_min) : config.axis_x_min : $$.d3.min(targets, function (t) {
                    return $$.d3.min(t.values, function (v) {
                        return v.x;
                    });
                });
            };
            c3_chart_internal_fn.getXDomainMax = function (targets) {
                var $$ = this,
                    config = $$.config;
                return isDefined(config.axis_x_max) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_max) : config.axis_x_max : $$.d3.max(targets, function (t) {
                    return $$.d3.max(t.values, function (v) {
                        return v.x;
                    });
                });
            };
            c3_chart_internal_fn.getXDomainPadding = function (domain) {
                var $$ = this,
                    config = $$.config,
                    diff = domain[1] - domain[0],
                    maxDataCount,
                    padding,
                    paddingLeft,
                    paddingRight;
                if ($$.isCategorized()) {
                    padding = 0;
                } else if ($$.hasType('bar')) {
                    maxDataCount = $$.getMaxDataCount();
                    padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5;
                } else {
                    padding = diff * 0.01;
                }
                if (typeof config.axis_x_padding === 'object' && notEmpty(config.axis_x_padding)) {
                    paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding;
                    paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding;
                } else if (typeof config.axis_x_padding === 'number') {
                    paddingLeft = paddingRight = config.axis_x_padding;
                } else {
                    paddingLeft = paddingRight = padding;
                }
                return { left: paddingLeft, right: paddingRight };
            };
            c3_chart_internal_fn.getXDomain = function (targets) {
                var $$ = this,
                    xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
                    firstX = xDomain[0],
                    lastX = xDomain[1],
                    padding = $$.getXDomainPadding(xDomain),
                    min = 0,
                    max = 0;
                // show center of x domain if min and max are the same
                if (firstX - lastX === 0 && !$$.isCategorized()) {
                    if ($$.isTimeSeries()) {
                        firstX = new Date(firstX.getTime() * 0.5);
                        lastX = new Date(lastX.getTime() * 1.5);
                    } else {
                        firstX = firstX === 0 ? 1 : firstX * 0.5;
                        lastX = lastX === 0 ? -1 : lastX * 1.5;
                    }
                }
                if (firstX || firstX === 0) {
                    min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left;
                }
                if (lastX || lastX === 0) {
                    max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right;
                }
                return [min, max];
            };
            c3_chart_internal_fn.updateXDomain = function (targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
                var $$ = this,
                    config = $$.config;

                if (withUpdateOrgXDomain) {
                    $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
                    $$.orgXDomain = $$.x.domain();
                    if (config.zoom_enabled) {
                        $$.zoom.scale($$.x).updateScaleExtent();
                    }
                    $$.subX.domain($$.x.domain());
                    if ($$.brush) {
                        $$.brush.scale($$.subX);
                    }
                }
                if (withUpdateXDomain) {
                    $$.x.domain(domain ? domain : !$$.brush || $$.brush.empty() ? $$.orgXDomain : $$.brush.extent());
                    if (config.zoom_enabled) {
                        $$.zoom.scale($$.x).updateScaleExtent();
                    }
                }

                // Trim domain when too big by zoom mousemove event
                if (withTrim) {
                    $$.x.domain($$.trimXDomain($$.x.orgDomain()));
                }

                return $$.x.domain();
            };
            c3_chart_internal_fn.trimXDomain = function (domain) {
                var zoomDomain = this.getZoomDomain(),
                    min = zoomDomain[0],
                    max = zoomDomain[1];
                if (domain[0] <= min) {
                    domain[1] = +domain[1] + (min - domain[0]);
                    domain[0] = min;
                }
                if (max <= domain[1]) {
                    domain[0] = +domain[0] - (domain[1] - max);
                    domain[1] = max;
                }
                return domain;
            };

            c3_chart_internal_fn.isX = function (key) {
                var $$ = this,
                    config = $$.config;
                return config.data_x && key === config.data_x || notEmpty(config.data_xs) && hasValue(config.data_xs, key);
            };
            c3_chart_internal_fn.isNotX = function (key) {
                return !this.isX(key);
            };
            c3_chart_internal_fn.getXKey = function (id) {
                var $$ = this,
                    config = $$.config;
                return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
            };
            c3_chart_internal_fn.getXValuesOfXKey = function (key, targets) {
                var $$ = this,
                    xValues,
                    ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
                ids.forEach(function (id) {
                    if ($$.getXKey(id) === key) {
                        xValues = $$.data.xs[id];
                    }
                });
                return xValues;
            };
            c3_chart_internal_fn.getIndexByX = function (x) {
                var $$ = this,
                    data = $$.filterByX($$.data.targets, x);
                return data.length ? data[0].index : null;
            };
            c3_chart_internal_fn.getXValue = function (id, i) {
                var $$ = this;
                return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
            };
            c3_chart_internal_fn.getOtherTargetXs = function () {
                var $$ = this,
                    idsForX = Object.keys($$.data.xs);
                return idsForX.length ? $$.data.xs[idsForX[0]] : null;
            };
            c3_chart_internal_fn.getOtherTargetX = function (index) {
                var xs = this.getOtherTargetXs();
                return xs && index < xs.length ? xs[index] : null;
            };
            c3_chart_internal_fn.addXs = function (xs) {
                var $$ = this;
                Object.keys(xs).forEach(function (id) {
                    $$.config.data_xs[id] = xs[id];
                });
            };
            c3_chart_internal_fn.hasMultipleX = function (xs) {
                return this.d3.set(Object.keys(xs).map(function (id) {
                    return xs[id];
                })).size() > 1;
            };
            c3_chart_internal_fn.isMultipleX = function () {
                return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter');
            };
            c3_chart_internal_fn.addName = function (data) {
                var $$ = this,
                    name;
                if (data) {
                    name = $$.config.data_names[data.id];
                    data.name = name !== undefined ? name : data.id;
                }
                return data;
            };
            c3_chart_internal_fn.getValueOnIndex = function (values, index) {
                var valueOnIndex = values.filter(function (v) {
                    return v.index === index;
                });
                return valueOnIndex.length ? valueOnIndex[0] : null;
            };
            c3_chart_internal_fn.updateTargetX = function (targets, x) {
                var $$ = this;
                targets.forEach(function (t) {
                    t.values.forEach(function (v, i) {
                        v.x = $$.generateTargetX(x[i], t.id, i);
                    });
                    $$.data.xs[t.id] = x;
                });
            };
            c3_chart_internal_fn.updateTargetXs = function (targets, xs) {
                var $$ = this;
                targets.forEach(function (t) {
                    if (xs[t.id]) {
                        $$.updateTargetX([t], xs[t.id]);
                    }
                });
            };
            c3_chart_internal_fn.generateTargetX = function (rawX, id, index) {
                var $$ = this,
                    x;
                if ($$.isTimeSeries()) {
                    x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
                } else if ($$.isCustomX() && !$$.isCategorized()) {
                    x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
                } else {
                    x = index;
                }
                return x;
            };
            c3_chart_internal_fn.cloneTarget = function (target) {
                return {
                    id: target.id,
                    id_org: target.id_org,
                    values: target.values.map(function (d) {
                        return { x: d.x, value: d.value, id: d.id };
                    })
                };
            };
            c3_chart_internal_fn.updateXs = function () {
                var $$ = this;
                if ($$.data.targets.length) {
                    $$.xs = [];
                    $$.data.targets[0].values.forEach(function (v) {
                        $$.xs[v.index] = v.x;
                    });
                }
            };
            c3_chart_internal_fn.getPrevX = function (i) {
                var x = this.xs[i - 1];
                return typeof x !== 'undefined' ? x : null;
            };
            c3_chart_internal_fn.getNextX = function (i) {
                var x = this.xs[i + 1];
                return typeof x !== 'undefined' ? x : null;
            };
            c3_chart_internal_fn.getMaxDataCount = function () {
                var $$ = this;
                return $$.d3.max($$.data.targets, function (t) {
                    return t.values.length;
                });
            };
            c3_chart_internal_fn.getMaxDataCountTarget = function (targets) {
                var length = targets.length,
                    max = 0,
                    maxTarget;
                if (length > 1) {
                    targets.forEach(function (t) {
                        if (t.values.length > max) {
                            maxTarget = t;
                            max = t.values.length;
                        }
                    });
                } else {
                    maxTarget = length ? targets[0] : null;
                }
                return maxTarget;
            };
            c3_chart_internal_fn.getEdgeX = function (targets) {
                var $$ = this;
                return !targets.length ? [0, 0] : [$$.d3.min(targets, function (t) {
                    return t.values[0].x;
                }), $$.d3.max(targets, function (t) {
                    return t.values[t.values.length - 1].x;
                })];
            };
            c3_chart_internal_fn.mapToIds = function (targets) {
                return targets.map(function (d) {
                    return d.id;
                });
            };
            c3_chart_internal_fn.mapToTargetIds = function (ids) {
                var $$ = this;
                return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);
            };
            c3_chart_internal_fn.hasTarget = function (targets, id) {
                var ids = this.mapToIds(targets),
                    i;
                for (i = 0; i < ids.length; i++) {
                    if (ids[i] === id) {
                        return true;
                    }
                }
                return false;
            };
            c3_chart_internal_fn.isTargetToShow = function (targetId) {
                return this.hiddenTargetIds.indexOf(targetId) < 0;
            };
            c3_chart_internal_fn.isLegendToShow = function (targetId) {
                return this.hiddenLegendIds.indexOf(targetId) < 0;
            };
            c3_chart_internal_fn.filterTargetsToShow = function (targets) {
                var $$ = this;
                return targets.filter(function (t) {
                    return $$.isTargetToShow(t.id);
                });
            };
            c3_chart_internal_fn.mapTargetsToUniqueXs = function (targets) {
                var $$ = this;
                var xs = $$.d3.set($$.d3.merge(targets.map(function (t) {
                    return t.values.map(function (v) {
                        return +v.x;
                    });
                }))).values();
                xs = $$.isTimeSeries() ? xs.map(function (x) {
                    return new Date(+x);
                }) : xs.map(function (x) {
                    return +x;
                });
                return xs.sort(function (a, b) {
                    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
                });
            };
            c3_chart_internal_fn.addHiddenTargetIds = function (targetIds) {
                this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
            };
            c3_chart_internal_fn.removeHiddenTargetIds = function (targetIds) {
                this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
            };
            c3_chart_internal_fn.addHiddenLegendIds = function (targetIds) {
                this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
            };
            c3_chart_internal_fn.removeHiddenLegendIds = function (targetIds) {
                this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
            };
            c3_chart_internal_fn.getValuesAsIdKeyed = function (targets) {
                var ys = {};
                targets.forEach(function (t) {
                    ys[t.id] = [];
                    t.values.forEach(function (v) {
                        ys[t.id].push(v.value);
                    });
                });
                return ys;
            };
            c3_chart_internal_fn.checkValueInTargets = function (targets, checker) {
                var ids = Object.keys(targets),
                    i,
                    j,
                    values;
                for (i = 0; i < ids.length; i++) {
                    values = targets[ids[i]].values;
                    for (j = 0; j < values.length; j++) {
                        if (checker(values[j].value)) {
                            return true;
                        }
                    }
                }
                return false;
            };
            c3_chart_internal_fn.hasNegativeValueInTargets = function (targets) {
                return this.checkValueInTargets(targets, function (v) {
                    return v < 0;
                });
            };
            c3_chart_internal_fn.hasPositiveValueInTargets = function (targets) {
                return this.checkValueInTargets(targets, function (v) {
                    return v > 0;
                });
            };
            c3_chart_internal_fn.isOrderDesc = function () {
                var config = this.config;
                return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'desc';
            };
            c3_chart_internal_fn.isOrderAsc = function () {
                var config = this.config;
                return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'asc';
            };
            c3_chart_internal_fn.orderTargets = function (targets) {
                var $$ = this,
                    config = $$.config,
                    orderAsc = $$.isOrderAsc(),
                    orderDesc = $$.isOrderDesc();
                if (orderAsc || orderDesc) {
                    targets.sort(function (t1, t2) {
                        var reducer = function (p, c) {
                            return p + Math.abs(c.value);
                        };
                        var t1Sum = t1.values.reduce(reducer, 0),
                            t2Sum = t2.values.reduce(reducer, 0);
                        return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
                    });
                } else if (isFunction(config.data_order)) {
                    targets.sort(config.data_order);
                } // TODO: accept name array for order
                return targets;
            };
            c3_chart_internal_fn.filterByX = function (targets, x) {
                return this.d3.merge(targets.map(function (t) {
                    return t.values;
                })).filter(function (v) {
                    return v.x - x === 0;
                });
            };
            c3_chart_internal_fn.filterRemoveNull = function (data) {
                return data.filter(function (d) {
                    return isValue(d.value);
                });
            };
            c3_chart_internal_fn.filterByXDomain = function (targets, xDomain) {
                return targets.map(function (t) {
                    return {
                        id: t.id,
                        id_org: t.id_org,
                        values: t.values.filter(function (v) {
                            return xDomain[0] <= v.x && v.x <= xDomain[1];
                        })
                    };
                });
            };
            c3_chart_internal_fn.hasDataLabel = function () {
                var config = this.config;
                if (typeof config.data_labels === 'boolean' && config.data_labels) {
                    return true;
                } else if (typeof config.data_labels === 'object' && notEmpty(config.data_labels)) {
                    return true;
                }
                return false;
            };
            c3_chart_internal_fn.getDataLabelLength = function (min, max, key) {
                var $$ = this,
                    lengths = [0, 0],
                    paddingCoef = 1.3;
                $$.selectChart.select('svg').selectAll('.dummy').data([min, max]).enter().append('text').text(function (d) {
                    return $$.dataLabelFormat(d.id)(d);
                }).each(function (d, i) {
                    lengths[i] = this.getBoundingClientRect()[key] * paddingCoef;
                }).remove();
                return lengths;
            };
            c3_chart_internal_fn.isNoneArc = function (d) {
                return this.hasTarget(this.data.targets, d.id);
            }, c3_chart_internal_fn.isArc = function (d) {
                return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
            };
            c3_chart_internal_fn.findSameXOfValues = function (values, index) {
                var i,
                    targetX = values[index].x,
                    sames = [];
                for (i = index - 1; i >= 0; i--) {
                    if (targetX !== values[i].x) {
                        break;
                    }
                    sames.push(values[i]);
                }
                for (i = index; i < values.length; i++) {
                    if (targetX !== values[i].x) {
                        break;
                    }
                    sames.push(values[i]);
                }
                return sames;
            };

            c3_chart_internal_fn.findClosestFromTargets = function (targets, pos) {
                var $$ = this,
                    candidates;

                // map to array of closest points of each target
                candidates = targets.map(function (target) {
                    return $$.findClosest(target.values, pos);
                });

                // decide closest point and return
                return $$.findClosest(candidates, pos);
            };
            c3_chart_internal_fn.findClosest = function (values, pos) {
                var $$ = this,
                    minDist = $$.config.point_sensitivity,
                    closest;

                // find mouseovering bar
                values.filter(function (v) {
                    return v && $$.isBarType(v.id);
                }).forEach(function (v) {
                    var shape = $$.main.select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index).node();
                    if (!closest && $$.isWithinBar(shape)) {
                        closest = v;
                    }
                });

                // find closest point from non-bar
                values.filter(function (v) {
                    return v && !$$.isBarType(v.id);
                }).forEach(function (v) {
                    var d = $$.dist(v, pos);
                    if (d < minDist) {
                        minDist = d;
                        closest = v;
                    }
                });

                return closest;
            };
            c3_chart_internal_fn.dist = function (data, pos) {
                var $$ = this,
                    config = $$.config,
                    xIndex = config.axis_rotated ? 1 : 0,
                    yIndex = config.axis_rotated ? 0 : 1,
                    y = $$.circleY(data, data.index),
                    x = $$.x(data.x);
                return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
            };
            c3_chart_internal_fn.convertValuesToStep = function (values) {
                var converted = [].concat(values),
                    i;

                if (!this.isCategorized()) {
                    return values;
                }

                for (i = values.length + 1; 0 < i; i--) {
                    converted[i] = converted[i - 1];
                }

                converted[0] = {
                    x: converted[0].x - 1,
                    value: converted[0].value,
                    id: converted[0].id
                };
                converted[values.length + 1] = {
                    x: converted[values.length].x + 1,
                    value: converted[values.length].value,
                    id: converted[values.length].id
                };

                return converted;
            };
            c3_chart_internal_fn.updateDataAttributes = function (name, attrs) {
                var $$ = this,
                    config = $$.config,
                    current = config['data_' + name];
                if (typeof attrs === 'undefined') {
                    return current;
                }
                Object.keys(attrs).forEach(function (id) {
                    current[id] = attrs[id];
                });
                $$.redraw({ withLegend: true });
                return current;
            };

            c3_chart_internal_fn.convertUrlToData = function (url, mimeType, headers, keys, done) {
                var $$ = this,
                    type = mimeType ? mimeType : 'csv';
                var req = $$.d3.xhr(url);
                if (headers) {
                    Object.keys(headers).forEach(function (header) {
                        req.header(header, headers[header]);
                    });
                }
                req.get(function (error, data) {
                    var d;
                    if (!data) {
                        throw new Error(error.responseURL + ' ' + error.status + ' (' + error.statusText + ')');
                    }
                    if (type === 'json') {
                        d = $$.convertJsonToData(JSON.parse(data.response), keys);
                    } else if (type === 'tsv') {
                        d = $$.convertTsvToData(data.response);
                    } else {
                        d = $$.convertCsvToData(data.response);
                    }
                    done.call($$, d);
                });
            };
            c3_chart_internal_fn.convertXsvToData = function (xsv, parser) {
                var rows = parser.parseRows(xsv),
                    d;
                if (rows.length === 1) {
                    d = [{}];
                    rows[0].forEach(function (id) {
                        d[0][id] = null;
                    });
                } else {
                    d = parser.parse(xsv);
                }
                return d;
            };
            c3_chart_internal_fn.convertCsvToData = function (csv) {
                return this.convertXsvToData(csv, this.d3.csv);
            };
            c3_chart_internal_fn.convertTsvToData = function (tsv) {
                return this.convertXsvToData(tsv, this.d3.tsv);
            };
            c3_chart_internal_fn.convertJsonToData = function (json, keys) {
                var $$ = this,
                    new_rows = [],
                    targetKeys,
                    data;
                if (keys) {
                    // when keys specified, json would be an array that includes objects
                    if (keys.x) {
                        targetKeys = keys.value.concat(keys.x);
                        $$.config.data_x = keys.x;
                    } else {
                        targetKeys = keys.value;
                    }
                    new_rows.push(targetKeys);
                    json.forEach(function (o) {
                        var new_row = [];
                        targetKeys.forEach(function (key) {
                            // convert undefined to null because undefined data will be removed in convertDataToTargets()
                            var v = $$.findValueInJson(o, key);
                            if (isUndefined(v)) {
                                v = null;
                            }
                            new_row.push(v);
                        });
                        new_rows.push(new_row);
                    });
                    data = $$.convertRowsToData(new_rows);
                } else {
                    Object.keys(json).forEach(function (key) {
                        new_rows.push([key].concat(json[key]));
                    });
                    data = $$.convertColumnsToData(new_rows);
                }
                return data;
            };
            c3_chart_internal_fn.findValueInJson = function (object, path) {
                path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties (replace [] with .)
                path = path.replace(/^\./, ''); // strip a leading dot
                var pathArray = path.split('.');
                for (var i = 0; i < pathArray.length; ++i) {
                    var k = pathArray[i];
                    if (k in object) {
                        object = object[k];
                    } else {
                        return;
                    }
                }
                return object;
            };
            c3_chart_internal_fn.convertRowsToData = function (rows) {
                var keys = rows[0],
                    new_row = {},
                    new_rows = [],
                    i,
                    j;
                for (i = 1; i < rows.length; i++) {
                    new_row = {};
                    for (j = 0; j < rows[i].length; j++) {
                        if (isUndefined(rows[i][j])) {
                            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
                        }
                        new_row[keys[j]] = rows[i][j];
                    }
                    new_rows.push(new_row);
                }
                return new_rows;
            };
            c3_chart_internal_fn.convertColumnsToData = function (columns) {
                var new_rows = [],
                    i,
                    j,
                    key;
                for (i = 0; i < columns.length; i++) {
                    key = columns[i][0];
                    for (j = 1; j < columns[i].length; j++) {
                        if (isUndefined(new_rows[j - 1])) {
                            new_rows[j - 1] = {};
                        }
                        if (isUndefined(columns[i][j])) {
                            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
                        }
                        new_rows[j - 1][key] = columns[i][j];
                    }
                }
                return new_rows;
            };
            c3_chart_internal_fn.convertDataToTargets = function (data, appendXs) {
                var $$ = this,
                    config = $$.config,
                    ids = $$.d3.keys(data[0]).filter($$.isNotX, $$),
                    xs = $$.d3.keys(data[0]).filter($$.isX, $$),
                    targets;

                // save x for update data by load when custom x and c3.x API
                ids.forEach(function (id) {
                    var xKey = $$.getXKey(id);

                    if ($$.isCustomX() || $$.isTimeSeries()) {
                        // if included in input data
                        if (xs.indexOf(xKey) >= 0) {
                            $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function (d) {
                                return d[xKey];
                            }).filter(isValue).map(function (rawX, i) {
                                return $$.generateTargetX(rawX, id, i);
                            }));
                        }
                        // if not included in input data, find from preloaded data of other id's x
                        else if (config.data_x) {
                                $$.data.xs[id] = $$.getOtherTargetXs();
                            }
                            // if not included in input data, find from preloaded data
                            else if (notEmpty(config.data_xs)) {
                                    $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
                                }
                        // MEMO: if no x included, use same x of current will be used
                    } else {
                        $$.data.xs[id] = data.map(function (d, i) {
                            return i;
                        });
                    }
                });

                // check x is defined
                ids.forEach(function (id) {
                    if (!$$.data.xs[id]) {
                        throw new Error('x is not defined for id = "' + id + '".');
                    }
                });

                // convert to target
                targets = ids.map(function (id, index) {
                    var convertedId = config.data_idConverter(id);
                    return {
                        id: convertedId,
                        id_org: id,
                        values: data.map(function (d, i) {
                            var xKey = $$.getXKey(id),
                                rawX = d[xKey],
                                value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null,
                                x;
                            // use x as categories if custom x and categorized
                            if ($$.isCustomX() && $$.isCategorized() && index === 0 && !isUndefined(rawX)) {
                                if (index === 0 && i === 0) {
                                    config.axis_x_categories = [];
                                }
                                x = config.axis_x_categories.indexOf(rawX);
                                if (x === -1) {
                                    x = config.axis_x_categories.length;
                                    config.axis_x_categories.push(rawX);
                                }
                            } else {
                                x = $$.generateTargetX(rawX, id, i);
                            }
                            // mark as x = undefined if value is undefined and filter to remove after mapped
                            if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
                                x = undefined;
                            }
                            return { x: x, value: value, id: convertedId };
                        }).filter(function (v) {
                            return isDefined(v.x);
                        })
                    };
                });

                // finish targets
                targets.forEach(function (t) {
                    var i;
                    // sort values by its x
                    if (config.data_xSort) {
                        t.values = t.values.sort(function (v1, v2) {
                            var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
                                x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
                            return x1 - x2;
                        });
                    }
                    // indexing each value
                    i = 0;
                    t.values.forEach(function (v) {
                        v.index = i++;
                    });
                    // this needs to be sorted because its index and value.index is identical
                    $$.data.xs[t.id].sort(function (v1, v2) {
                        return v1 - v2;
                    });
                });

                // cache information about values
                $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);
                $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets);

                // set target types
                if (config.data_type) {
                    $$.setTargetType($$.mapToIds(targets).filter(function (id) {
                        return !(id in config.data_types);
                    }), config.data_type);
                }

                // cache as original id keyed
                targets.forEach(function (d) {
                    $$.addCache(d.id_org, d);
                });

                return targets;
            };

            c3_chart_internal_fn.load = function (targets, args) {
                var $$ = this;
                if (targets) {
                    // filter loading targets if needed
                    if (args.filter) {
                        targets = targets.filter(args.filter);
                    }
                    // set type if args.types || args.type specified
                    if (args.type || args.types) {
                        targets.forEach(function (t) {
                            var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
                            $$.setTargetType(t.id, type);
                        });
                    }
                    // Update/Add data
                    $$.data.targets.forEach(function (d) {
                        for (var i = 0; i < targets.length; i++) {
                            if (d.id === targets[i].id) {
                                d.values = targets[i].values;
                                targets.splice(i, 1);
                                break;
                            }
                        }
                    });
                    $$.data.targets = $$.data.targets.concat(targets); // add remained
                }

                // Set targets
                $$.updateTargets($$.data.targets);

                // Redraw with new targets
                $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });

                if (args.done) {
                    args.done();
                }
            };
            c3_chart_internal_fn.loadFromArgs = function (args) {
                var $$ = this;
                if (args.data) {
                    $$.load($$.convertDataToTargets(args.data), args);
                } else if (args.url) {
                    $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {
                        $$.load($$.convertDataToTargets(data), args);
                    });
                } else if (args.json) {
                    $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
                } else if (args.rows) {
                    $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
                } else if (args.columns) {
                    $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
                } else {
                    $$.load(null, args);
                }
            };
            c3_chart_internal_fn.unload = function (targetIds, done) {
                var $$ = this;
                if (!done) {
                    done = function () {};
                }
                // filter existing target
                targetIds = targetIds.filter(function (id) {
                    return $$.hasTarget($$.data.targets, id);
                });
                // If no target, call done and return
                if (!targetIds || targetIds.length === 0) {
                    done();
                    return;
                }
                $$.svg.selectAll(targetIds.map(function (id) {
                    return $$.selectorTarget(id);
                })).transition().style('opacity', 0).remove().call($$.endall, done);
                targetIds.forEach(function (id) {
                    // Reset fadein for future load
                    $$.withoutFadeIn[id] = false;
                    // Remove target's elements
                    if ($$.legend) {
                        $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove();
                    }
                    // Remove target
                    $$.data.targets = $$.data.targets.filter(function (t) {
                        return t.id !== id;
                    });
                });
            };

            c3_chart_internal_fn.categoryName = function (i) {
                var config = this.config;
                return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
            };

            c3_chart_internal_fn.initEventRect = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.eventRects).style('fill-opacity', 0);
            };
            c3_chart_internal_fn.redrawEventRect = function () {
                var $$ = this,
                    config = $$.config,
                    eventRectUpdate,
                    maxDataCountTarget,
                    isMultipleX = $$.isMultipleX();

                // rects for mouseover
                var eventRects = $$.main.select('.' + CLASS.eventRects).style('cursor', config.zoom_enabled ? config.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(CLASS.eventRectsMultiple, isMultipleX).classed(CLASS.eventRectsSingle, !isMultipleX);

                // clear old rects
                eventRects.selectAll('.' + CLASS.eventRect).remove();

                // open as public variable
                $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);

                if (isMultipleX) {
                    eventRectUpdate = $$.eventRect.data([0]);
                    // enter : only one rect will be added
                    $$.generateEventRectsForMultipleXs(eventRectUpdate.enter());
                    // update
                    $$.updateEventRect(eventRectUpdate);
                    // exit : not needed because always only one rect exists
                } else {
                    // Set data and update $$.eventRect
                    maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
                    eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []);
                    $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
                    eventRectUpdate = $$.eventRect.data(function (d) {
                        return d;
                    });
                    // enter
                    $$.generateEventRectsForSingleX(eventRectUpdate.enter());
                    // update
                    $$.updateEventRect(eventRectUpdate);
                    // exit
                    eventRectUpdate.exit().remove();
                }
            };
            c3_chart_internal_fn.updateEventRect = function (eventRectUpdate) {
                var $$ = this,
                    config = $$.config,
                    x,
                    y,
                    w,
                    h,
                    rectW,
                    rectX;

                // set update selection if null
                eventRectUpdate = eventRectUpdate || $$.eventRect.data(function (d) {
                    return d;
                });

                if ($$.isMultipleX()) {
                    // TODO: rotated not supported yet
                    x = 0;
                    y = 0;
                    w = $$.width;
                    h = $$.height;
                } else {
                    if (($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized()) {

                        // update index for x that is used by prevX and nextX
                        $$.updateXs();

                        rectW = function (d) {
                            var prevX = $$.getPrevX(d.index),
                                nextX = $$.getNextX(d.index);

                            // if there this is a single data point make the eventRect full width (or height)
                            if (prevX === null && nextX === null) {
                                return config.axis_rotated ? $$.height : $$.width;
                            }

                            if (prevX === null) {
                                prevX = $$.x.domain()[0];
                            }
                            if (nextX === null) {
                                nextX = $$.x.domain()[1];
                            }

                            return Math.max(0, ($$.x(nextX) - $$.x(prevX)) / 2);
                        };
                        rectX = function (d) {
                            var prevX = $$.getPrevX(d.index),
                                nextX = $$.getNextX(d.index),
                                thisX = $$.data.xs[d.id][d.index];

                            // if there this is a single data point position the eventRect at 0
                            if (prevX === null && nextX === null) {
                                return 0;
                            }

                            if (prevX === null) {
                                prevX = $$.x.domain()[0];
                            }

                            return ($$.x(thisX) + $$.x(prevX)) / 2;
                        };
                    } else {
                        rectW = $$.getEventRectWidth();
                        rectX = function (d) {
                            return $$.x(d.x) - rectW / 2;
                        };
                    }
                    x = config.axis_rotated ? 0 : rectX;
                    y = config.axis_rotated ? rectX : 0;
                    w = config.axis_rotated ? $$.width : rectW;
                    h = config.axis_rotated ? rectW : $$.height;
                }

                eventRectUpdate.attr('class', $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
            };
            c3_chart_internal_fn.generateEventRectsForSingleX = function (eventRectEnter) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;
                eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on('mouseover', function (d) {
                    var index = d.index;

                    if ($$.dragging || $$.flowing) {
                        return;
                    } // do nothing while dragging/flowing
                    if ($$.hasArcType()) {
                        return;
                    }

                    // Expand shapes for selection
                    if (config.point_focus_expand_enabled) {
                        $$.expandCircles(index, null, true);
                    }
                    $$.expandBars(index, null, true);

                    // Call event handler
                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                        config.data_onmouseover.call($$.api, d);
                    });
                }).on('mouseout', function (d) {
                    var index = d.index;
                    if (!$$.config) {
                        return;
                    } // chart is destroyed
                    if ($$.hasArcType()) {
                        return;
                    }
                    $$.hideXGridFocus();
                    $$.hideTooltip();
                    // Undo expanded shapes
                    $$.unexpandCircles();
                    $$.unexpandBars();
                    // Call event handler
                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                        config.data_onmouseout.call($$.api, d);
                    });
                }).on('mousemove', function (d) {
                    var selectedData,
                        index = d.index,
                        eventRect = $$.svg.select('.' + CLASS.eventRect + '-' + index);

                    if ($$.dragging || $$.flowing) {
                        return;
                    } // do nothing while dragging/flowing
                    if ($$.hasArcType()) {
                        return;
                    }

                    if ($$.isStepType(d) && $$.config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
                        index -= 1;
                    }

                    // Show tooltip
                    selectedData = $$.filterTargetsToShow($$.data.targets).map(function (t) {
                        return $$.addName($$.getValueOnIndex(t.values, index));
                    });

                    if (config.tooltip_grouped) {
                        $$.showTooltip(selectedData, this);
                        $$.showXGridFocus(selectedData);
                    }

                    if (config.tooltip_grouped && (!config.data_selection_enabled || config.data_selection_grouped)) {
                        return;
                    }

                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function () {
                        d3.select(this).classed(CLASS.EXPANDED, true);
                        if (config.data_selection_enabled) {
                            eventRect.style('cursor', config.data_selection_grouped ? 'pointer' : null);
                        }
                        if (!config.tooltip_grouped) {
                            $$.hideXGridFocus();
                            $$.hideTooltip();
                            if (!config.data_selection_grouped) {
                                $$.unexpandCircles(index);
                                $$.unexpandBars(index);
                            }
                        }
                    }).filter(function (d) {
                        return $$.isWithinShape(this, d);
                    }).each(function (d) {
                        if (config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d))) {
                            eventRect.style('cursor', 'pointer');
                        }
                        if (!config.tooltip_grouped) {
                            $$.showTooltip([d], this);
                            $$.showXGridFocus([d]);
                            if (config.point_focus_expand_enabled) {
                                $$.expandCircles(index, d.id, true);
                            }
                            $$.expandBars(index, d.id, true);
                        }
                    });
                }).on('click', function (d) {
                    var index = d.index;
                    if ($$.hasArcType() || !$$.toggleShape) {
                        return;
                    }
                    if ($$.cancelClick) {
                        $$.cancelClick = false;
                        return;
                    }
                    if ($$.isStepType(d) && config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
                        index -= 1;
                    }
                    $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                        if (config.data_selection_grouped || $$.isWithinShape(this, d)) {
                            $$.toggleShape(this, d, index);
                            $$.config.data_onclick.call($$.api, d, this);
                        }
                    });
                }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {
                    $$.drag(d3.mouse(this));
                }).on('dragstart', function () {
                    $$.dragstart(d3.mouse(this));
                }).on('dragend', function () {
                    $$.dragend();
                }) : function () {});
            };

            c3_chart_internal_fn.generateEventRectsForMultipleXs = function (eventRectEnter) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;

                function mouseout() {
                    $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
                    $$.hideXGridFocus();
                    $$.hideTooltip();
                    $$.unexpandCircles();
                    $$.unexpandBars();
                }

                eventRectEnter.append('rect').attr('x', 0).attr('y', 0).attr('width', $$.width).attr('height', $$.height).attr('class', CLASS.eventRect).on('mouseout', function () {
                    if (!$$.config) {
                        return;
                    } // chart is destroyed
                    if ($$.hasArcType()) {
                        return;
                    }
                    mouseout();
                }).on('mousemove', function () {
                    var targetsToShow = $$.filterTargetsToShow($$.data.targets);
                    var mouse, closest, sameXData, selectedData;

                    if ($$.dragging) {
                        return;
                    } // do nothing when dragging
                    if ($$.hasArcType(targetsToShow)) {
                        return;
                    }

                    mouse = d3.mouse(this);
                    closest = $$.findClosestFromTargets(targetsToShow, mouse);

                    if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {
                        config.data_onmouseout.call($$.api, $$.mouseover);
                        $$.mouseover = undefined;
                    }

                    if (!closest) {
                        mouseout();
                        return;
                    }

                    if ($$.isScatterType(closest) || !config.tooltip_grouped) {
                        sameXData = [closest];
                    } else {
                        sameXData = $$.filterByX(targetsToShow, closest.x);
                    }

                    // show tooltip when cursor is close to some point
                    selectedData = sameXData.map(function (d) {
                        return $$.addName(d);
                    });
                    $$.showTooltip(selectedData, this);

                    // expand points
                    if (config.point_focus_expand_enabled) {
                        $$.expandCircles(closest.index, closest.id, true);
                    }
                    $$.expandBars(closest.index, closest.id, true);

                    // Show xgrid focus line
                    $$.showXGridFocus(selectedData);

                    // Show cursor as pointer if point is close to mouse position
                    if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
                        $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer');
                        if (!$$.mouseover) {
                            config.data_onmouseover.call($$.api, closest);
                            $$.mouseover = closest;
                        }
                    }
                }).on('click', function () {
                    var targetsToShow = $$.filterTargetsToShow($$.data.targets);
                    var mouse, closest;
                    if ($$.hasArcType(targetsToShow)) {
                        return;
                    }

                    mouse = d3.mouse(this);
                    closest = $$.findClosestFromTargets(targetsToShow, mouse);
                    if (!closest) {
                        return;
                    }
                    // select if selection enabled
                    if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
                        $$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll('.' + CLASS.shape + '-' + closest.index).each(function () {
                            if (config.data_selection_grouped || $$.isWithinShape(this, closest)) {
                                $$.toggleShape(this, closest, closest.index);
                                $$.config.data_onclick.call($$.api, closest, this);
                            }
                        });
                    }
                }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {
                    $$.drag(d3.mouse(this));
                }).on('dragstart', function () {
                    $$.dragstart(d3.mouse(this));
                }).on('dragend', function () {
                    $$.dragend();
                }) : function () {});
            };
            c3_chart_internal_fn.dispatchEvent = function (type, index, mouse) {
                var $$ = this,
                    selector = '.' + CLASS.eventRect + (!$$.isMultipleX() ? '-' + index : ''),
                    eventRect = $$.main.select(selector).node(),
                    box = eventRect.getBoundingClientRect(),
                    x = box.left + (mouse ? mouse[0] : 0),
                    y = box.top + (mouse ? mouse[1] : 0),
                    event = document.createEvent("MouseEvents");

                event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
                eventRect.dispatchEvent(event);
            };

            c3_chart_internal_fn.getCurrentWidth = function () {
                var $$ = this,
                    config = $$.config;
                return config.size_width ? config.size_width : $$.getParentWidth();
            };
            c3_chart_internal_fn.getCurrentHeight = function () {
                var $$ = this,
                    config = $$.config,
                    h = config.size_height ? config.size_height : $$.getParentHeight();
                return h > 0 ? h : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1);
            };
            c3_chart_internal_fn.getCurrentPaddingTop = function () {
                var $$ = this,
                    config = $$.config,
                    padding = isValue(config.padding_top) ? config.padding_top : 0;
                if ($$.title && $$.title.node()) {
                    padding += $$.getTitlePadding();
                }
                return padding;
            };
            c3_chart_internal_fn.getCurrentPaddingBottom = function () {
                var config = this.config;
                return isValue(config.padding_bottom) ? config.padding_bottom : 0;
            };
            c3_chart_internal_fn.getCurrentPaddingLeft = function (withoutRecompute) {
                var $$ = this,
                    config = $$.config;
                if (isValue(config.padding_left)) {
                    return config.padding_left;
                } else if (config.axis_rotated) {
                    return !config.axis_x_show ? 1 : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
                } else if (!config.axis_y_show || config.axis_y_inner) {
                    // && !config.axis_rotated
                    return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
                } else {
                    return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
                }
            };
            c3_chart_internal_fn.getCurrentPaddingRight = function () {
                var $$ = this,
                    config = $$.config,
                    defaultPadding = 10,
                    legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
                if (isValue(config.padding_right)) {
                    return config.padding_right + 1; // 1 is needed not to hide tick line
                } else if (config.axis_rotated) {
                    return defaultPadding + legendWidthOnRight;
                } else if (!config.axis_y2_show || config.axis_y2_inner) {
                    // && !config.axis_rotated
                    return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
                } else {
                    return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
                }
            };

            c3_chart_internal_fn.getParentRectValue = function (key) {
                var parent = this.selectChart.node(),
                    v;
                while (parent && parent.tagName !== 'BODY') {
                    try {
                        v = parent.getBoundingClientRect()[key];
                    } catch (e) {
                        if (key === 'width') {
                            // In IE in certain cases getBoundingClientRect
                            // will cause an "unspecified error"
                            v = parent.offsetWidth;
                        }
                    }
                    if (v) {
                        break;
                    }
                    parent = parent.parentNode;
                }
                return v;
            };
            c3_chart_internal_fn.getParentWidth = function () {
                return this.getParentRectValue('width');
            };
            c3_chart_internal_fn.getParentHeight = function () {
                var h = this.selectChart.style('height');
                return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
            };

            c3_chart_internal_fn.getSvgLeft = function (withoutRecompute) {
                var $$ = this,
                    config = $$.config,
                    hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
                    leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,
                    leftAxis = $$.main.select('.' + leftAxisClass).node(),
                    svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : { right: 0 },
                    chartRect = $$.selectChart.node().getBoundingClientRect(),
                    hasArc = $$.hasArcType(),
                    svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
                return svgLeft > 0 ? svgLeft : 0;
            };

            c3_chart_internal_fn.getAxisWidthByAxisId = function (id, withoutRecompute) {
                var $$ = this,
                    position = $$.axis.getLabelPositionById(id);
                return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
            };
            c3_chart_internal_fn.getHorizontalAxisHeight = function (axisId) {
                var $$ = this,
                    config = $$.config,
                    h = 30;
                if (axisId === 'x' && !config.axis_x_show) {
                    return 8;
                }
                if (axisId === 'x' && config.axis_x_height) {
                    return config.axis_x_height;
                }
                if (axisId === 'y' && !config.axis_y_show) {
                    return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
                }
                if (axisId === 'y2' && !config.axis_y2_show) {
                    return $$.rotated_padding_top;
                }
                // Calculate x axis height when tick rotated
                if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
                    h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180);
                }
                // Calculate y axis height when tick rotated
                if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {
                    h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_y_tick_rotate) / 180);
                }
                return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0);
            };

            c3_chart_internal_fn.getEventRectWidth = function () {
                return Math.max(0, this.xAxis.tickInterval());
            };

            c3_chart_internal_fn.getShapeIndices = function (typeFilter) {
                var $$ = this,
                    config = $$.config,
                    indices = {},
                    i = 0,
                    j,
                    k;
                $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
                    for (j = 0; j < config.data_groups.length; j++) {
                        if (config.data_groups[j].indexOf(d.id) < 0) {
                            continue;
                        }
                        for (k = 0; k < config.data_groups[j].length; k++) {
                            if (config.data_groups[j][k] in indices) {
                                indices[d.id] = indices[config.data_groups[j][k]];
                                break;
                            }
                        }
                    }
                    if (isUndefined(indices[d.id])) {
                        indices[d.id] = i++;
                    }
                });
                indices.__max__ = i - 1;
                return indices;
            };
            c3_chart_internal_fn.getShapeX = function (offset, targetsNum, indices, isSub) {
                var $$ = this,
                    scale = isSub ? $$.subX : $$.x;
                return function (d) {
                    var index = d.id in indices ? indices[d.id] : 0;
                    return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
                };
            };
            c3_chart_internal_fn.getShapeY = function (isSub) {
                var $$ = this;
                return function (d) {
                    var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
                    return scale(d.value);
                };
            };
            c3_chart_internal_fn.getShapeOffset = function (typeFilter, indices, isSub) {
                var $$ = this,
                    targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
                    targetIds = targets.map(function (t) {
                    return t.id;
                });
                return function (d, i) {
                    var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
                        y0 = scale(0),
                        offset = y0;
                    targets.forEach(function (t) {
                        var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;
                        if (t.id === d.id || indices[t.id] !== indices[d.id]) {
                            return;
                        }
                        if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
                            // check if the x values line up
                            if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {
                                // "+" for timeseries
                                // if not, try to find the value that does line up
                                i = -1;
                                values.forEach(function (v, j) {
                                    if (v.x === d.x) {
                                        i = j;
                                    }
                                });
                            }
                            if (i in values && values[i].value * d.value >= 0) {
                                offset += scale(values[i].value) - y0;
                            }
                        }
                    });
                    return offset;
                };
            };
            c3_chart_internal_fn.isWithinShape = function (that, d) {
                var $$ = this,
                    shape = $$.d3.select(that),
                    isWithin;
                if (!$$.isTargetToShow(d.id)) {
                    isWithin = false;
                } else if (that.nodeName === 'circle') {
                    isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
                } else if (that.nodeName === 'path') {
                    isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;
                }
                return isWithin;
            };

            c3_chart_internal_fn.getInterpolate = function (d) {
                var $$ = this,
                    interpolation = $$.isInterpolationType($$.config.spline_interpolation_type) ? $$.config.spline_interpolation_type : 'cardinal';
                return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
            };

            c3_chart_internal_fn.initLine = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
            };
            c3_chart_internal_fn.updateTargetsForLine = function (targets) {
                var $$ = this,
                    config = $$.config,
                    mainLineUpdate,
                    mainLineEnter,
                    classChartLine = $$.classChartLine.bind($$),
                    classLines = $$.classLines.bind($$),
                    classAreas = $$.classAreas.bind($$),
                    classCircles = $$.classCircles.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainLineUpdate = $$.main.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', function (d) {
                    return classChartLine(d) + classFocus(d);
                });
                mainLineEnter = mainLineUpdate.enter().append('g').attr('class', classChartLine).style('opacity', 0).style("pointer-events", "none");
                // Lines for each data
                mainLineEnter.append('g').attr("class", classLines);
                // Areas
                mainLineEnter.append('g').attr('class', classAreas);
                // Circles for each data point on lines
                mainLineEnter.append('g').attr("class", function (d) {
                    return $$.generateClass(CLASS.selectedCircles, d.id);
                });
                mainLineEnter.append('g').attr("class", classCircles).style("cursor", function (d) {
                    return config.data_selection_isselectable(d) ? "pointer" : null;
                });
                // Update date for selected circles
                targets.forEach(function (t) {
                    $$.main.selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll('.' + CLASS.selectedCircle).each(function (d) {
                        d.value = t.values[d.index].value;
                    });
                });
                // MEMO: can not keep same color...
                //mainLineUpdate.exit().remove();
            };
            c3_chart_internal_fn.updateLine = function (durationForExit) {
                var $$ = this;
                $$.mainLine = $$.main.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
                $$.mainLine.enter().append('path').attr('class', $$.classLine.bind($$)).style("stroke", $$.color);
                $$.mainLine.style("opacity", $$.initialOpacity.bind($$)).style('shape-rendering', function (d) {
                    return $$.isStepType(d) ? 'crispEdges' : '';
                }).attr('transform', null);
                $$.mainLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawLine = function (drawLine, withTransition) {
                return [(withTransition ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", 1)];
            };
            c3_chart_internal_fn.generateDrawLine = function (lineIndices, isSub) {
                var $$ = this,
                    config = $$.config,
                    line = $$.d3.svg.line(),
                    getPoints = $$.generateGetLinePoints(lineIndices, isSub),
                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                    xValue = function (d) {
                    return (isSub ? $$.subxx : $$.xx).call($$, d);
                },
                    yValue = function (d, i) {
                    return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
                };

                line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
                if (!config.line_connectNull) {
                    line = line.defined(function (d) {
                        return d.value != null;
                    });
                }
                return function (d) {
                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                        x = isSub ? $$.x : $$.subX,
                        y = yScaleGetter.call($$, d.id),
                        x0 = 0,
                        y0 = 0,
                        path;
                    if ($$.isLineType(d)) {
                        if (config.data_regions[d.id]) {
                            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                        } else {
                            if ($$.isStepType(d)) {
                                values = $$.convertValuesToStep(values);
                            }
                            path = line.interpolate($$.getInterpolate(d))(values);
                        }
                    } else {
                        if (values[0]) {
                            x0 = x(values[0].x);
                            y0 = y(values[0].value);
                        }
                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                    }
                    return path ? path : "M 0 0";
                };
            };
            c3_chart_internal_fn.generateGetLinePoints = function (lineIndices, isSub) {
                // partial duplication of generateGetBarPoints
                var $$ = this,
                    config = $$.config,
                    lineTargetsNum = lineIndices.__max__ + 1,
                    x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),
                    y = $$.getShapeY(!!isSub),
                    lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),
                    yScale = isSub ? $$.getSubYScale : $$.getYScale;
                return function (d, i) {
                    var y0 = yScale.call($$, d.id)(0),
                        offset = lineOffset(d, i) || y0,
                        // offset is for stacked area chart
                    posX = x(d),
                        posY = y(d);
                    // fix posY not to overflow opposite quadrant
                    if (config.axis_rotated) {
                        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                            posY = y0;
                        }
                    }
                    // 1 point that marks the line position
                    return [[posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
                    [posX, posY - (y0 - offset)], // needed for compatibility
                    [posX, posY - (y0 - offset)] // needed for compatibility
                    ];
                };
            };

            c3_chart_internal_fn.lineWithRegions = function (d, x, y, _regions) {
                var $$ = this,
                    config = $$.config,
                    prev = -1,
                    i,
                    j,
                    s = "M",
                    sWithRegion,
                    xp,
                    yp,
                    dx,
                    dy,
                    dd,
                    diff,
                    diffx2,
                    xOffset = $$.isCategorized() ? 0.5 : 0,
                    xValue,
                    yValue,
                    regions = [];

                function isWithinRegions(x, regions) {
                    var i;
                    for (i = 0; i < regions.length; i++) {
                        if (regions[i].start < x && x <= regions[i].end) {
                            return true;
                        }
                    }
                    return false;
                }

                // Check start/end of regions
                if (isDefined(_regions)) {
                    for (i = 0; i < _regions.length; i++) {
                        regions[i] = {};
                        if (isUndefined(_regions[i].start)) {
                            regions[i].start = d[0].x;
                        } else {
                            regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start;
                        }
                        if (isUndefined(_regions[i].end)) {
                            regions[i].end = d[d.length - 1].x;
                        } else {
                            regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;
                        }
                    }
                }

                // Set scales
                xValue = config.axis_rotated ? function (d) {
                    return y(d.value);
                } : function (d) {
                    return x(d.x);
                };
                yValue = config.axis_rotated ? function (d) {
                    return x(d.x);
                } : function (d) {
                    return y(d.value);
                };

                // Define svg generator function for region
                function generateM(points) {
                    return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1];
                }
                if ($$.isTimeSeries()) {
                    sWithRegion = function (d0, d1, j, diff) {
                        var x0 = d0.x.getTime(),
                            x_diff = d1.x - d0.x,
                            xv0 = new Date(x0 + x_diff * j),
                            xv1 = new Date(x0 + x_diff * (j + diff)),
                            points;
                        if (config.axis_rotated) {
                            points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]];
                        } else {
                            points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]];
                        }
                        return generateM(points);
                    };
                } else {
                    sWithRegion = function (d0, d1, j, diff) {
                        var points;
                        if (config.axis_rotated) {
                            points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]];
                        } else {
                            points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]];
                        }
                        return generateM(points);
                    };
                }

                // Generate
                for (i = 0; i < d.length; i++) {

                    // Draw as normal
                    if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
                        s += " " + xValue(d[i]) + " " + yValue(d[i]);
                    }
                    // Draw with region // TODO: Fix for horizotal charts
                    else {
                            xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
                            yp = $$.getScale(d[i - 1].value, d[i].value);

                            dx = x(d[i].x) - x(d[i - 1].x);
                            dy = y(d[i].value) - y(d[i - 1].value);
                            dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                            diff = 2 / dd;
                            diffx2 = diff * 2;

                            for (j = diff; j <= 1; j += diffx2) {
                                s += sWithRegion(d[i - 1], d[i], j, diff);
                            }
                        }
                    prev = d[i].x;
                }

                return s;
            };

            c3_chart_internal_fn.updateArea = function (durationForExit) {
                var $$ = this,
                    d3 = $$.d3;
                $$.mainArea = $$.main.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
                $$.mainArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
                    $$.orgAreaOpacity = +d3.select(this).style('opacity');return 0;
                });
                $$.mainArea.style("opacity", $$.orgAreaOpacity);
                $$.mainArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawArea = function (drawArea, withTransition) {
                return [(withTransition ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr("d", drawArea).style("fill", this.color).style("opacity", this.orgAreaOpacity)];
            };
            c3_chart_internal_fn.generateDrawArea = function (areaIndices, isSub) {
                var $$ = this,
                    config = $$.config,
                    area = $$.d3.svg.area(),
                    getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
                    yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
                    xValue = function (d) {
                    return (isSub ? $$.subxx : $$.xx).call($$, d);
                },
                    value0 = function (d, i) {
                    return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
                },
                    value1 = function (d, i) {
                    return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
                };

                area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1);
                if (!config.line_connectNull) {
                    area = area.defined(function (d) {
                        return d.value !== null;
                    });
                }

                return function (d) {
                    var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                        x0 = 0,
                        y0 = 0,
                        path;
                    if ($$.isAreaType(d)) {
                        if ($$.isStepType(d)) {
                            values = $$.convertValuesToStep(values);
                        }
                        path = area.interpolate($$.getInterpolate(d))(values);
                    } else {
                        if (values[0]) {
                            x0 = $$.x(values[0].x);
                            y0 = $$.getYScale(d.id)(values[0].value);
                        }
                        path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
                    }
                    return path ? path : "M 0 0";
                };
            };
            c3_chart_internal_fn.getAreaBaseValue = function () {
                return 0;
            };
            c3_chart_internal_fn.generateGetAreaPoints = function (areaIndices, isSub) {
                // partial duplication of generateGetBarPoints
                var $$ = this,
                    config = $$.config,
                    areaTargetsNum = areaIndices.__max__ + 1,
                    x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
                    y = $$.getShapeY(!!isSub),
                    areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
                    yScale = isSub ? $$.getSubYScale : $$.getYScale;
                return function (d, i) {
                    var y0 = yScale.call($$, d.id)(0),
                        offset = areaOffset(d, i) || y0,
                        // offset is for stacked area chart
                    posX = x(d),
                        posY = y(d);
                    // fix posY not to overflow opposite quadrant
                    if (config.axis_rotated) {
                        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                            posY = y0;
                        }
                    }
                    // 1 point that marks the area position
                    return [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
                    [posX, offset] // needed for compatibility
                    ];
                };
            };

            c3_chart_internal_fn.updateCircle = function () {
                var $$ = this;
                $$.mainCircle = $$.main.selectAll('.' + CLASS.circles).selectAll('.' + CLASS.circle).data($$.lineOrScatterData.bind($$));
                $$.mainCircle.enter().append("circle").attr("class", $$.classCircle.bind($$)).attr("r", $$.pointR.bind($$)).style("fill", $$.color);
                $$.mainCircle.style("opacity", $$.initialOpacityForCircle.bind($$));
                $$.mainCircle.exit().remove();
            };
            c3_chart_internal_fn.redrawCircle = function (cx, cy, withTransition) {
                var selectedCircles = this.main.selectAll('.' + CLASS.selectedCircle);
                return [(withTransition ? this.mainCircle.transition(Math.random().toString()) : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style("fill", this.color).attr("cx", cx).attr("cy", cy), (withTransition ? selectedCircles.transition(Math.random().toString()) : selectedCircles).attr("cx", cx).attr("cy", cy)];
            };
            c3_chart_internal_fn.circleX = function (d) {
                return d.x || d.x === 0 ? this.x(d.x) : null;
            };
            c3_chart_internal_fn.updateCircleY = function () {
                var $$ = this,
                    lineIndices,
                    getPoints;
                if ($$.config.data_groups.length > 0) {
                    lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices);
                    $$.circleY = function (d, i) {
                        return getPoints(d, i)[0][1];
                    };
                } else {
                    $$.circleY = function (d) {
                        return $$.getYScale(d.id)(d.value);
                    };
                }
            };
            c3_chart_internal_fn.getCircles = function (i, id) {
                var $$ = this;
                return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
            };
            c3_chart_internal_fn.expandCircles = function (i, id, reset) {
                var $$ = this,
                    r = $$.pointExpandedR.bind($$);
                if (reset) {
                    $$.unexpandCircles();
                }
                $$.getCircles(i, id).classed(CLASS.EXPANDED, true).attr('r', r);
            };
            c3_chart_internal_fn.unexpandCircles = function (i) {
                var $$ = this,
                    r = $$.pointR.bind($$);
                $$.getCircles(i).filter(function () {
                    return $$.d3.select(this).classed(CLASS.EXPANDED);
                }).classed(CLASS.EXPANDED, false).attr('r', r);
            };
            c3_chart_internal_fn.pointR = function (d) {
                var $$ = this,
                    config = $$.config;
                return $$.isStepType(d) ? 0 : isFunction(config.point_r) ? config.point_r(d) : config.point_r;
            };
            c3_chart_internal_fn.pointExpandedR = function (d) {
                var $$ = this,
                    config = $$.config;
                return config.point_focus_expand_enabled ? config.point_focus_expand_r ? config.point_focus_expand_r : $$.pointR(d) * 1.75 : $$.pointR(d);
            };
            c3_chart_internal_fn.pointSelectR = function (d) {
                var $$ = this,
                    config = $$.config;
                return isFunction(config.point_select_r) ? config.point_select_r(d) : config.point_select_r ? config.point_select_r : $$.pointR(d) * 4;
            };
            c3_chart_internal_fn.isWithinCircle = function (that, r) {
                var d3 = this.d3,
                    mouse = d3.mouse(that),
                    d3_this = d3.select(that),
                    cx = +d3_this.attr("cx"),
                    cy = +d3_this.attr("cy");
                return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
            };
            c3_chart_internal_fn.isWithinStep = function (that, y) {
                return Math.abs(y - this.d3.mouse(that)[1]) < 30;
            };

            c3_chart_internal_fn.initBar = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
            };
            c3_chart_internal_fn.updateTargetsForBar = function (targets) {
                var $$ = this,
                    config = $$.config,
                    mainBarUpdate,
                    mainBarEnter,
                    classChartBar = $$.classChartBar.bind($$),
                    classBars = $$.classBars.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainBarUpdate = $$.main.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', function (d) {
                    return classChartBar(d) + classFocus(d);
                });
                mainBarEnter = mainBarUpdate.enter().append('g').attr('class', classChartBar).style('opacity', 0).style("pointer-events", "none");
                // Bars for each data
                mainBarEnter.append('g').attr("class", classBars).style("cursor", function (d) {
                    return config.data_selection_isselectable(d) ? "pointer" : null;
                });
            };
            c3_chart_internal_fn.updateBar = function (durationForExit) {
                var $$ = this,
                    barData = $$.barData.bind($$),
                    classBar = $$.classBar.bind($$),
                    initialOpacity = $$.initialOpacity.bind($$),
                    color = function (d) {
                    return $$.color(d.id);
                };
                $$.mainBar = $$.main.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data(barData);
                $$.mainBar.enter().append('path').attr("class", classBar).style("stroke", color).style("fill", color);
                $$.mainBar.style("opacity", initialOpacity);
                $$.mainBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawBar = function (drawBar, withTransition) {
                return [(withTransition ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr('d', drawBar).style("fill", this.color).style("opacity", 1)];
            };
            c3_chart_internal_fn.getBarW = function (axis, barTargetsNum) {
                var $$ = this,
                    config = $$.config,
                    w = typeof config.bar_width === 'number' ? config.bar_width : barTargetsNum ? axis.tickInterval() * config.bar_width_ratio / barTargetsNum : 0;
                return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;
            };
            c3_chart_internal_fn.getBars = function (i, id) {
                var $$ = this;
                return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
            };
            c3_chart_internal_fn.expandBars = function (i, id, reset) {
                var $$ = this;
                if (reset) {
                    $$.unexpandBars();
                }
                $$.getBars(i, id).classed(CLASS.EXPANDED, true);
            };
            c3_chart_internal_fn.unexpandBars = function (i) {
                var $$ = this;
                $$.getBars(i).classed(CLASS.EXPANDED, false);
            };
            c3_chart_internal_fn.generateDrawBar = function (barIndices, isSub) {
                var $$ = this,
                    config = $$.config,
                    getPoints = $$.generateGetBarPoints(barIndices, isSub);
                return function (d, i) {
                    // 4 points that make a bar
                    var points = getPoints(d, i);

                    // switch points if axis is rotated, not applicable for sub chart
                    var indexX = config.axis_rotated ? 1 : 0;
                    var indexY = config.axis_rotated ? 0 : 1;

                    var path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' + 'L' + points[1][indexX] + ',' + points[1][indexY] + ' ' + 'L' + points[2][indexX] + ',' + points[2][indexY] + ' ' + 'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' + 'z';

                    return path;
                };
            };
            c3_chart_internal_fn.generateGetBarPoints = function (barIndices, isSub) {
                var $$ = this,
                    axis = isSub ? $$.subXAxis : $$.xAxis,
                    barTargetsNum = barIndices.__max__ + 1,
                    barW = $$.getBarW(axis, barTargetsNum),
                    barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
                    barY = $$.getShapeY(!!isSub),
                    barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
                    yScale = isSub ? $$.getSubYScale : $$.getYScale;
                return function (d, i) {
                    var y0 = yScale.call($$, d.id)(0),
                        offset = barOffset(d, i) || y0,
                        // offset is for stacked bar chart
                    posX = barX(d),
                        posY = barY(d);
                    // fix posY not to overflow opposite quadrant
                    if ($$.config.axis_rotated) {
                        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                            posY = y0;
                        }
                    }
                    // 4 points that make a bar
                    return [[posX, offset], [posX, posY - (y0 - offset)], [posX + barW, posY - (y0 - offset)], [posX + barW, offset]];
                };
            };
            c3_chart_internal_fn.isWithinBar = function (that) {
                var mouse = this.d3.mouse(that),
                    box = that.getBoundingClientRect(),
                    seg0 = that.pathSegList.getItem(0),
                    seg1 = that.pathSegList.getItem(1),
                    x = Math.min(seg0.x, seg1.x),
                    y = Math.min(seg0.y, seg1.y),
                    w = box.width,
                    h = box.height,
                    offset = 2,
                    sx = x - offset,
                    ex = x + w + offset,
                    sy = y + h + offset,
                    ey = y - offset;
                return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy;
            };

            c3_chart_internal_fn.initText = function () {
                var $$ = this;
                $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartTexts);
                $$.mainText = $$.d3.selectAll([]);
            };
            c3_chart_internal_fn.updateTargetsForText = function (targets) {
                var $$ = this,
                    mainTextUpdate,
                    mainTextEnter,
                    classChartText = $$.classChartText.bind($$),
                    classTexts = $$.classTexts.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainTextUpdate = $$.main.select('.' + CLASS.chartTexts).selectAll('.' + CLASS.chartText).data(targets).attr('class', function (d) {
                    return classChartText(d) + classFocus(d);
                });
                mainTextEnter = mainTextUpdate.enter().append('g').attr('class', classChartText).style('opacity', 0).style("pointer-events", "none");
                mainTextEnter.append('g').attr('class', classTexts);
            };
            c3_chart_internal_fn.updateText = function (durationForExit) {
                var $$ = this,
                    config = $$.config,
                    barOrLineData = $$.barOrLineData.bind($$),
                    classText = $$.classText.bind($$);
                $$.mainText = $$.main.selectAll('.' + CLASS.texts).selectAll('.' + CLASS.text).data(barOrLineData);
                $$.mainText.enter().append('text').attr("class", classText).attr('text-anchor', function (d) {
                    return config.axis_rotated ? d.value < 0 ? 'end' : 'start' : 'middle';
                }).style("stroke", 'none').style("fill", function (d) {
                    return $$.color(d);
                }).style("fill-opacity", 0);
                $$.mainText.text(function (d, i, j) {
                    return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
                });
                $$.mainText.exit().transition().duration(durationForExit).style('fill-opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawText = function (xForText, yForText, forFlow, withTransition) {
                return [(withTransition ? this.mainText.transition() : this.mainText).attr('x', xForText).attr('y', yForText).style("fill", this.color).style("fill-opacity", forFlow ? 0 : this.opacityForText.bind(this))];
            };
            c3_chart_internal_fn.getTextRect = function (text, cls, element) {
                var dummy = this.d3.select('body').append('div').classed('c3', true),
                    svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0),
                    font = this.d3.select(element).style('font'),
                    rect;
                svg.selectAll('.dummy').data([text]).enter().append('text').classed(cls ? cls : "", true).style('font', font).text(text).each(function () {
                    rect = this.getBoundingClientRect();
                });
                dummy.remove();
                return rect;
            };
            c3_chart_internal_fn.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {
                var $$ = this,
                    getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),
                    getBarPoints = $$.generateGetBarPoints(barIndices, false),
                    getLinePoints = $$.generateGetLinePoints(lineIndices, false),
                    getter = forX ? $$.getXForText : $$.getYForText;
                return function (d, i) {
                    var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints;
                    return getter.call($$, getPoints(d, i), d, this);
                };
            };
            c3_chart_internal_fn.getXForText = function (points, d, textElement) {
                var $$ = this,
                    box = textElement.getBoundingClientRect(),
                    xPos,
                    padding;
                if ($$.config.axis_rotated) {
                    padding = $$.isBarType(d) ? 4 : 6;
                    xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
                } else {
                    xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
                }
                // show labels regardless of the domain if value is null
                if (d.value === null) {
                    if (xPos > $$.width) {
                        xPos = $$.width - box.width;
                    } else if (xPos < 0) {
                        xPos = 4;
                    }
                }
                return xPos;
            };
            c3_chart_internal_fn.getYForText = function (points, d, textElement) {
                var $$ = this,
                    box = textElement.getBoundingClientRect(),
                    yPos;
                if ($$.config.axis_rotated) {
                    yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
                } else {
                    yPos = points[2][1];
                    if (d.value < 0 || d.value === 0 && !$$.hasPositiveValue) {
                        yPos += box.height;
                        if ($$.isBarType(d) && $$.isSafari()) {
                            yPos -= 3;
                        } else if (!$$.isBarType(d) && $$.isChrome()) {
                            yPos += 3;
                        }
                    } else {
                        yPos += $$.isBarType(d) ? -3 : -6;
                    }
                }
                // show labels regardless of the domain if value is null
                if (d.value === null && !$$.config.axis_rotated) {
                    if (yPos < box.height) {
                        yPos = box.height;
                    } else if (yPos > this.height) {
                        yPos = this.height - 4;
                    }
                }
                return yPos;
            };

            c3_chart_internal_fn.setTargetType = function (targetIds, type) {
                var $$ = this,
                    config = $$.config;
                $$.mapToTargetIds(targetIds).forEach(function (id) {
                    $$.withoutFadeIn[id] = type === config.data_types[id];
                    config.data_types[id] = type;
                });
                if (!targetIds) {
                    config.data_type = type;
                }
            };
            c3_chart_internal_fn.hasType = function (type, targets) {
                var $$ = this,
                    types = $$.config.data_types,
                    has = false;
                targets = targets || $$.data.targets;
                if (targets && targets.length) {
                    targets.forEach(function (target) {
                        var t = types[target.id];
                        if (t && t.indexOf(type) >= 0 || !t && type === 'line') {
                            has = true;
                        }
                    });
                } else if (Object.keys(types).length) {
                    Object.keys(types).forEach(function (id) {
                        if (types[id] === type) {
                            has = true;
                        }
                    });
                } else {
                    has = $$.config.data_type === type;
                }
                return has;
            };
            c3_chart_internal_fn.hasArcType = function (targets) {
                return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets);
            };
            c3_chart_internal_fn.isLineType = function (d) {
                var config = this.config,
                    id = isString(d) ? d : d.id;
                return !config.data_types[id] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isStepType = function (d) {
                var id = isString(d) ? d : d.id;
                return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isSplineType = function (d) {
                var id = isString(d) ? d : d.id;
                return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isAreaType = function (d) {
                var id = isString(d) ? d : d.id;
                return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
            };
            c3_chart_internal_fn.isBarType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'bar';
            };
            c3_chart_internal_fn.isScatterType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'scatter';
            };
            c3_chart_internal_fn.isPieType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'pie';
            };
            c3_chart_internal_fn.isGaugeType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'gauge';
            };
            c3_chart_internal_fn.isDonutType = function (d) {
                var id = isString(d) ? d : d.id;
                return this.config.data_types[id] === 'donut';
            };
            c3_chart_internal_fn.isArcType = function (d) {
                return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
            };
            c3_chart_internal_fn.lineData = function (d) {
                return this.isLineType(d) ? [d] : [];
            };
            c3_chart_internal_fn.arcData = function (d) {
                return this.isArcType(d.data) ? [d] : [];
            };
            /* not used
             function scatterData(d) {
             return isScatterType(d) ? d.values : [];
             }
             */
            c3_chart_internal_fn.barData = function (d) {
                return this.isBarType(d) ? d.values : [];
            };
            c3_chart_internal_fn.lineOrScatterData = function (d) {
                return this.isLineType(d) || this.isScatterType(d) ? d.values : [];
            };
            c3_chart_internal_fn.barOrLineData = function (d) {
                return this.isBarType(d) || this.isLineType(d) ? d.values : [];
            };
            c3_chart_internal_fn.isInterpolationType = function (type) {
                return ['linear', 'linear-closed', 'basis', 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', 'monotone'].indexOf(type) >= 0;
            };

            c3_chart_internal_fn.initGrid = function () {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3;
                $$.grid = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid);
                if (config.grid_x_show) {
                    $$.grid.append("g").attr("class", CLASS.xgrids);
                }
                if (config.grid_y_show) {
                    $$.grid.append('g').attr('class', CLASS.ygrids);
                }
                if (config.grid_focus_show) {
                    $$.grid.append('g').attr("class", CLASS.xgridFocus).append('line').attr('class', CLASS.xgridFocus);
                }
                $$.xgrid = d3.selectAll([]);
                if (!config.grid_lines_front) {
                    $$.initGridLines();
                }
            };
            c3_chart_internal_fn.initGridLines = function () {
                var $$ = this,
                    d3 = $$.d3;
                $$.gridLines = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid + ' ' + CLASS.gridLines);
                $$.gridLines.append('g').attr("class", CLASS.xgridLines);
                $$.gridLines.append('g').attr('class', CLASS.ygridLines);
                $$.xgridLines = d3.selectAll([]);
            };
            c3_chart_internal_fn.updateXGrid = function (withoutUpdate) {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3,
                    xgridData = $$.generateGridData(config.grid_x_type, $$.x),
                    tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;

                $$.xgridAttr = config.axis_rotated ? {
                    'x1': 0,
                    'x2': $$.width,
                    'y1': function (d) {
                        return $$.x(d) - tickOffset;
                    },
                    'y2': function (d) {
                        return $$.x(d) - tickOffset;
                    }
                } : {
                    'x1': function (d) {
                        return $$.x(d) + tickOffset;
                    },
                    'x2': function (d) {
                        return $$.x(d) + tickOffset;
                    },
                    'y1': 0,
                    'y2': $$.height
                };

                $$.xgrid = $$.main.select('.' + CLASS.xgrids).selectAll('.' + CLASS.xgrid).data(xgridData);
                $$.xgrid.enter().append('line').attr("class", CLASS.xgrid);
                if (!withoutUpdate) {
                    $$.xgrid.attr($$.xgridAttr).style("opacity", function () {
                        return +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1') === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
                    });
                }
                $$.xgrid.exit().remove();
            };

            c3_chart_internal_fn.updateYGrid = function () {
                var $$ = this,
                    config = $$.config,
                    gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
                $$.ygrid = $$.main.select('.' + CLASS.ygrids).selectAll('.' + CLASS.ygrid).data(gridValues);
                $$.ygrid.enter().append('line').attr('class', CLASS.ygrid);
                $$.ygrid.attr("x1", config.axis_rotated ? $$.y : 0).attr("x2", config.axis_rotated ? $$.y : $$.width).attr("y1", config.axis_rotated ? 0 : $$.y).attr("y2", config.axis_rotated ? $$.height : $$.y);
                $$.ygrid.exit().remove();
                $$.smoothLines($$.ygrid, 'grid');
            };

            c3_chart_internal_fn.gridTextAnchor = function (d) {
                return d.position ? d.position : "end";
            };
            c3_chart_internal_fn.gridTextDx = function (d) {
                return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
            };
            c3_chart_internal_fn.xGridTextX = function (d) {
                return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0;
            };
            c3_chart_internal_fn.yGridTextX = function (d) {
                return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width;
            };
            c3_chart_internal_fn.updateGrid = function (duration) {
                var $$ = this,
                    main = $$.main,
                    config = $$.config,
                    xgridLine,
                    ygridLine,
                    yv;

                // hide if arc type
                $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');

                main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
                if (config.grid_x_show) {
                    $$.updateXGrid();
                }
                $$.xgridLines = main.select('.' + CLASS.xgridLines).selectAll('.' + CLASS.xgridLine).data(config.grid_x_lines);
                // enter
                xgridLine = $$.xgridLines.enter().append('g').attr("class", function (d) {
                    return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
                });
                xgridLine.append('line').style("opacity", 0);
                xgridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "" : "rotate(-90)").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
                // udpate
                // done in d3.transition() of the end of this function
                // exit
                $$.xgridLines.exit().transition().duration(duration).style("opacity", 0).remove();

                // Y-Grid
                if (config.grid_y_show) {
                    $$.updateYGrid();
                }
                $$.ygridLines = main.select('.' + CLASS.ygridLines).selectAll('.' + CLASS.ygridLine).data(config.grid_y_lines);
                // enter
                ygridLine = $$.ygridLines.enter().append('g').attr("class", function (d) {
                    return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
                });
                ygridLine.append('line').style("opacity", 0);
                ygridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "rotate(-90)" : "").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
                // update
                yv = $$.yv.bind($$);
                $$.ygridLines.select('line').transition().duration(duration).attr("x1", config.axis_rotated ? yv : 0).attr("x2", config.axis_rotated ? yv : $$.width).attr("y1", config.axis_rotated ? 0 : yv).attr("y2", config.axis_rotated ? $$.height : yv).style("opacity", 1);
                $$.ygridLines.select('text').transition().duration(duration).attr("x", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr("y", yv).text(function (d) {
                    return d.text;
                }).style("opacity", 1);
                // exit
                $$.ygridLines.exit().transition().duration(duration).style("opacity", 0).remove();
            };
            c3_chart_internal_fn.redrawGrid = function (withTransition) {
                var $$ = this,
                    config = $$.config,
                    xv = $$.xv.bind($$),
                    lines = $$.xgridLines.select('line'),
                    texts = $$.xgridLines.select('text');
                return [(withTransition ? lines.transition() : lines).attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv).attr("y1", config.axis_rotated ? xv : 0).attr("y2", config.axis_rotated ? xv : $$.height).style("opacity", 1), (withTransition ? texts.transition() : texts).attr("x", config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr("y", xv).text(function (d) {
                    return d.text;
                }).style("opacity", 1)];
            };
            c3_chart_internal_fn.showXGridFocus = function (selectedData) {
                var $$ = this,
                    config = $$.config,
                    dataToShow = selectedData.filter(function (d) {
                    return d && isValue(d.value);
                }),
                    focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),
                    xx = $$.xx.bind($$);
                if (!config.tooltip_show) {
                    return;
                }
                // Hide when scatter plot exists
                if ($$.hasType('scatter') || $$.hasArcType()) {
                    return;
                }
                focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(config.axis_rotated ? 'y1' : 'x1', xx).attr(config.axis_rotated ? 'y2' : 'x2', xx);
                $$.smoothLines(focusEl, 'grid');
            };
            c3_chart_internal_fn.hideXGridFocus = function () {
                this.main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
            };
            c3_chart_internal_fn.updateXgridFocus = function () {
                var $$ = this,
                    config = $$.config;
                $$.main.select('line.' + CLASS.xgridFocus).attr("x1", config.axis_rotated ? 0 : -10).attr("x2", config.axis_rotated ? $$.width : -10).attr("y1", config.axis_rotated ? -10 : 0).attr("y2", config.axis_rotated ? -10 : $$.height);
            };
            c3_chart_internal_fn.generateGridData = function (type, scale) {
                var $$ = this,
                    gridData = [],
                    xDomain,
                    firstYear,
                    lastYear,
                    i,
                    tickNum = $$.main.select("." + CLASS.axisX).selectAll('.tick').size();
                if (type === 'year') {
                    xDomain = $$.getXDomain();
                    firstYear = xDomain[0].getFullYear();
                    lastYear = xDomain[1].getFullYear();
                    for (i = firstYear; i <= lastYear; i++) {
                        gridData.push(new Date(i + '-01-01 00:00:00'));
                    }
                } else {
                    gridData = scale.ticks(10);
                    if (gridData.length > tickNum) {
                        // use only int
                        gridData = gridData.filter(function (d) {
                            return ("" + d).indexOf('.') < 0;
                        });
                    }
                }
                return gridData;
            };
            c3_chart_internal_fn.getGridFilterToRemove = function (params) {
                return params ? function (line) {
                    var found = false;
                    [].concat(params).forEach(function (param) {
                        if ('value' in param && line.value === param.value || 'class' in param && line['class'] === param['class']) {
                            found = true;
                        }
                    });
                    return found;
                } : function () {
                    return true;
                };
            };
            c3_chart_internal_fn.removeGridLines = function (params, forX) {
                var $$ = this,
                    config = $$.config,
                    toRemove = $$.getGridFilterToRemove(params),
                    toShow = function (line) {
                    return !toRemove(line);
                },
                    classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,
                    classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
                $$.main.select('.' + classLines).selectAll('.' + classLine).filter(toRemove).transition().duration(config.transition_duration).style('opacity', 0).remove();
                if (forX) {
                    config.grid_x_lines = config.grid_x_lines.filter(toShow);
                } else {
                    config.grid_y_lines = config.grid_y_lines.filter(toShow);
                }
            };

            c3_chart_internal_fn.initTooltip = function () {
                var $$ = this,
                    config = $$.config,
                    i;
                $$.tooltip = $$.selectChart.style("position", "relative").append("div").attr('class', CLASS.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none");
                // Show tooltip if needed
                if (config.tooltip_init_show) {
                    if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
                        config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
                        for (i = 0; i < $$.data.targets[0].values.length; i++) {
                            if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {
                                break;
                            }
                        }
                        config.tooltip_init_x = i;
                    }
                    $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {
                        return $$.addName(d.values[config.tooltip_init_x]);
                    }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
                    $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
                }
            };
            c3_chart_internal_fn.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {
                var $$ = this,
                    config = $$.config,
                    titleFormat = config.tooltip_format_title || defaultTitleFormat,
                    nameFormat = config.tooltip_format_name || function (name) {
                    return name;
                },
                    valueFormat = config.tooltip_format_value || defaultValueFormat,
                    text,
                    i,
                    title,
                    value,
                    name,
                    bgcolor,
                    orderAsc = $$.isOrderAsc();

                if (config.data_groups.length === 0) {
                    d.sort(function (a, b) {
                        var v1 = a ? a.value : null,
                            v2 = b ? b.value : null;
                        return orderAsc ? v1 - v2 : v2 - v1;
                    });
                } else {
                    var ids = $$.orderTargets($$.data.targets).map(function (i) {
                        return i.id;
                    });
                    d.sort(function (a, b) {
                        var v1 = a ? a.value : null,
                            v2 = b ? b.value : null;
                        if (v1 > 0 && v2 > 0) {
                            v1 = a ? ids.indexOf(a.id) : null;
                            v2 = b ? ids.indexOf(b.id) : null;
                        }
                        return orderAsc ? v1 - v2 : v2 - v1;
                    });
                }

                for (i = 0; i < d.length; i++) {
                    if (!(d[i] && (d[i].value || d[i].value === 0))) {
                        continue;
                    }

                    if (!text) {
                        title = sanitise(titleFormat ? titleFormat(d[i].x) : d[i].x);
                        text = "<table class='" + $$.CLASS.tooltip + "'>" + (title || title === 0 ? "<tr><th colspan='2'>" + title + "</th></tr>" : "");
                    }

                    value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d));
                    if (value !== undefined) {
                        // Skip elements when their name is set to null
                        if (d[i].name === null) {
                            continue;
                        }
                        name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index));
                        bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);

                        text += "<tr class='" + $$.CLASS.tooltipName + "-" + $$.getTargetSelectorSuffix(d[i].id) + "'>";
                        text += "<td class='name'><span style='background-color:" + bgcolor + "'></span>" + name + "</td>";
                        text += "<td class='value'>" + value + "</td>";
                        text += "</tr>";
                    }
                }
                return text + "</table>";
            };
            c3_chart_internal_fn.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3;
                var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight;
                var forArc = $$.hasArcType(),
                    mouse = d3.mouse(element);
                // Determin tooltip position
                if (forArc) {
                    tooltipLeft = ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0];
                    tooltipTop = $$.height / 2 + mouse[1] + 20;
                } else {
                    svgLeft = $$.getSvgLeft(true);
                    if (config.axis_rotated) {
                        tooltipLeft = svgLeft + mouse[0] + 100;
                        tooltipRight = tooltipLeft + tWidth;
                        chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
                        tooltipTop = $$.x(dataToShow[0].x) + 20;
                    } else {
                        tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
                        tooltipRight = tooltipLeft + tWidth;
                        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
                        tooltipTop = mouse[1] + 15;
                    }

                    if (tooltipRight > chartRight) {
                        // 20 is needed for Firefox to keep tooltip width
                        tooltipLeft -= tooltipRight - chartRight + 20;
                    }
                    if (tooltipTop + tHeight > $$.currentHeight) {
                        tooltipTop -= tHeight + 30;
                    }
                }
                if (tooltipTop < 0) {
                    tooltipTop = 0;
                }
                return { top: tooltipTop, left: tooltipLeft };
            };
            c3_chart_internal_fn.showTooltip = function (selectedData, element) {
                var $$ = this,
                    config = $$.config;
                var tWidth, tHeight, position;
                var forArc = $$.hasArcType(),
                    dataToShow = selectedData.filter(function (d) {
                    return d && isValue(d.value);
                }),
                    positionFunction = config.tooltip_position || c3_chart_internal_fn.tooltipPosition;
                if (dataToShow.length === 0 || !config.tooltip_show) {
                    return;
                }
                $$.tooltip.html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", "block");

                // Get tooltip dimensions
                tWidth = $$.tooltip.property('offsetWidth');
                tHeight = $$.tooltip.property('offsetHeight');

                position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
                // Set tooltip
                $$.tooltip.style("top", position.top + "px").style("left", position.left + 'px');
            };
            c3_chart_internal_fn.hideTooltip = function () {
                this.tooltip.style("display", "none");
            };

            c3_chart_internal_fn.initLegend = function () {
                var $$ = this;
                $$.legendItemTextBox = {};
                $$.legendHasRendered = false;
                $$.legend = $$.svg.append("g").attr("transform", $$.getTranslate('legend'));
                if (!$$.config.legend_show) {
                    $$.legend.style('visibility', 'hidden');
                    $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
                    return;
                }
                // MEMO: call here to update legend box and tranlate for all
                // MEMO: translate will be upated by this, so transform not needed in updateLegend()
                $$.updateLegendWithDefaults();
            };
            c3_chart_internal_fn.updateLegendWithDefaults = function () {
                var $$ = this;
                $$.updateLegend($$.mapToIds($$.data.targets), { withTransform: false, withTransitionForTransform: false, withTransition: false });
            };
            c3_chart_internal_fn.updateSizeForLegend = function (legendHeight, legendWidth) {
                var $$ = this,
                    config = $$.config,
                    insetLegendPosition = {
                    top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,
                    left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5
                };

                $$.margin3 = {
                    top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,
                    right: NaN,
                    bottom: 0,
                    left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0
                };
            };
            c3_chart_internal_fn.transformLegend = function (withTransition) {
                var $$ = this;
                (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate('legend'));
            };
            c3_chart_internal_fn.updateLegendStep = function (step) {
                this.legendStep = step;
            };
            c3_chart_internal_fn.updateLegendItemWidth = function (w) {
                this.legendItemWidth = w;
            };
            c3_chart_internal_fn.updateLegendItemHeight = function (h) {
                this.legendItemHeight = h;
            };
            c3_chart_internal_fn.getLegendWidth = function () {
                var $$ = this;
                return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
            };
            c3_chart_internal_fn.getLegendHeight = function () {
                var $$ = this,
                    h = 0;
                if ($$.config.legend_show) {
                    if ($$.isLegendRight) {
                        h = $$.currentHeight;
                    } else {
                        h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
                    }
                }
                return h;
            };
            c3_chart_internal_fn.opacityForLegend = function (legendItem) {
                return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
            };
            c3_chart_internal_fn.opacityForUnfocusedLegend = function (legendItem) {
                return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
            };
            c3_chart_internal_fn.toggleFocusLegend = function (targetIds, focus) {
                var $$ = this;
                targetIds = $$.mapToTargetIds(targetIds);
                $$.legend.selectAll('.' + CLASS.legendItem).filter(function (id) {
                    return targetIds.indexOf(id) >= 0;
                }).classed(CLASS.legendItemFocused, focus).transition().duration(100).style('opacity', function () {
                    var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
                    return opacity.call($$, $$.d3.select(this));
                });
            };
            c3_chart_internal_fn.revertLegend = function () {
                var $$ = this,
                    d3 = $$.d3;
                $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemFocused, false).transition().duration(100).style('opacity', function () {
                    return $$.opacityForLegend(d3.select(this));
                });
            };
            c3_chart_internal_fn.showLegend = function (targetIds) {
                var $$ = this,
                    config = $$.config;
                if (!config.legend_show) {
                    config.legend_show = true;
                    $$.legend.style('visibility', 'visible');
                    if (!$$.legendHasRendered) {
                        $$.updateLegendWithDefaults();
                    }
                }
                $$.removeHiddenLegendIds(targetIds);
                $$.legend.selectAll($$.selectorLegends(targetIds)).style('visibility', 'visible').transition().style('opacity', function () {
                    return $$.opacityForLegend($$.d3.select(this));
                });
            };
            c3_chart_internal_fn.hideLegend = function (targetIds) {
                var $$ = this,
                    config = $$.config;
                if (config.legend_show && isEmpty(targetIds)) {
                    config.legend_show = false;
                    $$.legend.style('visibility', 'hidden');
                }
                $$.addHiddenLegendIds(targetIds);
                $$.legend.selectAll($$.selectorLegends(targetIds)).style('opacity', 0).style('visibility', 'hidden');
            };
            c3_chart_internal_fn.clearLegendItemTextBoxCache = function () {
                this.legendItemTextBox = {};
            };
            c3_chart_internal_fn.updateLegend = function (targetIds, options, transitions) {
                var $$ = this,
                    config = $$.config;
                var xForLegend, xForLegendText, xForLegendRect, yForLegend, yForLegendText, yForLegendRect, x1ForLegendTile, x2ForLegendTile, yForLegendTile;
                var paddingTop = 4,
                    paddingRight = 10,
                    maxWidth = 0,
                    maxHeight = 0,
                    posMin = 10,
                    tileWidth = config.legend_item_tile_width + 5;
                var l,
                    totalLength = 0,
                    offsets = {},
                    widths = {},
                    heights = {},
                    margins = [0],
                    steps = {},
                    step = 0;
                var withTransition, withTransitionForTransform;
                var texts, rects, tiles, background;

                // Skip elements when their name is set to null
                targetIds = targetIds.filter(function (id) {
                    return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
                });

                options = options || {};
                withTransition = getOption(options, "withTransition", true);
                withTransitionForTransform = getOption(options, "withTransitionForTransform", true);

                function getTextBox(textElement, id) {
                    if (!$$.legendItemTextBox[id]) {
                        $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);
                    }
                    return $$.legendItemTextBox[id];
                }

                function updatePositions(textElement, id, index) {
                    var reset = index === 0,
                        isLast = index === targetIds.length - 1,
                        box = getTextBox(textElement, id),
                        itemWidth = box.width + tileWidth + (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) + config.legend_padding,
                        itemHeight = box.height + paddingTop,
                        itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,
                        areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),
                        margin,
                        maxLength;

                    // MEMO: care about condifion of step, totalLength
                    function updateValues(id, withoutStep) {
                        if (!withoutStep) {
                            margin = (areaLength - totalLength - itemLength) / 2;
                            if (margin < posMin) {
                                margin = (areaLength - itemLength) / 2;
                                totalLength = 0;
                                step++;
                            }
                        }
                        steps[id] = step;
                        margins[step] = $$.isLegendInset ? 10 : margin;
                        offsets[id] = totalLength;
                        totalLength += itemLength;
                    }

                    if (reset) {
                        totalLength = 0;
                        step = 0;
                        maxWidth = 0;
                        maxHeight = 0;
                    }

                    if (config.legend_show && !$$.isLegendToShow(id)) {
                        widths[id] = heights[id] = steps[id] = offsets[id] = 0;
                        return;
                    }

                    widths[id] = itemWidth;
                    heights[id] = itemHeight;

                    if (!maxWidth || itemWidth >= maxWidth) {
                        maxWidth = itemWidth;
                    }
                    if (!maxHeight || itemHeight >= maxHeight) {
                        maxHeight = itemHeight;
                    }
                    maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;

                    if (config.legend_equally) {
                        Object.keys(widths).forEach(function (id) {
                            widths[id] = maxWidth;
                        });
                        Object.keys(heights).forEach(function (id) {
                            heights[id] = maxHeight;
                        });
                        margin = (areaLength - maxLength * targetIds.length) / 2;
                        if (margin < posMin) {
                            totalLength = 0;
                            step = 0;
                            targetIds.forEach(function (id) {
                                updateValues(id);
                            });
                        } else {
                            updateValues(id, true);
                        }
                    } else {
                        updateValues(id);
                    }
                }

                if ($$.isLegendInset) {
                    step = config.legend_inset_step ? config.legend_inset_step : targetIds.length;
                    $$.updateLegendStep(step);
                }

                if ($$.isLegendRight) {
                    xForLegend = function (id) {
                        return maxWidth * steps[id];
                    };
                    yForLegend = function (id) {
                        return margins[steps[id]] + offsets[id];
                    };
                } else if ($$.isLegendInset) {
                    xForLegend = function (id) {
                        return maxWidth * steps[id] + 10;
                    };
                    yForLegend = function (id) {
                        return margins[steps[id]] + offsets[id];
                    };
                } else {
                    xForLegend = function (id) {
                        return margins[steps[id]] + offsets[id];
                    };
                    yForLegend = function (id) {
                        return maxHeight * steps[id];
                    };
                }
                xForLegendText = function (id, i) {
                    return xForLegend(id, i) + 4 + config.legend_item_tile_width;
                };
                yForLegendText = function (id, i) {
                    return yForLegend(id, i) + 9;
                };
                xForLegendRect = function (id, i) {
                    return xForLegend(id, i);
                };
                yForLegendRect = function (id, i) {
                    return yForLegend(id, i) - 5;
                };
                x1ForLegendTile = function (id, i) {
                    return xForLegend(id, i) - 2;
                };
                x2ForLegendTile = function (id, i) {
                    return xForLegend(id, i) - 2 + config.legend_item_tile_width;
                };
                yForLegendTile = function (id, i) {
                    return yForLegend(id, i) + 4;
                };

                // Define g for legend area
                l = $$.legend.selectAll('.' + CLASS.legendItem).data(targetIds).enter().append('g').attr('class', function (id) {
                    return $$.generateClass(CLASS.legendItem, id);
                }).style('visibility', function (id) {
                    return $$.isLegendToShow(id) ? 'visible' : 'hidden';
                }).style('cursor', 'pointer').on('click', function (id) {
                    if (config.legend_item_onclick) {
                        config.legend_item_onclick.call($$, id);
                    } else {
                        if ($$.d3.event.altKey) {
                            $$.api.hide();
                            $$.api.show(id);
                        } else {
                            $$.api.toggle(id);
                            $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
                        }
                    }
                }).on('mouseover', function (id) {
                    if (config.legend_item_onmouseover) {
                        config.legend_item_onmouseover.call($$, id);
                    } else {
                        $$.d3.select(this).classed(CLASS.legendItemFocused, true);
                        if (!$$.transiting && $$.isTargetToShow(id)) {
                            $$.api.focus(id);
                        }
                    }
                }).on('mouseout', function (id) {
                    if (config.legend_item_onmouseout) {
                        config.legend_item_onmouseout.call($$, id);
                    } else {
                        $$.d3.select(this).classed(CLASS.legendItemFocused, false);
                        $$.api.revert();
                    }
                });
                l.append('text').text(function (id) {
                    return isDefined(config.data_names[id]) ? config.data_names[id] : id;
                }).each(function (id, i) {
                    updatePositions(this, id, i);
                }).style("pointer-events", "none").attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
                l.append('rect').attr("class", CLASS.legendItemEvent).style('fill-opacity', 0).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
                l.append('line').attr('class', CLASS.legendItemTile).style('stroke', $$.color).style("pointer-events", "none").attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200).attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200).attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('stroke-width', config.legend_item_tile_height);

                // Set background for inset legend
                background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
                if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
                    background = $$.legend.insert('g', '.' + CLASS.legendItem).attr("class", CLASS.legendBackground).append('rect');
                }

                texts = $$.legend.selectAll('text').data(targetIds).text(function (id) {
                    return isDefined(config.data_names[id]) ? config.data_names[id] : id;
                }) // MEMO: needed for update
                .each(function (id, i) {
                    updatePositions(this, id, i);
                });
                (withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText);

                rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
                (withTransition ? rects.transition() : rects).attr('width', function (id) {
                    return widths[id];
                }).attr('height', function (id) {
                    return heights[id];
                }).attr('x', xForLegendRect).attr('y', yForLegendRect);

                tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);
                (withTransition ? tiles.transition() : tiles).style('stroke', $$.color).attr('x1', x1ForLegendTile).attr('y1', yForLegendTile).attr('x2', x2ForLegendTile).attr('y2', yForLegendTile);

                if (background) {
                    (withTransition ? background.transition() : background).attr('height', $$.getLegendHeight() - 12).attr('width', maxWidth * (step + 1) + 10);
                }

                // toggle legend state
                $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function (id) {
                    return !$$.isTargetToShow(id);
                });

                // Update all to reflect change of legend
                $$.updateLegendItemWidth(maxWidth);
                $$.updateLegendItemHeight(maxHeight);
                $$.updateLegendStep(step);
                // Update size and scale
                $$.updateSizes();
                $$.updateScales();
                $$.updateSvgSize();
                // Update g positions
                $$.transformAll(withTransitionForTransform, transitions);
                $$.legendHasRendered = true;
            };

            c3_chart_internal_fn.initTitle = function () {
                var $$ = this;
                $$.title = $$.svg.append("text").text($$.config.title_text).attr("class", $$.CLASS.title);
            };
            c3_chart_internal_fn.redrawTitle = function () {
                var $$ = this;
                $$.title.attr("x", $$.xForTitle.bind($$)).attr("y", $$.yForTitle.bind($$));
            };
            c3_chart_internal_fn.xForTitle = function () {
                var $$ = this,
                    config = $$.config,
                    position = config.title_position || 'left',
                    x;
                if (position.indexOf('right') >= 0) {
                    x = $$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width - config.title_padding.right;
                } else if (position.indexOf('center') >= 0) {
                    x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2;
                } else {
                    // left
                    x = config.title_padding.left;
                }
                return x;
            };
            c3_chart_internal_fn.yForTitle = function () {
                var $$ = this;
                return $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height;
            };
            c3_chart_internal_fn.getTitlePadding = function () {
                var $$ = this;
                return $$.yForTitle() + $$.config.title_padding.bottom;
            };

            function Axis(owner) {
                API.call(this, owner);
            }

            inherit(API, Axis);

            Axis.prototype.init = function init() {

                var $$ = this.owner,
                    config = $$.config,
                    main = $$.main;
                $$.axes.x = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisX).attr("clip-path", $$.clipPathForXAxis).attr("transform", $$.getTranslate('x')).style("visibility", config.axis_x_show ? 'visible' : 'hidden');
                $$.axes.x.append("text").attr("class", CLASS.axisXLabel).attr("transform", config.axis_rotated ? "rotate(-90)" : "").style("text-anchor", this.textAnchorForXAxisLabel.bind(this));
                $$.axes.y = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY).attr("clip-path", config.axis_y_inner ? "" : $$.clipPathForYAxis).attr("transform", $$.getTranslate('y')).style("visibility", config.axis_y_show ? 'visible' : 'hidden');
                $$.axes.y.append("text").attr("class", CLASS.axisYLabel).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForYAxisLabel.bind(this));

                $$.axes.y2 = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY2)
                // clip-path?
                .attr("transform", $$.getTranslate('y2')).style("visibility", config.axis_y2_show ? 'visible' : 'hidden');
                $$.axes.y2.append("text").attr("class", CLASS.axisY2Label).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForY2AxisLabel.bind(this));
            };
            Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
                var $$ = this.owner,
                    config = $$.config,
                    axisParams = {
                    isCategory: $$.isCategorized(),
                    withOuterTick: withOuterTick,
                    tickMultiline: config.axis_x_tick_multiline,
                    tickWidth: config.axis_x_tick_width,
                    tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
                    withoutTransition: withoutTransition
                },
                    axis = c3_axis($$.d3, axisParams).scale(scale).orient(orient);

                if ($$.isTimeSeries() && tickValues && typeof tickValues !== "function") {
                    tickValues = tickValues.map(function (v) {
                        return $$.parseDate(v);
                    });
                }

                // Set tick
                axis.tickFormat(tickFormat).tickValues(tickValues);
                if ($$.isCategorized()) {
                    axis.tickCentered(config.axis_x_tick_centered);
                    if (isEmpty(config.axis_x_tick_culling)) {
                        config.axis_x_tick_culling = false;
                    }
                }

                return axis;
            };
            Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
                var $$ = this.owner,
                    config = $$.config,
                    tickValues;
                if (config.axis_x_tick_fit || config.axis_x_tick_count) {
                    tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
                }
                if (axis) {
                    axis.tickValues(tickValues);
                } else {
                    $$.xAxis.tickValues(tickValues);
                    $$.subXAxis.tickValues(tickValues);
                }
                return tickValues;
            };
            Axis.prototype.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
                var $$ = this.owner,
                    config = $$.config,
                    axisParams = {
                    withOuterTick: withOuterTick,
                    withoutTransition: withoutTransition,
                    tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate
                },
                    axis = c3_axis($$.d3, axisParams).scale(scale).orient(orient).tickFormat(tickFormat);
                if ($$.isTimeSeriesY()) {
                    axis.ticks($$.d3.time[config.axis_y_tick_time_value], config.axis_y_tick_time_interval);
                } else {
                    axis.tickValues(tickValues);
                }
                return axis;
            };
            Axis.prototype.getId = function getId(id) {
                var config = this.owner.config;
                return id in config.data_axes ? config.data_axes[id] : 'y';
            };
            Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
                var $$ = this.owner,
                    config = $$.config,
                    format = $$.isTimeSeries() ? $$.defaultAxisTimeFormat : $$.isCategorized() ? $$.categoryName : function (v) {
                    return v < 0 ? v.toFixed(0) : v;
                };
                if (config.axis_x_tick_format) {
                    if (isFunction(config.axis_x_tick_format)) {
                        format = config.axis_x_tick_format;
                    } else if ($$.isTimeSeries()) {
                        format = function (date) {
                            return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : "";
                        };
                    }
                }
                return isFunction(format) ? function (v) {
                    return format.call($$, v);
                } : format;
            };
            Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
                return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
            };
            Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
                return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
            };
            Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
                return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
            };
            Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
                return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
            };
            Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
                var $$ = this.owner,
                    config = $$.config,
                    option;
                if (axisId === 'y') {
                    option = config.axis_y_label;
                } else if (axisId === 'y2') {
                    option = config.axis_y2_label;
                } else if (axisId === 'x') {
                    option = config.axis_x_label;
                }
                return option;
            };
            Axis.prototype.getLabelText = function getLabelText(axisId) {
                var option = this.getLabelOptionByAxisId(axisId);
                return isString(option) ? option : option ? option.text : null;
            };
            Axis.prototype.setLabelText = function setLabelText(axisId, text) {
                var $$ = this.owner,
                    config = $$.config,
                    option = this.getLabelOptionByAxisId(axisId);
                if (isString(option)) {
                    if (axisId === 'y') {
                        config.axis_y_label = text;
                    } else if (axisId === 'y2') {
                        config.axis_y2_label = text;
                    } else if (axisId === 'x') {
                        config.axis_x_label = text;
                    }
                } else if (option) {
                    option.text = text;
                }
            };
            Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
                var option = this.getLabelOptionByAxisId(axisId),
                    position = option && typeof option === 'object' && option.position ? option.position : defaultPosition;
                return {
                    isInner: position.indexOf('inner') >= 0,
                    isOuter: position.indexOf('outer') >= 0,
                    isLeft: position.indexOf('left') >= 0,
                    isCenter: position.indexOf('center') >= 0,
                    isRight: position.indexOf('right') >= 0,
                    isTop: position.indexOf('top') >= 0,
                    isMiddle: position.indexOf('middle') >= 0,
                    isBottom: position.indexOf('bottom') >= 0
                };
            };
            Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
                return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
            };
            Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
                return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
            };
            Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
                return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
            };
            Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
                return id === 'y2' ? this.getY2AxisLabelPosition() : id === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition();
            };
            Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
                return this.getLabelText('x');
            };
            Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
                return this.getLabelText('y');
            };
            Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
                return this.getLabelText('y2');
            };
            Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
                var $$ = this.owner;
                if (forHorizontal) {
                    return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
                } else {
                    return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0;
                }
            };
            Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
                if (forHorizontal) {
                    return position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0";
                } else {
                    return position.isTop ? "-0.5em" : position.isBottom ? "0.5em" : "0";
                }
            };
            Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
                if (forHorizontal) {
                    return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
                } else {
                    return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
                }
            };
            Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
                return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
            };
            Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
                return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
            };
            Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
                return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
            };
            Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
                return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
            };
            Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
                return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
            };
            Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
                return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
            };
            Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
                var $$ = this.owner,
                    config = $$.config,
                    position = this.getXAxisLabelPosition();
                if (config.axis_rotated) {
                    return position.isInner ? "1.2em" : -25 - this.getMaxTickWidth('x');
                } else {
                    return position.isInner ? "-0.5em" : config.axis_x_height ? config.axis_x_height - 10 : "3em";
                }
            };
            Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
                var $$ = this.owner,
                    position = this.getYAxisLabelPosition();
                if ($$.config.axis_rotated) {
                    return position.isInner ? "-0.5em" : "3em";
                } else {
                    return position.isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10);
                }
            };
            Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
                var $$ = this.owner,
                    position = this.getY2AxisLabelPosition();
                if ($$.config.axis_rotated) {
                    return position.isInner ? "1.2em" : "-2.2em";
                } else {
                    return position.isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15);
                }
            };
            Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
                var $$ = this.owner;
                return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
            };
            Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
                var $$ = this.owner;
                return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
            };
            Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
                var $$ = this.owner;
                return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
            };
            Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
                var $$ = this.owner,
                    config = $$.config,
                    maxWidth = 0,
                    targetsToShow,
                    scale,
                    axis,
                    dummy,
                    svg;
                if (withoutRecompute && $$.currentMaxTickWidths[id]) {
                    return $$.currentMaxTickWidths[id];
                }
                if ($$.svg) {
                    targetsToShow = $$.filterTargetsToShow($$.data.targets);
                    if (id === 'y') {
                        scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
                        axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true, true);
                    } else if (id === 'y2') {
                        scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
                        axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true, true);
                    } else {
                        scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
                        axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
                        this.updateXAxisTickValues(targetsToShow, axis);
                    }
                    dummy = $$.d3.select('body').append('div').classed('c3', true);
                    svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0), svg.append('g').call(axis).each(function () {
                        $$.d3.select(this).selectAll('text').each(function () {
                            var box = this.getBoundingClientRect();
                            if (maxWidth < box.width) {
                                maxWidth = box.width;
                            }
                        });
                        dummy.remove();
                    });
                }
                $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
                return $$.currentMaxTickWidths[id];
            };

            Axis.prototype.updateLabels = function updateLabels(withTransition) {
                var $$ = this.owner;
                var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),
                    axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),
                    axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
                (withTransition ? axisXLabel.transition() : axisXLabel).attr("x", this.xForXAxisLabel.bind(this)).attr("dx", this.dxForXAxisLabel.bind(this)).attr("dy", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this));
                (withTransition ? axisYLabel.transition() : axisYLabel).attr("x", this.xForYAxisLabel.bind(this)).attr("dx", this.dxForYAxisLabel.bind(this)).attr("dy", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this));
                (withTransition ? axisY2Label.transition() : axisY2Label).attr("x", this.xForY2AxisLabel.bind(this)).attr("dx", this.dxForY2AxisLabel.bind(this)).attr("dy", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));
            };
            Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
                var p = typeof padding === 'number' ? padding : padding[key];
                if (!isValue(p)) {
                    return defaultValue;
                }
                if (padding.unit === 'ratio') {
                    return padding[key] * domainLength;
                }
                // assume padding is pixels if unit is not specified
                return this.convertPixelsToAxisPadding(p, domainLength);
            };
            Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
                var $$ = this.owner,
                    length = $$.config.axis_rotated ? $$.width : $$.height;
                return domainLength * (pixels / length);
            };
            Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
                var tickValues = values,
                    targetCount,
                    start,
                    end,
                    count,
                    interval,
                    i,
                    tickValue;
                if (tickCount) {
                    targetCount = isFunction(tickCount) ? tickCount() : tickCount;
                    // compute ticks according to tickCount
                    if (targetCount === 1) {
                        tickValues = [values[0]];
                    } else if (targetCount === 2) {
                        tickValues = [values[0], values[values.length - 1]];
                    } else if (targetCount > 2) {
                        count = targetCount - 2;
                        start = values[0];
                        end = values[values.length - 1];
                        interval = (end - start) / (count + 1);
                        // re-construct unique values
                        tickValues = [start];
                        for (i = 0; i < count; i++) {
                            tickValue = +start + interval * (i + 1);
                            tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
                        }
                        tickValues.push(end);
                    }
                }
                if (!forTimeSeries) {
                    tickValues = tickValues.sort(function (a, b) {
                        return a - b;
                    });
                }
                return tickValues;
            };
            Axis.prototype.generateTransitions = function generateTransitions(duration) {
                var $$ = this.owner,
                    axes = $$.axes;
                return {
                    axisX: duration ? axes.x.transition().duration(duration) : axes.x,
                    axisY: duration ? axes.y.transition().duration(duration) : axes.y,
                    axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
                    axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
                };
            };
            Axis.prototype.redraw = function redraw(transitions, isHidden) {
                var $$ = this.owner;
                $$.axes.x.style("opacity", isHidden ? 0 : 1);
                $$.axes.y.style("opacity", isHidden ? 0 : 1);
                $$.axes.y2.style("opacity", isHidden ? 0 : 1);
                $$.axes.subx.style("opacity", isHidden ? 0 : 1);
                transitions.axisX.call($$.xAxis);
                transitions.axisY.call($$.yAxis);
                transitions.axisY2.call($$.y2Axis);
                transitions.axisSubX.call($$.subXAxis);
            };

            c3_chart_internal_fn.getClipPath = function (id) {
                var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
                return "url(" + (isIE9 ? "" : document.URL.split('#')[0]) + "#" + id + ")";
            };
            c3_chart_internal_fn.appendClip = function (parent, id) {
                return parent.append("clipPath").attr("id", id).append("rect");
            };
            c3_chart_internal_fn.getAxisClipX = function (forHorizontal) {
                // axis line width + padding for left
                var left = Math.max(30, this.margin.left);
                return forHorizontal ? -(1 + left) : -(left - 1);
            };
            c3_chart_internal_fn.getAxisClipY = function (forHorizontal) {
                return forHorizontal ? -20 : -this.margin.top;
            };
            c3_chart_internal_fn.getXAxisClipX = function () {
                var $$ = this;
                return $$.getAxisClipX(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getXAxisClipY = function () {
                var $$ = this;
                return $$.getAxisClipY(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getYAxisClipX = function () {
                var $$ = this;
                return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
            };
            c3_chart_internal_fn.getYAxisClipY = function () {
                var $$ = this;
                return $$.getAxisClipY($$.config.axis_rotated);
            };
            c3_chart_internal_fn.getAxisClipWidth = function (forHorizontal) {
                var $$ = this,
                    left = Math.max(30, $$.margin.left),
                    right = Math.max(30, $$.margin.right);
                // width + axis line width + padding for left/right
                return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
            };
            c3_chart_internal_fn.getAxisClipHeight = function (forHorizontal) {
                // less than 20 is not enough to show the axis label 'outer' without legend
                return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
            };
            c3_chart_internal_fn.getXAxisClipWidth = function () {
                var $$ = this;
                return $$.getAxisClipWidth(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getXAxisClipHeight = function () {
                var $$ = this;
                return $$.getAxisClipHeight(!$$.config.axis_rotated);
            };
            c3_chart_internal_fn.getYAxisClipWidth = function () {
                var $$ = this;
                return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
            };
            c3_chart_internal_fn.getYAxisClipHeight = function () {
                var $$ = this;
                return $$.getAxisClipHeight($$.config.axis_rotated);
            };

            c3_chart_internal_fn.initPie = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config;
                $$.pie = d3.layout.pie().value(function (d) {
                    return d.values.reduce(function (a, b) {
                        return a + b.value;
                    }, 0);
                });
                if (!config.data_order) {
                    $$.pie.sort(null);
                }
            };

            c3_chart_internal_fn.updateRadius = function () {
                var $$ = this,
                    config = $$.config,
                    w = config.gauge_width || config.donut_width;
                $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2;
                $$.radius = $$.radiusExpanded * 0.95;
                $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
                $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0;
            };

            c3_chart_internal_fn.updateArc = function () {
                var $$ = this;
                $$.svgArc = $$.getSvgArc();
                $$.svgArcExpanded = $$.getSvgArcExpanded();
                $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
            };

            c3_chart_internal_fn.updateAngle = function (d) {
                var $$ = this,
                    config = $$.config,
                    found = false,
                    index = 0,
                    gMin,
                    gMax,
                    gTic,
                    gValue;

                if (!config) {
                    return null;
                }

                $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {
                    if (!found && t.data.id === d.data.id) {
                        found = true;
                        d = t;
                        d.index = index;
                    }
                    index++;
                });
                if (isNaN(d.startAngle)) {
                    d.startAngle = 0;
                }
                if (isNaN(d.endAngle)) {
                    d.endAngle = d.startAngle;
                }
                if ($$.isGaugeType(d.data)) {
                    gMin = config.gauge_min;
                    gMax = config.gauge_max;
                    gTic = Math.PI * (config.gauge_fullCircle ? 2 : 1) / (gMax - gMin);
                    gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
                    d.startAngle = config.gauge_startingAngle;
                    d.endAngle = d.startAngle + gTic * gValue;
                }
                return found ? d : null;
            };

            c3_chart_internal_fn.getSvgArc = function () {
                var $$ = this,
                    arc = $$.d3.svg.arc().outerRadius($$.radius).innerRadius($$.innerRadius),
                    newArc = function (d, withoutUpdate) {
                    var updated;
                    if (withoutUpdate) {
                        return arc(d);
                    } // for interpolate
                    updated = $$.updateAngle(d);
                    return updated ? arc(updated) : "M 0 0";
                };
                // TODO: extends all function
                newArc.centroid = arc.centroid;
                return newArc;
            };

            c3_chart_internal_fn.getSvgArcExpanded = function (rate) {
                var $$ = this,
                    arc = $$.d3.svg.arc().outerRadius($$.radiusExpanded * (rate ? rate : 1)).innerRadius($$.innerRadius);
                return function (d) {
                    var updated = $$.updateAngle(d);
                    return updated ? arc(updated) : "M 0 0";
                };
            };

            c3_chart_internal_fn.getArc = function (d, withoutUpdate, force) {
                return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
            };

            c3_chart_internal_fn.transformForArcLabel = function (d) {
                var $$ = this,
                    config = $$.config,
                    updated = $$.updateAngle(d),
                    c,
                    x,
                    y,
                    h,
                    ratio,
                    translate = "";
                if (updated && !$$.hasType('gauge')) {
                    c = this.svgArc.centroid(updated);
                    x = isNaN(c[0]) ? 0 : c[0];
                    y = isNaN(c[1]) ? 0 : c[1];
                    h = Math.sqrt(x * x + y * y);
                    if ($$.hasType('donut') && config.donut_label_ratio) {
                        ratio = isFunction(config.donut_label_ratio) ? config.donut_label_ratio(d, $$.radius, h) : config.donut_label_ratio;
                    } else if ($$.hasType('pie') && config.pie_label_ratio) {
                        ratio = isFunction(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio;
                    } else {
                        ratio = $$.radius && h ? (36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius / h : 0;
                    }
                    translate = "translate(" + x * ratio + ',' + y * ratio + ")";
                }
                return translate;
            };

            c3_chart_internal_fn.getArcRatio = function (d) {
                var $$ = this,
                    config = $$.config,
                    whole = Math.PI * ($$.hasType('gauge') && !config.gauge_fullCircle ? 1 : 2);
                return d ? (d.endAngle - d.startAngle) / whole : null;
            };

            c3_chart_internal_fn.convertToArcData = function (d) {
                return this.addName({
                    id: d.data.id,
                    value: d.value,
                    ratio: this.getArcRatio(d),
                    index: d.index
                });
            };

            c3_chart_internal_fn.textForArcLabel = function (d) {
                var $$ = this,
                    updated,
                    value,
                    ratio,
                    id,
                    format;
                if (!$$.shouldShowArcLabel()) {
                    return "";
                }
                updated = $$.updateAngle(d);
                value = updated ? updated.value : null;
                ratio = $$.getArcRatio(updated);
                id = d.data.id;
                if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
                    return "";
                }
                format = $$.getArcLabelFormat();
                return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);
            };

            c3_chart_internal_fn.expandArc = function (targetIds) {
                var $$ = this,
                    interval;

                // MEMO: avoid to cancel transition
                if ($$.transiting) {
                    interval = window.setInterval(function () {
                        if (!$$.transiting) {
                            window.clearInterval(interval);
                            if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
                                $$.expandArc(targetIds);
                            }
                        }
                    }, 10);
                    return;
                }

                targetIds = $$.mapToTargetIds(targetIds);

                $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function (d) {
                    if (!$$.shouldExpand(d.data.id)) {
                        return;
                    }
                    $$.d3.select(this).selectAll('path').transition().duration($$.expandDuration(d.data.id)).attr("d", $$.svgArcExpanded).transition().duration($$.expandDuration(d.data.id) * 2).attr("d", $$.svgArcExpandedSub).each(function (d) {
                        if ($$.isDonutType(d.data)) {
                            // callback here
                        }
                    });
                });
            };

            c3_chart_internal_fn.unexpandArc = function (targetIds) {
                var $$ = this;

                if ($$.transiting) {
                    return;
                }

                targetIds = $$.mapToTargetIds(targetIds);

                $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).selectAll('path').transition().duration(function (d) {
                    return $$.expandDuration(d.data.id);
                }).attr("d", $$.svgArc);
                $$.svg.selectAll('.' + CLASS.arc).style("opacity", 1);
            };

            c3_chart_internal_fn.expandDuration = function (id) {
                var $$ = this,
                    config = $$.config;

                if ($$.isDonutType(id)) {
                    return config.donut_expand_duration;
                } else if ($$.isGaugeType(id)) {
                    return config.gauge_expand_duration;
                } else if ($$.isPieType(id)) {
                    return config.pie_expand_duration;
                } else {
                    return 50;
                }
            };

            c3_chart_internal_fn.shouldExpand = function (id) {
                var $$ = this,
                    config = $$.config;
                return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
            };

            c3_chart_internal_fn.shouldShowArcLabel = function () {
                var $$ = this,
                    config = $$.config,
                    shouldShow = true;
                if ($$.hasType('donut')) {
                    shouldShow = config.donut_label_show;
                } else if ($$.hasType('pie')) {
                    shouldShow = config.pie_label_show;
                }
                // when gauge, always true
                return shouldShow;
            };

            c3_chart_internal_fn.meetsArcLabelThreshold = function (ratio) {
                var $$ = this,
                    config = $$.config,
                    threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold;
                return ratio >= threshold;
            };

            c3_chart_internal_fn.getArcLabelFormat = function () {
                var $$ = this,
                    config = $$.config,
                    format = config.pie_label_format;
                if ($$.hasType('gauge')) {
                    format = config.gauge_label_format;
                } else if ($$.hasType('donut')) {
                    format = config.donut_label_format;
                }
                return format;
            };

            c3_chart_internal_fn.getArcTitle = function () {
                var $$ = this;
                return $$.hasType('donut') ? $$.config.donut_title : "";
            };

            c3_chart_internal_fn.updateTargetsForArc = function (targets) {
                var $$ = this,
                    main = $$.main,
                    mainPieUpdate,
                    mainPieEnter,
                    classChartArc = $$.classChartArc.bind($$),
                    classArcs = $$.classArcs.bind($$),
                    classFocus = $$.classFocus.bind($$);
                mainPieUpdate = main.select('.' + CLASS.chartArcs).selectAll('.' + CLASS.chartArc).data($$.pie(targets)).attr("class", function (d) {
                    return classChartArc(d) + classFocus(d.data);
                });
                mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
                mainPieEnter.append('g').attr('class', classArcs);
                mainPieEnter.append("text").attr("dy", $$.hasType('gauge') ? "-.1em" : ".35em").style("opacity", 0).style("text-anchor", "middle").style("pointer-events", "none");
                // MEMO: can not keep same color..., but not bad to update color in redraw
                //mainPieUpdate.exit().remove();
            };

            c3_chart_internal_fn.initArc = function () {
                var $$ = this;
                $$.arcs = $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
                $$.arcs.append('text').attr('class', CLASS.chartArcsTitle).style("text-anchor", "middle").text($$.getArcTitle());
            };

            c3_chart_internal_fn.redrawArc = function (duration, durationForExit, withTransform) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    main = $$.main,
                    mainArc;
                mainArc = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arc).data($$.arcData.bind($$));
                mainArc.enter().append('path').attr("class", $$.classArc.bind($$)).style("fill", function (d) {
                    return $$.color(d.data);
                }).style("cursor", function (d) {
                    return config.interaction_enabled && config.data_selection_isselectable(d) ? "pointer" : null;
                }).style("opacity", 0).each(function (d) {
                    if ($$.isGaugeType(d.data)) {
                        d.startAngle = d.endAngle = config.gauge_startingAngle;
                    }
                    this._current = d;
                });
                mainArc.attr("transform", function (d) {
                    return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
                }).style("opacity", function (d) {
                    return d === this._current ? 0 : 1;
                }).on('mouseover', config.interaction_enabled ? function (d) {
                    var updated, arcData;
                    if ($$.transiting) {
                        // skip while transiting
                        return;
                    }
                    updated = $$.updateAngle(d);
                    if (updated) {
                        arcData = $$.convertToArcData(updated);
                        // transitions
                        $$.expandArc(updated.data.id);
                        $$.api.focus(updated.data.id);
                        $$.toggleFocusLegend(updated.data.id, true);
                        $$.config.data_onmouseover(arcData, this);
                    }
                } : null).on('mousemove', config.interaction_enabled ? function (d) {
                    var updated = $$.updateAngle(d),
                        arcData,
                        selectedData;
                    if (updated) {
                        arcData = $$.convertToArcData(updated), selectedData = [arcData];
                        $$.showTooltip(selectedData, this);
                    }
                } : null).on('mouseout', config.interaction_enabled ? function (d) {
                    var updated, arcData;
                    if ($$.transiting) {
                        // skip while transiting
                        return;
                    }
                    updated = $$.updateAngle(d);
                    if (updated) {
                        arcData = $$.convertToArcData(updated);
                        // transitions
                        $$.unexpandArc(updated.data.id);
                        $$.api.revert();
                        $$.revertLegend();
                        $$.hideTooltip();
                        $$.config.data_onmouseout(arcData, this);
                    }
                } : null).on('click', config.interaction_enabled ? function (d, i) {
                    var updated = $$.updateAngle(d),
                        arcData;
                    if (updated) {
                        arcData = $$.convertToArcData(updated);
                        if ($$.toggleShape) {
                            $$.toggleShape(this, arcData, i);
                        }
                        $$.config.data_onclick.call($$.api, arcData, this);
                    }
                } : null).each(function () {
                    $$.transiting = true;
                }).transition().duration(duration).attrTween("d", function (d) {
                    var updated = $$.updateAngle(d),
                        interpolate;
                    if (!updated) {
                        return function () {
                            return "M 0 0";
                        };
                    }
                    //                if (this._current === d) {
                    //                    this._current = {
                    //                        startAngle: Math.PI*2,
                    //                        endAngle: Math.PI*2,
                    //                    };
                    //                }
                    if (isNaN(this._current.startAngle)) {
                        this._current.startAngle = 0;
                    }
                    if (isNaN(this._current.endAngle)) {
                        this._current.endAngle = this._current.startAngle;
                    }
                    interpolate = d3.interpolate(this._current, updated);
                    this._current = interpolate(0);
                    return function (t) {
                        var interpolated = interpolate(t);
                        interpolated.data = d.data; // data.id will be updated by interporator
                        return $$.getArc(interpolated, true);
                    };
                }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
                    return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
                }) // Where gauge reading color would receive customization.
                .style("opacity", 1).call($$.endall, function () {
                    $$.transiting = false;
                });
                mainArc.exit().transition().duration(durationForExit).style('opacity', 0).remove();
                main.selectAll('.' + CLASS.chartArc).select('text').style("opacity", 0).attr('class', function (d) {
                    return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
                }).text($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style('font-size', function (d) {
                    return $$.isGaugeType(d.data) ? Math.round($$.radius / 5) + 'px' : '';
                }).transition().duration(duration).style("opacity", function (d) {
                    return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
                });
                main.select('.' + CLASS.chartArcsTitle).style("opacity", $$.hasType('donut') || $$.hasType('gauge') ? 1 : 0);

                if ($$.hasType('gauge')) {
                    $$.arcs.select('.' + CLASS.chartArcsBackground).attr("d", function () {
                        var d = {
                            data: [{ value: config.gauge_max }],
                            startAngle: config.gauge_startingAngle,
                            endAngle: -1 * config.gauge_startingAngle
                        };
                        return $$.getArc(d, true, true);
                    });
                    $$.arcs.select('.' + CLASS.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : '');
                    $$.arcs.select('.' + CLASS.chartArcsGaugeMin).attr("dx", -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_min : '');
                    $$.arcs.select('.' + CLASS.chartArcsGaugeMax).attr("dx", $$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_max : '');
                }
            };
            c3_chart_internal_fn.initGauge = function () {
                var arcs = this.arcs;
                if (this.hasType('gauge')) {
                    arcs.append('path').attr("class", CLASS.chartArcsBackground);
                    arcs.append("text").attr("class", CLASS.chartArcsGaugeUnit).style("text-anchor", "middle").style("pointer-events", "none");
                    arcs.append("text").attr("class", CLASS.chartArcsGaugeMin).style("text-anchor", "middle").style("pointer-events", "none");
                    arcs.append("text").attr("class", CLASS.chartArcsGaugeMax).style("text-anchor", "middle").style("pointer-events", "none");
                }
            };
            c3_chart_internal_fn.getGaugeLabelHeight = function () {
                return this.config.gauge_label_show ? 20 : 0;
            };

            c3_chart_internal_fn.initRegion = function () {
                var $$ = this;
                $$.region = $$.main.append('g').attr("clip-path", $$.clipPath).attr("class", CLASS.regions);
            };
            c3_chart_internal_fn.updateRegion = function (duration) {
                var $$ = this,
                    config = $$.config;

                // hide if arc type
                $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');

                $$.mainRegion = $$.main.select('.' + CLASS.regions).selectAll('.' + CLASS.region).data(config.regions);
                $$.mainRegion.enter().append('g').append('rect').style("fill-opacity", 0);
                $$.mainRegion.attr('class', $$.classRegion.bind($$));
                $$.mainRegion.exit().transition().duration(duration).style("opacity", 0).remove();
            };
            c3_chart_internal_fn.redrawRegion = function (withTransition) {
                var $$ = this,
                    regions = $$.mainRegion.selectAll('rect').each(function () {
                    // data is binded to g and it's not transferred to rect (child node) automatically,
                    // then data of each rect has to be updated manually.
                    // TODO: there should be more efficient way to solve this?
                    var parentData = $$.d3.select(this.parentNode).datum();
                    $$.d3.select(this).datum(parentData);
                }),
                    x = $$.regionX.bind($$),
                    y = $$.regionY.bind($$),
                    w = $$.regionWidth.bind($$),
                    h = $$.regionHeight.bind($$);
                return [(withTransition ? regions.transition() : regions).attr("x", x).attr("y", y).attr("width", w).attr("height", h).style("fill-opacity", function (d) {
                    return isValue(d.opacity) ? d.opacity : 0.1;
                })];
            };
            c3_chart_internal_fn.regionX = function (d) {
                var $$ = this,
                    config = $$.config,
                    xPos,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    xPos = config.axis_rotated ? 'start' in d ? yScale(d.start) : 0 : 0;
                } else {
                    xPos = config.axis_rotated ? 0 : 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0;
                }
                return xPos;
            };
            c3_chart_internal_fn.regionY = function (d) {
                var $$ = this,
                    config = $$.config,
                    yPos,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0;
                } else {
                    yPos = config.axis_rotated ? 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0 : 0;
                }
                return yPos;
            };
            c3_chart_internal_fn.regionWidth = function (d) {
                var $$ = this,
                    config = $$.config,
                    start = $$.regionX(d),
                    end,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    end = config.axis_rotated ? 'end' in d ? yScale(d.end) : $$.width : $$.width;
                } else {
                    end = config.axis_rotated ? $$.width : 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width;
                }
                return end < start ? 0 : end - start;
            };
            c3_chart_internal_fn.regionHeight = function (d) {
                var $$ = this,
                    config = $$.config,
                    start = this.regionY(d),
                    end,
                    yScale = d.axis === 'y' ? $$.y : $$.y2;
                if (d.axis === 'y' || d.axis === 'y2') {
                    end = config.axis_rotated ? $$.height : 'start' in d ? yScale(d.start) : $$.height;
                } else {
                    end = config.axis_rotated ? 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height : $$.height;
                }
                return end < start ? 0 : end - start;
            };
            c3_chart_internal_fn.isRegionOnX = function (d) {
                return !d.axis || d.axis === 'x';
            };

            c3_chart_internal_fn.drag = function (mouse) {
                var $$ = this,
                    config = $$.config,
                    main = $$.main,
                    d3 = $$.d3;
                var sx, sy, mx, my, minX, maxX, minY, maxY;

                if ($$.hasArcType()) {
                    return;
                }
                if (!config.data_selection_enabled) {
                    return;
                } // do nothing if not selectable
                if (config.zoom_enabled && !$$.zoom.altDomain) {
                    return;
                } // skip if zoomable because of conflict drag dehavior
                if (!config.data_selection_multiple) {
                    return;
                } // skip when single selection because drag is used for multiple selection

                sx = $$.dragStart[0];
                sy = $$.dragStart[1];
                mx = mouse[0];
                my = mouse[1];
                minX = Math.min(sx, mx);
                maxX = Math.max(sx, mx);
                minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my);
                maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

                main.select('.' + CLASS.dragarea).attr('x', minX).attr('y', minY).attr('width', maxX - minX).attr('height', maxY - minY);
                // TODO: binary search when multiple xs
                main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).filter(function (d) {
                    return config.data_selection_isselectable(d);
                }).each(function (d, i) {
                    var shape = d3.select(this),
                        isSelected = shape.classed(CLASS.SELECTED),
                        isIncluded = shape.classed(CLASS.INCLUDED),
                        _x,
                        _y,
                        _w,
                        _h,
                        toggle,
                        isWithin = false,
                        box;
                    if (shape.classed(CLASS.circle)) {
                        _x = shape.attr("cx") * 1;
                        _y = shape.attr("cy") * 1;
                        toggle = $$.togglePoint;
                        isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
                    } else if (shape.classed(CLASS.bar)) {
                        box = getPathBox(this);
                        _x = box.x;
                        _y = box.y;
                        _w = box.width;
                        _h = box.height;
                        toggle = $$.togglePath;
                        isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
                    } else {
                        // line/area selection not supported yet
                        return;
                    }
                    if (isWithin ^ isIncluded) {
                        shape.classed(CLASS.INCLUDED, !isIncluded);
                        // TODO: included/unincluded callback here
                        shape.classed(CLASS.SELECTED, !isSelected);
                        toggle.call($$, !isSelected, shape, d, i);
                    }
                });
            };

            c3_chart_internal_fn.dragstart = function (mouse) {
                var $$ = this,
                    config = $$.config;
                if ($$.hasArcType()) {
                    return;
                }
                if (!config.data_selection_enabled) {
                    return;
                } // do nothing if not selectable
                $$.dragStart = mouse;
                $$.main.select('.' + CLASS.chart).append('rect').attr('class', CLASS.dragarea).style('opacity', 0.1);
                $$.dragging = true;
            };

            c3_chart_internal_fn.dragend = function () {
                var $$ = this,
                    config = $$.config;
                if ($$.hasArcType()) {
                    return;
                }
                if (!config.data_selection_enabled) {
                    return;
                } // do nothing if not selectable
                $$.main.select('.' + CLASS.dragarea).transition().duration(100).style('opacity', 0).remove();
                $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
                $$.dragging = false;
            };

            c3_chart_internal_fn.selectPoint = function (target, d, i) {
                var $$ = this,
                    config = $$.config,
                    cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
                    cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),
                    r = $$.pointSelectR.bind($$);
                config.data_onselected.call($$.api, d, target.node());
                // add selected-circle on low layer g
                $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).data([d]).enter().append('circle').attr("class", function () {
                    return $$.generateClass(CLASS.selectedCircle, i);
                }).attr("cx", cx).attr("cy", cy).attr("stroke", function () {
                    return $$.color(d);
                }).attr("r", function (d) {
                    return $$.pointSelectR(d) * 1.4;
                }).transition().duration(100).attr("r", r);
            };
            c3_chart_internal_fn.unselectPoint = function (target, d, i) {
                var $$ = this;
                $$.config.data_onunselected.call($$.api, d, target.node());
                // remove selected-circle from low layer g
                $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).transition().duration(100).attr('r', 0).remove();
            };
            c3_chart_internal_fn.togglePoint = function (selected, target, d, i) {
                selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
            };
            c3_chart_internal_fn.selectPath = function (target, d) {
                var $$ = this;
                $$.config.data_onselected.call($$, d, target.node());
                if ($$.config.interaction_brighten) {
                    target.transition().duration(100).style("fill", function () {
                        return $$.d3.rgb($$.color(d)).brighter(0.75);
                    });
                }
            };
            c3_chart_internal_fn.unselectPath = function (target, d) {
                var $$ = this;
                $$.config.data_onunselected.call($$, d, target.node());
                if ($$.config.interaction_brighten) {
                    target.transition().duration(100).style("fill", function () {
                        return $$.color(d);
                    });
                }
            };
            c3_chart_internal_fn.togglePath = function (selected, target, d, i) {
                selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
            };
            c3_chart_internal_fn.getToggle = function (that, d) {
                var $$ = this,
                    toggle;
                if (that.nodeName === 'circle') {
                    if ($$.isStepType(d)) {
                        // circle is hidden in step chart, so treat as within the click area
                        toggle = function () {}; // TODO: how to select step chart?
                    } else {
                        toggle = $$.togglePoint;
                    }
                } else if (that.nodeName === 'path') {
                    toggle = $$.togglePath;
                }
                return toggle;
            };
            c3_chart_internal_fn.toggleShape = function (that, d, i) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    shape = d3.select(that),
                    isSelected = shape.classed(CLASS.SELECTED),
                    toggle = $$.getToggle(that, d).bind($$);

                if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
                    if (!config.data_selection_multiple) {
                        $$.main.selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : "")).selectAll('.' + CLASS.shape).each(function (d, i) {
                            var shape = d3.select(this);
                            if (shape.classed(CLASS.SELECTED)) {
                                toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                            }
                        });
                    }
                    shape.classed(CLASS.SELECTED, !isSelected);
                    toggle(!isSelected, shape, d, i);
                }
            };

            c3_chart_internal_fn.initBrush = function () {
                var $$ = this,
                    d3 = $$.d3;
                $$.brush = d3.svg.brush().on("brush", function () {
                    $$.redrawForBrush();
                });
                $$.brush.update = function () {
                    if ($$.context) {
                        $$.context.select('.' + CLASS.brush).call(this);
                    }
                    return this;
                };
                $$.brush.scale = function (scale) {
                    return $$.config.axis_rotated ? this.y(scale) : this.x(scale);
                };
            };
            c3_chart_internal_fn.initSubchart = function () {
                var $$ = this,
                    config = $$.config,
                    context = $$.context = $$.svg.append("g").attr("transform", $$.getTranslate('context')),
                    visibility = config.subchart_show ? 'visible' : 'hidden';

                context.style('visibility', visibility);

                // Define g for chart area
                context.append('g').attr("clip-path", $$.clipPathForSubchart).attr('class', CLASS.chart);

                // Define g for bar chart area
                context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);

                // Define g for line chart area
                context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);

                // Add extent rect for Brush
                context.append("g").attr("clip-path", $$.clipPath).attr("class", CLASS.brush).call($$.brush);

                // ATTENTION: This must be called AFTER chart added
                // Add Axis
                $$.axes.subx = context.append("g").attr("class", CLASS.axisX).attr("transform", $$.getTranslate('subx')).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : 'hidden');
            };
            c3_chart_internal_fn.updateTargetsForSubchart = function (targets) {
                var $$ = this,
                    context = $$.context,
                    config = $$.config,
                    contextLineEnter,
                    contextLineUpdate,
                    contextBarEnter,
                    contextBarUpdate,
                    classChartBar = $$.classChartBar.bind($$),
                    classBars = $$.classBars.bind($$),
                    classChartLine = $$.classChartLine.bind($$),
                    classLines = $$.classLines.bind($$),
                    classAreas = $$.classAreas.bind($$);

                if (config.subchart_show) {
                    //-- Bar --//
                    contextBarUpdate = context.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', classChartBar);
                    contextBarEnter = contextBarUpdate.enter().append('g').style('opacity', 0).attr('class', classChartBar);
                    // Bars for each data
                    contextBarEnter.append('g').attr("class", classBars);

                    //-- Line --//
                    contextLineUpdate = context.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', classChartLine);
                    contextLineEnter = contextLineUpdate.enter().append('g').style('opacity', 0).attr('class', classChartLine);
                    // Lines for each data
                    contextLineEnter.append("g").attr("class", classLines);
                    // Area
                    contextLineEnter.append("g").attr("class", classAreas);

                    //-- Brush --//
                    context.selectAll('.' + CLASS.brush + ' rect').attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
                }
            };
            c3_chart_internal_fn.updateBarForSubchart = function (durationForExit) {
                var $$ = this;
                $$.contextBar = $$.context.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data($$.barData.bind($$));
                $$.contextBar.enter().append('path').attr("class", $$.classBar.bind($$)).style("stroke", 'none').style("fill", $$.color);
                $$.contextBar.style("opacity", $$.initialOpacity.bind($$));
                $$.contextBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {
                (withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar).attr('d', drawBarOnSub).style('opacity', 1);
            };
            c3_chart_internal_fn.updateLineForSubchart = function (durationForExit) {
                var $$ = this;
                $$.contextLine = $$.context.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
                $$.contextLine.enter().append('path').attr('class', $$.classLine.bind($$)).style('stroke', $$.color);
                $$.contextLine.style("opacity", $$.initialOpacity.bind($$));
                $$.contextLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {
                (withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine).attr("d", drawLineOnSub).style('opacity', 1);
            };
            c3_chart_internal_fn.updateAreaForSubchart = function (durationForExit) {
                var $$ = this,
                    d3 = $$.d3;
                $$.contextArea = $$.context.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
                $$.contextArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
                    $$.orgAreaOpacity = +d3.select(this).style('opacity');return 0;
                });
                $$.contextArea.style("opacity", 0);
                $$.contextArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
            };
            c3_chart_internal_fn.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {
                (withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
            };
            c3_chart_internal_fn.redrawSubchart = function (withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    drawAreaOnSub,
                    drawBarOnSub,
                    drawLineOnSub;

                $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden');

                // subchart
                if (config.subchart_show) {
                    // reflect main chart to extent on subchart if zoomed
                    if (d3.event && d3.event.type === 'zoom') {
                        $$.brush.extent($$.x.orgDomain()).update();
                    }
                    // update subchart elements if needed
                    if (withSubchart) {

                        // extent rect
                        if (!$$.brush.empty()) {
                            $$.brush.extent($$.x.orgDomain()).update();
                        }
                        // setup drawer - MEMO: this must be called after axis updated
                        drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
                        drawBarOnSub = $$.generateDrawBar(barIndices, true);
                        drawLineOnSub = $$.generateDrawLine(lineIndices, true);

                        $$.updateBarForSubchart(duration);
                        $$.updateLineForSubchart(duration);
                        $$.updateAreaForSubchart(duration);

                        $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
                        $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
                        $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
                    }
                }
            };
            c3_chart_internal_fn.redrawForBrush = function () {
                var $$ = this,
                    x = $$.x;
                $$.redraw({
                    withTransition: false,
                    withY: $$.config.zoom_rescale,
                    withSubchart: false,
                    withUpdateXDomain: true,
                    withDimension: false
                });
                $$.config.subchart_onbrush.call($$.api, x.orgDomain());
            };
            c3_chart_internal_fn.transformContext = function (withTransition, transitions) {
                var $$ = this,
                    subXAxis;
                if (transitions && transitions.axisSubX) {
                    subXAxis = transitions.axisSubX;
                } else {
                    subXAxis = $$.context.select('.' + CLASS.axisX);
                    if (withTransition) {
                        subXAxis = subXAxis.transition();
                    }
                }
                $$.context.attr("transform", $$.getTranslate('context'));
                subXAxis.attr("transform", $$.getTranslate('subx'));
            };
            c3_chart_internal_fn.getDefaultExtent = function () {
                var $$ = this,
                    config = $$.config,
                    extent = isFunction(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;
                if ($$.isTimeSeries()) {
                    extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])];
                }
                return extent;
            };

            c3_chart_internal_fn.initZoom = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    startEvent;

                $$.zoom = d3.behavior.zoom().on("zoomstart", function () {
                    startEvent = d3.event.sourceEvent;
                    $$.zoom.altDomain = d3.event.sourceEvent.altKey ? $$.x.orgDomain() : null;
                    config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
                }).on("zoom", function () {
                    $$.redrawForZoom.call($$);
                }).on('zoomend', function () {
                    var event = d3.event.sourceEvent;
                    // if click, do nothing. otherwise, click interaction will be canceled.
                    if (event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY) {
                        return;
                    }
                    $$.redrawEventRect();
                    $$.updateZoom();
                    config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
                });
                $$.zoom.scale = function (scale) {
                    return config.axis_rotated ? this.y(scale) : this.x(scale);
                };
                $$.zoom.orgScaleExtent = function () {
                    var extent = config.zoom_extent ? config.zoom_extent : [1, 10];
                    return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
                };
                $$.zoom.updateScaleExtent = function () {
                    var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
                        extent = this.orgScaleExtent();
                    this.scaleExtent([extent[0] * ratio, extent[1] * ratio]);
                    return this;
                };
            };
            c3_chart_internal_fn.getZoomDomain = function () {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3,
                    min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),
                    max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);
                return [min, max];
            };
            c3_chart_internal_fn.updateZoom = function () {
                var $$ = this,
                    z = $$.config.zoom_enabled ? $$.zoom : function () {};
                $$.main.select('.' + CLASS.zoomRect).call(z).on("dblclick.zoom", null);
                $$.main.selectAll('.' + CLASS.eventRect).call(z).on("dblclick.zoom", null);
            };
            c3_chart_internal_fn.redrawForZoom = function () {
                var $$ = this,
                    d3 = $$.d3,
                    config = $$.config,
                    zoom = $$.zoom,
                    x = $$.x;
                if (!config.zoom_enabled) {
                    return;
                }
                if ($$.filterTargetsToShow($$.data.targets).length === 0) {
                    return;
                }
                if (d3.event.sourceEvent.type === 'mousemove' && zoom.altDomain) {
                    x.domain(zoom.altDomain);
                    zoom.scale(x).updateScaleExtent();
                    return;
                }
                if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
                    x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
                }
                $$.redraw({
                    withTransition: false,
                    withY: config.zoom_rescale,
                    withSubchart: false,
                    withEventRect: false,
                    withDimension: false
                });
                if (d3.event.sourceEvent.type === 'mousemove') {
                    $$.cancelClick = true;
                }
                config.zoom_onzoom.call($$.api, x.orgDomain());
            };

            c3_chart_internal_fn.generateColor = function () {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3,
                    colors = config.data_colors,
                    pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.scale.category10().range(),
                    callback = config.data_color,
                    ids = [];

                return function (d) {
                    var id = d.id || d.data && d.data.id || d,
                        color;

                    // if callback function is provided
                    if (colors[id] instanceof Function) {
                        color = colors[id](d);
                    }
                    // if specified, choose that color
                    else if (colors[id]) {
                            color = colors[id];
                        }
                        // if not specified, choose from pattern
                        else {
                                if (ids.indexOf(id) < 0) {
                                    ids.push(id);
                                }
                                color = pattern[ids.indexOf(id) % pattern.length];
                                colors[id] = color;
                            }
                    return callback instanceof Function ? callback(color, d) : color;
                };
            };
            c3_chart_internal_fn.generateLevelColor = function () {
                var $$ = this,
                    config = $$.config,
                    colors = config.color_pattern,
                    threshold = config.color_threshold,
                    asValue = threshold.unit === 'value',
                    values = threshold.values && threshold.values.length ? threshold.values : [],
                    max = threshold.max || 100;
                return notEmpty(config.color_threshold) ? function (value) {
                    var i,
                        v,
                        color = colors[colors.length - 1];
                    for (i = 0; i < values.length; i++) {
                        v = asValue ? value : value * 100 / max;
                        if (v < values[i]) {
                            color = colors[i];
                            break;
                        }
                    }
                    return color;
                } : null;
            };

            c3_chart_internal_fn.getYFormat = function (forArc) {
                var $$ = this,
                    formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,
                    formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
                return function (v, ratio, id) {
                    var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
                    return format.call($$, v, ratio);
                };
            };
            c3_chart_internal_fn.yFormat = function (v) {
                var $$ = this,
                    config = $$.config,
                    format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat;
                return format(v);
            };
            c3_chart_internal_fn.y2Format = function (v) {
                var $$ = this,
                    config = $$.config,
                    format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat;
                return format(v);
            };
            c3_chart_internal_fn.defaultValueFormat = function (v) {
                return isValue(v) ? +v : "";
            };
            c3_chart_internal_fn.defaultArcValueFormat = function (v, ratio) {
                return (ratio * 100).toFixed(1) + '%';
            };
            c3_chart_internal_fn.dataLabelFormat = function (targetId) {
                var $$ = this,
                    data_labels = $$.config.data_labels,
                    format,
                    defaultFormat = function (v) {
                    return isValue(v) ? +v : "";
                };
                // find format according to axis id
                if (typeof data_labels.format === 'function') {
                    format = data_labels.format;
                } else if (typeof data_labels.format === 'object') {
                    if (data_labels.format[targetId]) {
                        format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId];
                    } else {
                        format = function () {
                            return '';
                        };
                    }
                } else {
                    format = defaultFormat;
                }
                return format;
            };

            c3_chart_internal_fn.hasCaches = function (ids) {
                for (var i = 0; i < ids.length; i++) {
                    if (!(ids[i] in this.cache)) {
                        return false;
                    }
                }
                return true;
            };
            c3_chart_internal_fn.addCache = function (id, target) {
                this.cache[id] = this.cloneTarget(target);
            };
            c3_chart_internal_fn.getCaches = function (ids) {
                var targets = [],
                    i;
                for (i = 0; i < ids.length; i++) {
                    if (ids[i] in this.cache) {
                        targets.push(this.cloneTarget(this.cache[ids[i]]));
                    }
                }
                return targets;
            };

            var CLASS = c3_chart_internal_fn.CLASS = {
                target: 'c3-target',
                chart: 'c3-chart',
                chartLine: 'c3-chart-line',
                chartLines: 'c3-chart-lines',
                chartBar: 'c3-chart-bar',
                chartBars: 'c3-chart-bars',
                chartText: 'c3-chart-text',
                chartTexts: 'c3-chart-texts',
                chartArc: 'c3-chart-arc',
                chartArcs: 'c3-chart-arcs',
                chartArcsTitle: 'c3-chart-arcs-title',
                chartArcsBackground: 'c3-chart-arcs-background',
                chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
                chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
                chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
                selectedCircle: 'c3-selected-circle',
                selectedCircles: 'c3-selected-circles',
                eventRect: 'c3-event-rect',
                eventRects: 'c3-event-rects',
                eventRectsSingle: 'c3-event-rects-single',
                eventRectsMultiple: 'c3-event-rects-multiple',
                zoomRect: 'c3-zoom-rect',
                brush: 'c3-brush',
                focused: 'c3-focused',
                defocused: 'c3-defocused',
                region: 'c3-region',
                regions: 'c3-regions',
                title: 'c3-title',
                tooltipContainer: 'c3-tooltip-container',
                tooltip: 'c3-tooltip',
                tooltipName: 'c3-tooltip-name',
                shape: 'c3-shape',
                shapes: 'c3-shapes',
                line: 'c3-line',
                lines: 'c3-lines',
                bar: 'c3-bar',
                bars: 'c3-bars',
                circle: 'c3-circle',
                circles: 'c3-circles',
                arc: 'c3-arc',
                arcs: 'c3-arcs',
                area: 'c3-area',
                areas: 'c3-areas',
                empty: 'c3-empty',
                text: 'c3-text',
                texts: 'c3-texts',
                gaugeValue: 'c3-gauge-value',
                grid: 'c3-grid',
                gridLines: 'c3-grid-lines',
                xgrid: 'c3-xgrid',
                xgrids: 'c3-xgrids',
                xgridLine: 'c3-xgrid-line',
                xgridLines: 'c3-xgrid-lines',
                xgridFocus: 'c3-xgrid-focus',
                ygrid: 'c3-ygrid',
                ygrids: 'c3-ygrids',
                ygridLine: 'c3-ygrid-line',
                ygridLines: 'c3-ygrid-lines',
                axis: 'c3-axis',
                axisX: 'c3-axis-x',
                axisXLabel: 'c3-axis-x-label',
                axisY: 'c3-axis-y',
                axisYLabel: 'c3-axis-y-label',
                axisY2: 'c3-axis-y2',
                axisY2Label: 'c3-axis-y2-label',
                legendBackground: 'c3-legend-background',
                legendItem: 'c3-legend-item',
                legendItemEvent: 'c3-legend-item-event',
                legendItemTile: 'c3-legend-item-tile',
                legendItemHidden: 'c3-legend-item-hidden',
                legendItemFocused: 'c3-legend-item-focused',
                dragarea: 'c3-dragarea',
                EXPANDED: '_expanded_',
                SELECTED: '_selected_',
                INCLUDED: '_included_'
            };
            c3_chart_internal_fn.generateClass = function (prefix, targetId) {
                return " " + prefix + " " + prefix + this.getTargetSelectorSuffix(targetId);
            };
            c3_chart_internal_fn.classText = function (d) {
                return this.generateClass(CLASS.text, d.index);
            };
            c3_chart_internal_fn.classTexts = function (d) {
                return this.generateClass(CLASS.texts, d.id);
            };
            c3_chart_internal_fn.classShape = function (d) {
                return this.generateClass(CLASS.shape, d.index);
            };
            c3_chart_internal_fn.classShapes = function (d) {
                return this.generateClass(CLASS.shapes, d.id);
            };
            c3_chart_internal_fn.classLine = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.line, d.id);
            };
            c3_chart_internal_fn.classLines = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
            };
            c3_chart_internal_fn.classCircle = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
            };
            c3_chart_internal_fn.classCircles = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
            };
            c3_chart_internal_fn.classBar = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
            };
            c3_chart_internal_fn.classBars = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
            };
            c3_chart_internal_fn.classArc = function (d) {
                return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
            };
            c3_chart_internal_fn.classArcs = function (d) {
                return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
            };
            c3_chart_internal_fn.classArea = function (d) {
                return this.classShape(d) + this.generateClass(CLASS.area, d.id);
            };
            c3_chart_internal_fn.classAreas = function (d) {
                return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
            };
            c3_chart_internal_fn.classRegion = function (d, i) {
                return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '');
            };
            c3_chart_internal_fn.classEvent = function (d) {
                return this.generateClass(CLASS.eventRect, d.index);
            };
            c3_chart_internal_fn.classTarget = function (id) {
                var $$ = this;
                var additionalClassSuffix = $$.config.data_classes[id],
                    additionalClass = '';
                if (additionalClassSuffix) {
                    additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
                }
                return $$.generateClass(CLASS.target, id) + additionalClass;
            };
            c3_chart_internal_fn.classFocus = function (d) {
                return this.classFocused(d) + this.classDefocused(d);
            };
            c3_chart_internal_fn.classFocused = function (d) {
                return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
            };
            c3_chart_internal_fn.classDefocused = function (d) {
                return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '');
            };
            c3_chart_internal_fn.classChartText = function (d) {
                return CLASS.chartText + this.classTarget(d.id);
            };
            c3_chart_internal_fn.classChartLine = function (d) {
                return CLASS.chartLine + this.classTarget(d.id);
            };
            c3_chart_internal_fn.classChartBar = function (d) {
                return CLASS.chartBar + this.classTarget(d.id);
            };
            c3_chart_internal_fn.classChartArc = function (d) {
                return CLASS.chartArc + this.classTarget(d.data.id);
            };
            c3_chart_internal_fn.getTargetSelectorSuffix = function (targetId) {
                return targetId || targetId === 0 ? ('-' + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, '-') : '';
            };
            c3_chart_internal_fn.selectorTarget = function (id, prefix) {
                return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
            };
            c3_chart_internal_fn.selectorTargets = function (ids, prefix) {
                var $$ = this;
                ids = ids || [];
                return ids.length ? ids.map(function (id) {
                    return $$.selectorTarget(id, prefix);
                }) : null;
            };
            c3_chart_internal_fn.selectorLegend = function (id) {
                return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
            };
            c3_chart_internal_fn.selectorLegends = function (ids) {
                var $$ = this;
                return ids && ids.length ? ids.map(function (id) {
                    return $$.selectorLegend(id);
                }) : null;
            };

            var isValue = c3_chart_internal_fn.isValue = function (v) {
                return v || v === 0;
            },
                isFunction = c3_chart_internal_fn.isFunction = function (o) {
                return typeof o === 'function';
            },
                isString = c3_chart_internal_fn.isString = function (o) {
                return typeof o === 'string';
            },
                isUndefined = c3_chart_internal_fn.isUndefined = function (v) {
                return typeof v === 'undefined';
            },
                isDefined = c3_chart_internal_fn.isDefined = function (v) {
                return typeof v !== 'undefined';
            },
                ceil10 = c3_chart_internal_fn.ceil10 = function (v) {
                return Math.ceil(v / 10) * 10;
            },
                asHalfPixel = c3_chart_internal_fn.asHalfPixel = function (n) {
                return Math.ceil(n) + 0.5;
            },
                diffDomain = c3_chart_internal_fn.diffDomain = function (d) {
                return d[1] - d[0];
            },
                isEmpty = c3_chart_internal_fn.isEmpty = function (o) {
                return typeof o === 'undefined' || o === null || isString(o) && o.length === 0 || typeof o === 'object' && Object.keys(o).length === 0;
            },
                notEmpty = c3_chart_internal_fn.notEmpty = function (o) {
                return !c3_chart_internal_fn.isEmpty(o);
            },
                getOption = c3_chart_internal_fn.getOption = function (options, key, defaultValue) {
                return isDefined(options[key]) ? options[key] : defaultValue;
            },
                hasValue = c3_chart_internal_fn.hasValue = function (dict, value) {
                var found = false;
                Object.keys(dict).forEach(function (key) {
                    if (dict[key] === value) {
                        found = true;
                    }
                });
                return found;
            },
                sanitise = c3_chart_internal_fn.sanitise = function (str) {
                return typeof str === 'string' ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;') : str;
            },
                getPathBox = c3_chart_internal_fn.getPathBox = function (path) {
                var box = path.getBoundingClientRect(),
                    items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],
                    minX = items[0].x,
                    minY = Math.min(items[0].y, items[1].y);
                return { x: minX, y: minY, width: box.width, height: box.height };
            };

            c3_chart_fn.focus = function (targetIds) {
                var $$ = this.internal,
                    candidates;

                targetIds = $$.mapToTargetIds(targetIds);
                candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), this.revert();
                this.defocus();
                candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
                if ($$.hasArcType()) {
                    $$.expandArc(targetIds);
                }
                $$.toggleFocusLegend(targetIds, true);

                $$.focusedTargetIds = targetIds;
                $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
            };

            c3_chart_fn.defocus = function (targetIds) {
                var $$ = this.internal,
                    candidates;

                targetIds = $$.mapToTargetIds(targetIds);
                candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
                if ($$.hasArcType()) {
                    $$.unexpandArc(targetIds);
                }
                $$.toggleFocusLegend(targetIds, false);

                $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
                    return targetIds.indexOf(id) < 0;
                });
                $$.defocusedTargetIds = targetIds;
            };

            c3_chart_fn.revert = function (targetIds) {
                var $$ = this.internal,
                    candidates;

                targetIds = $$.mapToTargetIds(targetIds);
                candidates = $$.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets

                candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
                if ($$.hasArcType()) {
                    $$.unexpandArc(targetIds);
                }
                if ($$.config.legend_show) {
                    $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
                    $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
                        return $$.d3.select(this).classed(CLASS.legendItemFocused);
                    }).classed(CLASS.legendItemFocused, false);
                }

                $$.focusedTargetIds = [];
                $$.defocusedTargetIds = [];
            };

            c3_chart_fn.show = function (targetIds, options) {
                var $$ = this.internal,
                    targets;

                targetIds = $$.mapToTargetIds(targetIds);
                options = options || {};

                $$.removeHiddenTargetIds(targetIds);
                targets = $$.svg.selectAll($$.selectorTargets(targetIds));

                targets.transition().style('opacity', 1, 'important').call($$.endall, function () {
                    targets.style('opacity', null).style('opacity', 1);
                });

                if (options.withLegend) {
                    $$.showLegend(targetIds);
                }

                $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
            };

            c3_chart_fn.hide = function (targetIds, options) {
                var $$ = this.internal,
                    targets;

                targetIds = $$.mapToTargetIds(targetIds);
                options = options || {};

                $$.addHiddenTargetIds(targetIds);
                targets = $$.svg.selectAll($$.selectorTargets(targetIds));

                targets.transition().style('opacity', 0, 'important').call($$.endall, function () {
                    targets.style('opacity', null).style('opacity', 0);
                });

                if (options.withLegend) {
                    $$.hideLegend(targetIds);
                }

                $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
            };

            c3_chart_fn.toggle = function (targetIds, options) {
                var that = this,
                    $$ = this.internal;
                $$.mapToTargetIds(targetIds).forEach(function (targetId) {
                    $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);
                });
            };

            c3_chart_fn.zoom = function (domain) {
                var $$ = this.internal;
                if (domain) {
                    if ($$.isTimeSeries()) {
                        domain = domain.map(function (x) {
                            return $$.parseDate(x);
                        });
                    }
                    $$.brush.extent(domain);
                    $$.redraw({ withUpdateXDomain: true, withY: $$.config.zoom_rescale });
                    $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
                }
                return $$.brush.extent();
            };
            c3_chart_fn.zoom.enable = function (enabled) {
                var $$ = this.internal;
                $$.config.zoom_enabled = enabled;
                $$.updateAndRedraw();
            };
            c3_chart_fn.unzoom = function () {
                var $$ = this.internal;
                $$.brush.clear().update();
                $$.redraw({ withUpdateXDomain: true });
            };

            c3_chart_fn.zoom.max = function (max) {
                var $$ = this.internal,
                    config = $$.config,
                    d3 = $$.d3;
                if (max === 0 || max) {
                    config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);
                } else {
                    return config.zoom_x_max;
                }
            };

            c3_chart_fn.zoom.min = function (min) {
                var $$ = this.internal,
                    config = $$.config,
                    d3 = $$.d3;
                if (min === 0 || min) {
                    config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);
                } else {
                    return config.zoom_x_min;
                }
            };

            c3_chart_fn.zoom.range = function (range) {
                if (arguments.length) {
                    if (isDefined(range.max)) {
                        this.domain.max(range.max);
                    }
                    if (isDefined(range.min)) {
                        this.domain.min(range.min);
                    }
                } else {
                    return {
                        max: this.domain.max(),
                        min: this.domain.min()
                    };
                }
            };

            c3_chart_fn.load = function (args) {
                var $$ = this.internal,
                    config = $$.config;
                // update xs if specified
                if (args.xs) {
                    $$.addXs(args.xs);
                }
                // update names if exists
                if ('names' in args) {
                    c3_chart_fn.data.names.bind(this)(args.names);
                }
                // update classes if exists
                if ('classes' in args) {
                    Object.keys(args.classes).forEach(function (id) {
                        config.data_classes[id] = args.classes[id];
                    });
                }
                // update categories if exists
                if ('categories' in args && $$.isCategorized()) {
                    config.axis_x_categories = args.categories;
                }
                // update axes if exists
                if ('axes' in args) {
                    Object.keys(args.axes).forEach(function (id) {
                        config.data_axes[id] = args.axes[id];
                    });
                }
                // update colors if exists
                if ('colors' in args) {
                    Object.keys(args.colors).forEach(function (id) {
                        config.data_colors[id] = args.colors[id];
                    });
                }
                // use cache if exists
                if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
                    $$.load($$.getCaches(args.cacheIds), args.done);
                    return;
                }
                // unload if needed
                if ('unload' in args) {
                    // TODO: do not unload if target will load (included in url/rows/columns)
                    $$.unload($$.mapToTargetIds(typeof args.unload === 'boolean' && args.unload ? null : args.unload), function () {
                        $$.loadFromArgs(args);
                    });
                } else {
                    $$.loadFromArgs(args);
                }
            };

            c3_chart_fn.unload = function (args) {
                var $$ = this.internal;
                args = args || {};
                if (args instanceof Array) {
                    args = { ids: args };
                } else if (typeof args === 'string') {
                    args = { ids: [args] };
                }
                $$.unload($$.mapToTargetIds(args.ids), function () {
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
                    if (args.done) {
                        args.done();
                    }
                });
            };

            c3_chart_fn.flow = function (args) {
                var $$ = this.internal,
                    targets,
                    data,
                    notfoundIds = [],
                    orgDataCount = $$.getMaxDataCount(),
                    dataCount,
                    domain,
                    baseTarget,
                    baseValue,
                    length = 0,
                    tail = 0,
                    diff,
                    to;

                if (args.json) {
                    data = $$.convertJsonToData(args.json, args.keys);
                } else if (args.rows) {
                    data = $$.convertRowsToData(args.rows);
                } else if (args.columns) {
                    data = $$.convertColumnsToData(args.columns);
                } else {
                    return;
                }
                targets = $$.convertDataToTargets(data, true);

                // Update/Add data
                $$.data.targets.forEach(function (t) {
                    var found = false,
                        i,
                        j;
                    for (i = 0; i < targets.length; i++) {
                        if (t.id === targets[i].id) {
                            found = true;

                            if (t.values[t.values.length - 1]) {
                                tail = t.values[t.values.length - 1].index + 1;
                            }
                            length = targets[i].values.length;

                            for (j = 0; j < length; j++) {
                                targets[i].values[j].index = tail + j;
                                if (!$$.isTimeSeries()) {
                                    targets[i].values[j].x = tail + j;
                                }
                            }
                            t.values = t.values.concat(targets[i].values);

                            targets.splice(i, 1);
                            break;
                        }
                    }
                    if (!found) {
                        notfoundIds.push(t.id);
                    }
                });

                // Append null for not found targets
                $$.data.targets.forEach(function (t) {
                    var i, j;
                    for (i = 0; i < notfoundIds.length; i++) {
                        if (t.id === notfoundIds[i]) {
                            tail = t.values[t.values.length - 1].index + 1;
                            for (j = 0; j < length; j++) {
                                t.values.push({
                                    id: t.id,
                                    index: tail + j,
                                    x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                                    value: null
                                });
                            }
                        }
                    }
                });

                // Generate null values for new target
                if ($$.data.targets.length) {
                    targets.forEach(function (t) {
                        var i,
                            missing = [];
                        for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
                            missing.push({
                                id: t.id,
                                index: i,
                                x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
                                value: null
                            });
                        }
                        t.values.forEach(function (v) {
                            v.index += tail;
                            if (!$$.isTimeSeries()) {
                                v.x += tail;
                            }
                        });
                        t.values = missing.concat(t.values);
                    });
                }
                $$.data.targets = $$.data.targets.concat(targets); // add remained

                // check data count because behavior needs to change when it's only one
                dataCount = $$.getMaxDataCount();
                baseTarget = $$.data.targets[0];
                baseValue = baseTarget.values[0];

                // Update length to flow if needed
                if (isDefined(args.to)) {
                    length = 0;
                    to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
                    baseTarget.values.forEach(function (v) {
                        if (v.x < to) {
                            length++;
                        }
                    });
                } else if (isDefined(args.length)) {
                    length = args.length;
                }

                // If only one data, update the domain to flow from left edge of the chart
                if (!orgDataCount) {
                    if ($$.isTimeSeries()) {
                        if (baseTarget.values.length > 1) {
                            diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
                        } else {
                            diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
                        }
                    } else {
                        diff = 1;
                    }
                    domain = [baseValue.x - diff, baseValue.x];
                    $$.updateXDomain(null, true, true, false, domain);
                } else if (orgDataCount === 1) {
                    if ($$.isTimeSeries()) {
                        diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
                        domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
                        $$.updateXDomain(null, true, true, false, domain);
                    }
                }

                // Set targets
                $$.updateTargets($$.data.targets);

                // Redraw with new targets
                $$.redraw({
                    flow: {
                        index: baseValue.index,
                        length: length,
                        duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
                        done: args.done,
                        orgDataCount: orgDataCount
                    },
                    withLegend: true,
                    withTransition: orgDataCount > 1,
                    withTrimXDomain: false,
                    withUpdateXAxis: true
                });
            };

            c3_chart_internal_fn.generateFlow = function (args) {
                var $$ = this,
                    config = $$.config,
                    d3 = $$.d3;

                return function () {
                    var targets = args.targets,
                        flow = args.flow,
                        drawBar = args.drawBar,
                        drawLine = args.drawLine,
                        drawArea = args.drawArea,
                        cx = args.cx,
                        cy = args.cy,
                        xv = args.xv,
                        xForText = args.xForText,
                        yForText = args.yForText,
                        duration = args.duration;

                    var translateX,
                        scaleX = 1,
                        transform,
                        flowIndex = flow.index,
                        flowLength = flow.length,
                        flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
                        flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
                        orgDomain = $$.x.domain(),
                        domain,
                        durationForFlow = flow.duration || duration,
                        done = flow.done || function () {},
                        wait = $$.generateWait();

                    var xgrid = $$.xgrid || d3.selectAll([]),
                        xgridLines = $$.xgridLines || d3.selectAll([]),
                        mainRegion = $$.mainRegion || d3.selectAll([]),
                        mainText = $$.mainText || d3.selectAll([]),
                        mainBar = $$.mainBar || d3.selectAll([]),
                        mainLine = $$.mainLine || d3.selectAll([]),
                        mainArea = $$.mainArea || d3.selectAll([]),
                        mainCircle = $$.mainCircle || d3.selectAll([]);

                    // set flag
                    $$.flowing = true;

                    // remove head data after rendered
                    $$.data.targets.forEach(function (d) {
                        d.values.splice(0, flowLength);
                    });

                    // update x domain to generate axis elements for flow
                    domain = $$.updateXDomain(targets, true, true);
                    // update elements related to x scale
                    if ($$.updateXGrid) {
                        $$.updateXGrid(true);
                    }

                    // generate transform to flow
                    if (!flow.orgDataCount) {
                        // if empty
                        if ($$.data.targets[0].values.length !== 1) {
                            translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                        } else {
                            if ($$.isTimeSeries()) {
                                flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
                                flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
                                translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                            } else {
                                translateX = diffDomain(domain) / 2;
                            }
                        }
                    } else if (flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {
                        translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                    } else {
                        if ($$.isTimeSeries()) {
                            translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                        } else {
                            translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                        }
                    }
                    scaleX = diffDomain(orgDomain) / diffDomain(domain);
                    transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';

                    $$.hideXGridFocus();

                    d3.transition().ease('linear').duration(durationForFlow).each(function () {
                        wait.add($$.axes.x.transition().call($$.xAxis));
                        wait.add(mainBar.transition().attr('transform', transform));
                        wait.add(mainLine.transition().attr('transform', transform));
                        wait.add(mainArea.transition().attr('transform', transform));
                        wait.add(mainCircle.transition().attr('transform', transform));
                        wait.add(mainText.transition().attr('transform', transform));
                        wait.add(mainRegion.filter($$.isRegionOnX).transition().attr('transform', transform));
                        wait.add(xgrid.transition().attr('transform', transform));
                        wait.add(xgridLines.transition().attr('transform', transform));
                    }).call(wait, function () {
                        var i,
                            shapes = [],
                            texts = [],
                            eventRects = [];

                        // remove flowed elements
                        if (flowLength) {
                            for (i = 0; i < flowLength; i++) {
                                shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
                                texts.push('.' + CLASS.text + '-' + (flowIndex + i));
                                eventRects.push('.' + CLASS.eventRect + '-' + (flowIndex + i));
                            }
                            $$.svg.selectAll('.' + CLASS.shapes).selectAll(shapes).remove();
                            $$.svg.selectAll('.' + CLASS.texts).selectAll(texts).remove();
                            $$.svg.selectAll('.' + CLASS.eventRects).selectAll(eventRects).remove();
                            $$.svg.select('.' + CLASS.xgrid).remove();
                        }

                        // draw again for removing flowed elements and reverting attr
                        xgrid.attr('transform', null).attr($$.xgridAttr);
                        xgridLines.attr('transform', null);
                        xgridLines.select('line').attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv);
                        xgridLines.select('text').attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv);
                        mainBar.attr('transform', null).attr("d", drawBar);
                        mainLine.attr('transform', null).attr("d", drawLine);
                        mainArea.attr('transform', null).attr("d", drawArea);
                        mainCircle.attr('transform', null).attr("cx", cx).attr("cy", cy);
                        mainText.attr('transform', null).attr('x', xForText).attr('y', yForText).style('fill-opacity', $$.opacityForText.bind($$));
                        mainRegion.attr('transform', null);
                        mainRegion.select('rect').filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));

                        if (config.interaction_enabled) {
                            $$.redrawEventRect();
                        }

                        // callback for end of flow
                        done();

                        $$.flowing = false;
                    });
                };
            };

            c3_chart_fn.selected = function (targetId) {
                var $$ = this.internal,
                    d3 = $$.d3;
                return d3.merge($$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId)).selectAll('.' + CLASS.shape).filter(function () {
                    return d3.select(this).classed(CLASS.SELECTED);
                }).map(function (d) {
                    return d.map(function (d) {
                        var data = d.__data__;return data.data ? data.data : data;
                    });
                }));
            };
            c3_chart_fn.select = function (ids, indices, resetOther) {
                var $$ = this.internal,
                    d3 = $$.d3,
                    config = $$.config;
                if (!config.data_selection_enabled) {
                    return;
                }
                $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {
                    var shape = d3.select(this),
                        id = d.data ? d.data.id : d.id,
                        toggle = $$.getToggle(this, d).bind($$),
                        isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
                        isTargetIndex = !indices || indices.indexOf(i) >= 0,
                        isSelected = shape.classed(CLASS.SELECTED);
                    // line/area selection not supported yet
                    if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                        return;
                    }
                    if (isTargetId && isTargetIndex) {
                        if (config.data_selection_isselectable(d) && !isSelected) {
                            toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
                        }
                    } else if (isDefined(resetOther) && resetOther) {
                        if (isSelected) {
                            toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                        }
                    }
                });
            };
            c3_chart_fn.unselect = function (ids, indices) {
                var $$ = this.internal,
                    d3 = $$.d3,
                    config = $$.config;
                if (!config.data_selection_enabled) {
                    return;
                }
                $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {
                    var shape = d3.select(this),
                        id = d.data ? d.data.id : d.id,
                        toggle = $$.getToggle(this, d).bind($$),
                        isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
                        isTargetIndex = !indices || indices.indexOf(i) >= 0,
                        isSelected = shape.classed(CLASS.SELECTED);
                    // line/area selection not supported yet
                    if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                        return;
                    }
                    if (isTargetId && isTargetIndex) {
                        if (config.data_selection_isselectable(d)) {
                            if (isSelected) {
                                toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                            }
                        }
                    }
                });
            };

            c3_chart_fn.transform = function (type, targetIds) {
                var $$ = this.internal,
                    options = ['pie', 'donut'].indexOf(type) >= 0 ? { withTransform: true } : null;
                $$.transformTo(targetIds, type, options);
            };

            c3_chart_internal_fn.transformTo = function (targetIds, type, optionsForRedraw) {
                var $$ = this,
                    withTransitionForAxis = !$$.hasArcType(),
                    options = optionsForRedraw || { withTransitionForAxis: withTransitionForAxis };
                options.withTransitionForTransform = false;
                $$.transiting = false;
                $$.setTargetType(targetIds, type);
                $$.updateTargets($$.data.targets); // this is needed when transforming to arc
                $$.updateAndRedraw(options);
            };

            c3_chart_fn.groups = function (groups) {
                var $$ = this.internal,
                    config = $$.config;
                if (isUndefined(groups)) {
                    return config.data_groups;
                }
                config.data_groups = groups;
                $$.redraw();
                return config.data_groups;
            };

            c3_chart_fn.xgrids = function (grids) {
                var $$ = this.internal,
                    config = $$.config;
                if (!grids) {
                    return config.grid_x_lines;
                }
                config.grid_x_lines = grids;
                $$.redrawWithoutRescale();
                return config.grid_x_lines;
            };
            c3_chart_fn.xgrids.add = function (grids) {
                var $$ = this.internal;
                return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
            };
            c3_chart_fn.xgrids.remove = function (params) {
                // TODO: multiple
                var $$ = this.internal;
                $$.removeGridLines(params, true);
            };

            c3_chart_fn.ygrids = function (grids) {
                var $$ = this.internal,
                    config = $$.config;
                if (!grids) {
                    return config.grid_y_lines;
                }
                config.grid_y_lines = grids;
                $$.redrawWithoutRescale();
                return config.grid_y_lines;
            };
            c3_chart_fn.ygrids.add = function (grids) {
                var $$ = this.internal;
                return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
            };
            c3_chart_fn.ygrids.remove = function (params) {
                // TODO: multiple
                var $$ = this.internal;
                $$.removeGridLines(params, false);
            };

            c3_chart_fn.regions = function (regions) {
                var $$ = this.internal,
                    config = $$.config;
                if (!regions) {
                    return config.regions;
                }
                config.regions = regions;
                $$.redrawWithoutRescale();
                return config.regions;
            };
            c3_chart_fn.regions.add = function (regions) {
                var $$ = this.internal,
                    config = $$.config;
                if (!regions) {
                    return config.regions;
                }
                config.regions = config.regions.concat(regions);
                $$.redrawWithoutRescale();
                return config.regions;
            };
            c3_chart_fn.regions.remove = function (options) {
                var $$ = this.internal,
                    config = $$.config,
                    duration,
                    classes,
                    regions;

                options = options || {};
                duration = $$.getOption(options, "duration", config.transition_duration);
                classes = $$.getOption(options, "classes", [CLASS.region]);

                regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function (c) {
                    return '.' + c;
                }));
                (duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove();

                config.regions = config.regions.filter(function (region) {
                    var found = false;
                    if (!region['class']) {
                        return true;
                    }
                    region['class'].split(' ').forEach(function (c) {
                        if (classes.indexOf(c) >= 0) {
                            found = true;
                        }
                    });
                    return !found;
                });

                return config.regions;
            };

            c3_chart_fn.data = function (targetIds) {
                var targets = this.internal.data.targets;
                return typeof targetIds === 'undefined' ? targets : targets.filter(function (t) {
                    return [].concat(targetIds).indexOf(t.id) >= 0;
                });
            };
            c3_chart_fn.data.shown = function (targetIds) {
                return this.internal.filterTargetsToShow(this.data(targetIds));
            };
            c3_chart_fn.data.values = function (targetId) {
                var targets,
                    values = null;
                if (targetId) {
                    targets = this.data(targetId);
                    values = targets[0] ? targets[0].values.map(function (d) {
                        return d.value;
                    }) : null;
                }
                return values;
            };
            c3_chart_fn.data.names = function (names) {
                this.internal.clearLegendItemTextBoxCache();
                return this.internal.updateDataAttributes('names', names);
            };
            c3_chart_fn.data.colors = function (colors) {
                return this.internal.updateDataAttributes('colors', colors);
            };
            c3_chart_fn.data.axes = function (axes) {
                return this.internal.updateDataAttributes('axes', axes);
            };

            c3_chart_fn.category = function (i, category) {
                var $$ = this.internal,
                    config = $$.config;
                if (arguments.length > 1) {
                    config.axis_x_categories[i] = category;
                    $$.redraw();
                }
                return config.axis_x_categories[i];
            };
            c3_chart_fn.categories = function (categories) {
                var $$ = this.internal,
                    config = $$.config;
                if (!arguments.length) {
                    return config.axis_x_categories;
                }
                config.axis_x_categories = categories;
                $$.redraw();
                return config.axis_x_categories;
            };

            // TODO: fix
            c3_chart_fn.color = function (id) {
                var $$ = this.internal;
                return $$.color(id); // more patterns
            };

            c3_chart_fn.x = function (x) {
                var $$ = this.internal;
                if (arguments.length) {
                    $$.updateTargetX($$.data.targets, x);
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                }
                return $$.data.xs;
            };
            c3_chart_fn.xs = function (xs) {
                var $$ = this.internal;
                if (arguments.length) {
                    $$.updateTargetXs($$.data.targets, xs);
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                }
                return $$.data.xs;
            };

            c3_chart_fn.axis = function () {};
            c3_chart_fn.axis.labels = function (labels) {
                var $$ = this.internal;
                if (arguments.length) {
                    Object.keys(labels).forEach(function (axisId) {
                        $$.axis.setLabelText(axisId, labels[axisId]);
                    });
                    $$.axis.updateLabels();
                }
                // TODO: return some values?
            };
            c3_chart_fn.axis.max = function (max) {
                var $$ = this.internal,
                    config = $$.config;
                if (arguments.length) {
                    if (typeof max === 'object') {
                        if (isValue(max.x)) {
                            config.axis_x_max = max.x;
                        }
                        if (isValue(max.y)) {
                            config.axis_y_max = max.y;
                        }
                        if (isValue(max.y2)) {
                            config.axis_y2_max = max.y2;
                        }
                    } else {
                        config.axis_y_max = config.axis_y2_max = max;
                    }
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                } else {
                    return {
                        x: config.axis_x_max,
                        y: config.axis_y_max,
                        y2: config.axis_y2_max
                    };
                }
            };
            c3_chart_fn.axis.min = function (min) {
                var $$ = this.internal,
                    config = $$.config;
                if (arguments.length) {
                    if (typeof min === 'object') {
                        if (isValue(min.x)) {
                            config.axis_x_min = min.x;
                        }
                        if (isValue(min.y)) {
                            config.axis_y_min = min.y;
                        }
                        if (isValue(min.y2)) {
                            config.axis_y2_min = min.y2;
                        }
                    } else {
                        config.axis_y_min = config.axis_y2_min = min;
                    }
                    $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
                } else {
                    return {
                        x: config.axis_x_min,
                        y: config.axis_y_min,
                        y2: config.axis_y2_min
                    };
                }
            };
            c3_chart_fn.axis.range = function (range) {
                if (arguments.length) {
                    if (isDefined(range.max)) {
                        this.axis.max(range.max);
                    }
                    if (isDefined(range.min)) {
                        this.axis.min(range.min);
                    }
                } else {
                    return {
                        max: this.axis.max(),
                        min: this.axis.min()
                    };
                }
            };

            c3_chart_fn.legend = function () {};
            c3_chart_fn.legend.show = function (targetIds) {
                var $$ = this.internal;
                $$.showLegend($$.mapToTargetIds(targetIds));
                $$.updateAndRedraw({ withLegend: true });
            };
            c3_chart_fn.legend.hide = function (targetIds) {
                var $$ = this.internal;
                $$.hideLegend($$.mapToTargetIds(targetIds));
                $$.updateAndRedraw({ withLegend: true });
            };

            c3_chart_fn.resize = function (size) {
                var $$ = this.internal,
                    config = $$.config;
                config.size_width = size ? size.width : null;
                config.size_height = size ? size.height : null;
                this.flush();
            };

            c3_chart_fn.flush = function () {
                var $$ = this.internal;
                $$.updateAndRedraw({ withLegend: true, withTransition: false, withTransitionForTransform: false });
            };

            c3_chart_fn.destroy = function () {
                var $$ = this.internal;

                window.clearInterval($$.intervalForObserveInserted);

                if ($$.resizeTimeout !== undefined) {
                    window.clearTimeout($$.resizeTimeout);
                }

                if (window.detachEvent) {
                    window.detachEvent('onresize', $$.resizeFunction);
                } else if (window.removeEventListener) {
                    window.removeEventListener('resize', $$.resizeFunction);
                } else {
                    var wrapper = window.onresize;
                    // check if no one else removed our wrapper and remove our resizeFunction from it
                    if (wrapper && wrapper.add && wrapper.remove) {
                        wrapper.remove($$.resizeFunction);
                    }
                }

                $$.selectChart.classed('c3', false).html("");

                // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.
                Object.keys($$).forEach(function (key) {
                    $$[key] = null;
                });

                return null;
            };

            c3_chart_fn.tooltip = function () {};
            c3_chart_fn.tooltip.show = function (args) {
                var $$ = this.internal,
                    index,
                    mouse;

                // determine mouse position on the chart
                if (args.mouse) {
                    mouse = args.mouse;
                }

                // determine focus data
                if (args.data) {
                    if ($$.isMultipleX()) {
                        // if multiple xs, target point will be determined by mouse
                        mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)];
                        index = null;
                    } else {
                        // TODO: when tooltip_grouped = false
                        index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x);
                    }
                } else if (typeof args.x !== 'undefined') {
                    index = $$.getIndexByX(args.x);
                } else if (typeof args.index !== 'undefined') {
                    index = args.index;
                }

                // emulate mouse events to show
                $$.dispatchEvent('mouseover', index, mouse);
                $$.dispatchEvent('mousemove', index, mouse);

                $$.config.tooltip_onshow.call($$, args.data);
            };
            c3_chart_fn.tooltip.hide = function () {
                // TODO: get target data by checking the state of focus
                this.internal.dispatchEvent('mouseout', 0);

                this.internal.config.tooltip_onhide.call(this);
            };

            // Features:
            // 1. category axis
            // 2. ceil values of translate/x/y to int for half pixel antialiasing
            // 3. multiline tick text
            var tickTextCharSize;
            function c3_axis(d3, params) {
                var scale = d3.scale.linear(),
                    orient = "bottom",
                    innerTickSize = 6,
                    outerTickSize,
                    tickPadding = 3,
                    tickValues = null,
                    tickFormat,
                    tickArguments;

                var tickOffset = 0,
                    tickCulling = true,
                    tickCentered;

                params = params || {};
                outerTickSize = params.withOuterTick ? 6 : 0;

                function axisX(selection, x) {
                    selection.attr("transform", function (d) {
                        return "translate(" + Math.ceil(x(d) + tickOffset) + ", 0)";
                    });
                }
                function axisY(selection, y) {
                    selection.attr("transform", function (d) {
                        return "translate(0," + Math.ceil(y(d)) + ")";
                    });
                }
                function scaleExtent(domain) {
                    var start = domain[0],
                        stop = domain[domain.length - 1];
                    return start < stop ? [start, stop] : [stop, start];
                }
                function generateTicks(scale) {
                    var i,
                        domain,
                        ticks = [];
                    if (scale.ticks) {
                        return scale.ticks.apply(scale, tickArguments);
                    }
                    domain = scale.domain();
                    for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
                        ticks.push(i);
                    }
                    if (ticks.length > 0 && ticks[0] > 0) {
                        ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
                    }
                    return ticks;
                }
                function copyScale() {
                    var newScale = scale.copy(),
                        domain;
                    if (params.isCategory) {
                        domain = scale.domain();
                        newScale.domain([domain[0], domain[1] - 1]);
                    }
                    return newScale;
                }
                function textFormatted(v) {
                    var formatted = tickFormat ? tickFormat(v) : v;
                    return typeof formatted !== 'undefined' ? formatted : '';
                }
                function getSizeFor1Char(tick) {
                    if (tickTextCharSize) {
                        return tickTextCharSize;
                    }
                    var size = {
                        h: 11.5,
                        w: 5.5
                    };
                    tick.select('text').text(textFormatted).each(function (d) {
                        var box = this.getBoundingClientRect(),
                            text = textFormatted(d),
                            h = box.height,
                            w = text ? box.width / text.length : undefined;
                        if (h && w) {
                            size.h = h;
                            size.w = w;
                        }
                    }).text('');
                    tickTextCharSize = size;
                    return size;
                }
                function transitionise(selection) {
                    return params.withoutTransition ? selection : d3.transition(selection);
                }
                function axis(g) {
                    g.each(function () {
                        var g = axis.g = d3.select(this);

                        var scale0 = this.__chart__ || scale,
                            scale1 = this.__chart__ = copyScale();

                        var ticks = tickValues ? tickValues : generateTicks(scale1),
                            tick = g.selectAll(".tick").data(ticks, scale1),
                            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1e-6),

                        // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.
                        tickExit = tick.exit().remove(),
                            tickUpdate = transitionise(tick).style("opacity", 1),
                            tickTransform,
                            tickX,
                            tickY;

                        var range = scale.rangeExtent ? scale.rangeExtent() : scaleExtent(scale.range()),
                            path = g.selectAll(".domain").data([0]),
                            pathUpdate = (path.enter().append("path").attr("class", "domain"), transitionise(path));
                        tickEnter.append("line");
                        tickEnter.append("text");

                        var lineEnter = tickEnter.select("line"),
                            lineUpdate = tickUpdate.select("line"),
                            textEnter = tickEnter.select("text"),
                            textUpdate = tickUpdate.select("text");

                        if (params.isCategory) {
                            tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
                            tickX = tickCentered ? 0 : tickOffset;
                            tickY = tickCentered ? tickOffset : 0;
                        } else {
                            tickOffset = tickX = 0;
                        }

                        var text,
                            tspan,
                            sizeFor1Char = getSizeFor1Char(g.select('.tick')),
                            counts = [];
                        var tickLength = Math.max(innerTickSize, 0) + tickPadding,
                            isVertical = orient === 'left' || orient === 'right';

                        // this should be called only when category axis
                        function splitTickText(d, maxWidth) {
                            var tickText = textFormatted(d),
                                subtext,
                                spaceIndex,
                                textWidth,
                                splitted = [];

                            if (Object.prototype.toString.call(tickText) === "[object Array]") {
                                return tickText;
                            }

                            if (!maxWidth || maxWidth <= 0) {
                                maxWidth = isVertical ? 95 : params.isCategory ? Math.ceil(scale1(ticks[1]) - scale1(ticks[0])) - 12 : 110;
                            }

                            function split(splitted, text) {
                                spaceIndex = undefined;
                                for (var i = 1; i < text.length; i++) {
                                    if (text.charAt(i) === ' ') {
                                        spaceIndex = i;
                                    }
                                    subtext = text.substr(0, i + 1);
                                    textWidth = sizeFor1Char.w * subtext.length;
                                    // if text width gets over tick width, split by space index or crrent index
                                    if (maxWidth < textWidth) {
                                        return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
                                    }
                                }
                                return splitted.concat(text);
                            }

                            return split(splitted, tickText + "");
                        }

                        function tspanDy(d, i) {
                            var dy = sizeFor1Char.h;
                            if (i === 0) {
                                if (orient === 'left' || orient === 'right') {
                                    dy = -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3);
                                } else {
                                    dy = ".71em";
                                }
                            }
                            return dy;
                        }

                        function tickSize(d) {
                            var tickPosition = scale(d) + (tickCentered ? 0 : tickOffset);
                            return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
                        }

                        text = tick.select("text");
                        tspan = text.selectAll('tspan').data(function (d, i) {
                            var splitted = params.tickMultiline ? splitTickText(d, params.tickWidth) : [].concat(textFormatted(d));
                            counts[i] = splitted.length;
                            return splitted.map(function (s) {
                                return { index: i, splitted: s };
                            });
                        });
                        tspan.enter().append('tspan');
                        tspan.exit().remove();
                        tspan.text(function (d) {
                            return d.splitted;
                        });

                        var rotate = params.tickTextRotate;

                        function textAnchorForText(rotate) {
                            if (!rotate) {
                                return 'middle';
                            }
                            return rotate > 0 ? "start" : "end";
                        }
                        function textTransform(rotate) {
                            if (!rotate) {
                                return '';
                            }
                            return "rotate(" + rotate + ")";
                        }
                        function dxForText(rotate) {
                            if (!rotate) {
                                return 0;
                            }
                            return 8 * Math.sin(Math.PI * (rotate / 180));
                        }
                        function yForText(rotate) {
                            if (!rotate) {
                                return tickLength;
                            }
                            return 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1);
                        }

                        switch (orient) {
                            case "bottom":
                                {
                                    tickTransform = axisX;
                                    lineEnter.attr("y2", innerTickSize);
                                    textEnter.attr("y", tickLength);
                                    lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", tickSize);
                                    textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate));
                                    tspan.attr('x', 0).attr("dy", tspanDy).attr('dx', dxForText(rotate));
                                    pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
                                    break;
                                }
                            case "top":
                                {
                                    // TODO: rotated tick text
                                    tickTransform = axisX;
                                    lineEnter.attr("y2", -innerTickSize);
                                    textEnter.attr("y", -tickLength);
                                    lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
                                    textUpdate.attr("x", 0).attr("y", -tickLength);
                                    text.style("text-anchor", "middle");
                                    tspan.attr('x', 0).attr("dy", "0em");
                                    pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
                                    break;
                                }
                            case "left":
                                {
                                    tickTransform = axisY;
                                    lineEnter.attr("x2", -innerTickSize);
                                    textEnter.attr("x", -tickLength);
                                    lineUpdate.attr("x2", -innerTickSize).attr("y1", tickY).attr("y2", tickY);
                                    textUpdate.attr("x", -tickLength).attr("y", tickOffset);
                                    text.style("text-anchor", "end");
                                    tspan.attr('x', -tickLength).attr("dy", tspanDy);
                                    pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
                                    break;
                                }
                            case "right":
                                {
                                    tickTransform = axisY;
                                    lineEnter.attr("x2", innerTickSize);
                                    textEnter.attr("x", tickLength);
                                    lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
                                    textUpdate.attr("x", tickLength).attr("y", 0);
                                    text.style("text-anchor", "start");
                                    tspan.attr('x', tickLength).attr("dy", tspanDy);
                                    pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
                                    break;
                                }
                        }
                        if (scale1.rangeBand) {
                            var x = scale1,
                                dx = x.rangeBand() / 2;
                            scale0 = scale1 = function (d) {
                                return x(d) + dx;
                            };
                        } else if (scale0.rangeBand) {
                            scale0 = scale1;
                        } else {
                            tickExit.call(tickTransform, scale1);
                        }
                        tickEnter.call(tickTransform, scale0);
                        tickUpdate.call(tickTransform, scale1);
                    });
                }
                axis.scale = function (x) {
                    if (!arguments.length) {
                        return scale;
                    }
                    scale = x;
                    return axis;
                };
                axis.orient = function (x) {
                    if (!arguments.length) {
                        return orient;
                    }
                    orient = x in { top: 1, right: 1, bottom: 1, left: 1 } ? x + "" : "bottom";
                    return axis;
                };
                axis.tickFormat = function (format) {
                    if (!arguments.length) {
                        return tickFormat;
                    }
                    tickFormat = format;
                    return axis;
                };
                axis.tickCentered = function (isCentered) {
                    if (!arguments.length) {
                        return tickCentered;
                    }
                    tickCentered = isCentered;
                    return axis;
                };
                axis.tickOffset = function () {
                    return tickOffset;
                };
                axis.tickInterval = function () {
                    var interval, length;
                    if (params.isCategory) {
                        interval = tickOffset * 2;
                    } else {
                        length = axis.g.select('path.domain').node().getTotalLength() - outerTickSize * 2;
                        interval = length / axis.g.selectAll('line').size();
                    }
                    return interval === Infinity ? 0 : interval;
                };
                axis.ticks = function () {
                    if (!arguments.length) {
                        return tickArguments;
                    }
                    tickArguments = arguments;
                    return axis;
                };
                axis.tickCulling = function (culling) {
                    if (!arguments.length) {
                        return tickCulling;
                    }
                    tickCulling = culling;
                    return axis;
                };
                axis.tickValues = function (x) {
                    if (typeof x === 'function') {
                        tickValues = function () {
                            return x(scale.domain());
                        };
                    } else {
                        if (!arguments.length) {
                            return tickValues;
                        }
                        tickValues = x;
                    }
                    return axis;
                };
                return axis;
            }

            c3_chart_internal_fn.isSafari = function () {
                var ua = window.navigator.userAgent;
                return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
            };
            c3_chart_internal_fn.isChrome = function () {
                var ua = window.navigator.userAgent;
                return ua.indexOf('Chrome') >= 0;
            };

            /* jshint ignore:start */

            // PhantomJS doesn't have support for Function.prototype.bind, which has caused confusion. Use
            // this polyfill to avoid the confusion.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill

            if (!Function.prototype.bind) {
                Function.prototype.bind = function (oThis) {
                    if (typeof this !== 'function') {
                        // closest thing possible to the ECMAScript 5
                        // internal IsCallable function
                        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                    }

                    var aArgs = Array.prototype.slice.call(arguments, 1),
                        fToBind = this,
                        fNOP = function () {},
                        fBound = function () {
                        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                    };

                    fNOP.prototype = this.prototype;
                    fBound.prototype = new fNOP();

                    return fBound;
                };
            }

            //SVGPathSeg API polyfill
            //https://github.com/progers/pathseg
            //
            //This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from
            //SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec
            //changes which were implemented in Firefox 43 and Chrome 46.
            //Chrome 48 removes these APIs, so this polyfill is required.

            (function () {
                "use strict";

                if (!("SVGPathSeg" in window)) {
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
                    window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {
                        this.pathSegType = type;
                        this.pathSegTypeAsLetter = typeAsLetter;
                        this._owningPathSegList = owningPathSegList;
                    };

                    SVGPathSeg.PATHSEG_UNKNOWN = 0;
                    SVGPathSeg.PATHSEG_CLOSEPATH = 1;
                    SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
                    SVGPathSeg.PATHSEG_MOVETO_REL = 3;
                    SVGPathSeg.PATHSEG_LINETO_ABS = 4;
                    SVGPathSeg.PATHSEG_LINETO_REL = 5;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
                    SVGPathSeg.PATHSEG_ARC_ABS = 10;
                    SVGPathSeg.PATHSEG_ARC_REL = 11;
                    SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
                    SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
                    SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
                    SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
                    SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
                    SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

                    // Notify owning PathSegList on any changes so they can be synchronized back to the path element.
                    SVGPathSeg.prototype._segmentChanged = function () {
                        if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this);
                    };

                    window.SVGPathSegClosePath = function (owningPathSegList) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CLOSEPATH, "z", owningPathSegList);
                    };
                    SVGPathSegClosePath.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegClosePath.prototype.toString = function () {
                        return "[object SVGPathSegClosePath]";
                    };
                    SVGPathSegClosePath.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter;
                    };
                    SVGPathSegClosePath.prototype.clone = function () {
                        return new SVGPathSegClosePath(undefined);
                    };

                    window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_ABS, "M", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegMovetoAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegMovetoAbs.prototype.toString = function () {
                        return "[object SVGPathSegMovetoAbs]";
                    };
                    SVGPathSegMovetoAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegMovetoAbs.prototype.clone = function () {
                        return new SVGPathSegMovetoAbs(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegMovetoAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegMovetoAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_REL, "m", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegMovetoRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegMovetoRel.prototype.toString = function () {
                        return "[object SVGPathSegMovetoRel]";
                    };
                    SVGPathSegMovetoRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegMovetoRel.prototype.clone = function () {
                        return new SVGPathSegMovetoRel(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegMovetoRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegMovetoRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_ABS, "L", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegLinetoAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoAbs.prototype.toString = function () {
                        return "[object SVGPathSegLinetoAbs]";
                    };
                    SVGPathSegLinetoAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegLinetoAbs.prototype.clone = function () {
                        return new SVGPathSegLinetoAbs(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegLinetoAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_REL, "l", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegLinetoRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoRel.prototype.toString = function () {
                        return "[object SVGPathSegLinetoRel]";
                    };
                    SVGPathSegLinetoRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegLinetoRel.prototype.clone = function () {
                        return new SVGPathSegLinetoRel(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegLinetoRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicAbs]";
                    };
                    SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicRel]";
                    };
                    SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                    };
                    SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticAbs]";
                    };
                    SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x1 = x1;
                        this._y1 = y1;
                    };
                    SVGPathSegCurvetoQuadraticRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticRel]";
                    };
                    SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function () {
                            return this._x1;
                        }, set: function (x1) {
                            this._x1 = x1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function () {
                            return this._y1;
                        }, set: function (y1) {
                            this._y1 = y1;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_ABS, "A", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._r1 = r1;
                        this._r2 = r2;
                        this._angle = angle;
                        this._largeArcFlag = largeArcFlag;
                        this._sweepFlag = sweepFlag;
                    };
                    SVGPathSegArcAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegArcAbs.prototype.toString = function () {
                        return "[object SVGPathSegArcAbs]";
                    };
                    SVGPathSegArcAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
                    };
                    SVGPathSegArcAbs.prototype.clone = function () {
                        return new SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
                    };
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "r1", { get: function () {
                            return this._r1;
                        }, set: function (r1) {
                            this._r1 = r1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "r2", { get: function () {
                            return this._r2;
                        }, set: function (r2) {
                            this._r2 = r2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "angle", { get: function () {
                            return this._angle;
                        }, set: function (angle) {
                            this._angle = angle;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function () {
                            return this._largeArcFlag;
                        }, set: function (largeArcFlag) {
                            this._largeArcFlag = largeArcFlag;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcAbs.prototype, "sweepFlag", { get: function () {
                            return this._sweepFlag;
                        }, set: function (sweepFlag) {
                            this._sweepFlag = sweepFlag;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_REL, "a", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._r1 = r1;
                        this._r2 = r2;
                        this._angle = angle;
                        this._largeArcFlag = largeArcFlag;
                        this._sweepFlag = sweepFlag;
                    };
                    SVGPathSegArcRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegArcRel.prototype.toString = function () {
                        return "[object SVGPathSegArcRel]";
                    };
                    SVGPathSegArcRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
                    };
                    SVGPathSegArcRel.prototype.clone = function () {
                        return new SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
                    };
                    Object.defineProperty(SVGPathSegArcRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "r1", { get: function () {
                            return this._r1;
                        }, set: function (r1) {
                            this._r1 = r1;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "r2", { get: function () {
                            return this._r2;
                        }, set: function (r2) {
                            this._r2 = r2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "angle", { get: function () {
                            return this._angle;
                        }, set: function (angle) {
                            this._angle = angle;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "largeArcFlag", { get: function () {
                            return this._largeArcFlag;
                        }, set: function (largeArcFlag) {
                            this._largeArcFlag = largeArcFlag;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegArcRel.prototype, "sweepFlag", { get: function () {
                            return this._sweepFlag;
                        }, set: function (sweepFlag) {
                            this._sweepFlag = sweepFlag;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", owningPathSegList);
                        this._x = x;
                    };
                    SVGPathSegLinetoHorizontalAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {
                        return "[object SVGPathSegLinetoHorizontalAbs]";
                    };
                    SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x;
                    };
                    SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {
                        return new SVGPathSegLinetoHorizontalAbs(undefined, this._x);
                    };
                    Object.defineProperty(SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", owningPathSegList);
                        this._x = x;
                    };
                    SVGPathSegLinetoHorizontalRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoHorizontalRel.prototype.toString = function () {
                        return "[object SVGPathSegLinetoHorizontalRel]";
                    };
                    SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x;
                    };
                    SVGPathSegLinetoHorizontalRel.prototype.clone = function () {
                        return new SVGPathSegLinetoHorizontalRel(undefined, this._x);
                    };
                    Object.defineProperty(SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", owningPathSegList);
                        this._y = y;
                    };
                    SVGPathSegLinetoVerticalAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoVerticalAbs.prototype.toString = function () {
                        return "[object SVGPathSegLinetoVerticalAbs]";
                    };
                    SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._y;
                    };
                    SVGPathSegLinetoVerticalAbs.prototype.clone = function () {
                        return new SVGPathSegLinetoVerticalAbs(undefined, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", owningPathSegList);
                        this._y = y;
                    };
                    SVGPathSegLinetoVerticalRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegLinetoVerticalRel.prototype.toString = function () {
                        return "[object SVGPathSegLinetoVerticalRel]";
                    };
                    SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._y;
                    };
                    SVGPathSegLinetoVerticalRel.prototype.clone = function () {
                        return new SVGPathSegLinetoVerticalRel(undefined, this._y);
                    };
                    Object.defineProperty(SVGPathSegLinetoVerticalRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicSmoothAbs]";
                    };
                    SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", owningPathSegList);
                        this._x = x;
                        this._y = y;
                        this._x2 = x2;
                        this._y2 = y2;
                    };
                    SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoCubicSmoothRel]";
                    };
                    SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);
                    };
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function () {
                            return this._x2;
                        }, set: function (x2) {
                            this._x2 = x2;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function () {
                            return this._y2;
                        }, set: function (y2) {
                            this._y2 = y2;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticSmoothAbs]";
                    };
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {
                        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", owningPathSegList);
                        this._x = x;
                        this._y = y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(SVGPathSeg.prototype);
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {
                        return "[object SVGPathSegCurvetoQuadraticSmoothRel]";
                    };
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {
                        return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
                    };
                    SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {
                        return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);
                    };
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function () {
                            return this._x;
                        }, set: function (x) {
                            this._x = x;this._segmentChanged();
                        }, enumerable: true });
                    Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function () {
                            return this._y;
                        }, set: function (y) {
                            this._y = y;this._segmentChanged();
                        }, enumerable: true });

                    // Add createSVGPathSeg* functions to SVGPathElement.
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathElement.
                    SVGPathElement.prototype.createSVGPathSegClosePath = function () {
                        return new SVGPathSegClosePath(undefined);
                    };
                    SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {
                        return new SVGPathSegMovetoAbs(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {
                        return new SVGPathSegMovetoRel(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {
                        return new SVGPathSegLinetoAbs(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {
                        return new SVGPathSegLinetoRel(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {
                        return new SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {
                        return new SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {
                        return new SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {
                        return new SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);
                    };
                    SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        return new SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
                    };
                    SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                        return new SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {
                        return new SVGPathSegLinetoHorizontalAbs(undefined, x);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {
                        return new SVGPathSegLinetoHorizontalRel(undefined, x);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {
                        return new SVGPathSegLinetoVerticalAbs(undefined, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {
                        return new SVGPathSegLinetoVerticalRel(undefined, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {
                        return new SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {
                        return new SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {
                        return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);
                    };
                    SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {
                        return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);
                    };
                }

                if (!("SVGPathSegList" in window)) {
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
                    window.SVGPathSegList = function (pathElement) {
                        this._pathElement = pathElement;
                        this._list = this._parsePath(this._pathElement.getAttribute("d"));

                        // Use a MutationObserver to catch changes to the path's "d" attribute.
                        this._mutationObserverConfig = { "attributes": true, "attributeFilter": ["d"] };
                        this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
                        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
                    };

                    Object.defineProperty(SVGPathSegList.prototype, "numberOfItems", {
                        get: function () {
                            this._checkPathSynchronizedToList();
                            return this._list.length;
                        },
                        enumerable: true
                    });

                    // Add the pathSegList accessors to SVGPathElement.
                    // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData
                    Object.defineProperty(SVGPathElement.prototype, "pathSegList", {
                        get: function () {
                            if (!this._pathSegList) this._pathSegList = new SVGPathSegList(this);
                            return this._pathSegList;
                        },
                        enumerable: true
                    });
                    // FIXME: The following are not implemented and simply return SVGPathElement.pathSegList.
                    Object.defineProperty(SVGPathElement.prototype, "normalizedPathSegList", { get: function () {
                            return this.pathSegList;
                        }, enumerable: true });
                    Object.defineProperty(SVGPathElement.prototype, "animatedPathSegList", { get: function () {
                            return this.pathSegList;
                        }, enumerable: true });
                    Object.defineProperty(SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function () {
                            return this.pathSegList;
                        }, enumerable: true });

                    // Process any pending mutations to the path element and update the list as needed.
                    // This should be the first call of all public functions and is needed because
                    // MutationObservers are not synchronous so we can have pending asynchronous mutations.
                    SVGPathSegList.prototype._checkPathSynchronizedToList = function () {
                        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
                    };

                    SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {
                        if (!this._pathElement) return;
                        var hasPathMutations = false;
                        mutationRecords.forEach(function (record) {
                            if (record.attributeName == "d") hasPathMutations = true;
                        });
                        if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute("d"));
                    };

                    // Serialize the list and update the path's 'd' attribute.
                    SVGPathSegList.prototype._writeListToPath = function () {
                        this._pathElementMutationObserver.disconnect();
                        this._pathElement.setAttribute("d", SVGPathSegList._pathSegArrayAsString(this._list));
                        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
                    };

                    // When a path segment changes the list needs to be synchronized back to the path element.
                    SVGPathSegList.prototype.segmentChanged = function (pathSeg) {
                        this._writeListToPath();
                    };

                    SVGPathSegList.prototype.clear = function () {
                        this._checkPathSynchronizedToList();

                        this._list.forEach(function (pathSeg) {
                            pathSeg._owningPathSegList = null;
                        });
                        this._list = [];
                        this._writeListToPath();
                    };

                    SVGPathSegList.prototype.initialize = function (newItem) {
                        this._checkPathSynchronizedToList();

                        this._list = [newItem];
                        newItem._owningPathSegList = this;
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList.prototype._checkValidIndex = function (index) {
                        if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw "INDEX_SIZE_ERR";
                    };

                    SVGPathSegList.prototype.getItem = function (index) {
                        this._checkPathSynchronizedToList();

                        this._checkValidIndex(index);
                        return this._list[index];
                    };

                    SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {
                        this._checkPathSynchronizedToList();

                        // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
                        if (index > this.numberOfItems) index = this.numberOfItems;
                        if (newItem._owningPathSegList) {
                            // SVG2 spec says to make a copy.
                            newItem = newItem.clone();
                        }
                        this._list.splice(index, 0, newItem);
                        newItem._owningPathSegList = this;
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList.prototype.replaceItem = function (newItem, index) {
                        this._checkPathSynchronizedToList();

                        if (newItem._owningPathSegList) {
                            // SVG2 spec says to make a copy.
                            newItem = newItem.clone();
                        }
                        this._checkValidIndex(index);
                        this._list[index] = newItem;
                        newItem._owningPathSegList = this;
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList.prototype.removeItem = function (index) {
                        this._checkPathSynchronizedToList();

                        this._checkValidIndex(index);
                        var item = this._list[index];
                        this._list.splice(index, 1);
                        this._writeListToPath();
                        return item;
                    };

                    SVGPathSegList.prototype.appendItem = function (newItem) {
                        this._checkPathSynchronizedToList();

                        if (newItem._owningPathSegList) {
                            // SVG2 spec says to make a copy.
                            newItem = newItem.clone();
                        }
                        this._list.push(newItem);
                        newItem._owningPathSegList = this;
                        // TODO: Optimize this to just append to the existing attribute.
                        this._writeListToPath();
                        return newItem;
                    };

                    SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {
                        var string = "";
                        var first = true;
                        pathSegArray.forEach(function (pathSeg) {
                            if (first) {
                                first = false;
                                string += pathSeg._asPathString();
                            } else {
                                string += " " + pathSeg._asPathString();
                            }
                        });
                        return string;
                    };

                    // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.
                    SVGPathSegList.prototype._parsePath = function (string) {
                        if (!string || string.length == 0) return [];

                        var owningPathSegList = this;

                        var Builder = function () {
                            this.pathSegList = [];
                        };

                        Builder.prototype.appendSegment = function (pathSeg) {
                            this.pathSegList.push(pathSeg);
                        };

                        var Source = function (string) {
                            this._string = string;
                            this._currentIndex = 0;
                            this._endIndex = this._string.length;
                            this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN;

                            this._skipOptionalSpaces();
                        };

                        Source.prototype._isCurrentSpace = function () {
                            var character = this._string[this._currentIndex];
                            return character <= " " && (character == " " || character == "\n" || character == "\t" || character == "\r" || character == "\f");
                        };

                        Source.prototype._skipOptionalSpaces = function () {
                            while (this._currentIndex < this._endIndex && this._isCurrentSpace()) this._currentIndex++;
                            return this._currentIndex < this._endIndex;
                        };

                        Source.prototype._skipOptionalSpacesOrDelimiter = function () {
                            if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ",") return false;
                            if (this._skipOptionalSpaces()) {
                                if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ",") {
                                    this._currentIndex++;
                                    this._skipOptionalSpaces();
                                }
                            }
                            return this._currentIndex < this._endIndex;
                        };

                        Source.prototype.hasMoreData = function () {
                            return this._currentIndex < this._endIndex;
                        };

                        Source.prototype.peekSegmentType = function () {
                            var lookahead = this._string[this._currentIndex];
                            return this._pathSegTypeFromChar(lookahead);
                        };

                        Source.prototype._pathSegTypeFromChar = function (lookahead) {
                            switch (lookahead) {
                                case "Z":
                                case "z":
                                    return SVGPathSeg.PATHSEG_CLOSEPATH;
                                case "M":
                                    return SVGPathSeg.PATHSEG_MOVETO_ABS;
                                case "m":
                                    return SVGPathSeg.PATHSEG_MOVETO_REL;
                                case "L":
                                    return SVGPathSeg.PATHSEG_LINETO_ABS;
                                case "l":
                                    return SVGPathSeg.PATHSEG_LINETO_REL;
                                case "C":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                                case "c":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                                case "Q":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                                case "q":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                                case "A":
                                    return SVGPathSeg.PATHSEG_ARC_ABS;
                                case "a":
                                    return SVGPathSeg.PATHSEG_ARC_REL;
                                case "H":
                                    return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                                case "h":
                                    return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                                case "V":
                                    return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                                case "v":
                                    return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                                case "S":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                                case "s":
                                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                                case "T":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                                case "t":
                                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                                default:
                                    return SVGPathSeg.PATHSEG_UNKNOWN;
                            }
                        };

                        Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {
                            // Check for remaining coordinates in the current command.
                            if ((lookahead == "+" || lookahead == "-" || lookahead == "." || lookahead >= "0" && lookahead <= "9") && previousCommand != SVGPathSeg.PATHSEG_CLOSEPATH) {
                                if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_ABS) return SVGPathSeg.PATHSEG_LINETO_ABS;
                                if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_REL) return SVGPathSeg.PATHSEG_LINETO_REL;
                                return previousCommand;
                            }
                            return SVGPathSeg.PATHSEG_UNKNOWN;
                        };

                        Source.prototype.initialCommandIsMoveTo = function () {
                            // If the path is empty it is still valid, so return true.
                            if (!this.hasMoreData()) return true;
                            var command = this.peekSegmentType();
                            // Path must start with moveTo.
                            return command == SVGPathSeg.PATHSEG_MOVETO_ABS || command == SVGPathSeg.PATHSEG_MOVETO_REL;
                        };

                        // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
                        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF
                        Source.prototype._parseNumber = function () {
                            var exponent = 0;
                            var integer = 0;
                            var frac = 1;
                            var decimal = 0;
                            var sign = 1;
                            var expsign = 1;

                            var startIndex = this._currentIndex;

                            this._skipOptionalSpaces();

                            // Read the sign.
                            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "+") this._currentIndex++;else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "-") {
                                this._currentIndex++;
                                sign = -1;
                            }

                            if (this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && this._string.charAt(this._currentIndex) != ".")
                                // The first character of a number must be one of [0-9+-.].
                                return undefined;

                            // Read the integer part, build right-to-left.
                            var startIntPartIndex = this._currentIndex;
                            while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") this._currentIndex++; // Advance to first non-digit.

                            if (this._currentIndex != startIntPartIndex) {
                                var scanIntPartIndex = this._currentIndex - 1;
                                var multiplier = 1;
                                while (scanIntPartIndex >= startIntPartIndex) {
                                    integer += multiplier * (this._string.charAt(scanIntPartIndex--) - "0");
                                    multiplier *= 10;
                                }
                            }

                            // Read the decimals.
                            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ".") {
                                this._currentIndex++;

                                // There must be a least one digit following the .
                                if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;
                                while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") decimal += (this._string.charAt(this._currentIndex++) - "0") * (frac *= 0.1);
                            }

                            // Read the exponent part.
                            if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == "e" || this._string.charAt(this._currentIndex) == "E") && this._string.charAt(this._currentIndex + 1) != "x" && this._string.charAt(this._currentIndex + 1) != "m") {
                                this._currentIndex++;

                                // Read the sign of the exponent.
                                if (this._string.charAt(this._currentIndex) == "+") {
                                    this._currentIndex++;
                                } else if (this._string.charAt(this._currentIndex) == "-") {
                                    this._currentIndex++;
                                    expsign = -1;
                                }

                                // There must be an exponent.
                                if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;

                                while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
                                    exponent *= 10;
                                    exponent += this._string.charAt(this._currentIndex) - "0";
                                    this._currentIndex++;
                                }
                            }

                            var number = integer + decimal;
                            number *= sign;

                            if (exponent) number *= Math.pow(10, expsign * exponent);

                            if (startIndex == this._currentIndex) return undefined;

                            this._skipOptionalSpacesOrDelimiter();

                            return number;
                        };

                        Source.prototype._parseArcFlag = function () {
                            if (this._currentIndex >= this._endIndex) return undefined;
                            var flag = false;
                            var flagChar = this._string.charAt(this._currentIndex++);
                            if (flagChar == "0") flag = false;else if (flagChar == "1") flag = true;else return undefined;

                            this._skipOptionalSpacesOrDelimiter();
                            return flag;
                        };

                        Source.prototype.parseSegment = function () {
                            var lookahead = this._string[this._currentIndex];
                            var command = this._pathSegTypeFromChar(lookahead);
                            if (command == SVGPathSeg.PATHSEG_UNKNOWN) {
                                // Possibly an implicit command. Not allowed if this is the first command.
                                if (this._previousCommand == SVGPathSeg.PATHSEG_UNKNOWN) return null;
                                command = this._nextCommandHelper(lookahead, this._previousCommand);
                                if (command == SVGPathSeg.PATHSEG_UNKNOWN) return null;
                            } else {
                                this._currentIndex++;
                            }

                            this._previousCommand = command;

                            switch (command) {
                                case SVGPathSeg.PATHSEG_MOVETO_REL:
                                    return new SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                                    return new SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_REL:
                                    return new SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_ABS:
                                    return new SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                                    return new SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                                    return new SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                                    return new SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                                    return new SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
                                case SVGPathSeg.PATHSEG_CLOSEPATH:
                                    this._skipOptionalSpaces();
                                    return new SVGPathSegClosePath(owningPathSegList);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                                    var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                                    var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                                    return new SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                                    return new SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                                case SVGPathSeg.PATHSEG_ARC_REL:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                                case SVGPathSeg.PATHSEG_ARC_ABS:
                                    var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };
                                    return new SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                                default:
                                    throw "Unknown path seg type.";
                            }
                        };

                        var builder = new Builder();
                        var source = new Source(string);

                        if (!source.initialCommandIsMoveTo()) return [];
                        while (source.hasMoreData()) {
                            var pathSeg = source.parseSegment();
                            if (!pathSeg) return [];
                            builder.appendSegment(pathSeg);
                        }

                        return builder.pathSegList;
                    };
                }
            })();

            /* jshint ignore:end */

            if (typeof define === 'function' && define.amd) {
                define("c3", ["d3"], function () {
                    return c3;
                });
            } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
                module.exports = c3;
            } else {
                window.c3 = c3;
            }
        })(window);
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("6e", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("6f", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("5b", ["5b"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "ace", null);

    (function ($__global) {
        /* ***** BEGIN LICENSE BLOCK *****
         * Distributed under the BSD license:
         *
         * Copyright (c) 2010, Ajax.org B.V.
         * All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are met:
         *     * Redistributions of source code must retain the above copyright
         *       notice, this list of conditions and the following disclaimer.
         *     * Redistributions in binary form must reproduce the above copyright
         *       notice, this list of conditions and the following disclaimer in the
         *       documentation and/or other materials provided with the distribution.
         *     * Neither the name of Ajax.org B.V. nor the
         *       names of its contributors may be used to endorse or promote products
         *       derived from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
         * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
         * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * ***** END LICENSE BLOCK ***** */

        /**
         * Define a module along with a payload
         * @param module a name for the payload
         * @param payload a function to call with (require, exports, module) params
         */

        (function () {

            var ACE_NAMESPACE = "ace";

            var global = function () {
                return this;
            }();
            if (!global && typeof window != "undefined") global = window; // strict mode


            if (!ACE_NAMESPACE && typeof requirejs !== "undefined") return;

            var define = function (module, deps, payload) {
                if (typeof module !== "string") {
                    if (define.original) define.original.apply(this, arguments);else {
                        console.error("dropping module because define wasn\'t a string.");
                        console.trace();
                    }
                    return;
                }
                if (arguments.length == 2) payload = deps;
                if (!define.modules[module]) {
                    define.payloads[module] = payload;
                    define.modules[module] = null;
                }
            };

            define.modules = {};
            define.payloads = {};

            /**
             * Get at functionality define()ed using the function above
             */
            var _require = function (parentId, module, callback) {
                if (typeof module === "string") {
                    var payload = lookup(parentId, module);
                    if (payload != undefined) {
                        callback && callback();
                        return payload;
                    }
                } else if (Object.prototype.toString.call(module) === "[object Array]") {
                    var params = [];
                    for (var i = 0, l = module.length; i < l; ++i) {
                        var dep = lookup(parentId, module[i]);
                        if (dep == undefined && require.original) return;
                        params.push(dep);
                    }
                    return callback && callback.apply(null, params) || true;
                }
            };

            var require = function (module, callback) {
                var packagedModule = _require("", module, callback);
                if (packagedModule == undefined && require.original) return require.original.apply(this, arguments);
                return packagedModule;
            };

            var normalizeModule = function (parentId, moduleName) {
                // normalize plugin requires
                if (moduleName.indexOf("!") !== -1) {
                    var chunks = moduleName.split("!");
                    return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
                }
                // normalize relative requires
                if (moduleName.charAt(0) == ".") {
                    var base = parentId.split("/").slice(0, -1).join("/");
                    moduleName = base + "/" + moduleName;

                    while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
                        var previous = moduleName;
                        moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
                    }
                }
                return moduleName;
            };

            /**
             * Internal function to lookup moduleNames and resolve them by calling the
             * definition function if needed.
             */
            var lookup = function (parentId, moduleName) {
                moduleName = normalizeModule(parentId, moduleName);

                var module = define.modules[moduleName];
                if (!module) {
                    module = define.payloads[moduleName];
                    if (typeof module === 'function') {
                        var exports = {};
                        var mod = {
                            id: moduleName,
                            uri: '',
                            exports: exports,
                            packaged: true
                        };

                        var req = function (module, callback) {
                            return _require(moduleName, module, callback);
                        };

                        var returnValue = module(req, exports, mod);
                        exports = returnValue || mod.exports;
                        define.modules[moduleName] = exports;
                        delete define.payloads[moduleName];
                    }
                    module = define.modules[moduleName] = exports || module;
                }
                return module;
            };

            function exportAce(ns) {
                var root = global;
                if (ns) {
                    if (!global[ns]) global[ns] = {};
                    root = global[ns];
                }

                if (!root.define || !root.define.packaged) {
                    define.original = root.define;
                    root.define = define;
                    root.define.packaged = true;
                }

                if (!root.require || !root.require.packaged) {
                    require.original = root.require;
                    root.require = require;
                    root.require.packaged = true;
                }
            }

            exportAce(ACE_NAMESPACE);
        })();

        ace.define("ace/lib/regexp", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var real = {
                exec: RegExp.prototype.exec,
                test: RegExp.prototype.test,
                match: String.prototype.match,
                replace: String.prototype.replace,
                split: String.prototype.split
            },
                compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined,
                // check `exec` handling of nonparticipating capturing groups
            compliantLastIndexIncrement = function () {
                var x = /^/g;
                real.test.call(x, "");
                return !x.lastIndex;
            }();

            if (compliantLastIndexIncrement && compliantExecNpcg) return;
            RegExp.prototype.exec = function (str) {
                var match = real.exec.apply(this, arguments),
                    name,
                    r2;
                if (typeof str == 'string' && match) {
                    if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                        r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                        real.replace.call(str.slice(match.index), r2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === undefined) match[i] = undefined;
                            }
                        });
                    }
                    if (this._xregexp && this._xregexp.captureNames) {
                        for (var i = 1; i < match.length; i++) {
                            name = this._xregexp.captureNames[i - 1];
                            if (name) match[name] = match[i];
                        }
                    }
                    if (!compliantLastIndexIncrement && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
                }
                return match;
            };
            if (!compliantLastIndexIncrement) {
                RegExp.prototype.test = function (str) {
                    var match = real.exec.call(this, str);
                    if (match && this.global && !match[0].length && this.lastIndex > match.index) this.lastIndex--;
                    return !!match;
                };
            }

            function getNativeFlags(regex) {
                return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + ( // Proposed for ES4; included in AS3
                regex.sticky ? "y" : "");
            }

            function indexOf(array, item, from) {
                if (Array.prototype.indexOf) // Use the native array method if available
                    return array.indexOf(item, from);
                for (var i = from || 0; i < array.length; i++) {
                    if (array[i] === item) return i;
                }
                return -1;
            }
        });

        ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (require, exports, module) {

            function Empty() {}

            if (!Function.prototype.bind) {
                Function.prototype.bind = function bind(that) {
                    // .length is 1
                    var target = this;
                    if (typeof target != "function") {
                        throw new TypeError("Function.prototype.bind called on incompatible " + target);
                    }
                    var args = slice.call(arguments, 1); // for normal call
                    var bound = function () {

                        if (this instanceof bound) {

                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    if (target.prototype) {
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            }
            var call = Function.prototype.call;
            var prototypeOfArray = Array.prototype;
            var prototypeOfObject = Object.prototype;
            var slice = prototypeOfArray.slice;
            var _toString = call.bind(prototypeOfObject.toString);
            var owns = call.bind(prototypeOfObject.hasOwnProperty);
            var defineGetter;
            var defineSetter;
            var lookupGetter;
            var lookupSetter;
            var supportsAccessors;
            if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
                defineGetter = call.bind(prototypeOfObject.__defineGetter__);
                defineSetter = call.bind(prototypeOfObject.__defineSetter__);
                lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
                lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
            }
            if ([1, 2].splice(0).length != 2) {
                if (function () {
                    // test IE < 9 to splice bug - see issue #138
                    function makeArray(l) {
                        var a = new Array(l + 2);
                        a[0] = a[1] = 0;
                        return a;
                    }
                    var array = [],
                        lengthBefore;

                    array.splice.apply(array, makeArray(20));
                    array.splice.apply(array, makeArray(26));

                    lengthBefore = array.length; //46
                    array.splice(5, 0, "XXX"); // add one element

                    lengthBefore + 1 == array.length;

                    if (lengthBefore + 1 == array.length) {
                        return true; // has right splice implementation without bugs
                    }
                }()) {
                    //IE 6/7
                    var array_splice = Array.prototype.splice;
                    Array.prototype.splice = function (start, deleteCount) {
                        if (!arguments.length) {
                            return [];
                        } else {
                            return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? this.length - start : deleteCount].concat(slice.call(arguments, 2)));
                        }
                    };
                } else {
                    //IE8
                    Array.prototype.splice = function (pos, removeCount) {
                        var length = this.length;
                        if (pos > 0) {
                            if (pos > length) pos = length;
                        } else if (pos == void 0) {
                            pos = 0;
                        } else if (pos < 0) {
                            pos = Math.max(length + pos, 0);
                        }

                        if (!(pos + removeCount < length)) removeCount = length - pos;

                        var removed = this.slice(pos, pos + removeCount);
                        var insert = slice.call(arguments, 2);
                        var add = insert.length;
                        if (pos === length) {
                            if (add) {
                                this.push.apply(this, insert);
                            }
                        } else {
                            var remove = Math.min(removeCount, length - pos);
                            var tailOldPos = pos + remove;
                            var tailNewPos = tailOldPos + add - remove;
                            var tailCount = length - tailOldPos;
                            var lengthAfterRemove = length - remove;

                            if (tailNewPos < tailOldPos) {
                                // case A
                                for (var i = 0; i < tailCount; ++i) {
                                    this[tailNewPos + i] = this[tailOldPos + i];
                                }
                            } else if (tailNewPos > tailOldPos) {
                                // case B
                                for (i = tailCount; i--;) {
                                    this[tailNewPos + i] = this[tailOldPos + i];
                                }
                            } // else, add == remove (nothing to do)

                            if (add && pos === lengthAfterRemove) {
                                this.length = lengthAfterRemove; // truncate array
                                this.push.apply(this, insert);
                            } else {
                                this.length = lengthAfterRemove + add; // reserves space
                                for (i = 0; i < add; ++i) {
                                    this[pos + i] = insert[i];
                                }
                            }
                        }
                        return removed;
                    };
                }
            }
            if (!Array.isArray) {
                Array.isArray = function isArray(obj) {
                    return _toString(obj) == "[object Array]";
                };
            }
            var boxedString = Object("a"),
                splitString = boxedString[0] != "a" || !(0 in boxedString);

            if (!Array.prototype.forEach) {
                Array.prototype.forEach = function forEach(fun /*, thisp*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        thisp = arguments[1],
                        i = -1,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(); // TODO message
                    }

                    while (++i < length) {
                        if (i in self) {
                            fun.call(thisp, self[i], i, object);
                        }
                    }
                };
            }
            if (!Array.prototype.map) {
                Array.prototype.map = function map(fun /*, thisp*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        result = Array(length),
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self) result[i] = fun.call(thisp, self[i], i, object);
                    }
                    return result;
                };
            }
            if (!Array.prototype.filter) {
                Array.prototype.filter = function filter(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        result = [],
                        value,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self) {
                            value = self[i];
                            if (fun.call(thisp, value, i, object)) {
                                result.push(value);
                            }
                        }
                    }
                    return result;
                };
            }
            if (!Array.prototype.every) {
                Array.prototype.every = function every(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self && !fun.call(thisp, self[i], i, object)) {
                            return false;
                        }
                    }
                    return true;
                };
            }
            if (!Array.prototype.some) {
                Array.prototype.some = function some(fun /*, thisp */) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0,
                        thisp = arguments[1];
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }

                    for (var i = 0; i < length; i++) {
                        if (i in self && fun.call(thisp, self[i], i, object)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            if (!Array.prototype.reduce) {
                Array.prototype.reduce = function reduce(fun /*, initial*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }
                    if (!length && arguments.length == 1) {
                        throw new TypeError("reduce of empty array with no initial value");
                    }

                    var i = 0;
                    var result;
                    if (arguments.length >= 2) {
                        result = arguments[1];
                    } else {
                        do {
                            if (i in self) {
                                result = self[i++];
                                break;
                            }
                            if (++i >= length) {
                                throw new TypeError("reduce of empty array with no initial value");
                            }
                        } while (true);
                    }

                    for (; i < length; i++) {
                        if (i in self) {
                            result = fun.call(void 0, result, self[i], i, object);
                        }
                    }

                    return result;
                };
            }
            if (!Array.prototype.reduceRight) {
                Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
                    var object = toObject(this),
                        self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
                        length = self.length >>> 0;
                    if (_toString(fun) != "[object Function]") {
                        throw new TypeError(fun + " is not a function");
                    }
                    if (!length && arguments.length == 1) {
                        throw new TypeError("reduceRight of empty array with no initial value");
                    }

                    var result,
                        i = length - 1;
                    if (arguments.length >= 2) {
                        result = arguments[1];
                    } else {
                        do {
                            if (i in self) {
                                result = self[i--];
                                break;
                            }
                            if (--i < 0) {
                                throw new TypeError("reduceRight of empty array with no initial value");
                            }
                        } while (true);
                    }

                    do {
                        if (i in this) {
                            result = fun.call(void 0, result, self[i], i, object);
                        }
                    } while (i--);

                    return result;
                };
            }
            if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
                Array.prototype.indexOf = function indexOf(sought /*, fromIndex */) {
                    var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
                        length = self.length >>> 0;

                    if (!length) {
                        return -1;
                    }

                    var i = 0;
                    if (arguments.length > 1) {
                        i = toInteger(arguments[1]);
                    }
                    i = i >= 0 ? i : Math.max(0, length + i);
                    for (; i < length; i++) {
                        if (i in self && self[i] === sought) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
                Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
                    var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
                        length = self.length >>> 0;

                    if (!length) {
                        return -1;
                    }
                    var i = length - 1;
                    if (arguments.length > 1) {
                        i = Math.min(i, toInteger(arguments[1]));
                    }
                    i = i >= 0 ? i : length - Math.abs(i);
                    for (; i >= 0; i--) {
                        if (i in self && sought === self[i]) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            if (!Object.getPrototypeOf) {
                Object.getPrototypeOf = function getPrototypeOf(object) {
                    return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
                };
            }
            if (!Object.getOwnPropertyDescriptor) {
                var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
                Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
                    if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT + object);
                    if (!owns(object, property)) return;

                    var descriptor, getter, setter;
                    descriptor = { enumerable: true, configurable: true };
                    if (supportsAccessors) {
                        var prototype = object.__proto__;
                        object.__proto__ = prototypeOfObject;

                        var getter = lookupGetter(object, property);
                        var setter = lookupSetter(object, property);
                        object.__proto__ = prototype;

                        if (getter || setter) {
                            if (getter) descriptor.get = getter;
                            if (setter) descriptor.set = setter;
                            return descriptor;
                        }
                    }
                    descriptor.value = object[property];
                    return descriptor;
                };
            }
            if (!Object.getOwnPropertyNames) {
                Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
                    return Object.keys(object);
                };
            }
            if (!Object.create) {
                var createEmpty;
                if (Object.prototype.__proto__ === null) {
                    createEmpty = function () {
                        return { "__proto__": null };
                    };
                } else {
                    createEmpty = function () {
                        var empty = {};
                        for (var i in empty) empty[i] = null;
                        empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
                        return empty;
                    };
                }

                Object.create = function create(prototype, properties) {
                    var object;
                    if (prototype === null) {
                        object = createEmpty();
                    } else {
                        if (typeof prototype != "object") throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
                        var Type = function () {};
                        Type.prototype = prototype;
                        object = new Type();
                        object.__proto__ = prototype;
                    }
                    if (properties !== void 0) Object.defineProperties(object, properties);
                    return object;
                };
            }

            function doesDefinePropertyWork(object) {
                try {
                    Object.defineProperty(object, "sentinel", {});
                    return "sentinel" in object;
                } catch (exception) {}
            }
            if (Object.defineProperty) {
                var definePropertyWorksOnObject = doesDefinePropertyWork({});
                var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
                if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
                    var definePropertyFallback = Object.defineProperty;
                }
            }

            if (!Object.defineProperty || definePropertyFallback) {
                var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
                var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
                var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";

                Object.defineProperty = function defineProperty(object, property, descriptor) {
                    if (typeof object != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT_TARGET + object);
                    if (typeof descriptor != "object" && typeof descriptor != "function" || descriptor === null) throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
                    if (definePropertyFallback) {
                        try {
                            return definePropertyFallback.call(Object, object, property, descriptor);
                        } catch (exception) {}
                    }
                    if (owns(descriptor, "value")) {

                        if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                            var prototype = object.__proto__;
                            object.__proto__ = prototypeOfObject;
                            delete object[property];
                            object[property] = descriptor.value;
                            object.__proto__ = prototype;
                        } else {
                            object[property] = descriptor.value;
                        }
                    } else {
                        if (!supportsAccessors) throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                        if (owns(descriptor, "get")) defineGetter(object, property, descriptor.get);
                        if (owns(descriptor, "set")) defineSetter(object, property, descriptor.set);
                    }

                    return object;
                };
            }
            if (!Object.defineProperties) {
                Object.defineProperties = function defineProperties(object, properties) {
                    for (var property in properties) {
                        if (owns(properties, property)) Object.defineProperty(object, property, properties[property]);
                    }
                    return object;
                };
            }
            if (!Object.seal) {
                Object.seal = function seal(object) {
                    return object;
                };
            }
            if (!Object.freeze) {
                Object.freeze = function freeze(object) {
                    return object;
                };
            }
            try {
                Object.freeze(function () {});
            } catch (exception) {
                Object.freeze = function freeze(freezeObject) {
                    return function freeze(object) {
                        if (typeof object == "function") {
                            return object;
                        } else {
                            return freezeObject(object);
                        }
                    };
                }(Object.freeze);
            }
            if (!Object.preventExtensions) {
                Object.preventExtensions = function preventExtensions(object) {
                    return object;
                };
            }
            if (!Object.isSealed) {
                Object.isSealed = function isSealed(object) {
                    return false;
                };
            }
            if (!Object.isFrozen) {
                Object.isFrozen = function isFrozen(object) {
                    return false;
                };
            }
            if (!Object.isExtensible) {
                Object.isExtensible = function isExtensible(object) {
                    if (Object(object) === object) {
                        throw new TypeError(); // TODO message
                    }
                    var name = '';
                    while (owns(object, name)) {
                        name += '?';
                    }
                    object[name] = true;
                    var returnValue = owns(object, name);
                    delete object[name];
                    return returnValue;
                };
            }
            if (!Object.keys) {
                var hasDontEnumBug = true,
                    dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
                    dontEnumsLength = dontEnums.length;

                for (var key in { "toString": null }) {
                    hasDontEnumBug = false;
                }

                Object.keys = function keys(object) {

                    if (typeof object != "object" && typeof object != "function" || object === null) {
                        throw new TypeError("Object.keys called on a non-object");
                    }

                    var keys = [];
                    for (var name in object) {
                        if (owns(object, name)) {
                            keys.push(name);
                        }
                    }

                    if (hasDontEnumBug) {
                        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                            var dontEnum = dontEnums[i];
                            if (owns(object, dontEnum)) {
                                keys.push(dontEnum);
                            }
                        }
                    }
                    return keys;
                };
            }
            if (!Date.now) {
                Date.now = function now() {
                    return new Date().getTime();
                };
            }
            var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
            if (!String.prototype.trim || ws.trim()) {
                ws = "[" + ws + "]";
                var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
                    trimEndRegexp = new RegExp(ws + ws + "*$");
                String.prototype.trim = function trim() {
                    return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
                };
            }

            function toInteger(n) {
                n = +n;
                if (n !== n) {
                    // isNaN
                    n = 0;
                } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
                return n;
            }

            function isPrimitive(input) {
                var type = typeof input;
                return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
            }

            function toPrimitive(input) {
                var val, valueOf, toString;
                if (isPrimitive(input)) {
                    return input;
                }
                valueOf = input.valueOf;
                if (typeof valueOf === "function") {
                    val = valueOf.call(input);
                    if (isPrimitive(val)) {
                        return val;
                    }
                }
                toString = input.toString;
                if (typeof toString === "function") {
                    val = toString.call(input);
                    if (isPrimitive(val)) {
                        return val;
                    }
                }
                throw new TypeError();
            }
            var toObject = function (o) {
                if (o == null) {
                    // this matches both null and undefined
                    throw new TypeError("can't convert " + o + " to object");
                }
                return Object(o);
            };
        });

        ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function (require, exports, module) {
            "use strict";

            require("./regexp");
            require("./es5-shim");
        });

        ace.define("ace/lib/dom", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var XHTML_NS = "http://www.w3.org/1999/xhtml";

            exports.getDocumentHead = function (doc) {
                if (!doc) doc = document;
                return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
            };

            exports.createElement = function (tag, ns) {
                return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
            };

            exports.hasCssClass = function (el, name) {
                var classes = (el.className + "").split(/\s+/g);
                return classes.indexOf(name) !== -1;
            };
            exports.addCssClass = function (el, name) {
                if (!exports.hasCssClass(el, name)) {
                    el.className += " " + name;
                }
            };
            exports.removeCssClass = function (el, name) {
                var classes = el.className.split(/\s+/g);
                while (true) {
                    var index = classes.indexOf(name);
                    if (index == -1) {
                        break;
                    }
                    classes.splice(index, 1);
                }
                el.className = classes.join(" ");
            };

            exports.toggleCssClass = function (el, name) {
                var classes = el.className.split(/\s+/g),
                    add = true;
                while (true) {
                    var index = classes.indexOf(name);
                    if (index == -1) {
                        break;
                    }
                    add = false;
                    classes.splice(index, 1);
                }
                if (add) classes.push(name);

                el.className = classes.join(" ");
                return add;
            };
            exports.setCssClass = function (node, className, include) {
                if (include) {
                    exports.addCssClass(node, className);
                } else {
                    exports.removeCssClass(node, className);
                }
            };

            exports.hasCssString = function (id, doc) {
                var index = 0,
                    sheets;
                doc = doc || document;

                if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
                    while (index < sheets.length) if (sheets[index++].owningElement.id === id) return true;
                } else if (sheets = doc.getElementsByTagName("style")) {
                    while (index < sheets.length) if (sheets[index++].id === id) return true;
                }

                return false;
            };

            exports.importCssString = function importCssString(cssText, id, doc) {
                doc = doc || document;
                if (id && exports.hasCssString(id, doc)) return null;

                var style;

                if (id) cssText += "\n/*# sourceURL=ace/css/" + id + " */";

                if (doc.createStyleSheet) {
                    style = doc.createStyleSheet();
                    style.cssText = cssText;
                    if (id) style.owningElement.id = id;
                } else {
                    style = exports.createElement("style");
                    style.appendChild(doc.createTextNode(cssText));
                    if (id) style.id = id;

                    exports.getDocumentHead(doc).appendChild(style);
                }
            };

            exports.importCssStylsheet = function (uri, doc) {
                if (doc.createStyleSheet) {
                    doc.createStyleSheet(uri);
                } else {
                    var link = exports.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = uri;

                    exports.getDocumentHead(doc).appendChild(link);
                }
            };

            exports.getInnerWidth = function (element) {
                return parseInt(exports.computedStyle(element, "paddingLeft"), 10) + parseInt(exports.computedStyle(element, "paddingRight"), 10) + element.clientWidth;
            };

            exports.getInnerHeight = function (element) {
                return parseInt(exports.computedStyle(element, "paddingTop"), 10) + parseInt(exports.computedStyle(element, "paddingBottom"), 10) + element.clientHeight;
            };

            exports.scrollbarWidth = function (document) {
                var inner = exports.createElement("ace_inner");
                inner.style.width = "100%";
                inner.style.minWidth = "0px";
                inner.style.height = "200px";
                inner.style.display = "block";

                var outer = exports.createElement("ace_outer");
                var style = outer.style;

                style.position = "absolute";
                style.left = "-10000px";
                style.overflow = "hidden";
                style.width = "200px";
                style.minWidth = "0px";
                style.height = "150px";
                style.display = "block";

                outer.appendChild(inner);

                var body = document.documentElement;
                body.appendChild(outer);

                var noScrollbar = inner.offsetWidth;

                style.overflow = "scroll";
                var withScrollbar = inner.offsetWidth;

                if (noScrollbar == withScrollbar) {
                    withScrollbar = outer.clientWidth;
                }

                body.removeChild(outer);

                return noScrollbar - withScrollbar;
            };

            if (typeof document == "undefined") {
                exports.importCssString = function () {};
                return;
            }

            if (window.pageYOffset !== undefined) {
                exports.getPageScrollTop = function () {
                    return window.pageYOffset;
                };

                exports.getPageScrollLeft = function () {
                    return window.pageXOffset;
                };
            } else {
                exports.getPageScrollTop = function () {
                    return document.body.scrollTop;
                };

                exports.getPageScrollLeft = function () {
                    return document.body.scrollLeft;
                };
            }

            if (window.getComputedStyle) exports.computedStyle = function (element, style) {
                if (style) return (window.getComputedStyle(element, "") || {})[style] || "";
                return window.getComputedStyle(element, "") || {};
            };else exports.computedStyle = function (element, style) {
                if (style) return element.currentStyle[style];
                return element.currentStyle;
            };
            exports.setInnerHtml = function (el, innerHtml) {
                var element = el.cloneNode(false); //document.createElement("div");
                element.innerHTML = innerHtml;
                el.parentNode.replaceChild(element, el);
                return element;
            };

            if ("textContent" in document.documentElement) {
                exports.setInnerText = function (el, innerText) {
                    el.textContent = innerText;
                };

                exports.getInnerText = function (el) {
                    return el.textContent;
                };
            } else {
                exports.setInnerText = function (el, innerText) {
                    el.innerText = innerText;
                };

                exports.getInnerText = function (el) {
                    return el.innerText;
                };
            }

            exports.getParentWindow = function (document) {
                return document.defaultView || document.parentWindow;
            };
        });

        ace.define("ace/lib/oop", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.inherits = function (ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };

            exports.mixin = function (obj, mixin) {
                for (var key in mixin) {
                    obj[key] = mixin[key];
                }
                return obj;
            };

            exports.implement = function (proto, mixin) {
                exports.mixin(proto, mixin);
            };
        });

        ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            require("./fixoldbrowsers");

            var oop = require("./oop");
            var Keys = function () {
                var ret = {
                    MODIFIER_KEYS: {
                        16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
                    },

                    KEY_MODS: {
                        "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
                        "super": 8, "meta": 8, "command": 8, "cmd": 8
                    },

                    FUNCTION_KEYS: {
                        8: "Backspace",
                        9: "Tab",
                        13: "Return",
                        19: "Pause",
                        27: "Esc",
                        32: "Space",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "Left",
                        38: "Up",
                        39: "Right",
                        40: "Down",
                        44: "Print",
                        45: "Insert",
                        46: "Delete",
                        96: "Numpad0",
                        97: "Numpad1",
                        98: "Numpad2",
                        99: "Numpad3",
                        100: "Numpad4",
                        101: "Numpad5",
                        102: "Numpad6",
                        103: "Numpad7",
                        104: "Numpad8",
                        105: "Numpad9",
                        '-13': "NumpadEnter",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "Numlock",
                        145: "Scrolllock"
                    },

                    PRINTABLE_KEYS: {
                        32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5',
                        54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 61: '=', 65: 'a',
                        66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h',
                        73: 'i', 74: 'j', 75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o',
                        80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't', 85: 'u', 86: 'v',
                        87: 'w', 88: 'x', 89: 'y', 90: 'z', 107: '+', 109: '-', 110: '.',
                        186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
                        219: '[', 220: '\\', 221: ']', 222: "'", 111: '/', 106: '*'
                    }
                };
                var name, i;
                for (i in ret.FUNCTION_KEYS) {
                    name = ret.FUNCTION_KEYS[i].toLowerCase();
                    ret[name] = parseInt(i, 10);
                }
                for (i in ret.PRINTABLE_KEYS) {
                    name = ret.PRINTABLE_KEYS[i].toLowerCase();
                    ret[name] = parseInt(i, 10);
                }
                oop.mixin(ret, ret.MODIFIER_KEYS);
                oop.mixin(ret, ret.PRINTABLE_KEYS);
                oop.mixin(ret, ret.FUNCTION_KEYS);
                ret.enter = ret["return"];
                ret.escape = ret.esc;
                ret.del = ret["delete"];
                ret[173] = '-';

                (function () {
                    var mods = ["cmd", "ctrl", "alt", "shift"];
                    for (var i = Math.pow(2, mods.length); i--;) {
                        ret.KEY_MODS[i] = mods.filter(function (x) {
                            return i & ret.KEY_MODS[x];
                        }).join("-") + "-";
                    }
                })();

                ret.KEY_MODS[0] = "";
                ret.KEY_MODS[-1] = "input-";

                return ret;
            }();
            oop.mixin(exports, Keys);

            exports.keyCodeToString = function (keyCode) {
                var keyString = Keys[keyCode];
                if (typeof keyString != "string") keyString = String.fromCharCode(keyCode);
                return keyString.toLowerCase();
            };
        });

        ace.define("ace/lib/useragent", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.OS = {
                LINUX: "LINUX",
                MAC: "MAC",
                WINDOWS: "WINDOWS"
            };
            exports.getOS = function () {
                if (exports.isMac) {
                    return exports.OS.MAC;
                } else if (exports.isLinux) {
                    return exports.OS.LINUX;
                } else {
                    return exports.OS.WINDOWS;
                }
            };
            if (typeof navigator != "object") return;

            var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
            var ua = navigator.userAgent;
            exports.isWin = os == "win";
            exports.isMac = os == "mac";
            exports.isLinux = os == "linux";
            exports.isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie

            exports.isOldIE = exports.isIE && exports.isIE < 9;
            exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
            exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/) || [])[1], 10) < 4;
            exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
            exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

            exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

            exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

            exports.isIPad = ua.indexOf("iPad") >= 0;

            exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

            exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
        });

        ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var keys = require("./keys");
            var useragent = require("./useragent");

            var pressedKeys = null;
            var ts = 0;

            exports.addListener = function (elem, type, callback) {
                if (elem.addEventListener) {
                    return elem.addEventListener(type, callback, false);
                }
                if (elem.attachEvent) {
                    var wrapper = function () {
                        callback.call(elem, window.event);
                    };
                    callback._wrapper = wrapper;
                    elem.attachEvent("on" + type, wrapper);
                }
            };

            exports.removeListener = function (elem, type, callback) {
                if (elem.removeEventListener) {
                    return elem.removeEventListener(type, callback, false);
                }
                if (elem.detachEvent) {
                    elem.detachEvent("on" + type, callback._wrapper || callback);
                }
            };
            exports.stopEvent = function (e) {
                exports.stopPropagation(e);
                exports.preventDefault(e);
                return false;
            };

            exports.stopPropagation = function (e) {
                if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
            };

            exports.preventDefault = function (e) {
                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
            };
            exports.getButton = function (e) {
                if (e.type == "dblclick") return 0;
                if (e.type == "contextmenu" || useragent.isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
                if (e.preventDefault) {
                    return e.button;
                } else {
                    return { 1: 0, 2: 2, 4: 1 }[e.button];
                }
            };

            exports.capture = function (el, eventHandler, releaseCaptureHandler) {
                function onMouseUp(e) {
                    eventHandler && eventHandler(e);
                    releaseCaptureHandler && releaseCaptureHandler(e);

                    exports.removeListener(document, "mousemove", eventHandler, true);
                    exports.removeListener(document, "mouseup", onMouseUp, true);
                    exports.removeListener(document, "dragstart", onMouseUp, true);
                }

                exports.addListener(document, "mousemove", eventHandler, true);
                exports.addListener(document, "mouseup", onMouseUp, true);
                exports.addListener(document, "dragstart", onMouseUp, true);

                return onMouseUp;
            };

            exports.addTouchMoveListener = function (el, callback) {
                if ("ontouchmove" in el) {
                    var startx, starty;
                    exports.addListener(el, "touchstart", function (e) {
                        var touchObj = e.changedTouches[0];
                        startx = touchObj.clientX;
                        starty = touchObj.clientY;
                    });
                    exports.addListener(el, "touchmove", function (e) {
                        var factor = 1,
                            touchObj = e.changedTouches[0];

                        e.wheelX = -(touchObj.clientX - startx) / factor;
                        e.wheelY = -(touchObj.clientY - starty) / factor;

                        startx = touchObj.clientX;
                        starty = touchObj.clientY;

                        callback(e);
                    });
                }
            };

            exports.addMouseWheelListener = function (el, callback) {
                if ("onmousewheel" in el) {
                    exports.addListener(el, "mousewheel", function (e) {
                        var factor = 8;
                        if (e.wheelDeltaX !== undefined) {
                            e.wheelX = -e.wheelDeltaX / factor;
                            e.wheelY = -e.wheelDeltaY / factor;
                        } else {
                            e.wheelX = 0;
                            e.wheelY = -e.wheelDelta / factor;
                        }
                        callback(e);
                    });
                } else if ("onwheel" in el) {
                    exports.addListener(el, "wheel", function (e) {
                        var factor = 0.35;
                        switch (e.deltaMode) {
                            case e.DOM_DELTA_PIXEL:
                                e.wheelX = e.deltaX * factor || 0;
                                e.wheelY = e.deltaY * factor || 0;
                                break;
                            case e.DOM_DELTA_LINE:
                            case e.DOM_DELTA_PAGE:
                                e.wheelX = (e.deltaX || 0) * 5;
                                e.wheelY = (e.deltaY || 0) * 5;
                                break;
                        }

                        callback(e);
                    });
                } else {
                    exports.addListener(el, "DOMMouseScroll", function (e) {
                        if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                            e.wheelX = (e.detail || 0) * 5;
                            e.wheelY = 0;
                        } else {
                            e.wheelX = 0;
                            e.wheelY = (e.detail || 0) * 5;
                        }
                        callback(e);
                    });
                }
            };

            exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName) {
                var clicks = 0;
                var startX, startY, timer;
                var eventNames = {
                    2: "dblclick",
                    3: "tripleclick",
                    4: "quadclick"
                };

                function onMousedown(e) {
                    if (exports.getButton(e) !== 0) {
                        clicks = 0;
                    } else if (e.detail > 1) {
                        clicks++;
                        if (clicks > 4) clicks = 1;
                    } else {
                        clicks = 1;
                    }
                    if (useragent.isIE) {
                        var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                        if (!timer || isNewClick) clicks = 1;
                        if (timer) clearTimeout(timer);
                        timer = setTimeout(function () {
                            timer = null;
                        }, timeouts[clicks - 1] || 600);

                        if (clicks == 1) {
                            startX = e.clientX;
                            startY = e.clientY;
                        }
                    }

                    e._clicks = clicks;

                    eventHandler[callbackName]("mousedown", e);

                    if (clicks > 4) clicks = 0;else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
                }
                function onDblclick(e) {
                    clicks = 2;
                    if (timer) clearTimeout(timer);
                    timer = setTimeout(function () {
                        timer = null;
                    }, timeouts[clicks - 1] || 600);
                    eventHandler[callbackName]("mousedown", e);
                    eventHandler[callbackName](eventNames[clicks], e);
                }
                if (!Array.isArray(elements)) elements = [elements];
                elements.forEach(function (el) {
                    exports.addListener(el, "mousedown", onMousedown);
                    if (useragent.isOldIE) exports.addListener(el, "dblclick", onDblclick);
                });
            };

            var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function (e) {
                return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
            } : function (e) {
                return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
            };

            exports.getModifierString = function (e) {
                return keys.KEY_MODS[getModifierHash(e)];
            };

            function normalizeCommandKeys(callback, e, keyCode) {
                var hashId = getModifierHash(e);

                if (!useragent.isMac && pressedKeys) {
                    if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win"))) hashId |= 8;
                    if (pressedKeys.altGr) {
                        if ((3 & hashId) != 3) pressedKeys.altGr = 0;else return;
                    }
                    if (keyCode === 18 || keyCode === 17) {
                        var location = "location" in e ? e.location : e.keyLocation;
                        if (keyCode === 17 && location === 1) {
                            if (pressedKeys[keyCode] == 1) ts = e.timeStamp;
                        } else if (keyCode === 18 && hashId === 3 && location === 2) {
                            var dt = e.timeStamp - ts;
                            if (dt < 50) pressedKeys.altGr = true;
                        }
                    }
                }

                if (keyCode in keys.MODIFIER_KEYS) {
                    keyCode = -1;
                }
                if (hashId & 8 && keyCode >= 91 && keyCode <= 93) {
                    keyCode = -1;
                }

                if (!hashId && keyCode === 13) {
                    var location = "location" in e ? e.location : e.keyLocation;
                    if (location === 3) {
                        callback(e, hashId, -keyCode);
                        if (e.defaultPrevented) return;
                    }
                }

                if (useragent.isChromeOS && hashId & 8) {
                    callback(e, hashId, keyCode);
                    if (e.defaultPrevented) return;else hashId &= ~8;
                }
                if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
                    return false;
                }

                return callback(e, hashId, keyCode);
            }

            exports.addCommandKeyListener = function (el, callback) {
                var addListener = exports.addListener;
                if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
                    var lastKeyDownKeyCode = null;
                    addListener(el, "keydown", function (e) {
                        lastKeyDownKeyCode = e.keyCode;
                    });
                    addListener(el, "keypress", function (e) {
                        return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                    });
                } else {
                    var lastDefaultPrevented = null;

                    addListener(el, "keydown", function (e) {
                        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                        var result = normalizeCommandKeys(callback, e, e.keyCode);
                        lastDefaultPrevented = e.defaultPrevented;
                        return result;
                    });

                    addListener(el, "keypress", function (e) {
                        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                            exports.stopEvent(e);
                            lastDefaultPrevented = null;
                        }
                    });

                    addListener(el, "keyup", function (e) {
                        pressedKeys[e.keyCode] = null;
                    });

                    if (!pressedKeys) {
                        resetPressedKeys();
                        addListener(window, "focus", resetPressedKeys);
                    }
                }
            };
            function resetPressedKeys() {
                pressedKeys = Object.create(null);
            }

            if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
                var postMessageId = 1;
                exports.nextTick = function (callback, win) {
                    win = win || window;
                    var messageName = "zero-timeout-message-" + postMessageId;
                    exports.addListener(win, "message", function listener(e) {
                        if (e.data == messageName) {
                            exports.stopPropagation(e);
                            exports.removeListener(win, "message", listener);
                            callback();
                        }
                    });
                    win.postMessage(messageName, "*");
                };
            }

            exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);

            if (exports.nextFrame) exports.nextFrame = exports.nextFrame.bind(window);else exports.nextFrame = function (callback) {
                setTimeout(callback, 17);
            };
        });

        ace.define("ace/lib/lang", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.last = function (a) {
                return a[a.length - 1];
            };

            exports.stringReverse = function (string) {
                return string.split("").reverse().join("");
            };

            exports.stringRepeat = function (string, count) {
                var result = '';
                while (count > 0) {
                    if (count & 1) result += string;

                    if (count >>= 1) string += string;
                }
                return result;
            };

            var trimBeginRegexp = /^\s\s*/;
            var trimEndRegexp = /\s\s*$/;

            exports.stringTrimLeft = function (string) {
                return string.replace(trimBeginRegexp, '');
            };

            exports.stringTrimRight = function (string) {
                return string.replace(trimEndRegexp, '');
            };

            exports.copyObject = function (obj) {
                var copy = {};
                for (var key in obj) {
                    copy[key] = obj[key];
                }
                return copy;
            };

            exports.copyArray = function (array) {
                var copy = [];
                for (var i = 0, l = array.length; i < l; i++) {
                    if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
                }
                return copy;
            };

            exports.deepCopy = function deepCopy(obj) {
                if (typeof obj !== "object" || !obj) return obj;
                var copy;
                if (Array.isArray(obj)) {
                    copy = [];
                    for (var key = 0; key < obj.length; key++) {
                        copy[key] = deepCopy(obj[key]);
                    }
                    return copy;
                }
                if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;

                copy = {};
                for (var key in obj) copy[key] = deepCopy(obj[key]);
                return copy;
            };

            exports.arrayToMap = function (arr) {
                var map = {};
                for (var i = 0; i < arr.length; i++) {
                    map[arr[i]] = 1;
                }
                return map;
            };

            exports.createMap = function (props) {
                var map = Object.create(null);
                for (var i in props) {
                    map[i] = props[i];
                }
                return map;
            };
            exports.arrayRemove = function (array, value) {
                for (var i = 0; i <= array.length; i++) {
                    if (value === array[i]) {
                        array.splice(i, 1);
                    }
                }
            };

            exports.escapeRegExp = function (str) {
                return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
            };

            exports.escapeHTML = function (str) {
                return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
            };

            exports.getMatchOffsets = function (string, regExp) {
                var matches = [];

                string.replace(regExp, function (str) {
                    matches.push({
                        offset: arguments[arguments.length - 2],
                        length: str.length
                    });
                });

                return matches;
            };
            exports.deferredCall = function (fcn) {
                var timer = null;
                var callback = function () {
                    timer = null;
                    fcn();
                };

                var deferred = function (timeout) {
                    deferred.cancel();
                    timer = setTimeout(callback, timeout || 0);
                    return deferred;
                };

                deferred.schedule = deferred;

                deferred.call = function () {
                    this.cancel();
                    fcn();
                    return deferred;
                };

                deferred.cancel = function () {
                    clearTimeout(timer);
                    timer = null;
                    return deferred;
                };

                deferred.isPending = function () {
                    return timer;
                };

                return deferred;
            };

            exports.delayedCall = function (fcn, defaultTimeout) {
                var timer = null;
                var callback = function () {
                    timer = null;
                    fcn();
                };

                var _self = function (timeout) {
                    if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
                };

                _self.delay = function (timeout) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(callback, timeout || defaultTimeout);
                };
                _self.schedule = _self;

                _self.call = function () {
                    this.cancel();
                    fcn();
                };

                _self.cancel = function () {
                    timer && clearTimeout(timer);
                    timer = null;
                };

                _self.isPending = function () {
                    return timer;
                };

                return _self;
            };
        });

        ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var BROKEN_SETDATA = useragent.isChrome < 18;
            var USE_IE_MIME_TYPE = useragent.isIE;

            var TextInput = function (parentNode, host) {
                var text = dom.createElement("textarea");
                text.className = "ace_text-input";

                if (useragent.isTouchPad) text.setAttribute("x-palm-disable-auto-cap", true);

                text.setAttribute("wrap", "off");
                text.setAttribute("autocorrect", "off");
                text.setAttribute("autocapitalize", "off");
                text.setAttribute("spellcheck", false);

                text.style.opacity = "0";
                if (useragent.isOldIE) text.style.top = "-1000px";
                parentNode.insertBefore(text, parentNode.firstChild);

                var PLACEHOLDER = "\x01\x01";

                var copied = false;
                var pasted = false;
                var inComposition = false;
                var tempStyle = '';
                var isSelectionEmpty = true;
                try {
                    var isFocused = document.activeElement === text;
                } catch (e) {}

                event.addListener(text, "blur", function (e) {
                    host.onBlur(e);
                    isFocused = false;
                });
                event.addListener(text, "focus", function (e) {
                    isFocused = true;
                    host.onFocus(e);
                    resetSelection();
                });
                this.focus = function () {
                    if (tempStyle) return text.focus();
                    var top = text.style.top;
                    text.style.position = "fixed";
                    text.style.top = "0px";
                    text.focus();
                    setTimeout(function () {
                        text.style.position = "";
                        if (text.style.top == "0px") text.style.top = top;
                    }, 0);
                };
                this.blur = function () {
                    text.blur();
                };
                this.isFocused = function () {
                    return isFocused;
                };
                var syncSelection = lang.delayedCall(function () {
                    isFocused && resetSelection(isSelectionEmpty);
                });
                var syncValue = lang.delayedCall(function () {
                    if (!inComposition) {
                        text.value = PLACEHOLDER;
                        isFocused && resetSelection();
                    }
                });

                function resetSelection(isEmpty) {
                    if (inComposition) return;
                    inComposition = true;

                    if (inputHandler) {
                        selectionStart = 0;
                        selectionEnd = isEmpty ? 0 : text.value.length - 1;
                    } else {
                        var selectionStart = isEmpty ? 2 : 1;
                        var selectionEnd = 2;
                    }
                    try {
                        text.setSelectionRange(selectionStart, selectionEnd);
                    } catch (e) {}

                    inComposition = false;
                }

                function resetValue() {
                    if (inComposition) return;
                    text.value = PLACEHOLDER;
                    if (useragent.isWebKit) syncValue.schedule();
                }

                useragent.isWebKit || host.addEventListener('changeSelection', function () {
                    if (host.selection.isEmpty() != isSelectionEmpty) {
                        isSelectionEmpty = !isSelectionEmpty;
                        syncSelection.schedule();
                    }
                });

                resetValue();
                if (isFocused) host.onFocus();

                var isAllSelected = function (text) {
                    return text.selectionStart === 0 && text.selectionEnd === text.value.length;
                };
                if (!text.setSelectionRange && text.createTextRange) {
                    text.setSelectionRange = function (selectionStart, selectionEnd) {
                        var range = this.createTextRange();
                        range.collapse(true);
                        range.moveStart('character', selectionStart);
                        range.moveEnd('character', selectionEnd);
                        range.select();
                    };
                    isAllSelected = function (text) {
                        try {
                            var range = text.ownerDocument.selection.createRange();
                        } catch (e) {}
                        if (!range || range.parentElement() != text) return false;
                        return range.text == text.value;
                    };
                }
                if (useragent.isOldIE) {
                    var inPropertyChange = false;
                    var onPropertyChange = function (e) {
                        if (inPropertyChange) return;
                        var data = text.value;
                        if (inComposition || !data || data == PLACEHOLDER) return;
                        if (e && data == PLACEHOLDER[0]) return syncProperty.schedule();

                        sendText(data);
                        inPropertyChange = true;
                        resetValue();
                        inPropertyChange = false;
                    };
                    var syncProperty = lang.delayedCall(onPropertyChange);
                    event.addListener(text, "propertychange", onPropertyChange);

                    var keytable = { 13: 1, 27: 1 };
                    event.addListener(text, "keyup", function (e) {
                        if (inComposition && (!text.value || keytable[e.keyCode])) setTimeout(onCompositionEnd, 0);
                        if ((text.value.charCodeAt(0) || 0) < 129) {
                            return syncProperty.call();
                        }
                        inComposition ? onCompositionUpdate() : onCompositionStart();
                    });
                    event.addListener(text, "keydown", function (e) {
                        syncProperty.schedule(50);
                    });
                }

                var onSelect = function (e) {
                    if (copied) {
                        copied = false;
                    } else if (isAllSelected(text)) {
                        host.selectAll();
                        resetSelection();
                    } else if (inputHandler) {
                        resetSelection(host.selection.isEmpty());
                    }
                };

                var inputHandler = null;
                this.setInputHandler = function (cb) {
                    inputHandler = cb;
                };
                this.getInputHandler = function () {
                    return inputHandler;
                };
                var afterContextMenu = false;

                var sendText = function (data) {
                    if (inputHandler) {
                        data = inputHandler(data);
                        inputHandler = null;
                    }
                    if (pasted) {
                        resetSelection();
                        if (data) host.onPaste(data);
                        pasted = false;
                    } else if (data == PLACEHOLDER.charAt(0)) {
                        if (afterContextMenu) host.execCommand("del", { source: "ace" });else // some versions of android do not fire keydown when pressing backspace
                            host.execCommand("backspace", { source: "ace" });
                    } else {
                        if (data.substring(0, 2) == PLACEHOLDER) data = data.substr(2);else if (data.charAt(0) == PLACEHOLDER.charAt(0)) data = data.substr(1);else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
                        if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);

                        if (data) host.onTextInput(data);
                    }
                    if (afterContextMenu) afterContextMenu = false;
                };
                var onInput = function (e) {
                    if (inComposition) return;
                    var data = text.value;
                    sendText(data);
                    resetValue();
                };

                var handleClipboardData = function (e, data, forceIEMime) {
                    var clipboardData = e.clipboardData || window.clipboardData;
                    if (!clipboardData || BROKEN_SETDATA) return;
                    var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
                    try {
                        if (data) {
                            return clipboardData.setData(mime, data) !== false;
                        } else {
                            return clipboardData.getData(mime);
                        }
                    } catch (e) {
                        if (!forceIEMime) return handleClipboardData(e, data, true);
                    }
                };

                var doCopy = function (e, isCut) {
                    var data = host.getCopyText();
                    if (!data) return event.preventDefault(e);

                    if (handleClipboardData(e, data)) {
                        isCut ? host.onCut() : host.onCopy();
                        event.preventDefault(e);
                    } else {
                        copied = true;
                        text.value = data;
                        text.select();
                        setTimeout(function () {
                            copied = false;
                            resetValue();
                            resetSelection();
                            isCut ? host.onCut() : host.onCopy();
                        });
                    }
                };

                var onCut = function (e) {
                    doCopy(e, true);
                };

                var onCopy = function (e) {
                    doCopy(e, false);
                };

                var onPaste = function (e) {
                    var data = handleClipboardData(e);
                    if (typeof data == "string") {
                        if (data) host.onPaste(data, e);
                        if (useragent.isIE) setTimeout(resetSelection);
                        event.preventDefault(e);
                    } else {
                        text.value = "";
                        pasted = true;
                    }
                };

                event.addCommandKeyListener(text, host.onCommandKey.bind(host));

                event.addListener(text, "select", onSelect);

                event.addListener(text, "input", onInput);

                event.addListener(text, "cut", onCut);
                event.addListener(text, "copy", onCopy);
                event.addListener(text, "paste", onPaste);
                if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
                    event.addListener(parentNode, "keydown", function (e) {
                        if (useragent.isMac && !e.metaKey || !e.ctrlKey) return;

                        switch (e.keyCode) {
                            case 67:
                                onCopy(e);
                                break;
                            case 86:
                                onPaste(e);
                                break;
                            case 88:
                                onCut(e);
                                break;
                        }
                    });
                }
                var onCompositionStart = function (e) {
                    if (inComposition || !host.onCompositionStart || host.$readOnly) return;
                    inComposition = {};
                    inComposition.canUndo = host.session.$undoManager;
                    host.onCompositionStart();
                    setTimeout(onCompositionUpdate, 0);
                    host.on("mousedown", onCompositionEnd);
                    if (inComposition.canUndo && !host.selection.isEmpty()) {
                        host.insert("");
                        host.session.markUndoGroup();
                        host.selection.clearSelection();
                    }
                    host.session.markUndoGroup();
                };

                var onCompositionUpdate = function () {
                    if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
                    var val = text.value.replace(/\x01/g, "");
                    if (inComposition.lastValue === val) return;

                    host.onCompositionUpdate(val);
                    if (inComposition.lastValue) host.undo();
                    if (inComposition.canUndo) inComposition.lastValue = val;
                    if (inComposition.lastValue) {
                        var r = host.selection.getRange();
                        host.insert(inComposition.lastValue);
                        host.session.markUndoGroup();
                        inComposition.range = host.selection.getRange();
                        host.selection.setRange(r);
                        host.selection.clearSelection();
                    }
                };

                var onCompositionEnd = function (e) {
                    if (!host.onCompositionEnd || host.$readOnly) return;
                    var c = inComposition;
                    inComposition = false;
                    var timer = setTimeout(function () {
                        timer = null;
                        var str = text.value.replace(/\x01/g, "");
                        if (inComposition) return;else if (str == c.lastValue) resetValue();else if (!c.lastValue && str) {
                            resetValue();
                            sendText(str);
                        }
                    });
                    inputHandler = function compositionInputHandler(str) {
                        if (timer) clearTimeout(timer);
                        str = str.replace(/\x01/g, "");
                        if (str == c.lastValue) return "";
                        if (c.lastValue && timer) host.undo();
                        return str;
                    };
                    host.onCompositionEnd();
                    host.removeListener("mousedown", onCompositionEnd);
                    if (e.type == "compositionend" && c.range) {
                        host.selection.setRange(c.range);
                    }
                };

                var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

                event.addListener(text, "compositionstart", onCompositionStart);
                if (useragent.isGecko) {
                    event.addListener(text, "text", function () {
                        syncComposition.schedule();
                    });
                } else {
                    event.addListener(text, "keyup", function () {
                        syncComposition.schedule();
                    });
                    event.addListener(text, "keydown", function () {
                        syncComposition.schedule();
                    });
                }
                event.addListener(text, "compositionend", onCompositionEnd);

                this.getElement = function () {
                    return text;
                };

                this.setReadOnly = function (readOnly) {
                    text.readOnly = readOnly;
                };

                this.onContextMenu = function (e) {
                    afterContextMenu = true;
                    resetSelection(host.selection.isEmpty());
                    host._emit("nativecontextmenu", { target: host, domEvent: e });
                    this.moveToMouse(e, true);
                };

                this.moveToMouse = function (e, bringToFront) {
                    if (!bringToFront && useragent.isOldIE) return;
                    if (!tempStyle) tempStyle = text.style.cssText;
                    text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");

                    var rect = host.container.getBoundingClientRect();
                    var style = dom.computedStyle(host.container);
                    var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                    var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                    var maxTop = rect.bottom - top - text.clientHeight - 2;
                    var move = function (e) {
                        text.style.left = e.clientX - left - 2 + "px";
                        text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
                    };
                    move(e);

                    if (e.type != "mousedown") return;

                    if (host.renderer.$keepTextAreaAtCursor) host.renderer.$keepTextAreaAtCursor = null;

                    clearTimeout(closeTimeout);
                    if (useragent.isWin && !useragent.isOldIE) event.capture(host.container, move, onContextMenuClose);
                };

                this.onContextMenuClose = onContextMenuClose;
                var closeTimeout;
                function onContextMenuClose() {
                    clearTimeout(closeTimeout);
                    closeTimeout = setTimeout(function () {
                        if (tempStyle) {
                            text.style.cssText = tempStyle;
                            tempStyle = '';
                        }
                        if (host.renderer.$keepTextAreaAtCursor == null) {
                            host.renderer.$keepTextAreaAtCursor = true;
                            host.renderer.$moveTextAreaToCursor();
                        }
                    }, useragent.isOldIE ? 200 : 0);
                }

                var onContextMenu = function (e) {
                    host.textInput.onContextMenu(e);
                    onContextMenuClose();
                };
                event.addListener(text, "mouseup", onContextMenu);
                event.addListener(text, "mousedown", function (e) {
                    e.preventDefault();
                    onContextMenuClose();
                });
                event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
                event.addListener(text, "contextmenu", onContextMenu);
            };

            exports.TextInput = TextInput;
        });

        ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var event = require("../lib/event");
            var useragent = require("../lib/useragent");

            var DRAG_OFFSET = 0; // pixels

            function DefaultHandlers(mouseHandler) {
                mouseHandler.$clickSelection = null;

                var editor = mouseHandler.editor;
                editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
                editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
                editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
                editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
                editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
                editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

                var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

                exports.forEach(function (x) {
                    mouseHandler[x] = this[x];
                }, this);

                mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
                mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
            }

            (function () {

                this.onMouseDown = function (ev) {
                    var inSelection = ev.inSelection();
                    var pos = ev.getDocumentPosition();
                    this.mousedownEvent = ev;
                    var editor = this.editor;

                    var button = ev.getButton();
                    if (button !== 0) {
                        var selectionRange = editor.getSelectionRange();
                        var selectionEmpty = selectionRange.isEmpty();
                        editor.$blockScrolling++;
                        if (selectionEmpty || button == 1) editor.selection.moveToPosition(pos);
                        editor.$blockScrolling--;
                        if (button == 2) editor.textInput.onContextMenu(ev.domEvent);
                        return; // stopping event here breaks contextmenu on ff mac
                    }

                    this.mousedownEvent.time = Date.now();
                    if (inSelection && !editor.isFocused()) {
                        editor.focus();
                        if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                            this.setState("focusWait");
                            this.captureMouse(ev);
                            return;
                        }
                    }

                    this.captureMouse(ev);
                    this.startSelect(pos, ev.domEvent._clicks > 1);
                    return ev.preventDefault();
                };

                this.startSelect = function (pos, waitForClickSelection) {
                    pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
                    var editor = this.editor;
                    editor.$blockScrolling++;
                    if (this.mousedownEvent.getShiftKey()) editor.selection.selectToPosition(pos);else if (!waitForClickSelection) editor.selection.moveToPosition(pos);
                    if (!waitForClickSelection) this.select();
                    if (editor.renderer.scroller.setCapture) {
                        editor.renderer.scroller.setCapture();
                    }
                    editor.setStyle("ace_selecting");
                    this.setState("select");
                    editor.$blockScrolling--;
                };

                this.select = function () {
                    var anchor,
                        editor = this.editor;
                    var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                    editor.$blockScrolling++;
                    if (this.$clickSelection) {
                        var cmp = this.$clickSelection.comparePoint(cursor);

                        if (cmp == -1) {
                            anchor = this.$clickSelection.end;
                        } else if (cmp == 1) {
                            anchor = this.$clickSelection.start;
                        } else {
                            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                            cursor = orientedRange.cursor;
                            anchor = orientedRange.anchor;
                        }
                        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    }
                    editor.selection.selectToPosition(cursor);
                    editor.$blockScrolling--;
                    editor.renderer.scrollCursorIntoView();
                };

                this.extendSelectionBy = function (unitName) {
                    var anchor,
                        editor = this.editor;
                    var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                    var range = editor.selection[unitName](cursor.row, cursor.column);
                    editor.$blockScrolling++;
                    if (this.$clickSelection) {
                        var cmpStart = this.$clickSelection.comparePoint(range.start);
                        var cmpEnd = this.$clickSelection.comparePoint(range.end);

                        if (cmpStart == -1 && cmpEnd <= 0) {
                            anchor = this.$clickSelection.end;
                            if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
                        } else if (cmpEnd == 1 && cmpStart >= 0) {
                            anchor = this.$clickSelection.start;
                            if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
                        } else if (cmpStart == -1 && cmpEnd == 1) {
                            cursor = range.end;
                            anchor = range.start;
                        } else {
                            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                            cursor = orientedRange.cursor;
                            anchor = orientedRange.anchor;
                        }
                        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                    }
                    editor.selection.selectToPosition(cursor);
                    editor.$blockScrolling--;
                    editor.renderer.scrollCursorIntoView();
                };

                this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function () {
                    this.$clickSelection = null;
                    this.editor.unsetStyle("ace_selecting");
                    if (this.editor.renderer.scroller.releaseCapture) {
                        this.editor.renderer.scroller.releaseCapture();
                    }
                };

                this.focusWait = function () {
                    var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                    var time = Date.now();

                    if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout) this.startSelect(this.mousedownEvent.getDocumentPosition());
                };

                this.onDoubleClick = function (ev) {
                    var pos = ev.getDocumentPosition();
                    var editor = this.editor;
                    var session = editor.session;

                    var range = session.getBracketRange(pos);
                    if (range) {
                        if (range.isEmpty()) {
                            range.start.column--;
                            range.end.column++;
                        }
                        this.setState("select");
                    } else {
                        range = editor.selection.getWordRange(pos.row, pos.column);
                        this.setState("selectByWords");
                    }
                    this.$clickSelection = range;
                    this.select();
                };

                this.onTripleClick = function (ev) {
                    var pos = ev.getDocumentPosition();
                    var editor = this.editor;

                    this.setState("selectByLines");
                    var range = editor.getSelectionRange();
                    if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                        this.$clickSelection = editor.selection.getLineRange(range.start.row);
                        this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
                    } else {
                        this.$clickSelection = editor.selection.getLineRange(pos.row);
                    }
                    this.select();
                };

                this.onQuadClick = function (ev) {
                    var editor = this.editor;

                    editor.selectAll();
                    this.$clickSelection = editor.getSelectionRange();
                    this.setState("selectAll");
                };

                this.onMouseWheel = function (ev) {
                    if (ev.getAccelKey()) return;
                    if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                        ev.wheelX = ev.wheelY;
                        ev.wheelY = 0;
                    }

                    var t = ev.domEvent.timeStamp;
                    var dt = t - (this.$lastScrollTime || 0);

                    var editor = this.editor;
                    var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    if (isScrolable || dt < 200) {
                        this.$lastScrollTime = t;
                        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                        return ev.stop();
                    }
                };

                this.onTouchMove = function (ev) {
                    var t = ev.domEvent.timeStamp;
                    var dt = t - (this.$lastScrollTime || 0);

                    var editor = this.editor;
                    var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                    if (isScrolable || dt < 200) {
                        this.$lastScrollTime = t;
                        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                        return ev.stop();
                    }
                };
            }).call(DefaultHandlers.prototype);

            exports.DefaultHandlers = DefaultHandlers;

            function calcDistance(ax, ay, bx, by) {
                return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
            }

            function calcRangeOrientation(range, cursor) {
                if (range.start.row == range.end.row) var cmp = 2 * cursor.column - range.start.column - range.end.column;else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) var cmp = cursor.column - 4;else var cmp = 2 * cursor.row - range.start.row - range.end.row;

                if (cmp < 0) return { cursor: range.start, anchor: range.end };else return { cursor: range.end, anchor: range.start };
            }
        });

        ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            function Tooltip(parentNode) {
                this.isOpen = false;
                this.$element = null;
                this.$parentNode = parentNode;
            }

            (function () {
                this.$init = function () {
                    this.$element = dom.createElement("div");
                    this.$element.className = "ace_tooltip";
                    this.$element.style.display = "none";
                    this.$parentNode.appendChild(this.$element);
                    return this.$element;
                };
                this.getElement = function () {
                    return this.$element || this.$init();
                };
                this.setText = function (text) {
                    dom.setInnerText(this.getElement(), text);
                };
                this.setHtml = function (html) {
                    this.getElement().innerHTML = html;
                };
                this.setPosition = function (x, y) {
                    this.getElement().style.left = x + "px";
                    this.getElement().style.top = y + "px";
                };
                this.setClassName = function (className) {
                    dom.addCssClass(this.getElement(), className);
                };
                this.show = function (text, x, y) {
                    if (text != null) this.setText(text);
                    if (x != null && y != null) this.setPosition(x, y);
                    if (!this.isOpen) {
                        this.getElement().style.display = "block";
                        this.isOpen = true;
                    }
                };

                this.hide = function () {
                    if (this.isOpen) {
                        this.getElement().style.display = "none";
                        this.isOpen = false;
                    }
                };
                this.getHeight = function () {
                    return this.getElement().offsetHeight;
                };
                this.getWidth = function () {
                    return this.getElement().offsetWidth;
                };
            }).call(Tooltip.prototype);

            exports.Tooltip = Tooltip;
        });

        ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var oop = require("../lib/oop");
            var event = require("../lib/event");
            var Tooltip = require("../tooltip").Tooltip;

            function GutterHandler(mouseHandler) {
                var editor = mouseHandler.editor;
                var gutter = editor.renderer.$gutterLayer;
                var tooltip = new GutterTooltip(editor.container);

                mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
                    if (!editor.isFocused() || e.getButton() != 0) return;
                    var gutterRegion = gutter.getRegion(e);

                    if (gutterRegion == "foldWidgets") return;

                    var row = e.getDocumentPosition().row;
                    var selection = editor.session.selection;

                    if (e.getShiftKey()) selection.selectTo(row, 0);else {
                        if (e.domEvent.detail == 2) {
                            editor.selectAll();
                            return e.preventDefault();
                        }
                        mouseHandler.$clickSelection = editor.selection.getLineRange(row);
                    }
                    mouseHandler.setState("selectByLines");
                    mouseHandler.captureMouse(e);
                    return e.preventDefault();
                });

                var tooltipTimeout, mouseEvent, tooltipAnnotation;

                function showTooltip() {
                    var row = mouseEvent.getDocumentPosition().row;
                    var annotation = gutter.$annotations[row];
                    if (!annotation) return hideTooltip();

                    var maxRow = editor.session.getLength();
                    if (row == maxRow) {
                        var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                        var pos = mouseEvent.$pos;
                        if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column)) return hideTooltip();
                    }

                    if (tooltipAnnotation == annotation) return;
                    tooltipAnnotation = annotation.text.join("<br/>");

                    tooltip.setHtml(tooltipAnnotation);
                    tooltip.show();
                    editor._signal("showGutterTooltip", tooltip);
                    editor.on("mousewheel", hideTooltip);

                    if (mouseHandler.$tooltipFollowsMouse) {
                        moveTooltip(mouseEvent);
                    } else {
                        var gutterElement = mouseEvent.domEvent.target;
                        var rect = gutterElement.getBoundingClientRect();
                        var style = tooltip.getElement().style;
                        style.left = rect.right + "px";
                        style.top = rect.bottom + "px";
                    }
                }

                function hideTooltip() {
                    if (tooltipTimeout) tooltipTimeout = clearTimeout(tooltipTimeout);
                    if (tooltipAnnotation) {
                        tooltip.hide();
                        tooltipAnnotation = null;
                        editor._signal("hideGutterTooltip", tooltip);
                        editor.removeEventListener("mousewheel", hideTooltip);
                    }
                }

                function moveTooltip(e) {
                    tooltip.setPosition(e.x, e.y);
                }

                mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
                    var target = e.domEvent.target || e.domEvent.srcElement;
                    if (dom.hasCssClass(target, "ace_fold-widget")) return hideTooltip();

                    if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) moveTooltip(e);

                    mouseEvent = e;
                    if (tooltipTimeout) return;
                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();else hideTooltip();
                    }, 50);
                });

                event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
                    mouseEvent = null;
                    if (!tooltipAnnotation || tooltipTimeout) return;

                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        hideTooltip();
                    }, 50);
                });

                editor.on("changeSession", hideTooltip);
            }

            function GutterTooltip(parentNode) {
                Tooltip.call(this, parentNode);
            }

            oop.inherits(GutterTooltip, Tooltip);

            (function () {
                this.setPosition = function (x, y) {
                    var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                    var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                    var width = this.getWidth();
                    var height = this.getHeight();
                    x += 15;
                    y += 15;
                    if (x + width > windowWidth) {
                        x -= x + width - windowWidth;
                    }
                    if (y + height > windowHeight) {
                        y -= 20 + height;
                    }
                    Tooltip.prototype.setPosition.call(this, x, y);
                };
            }).call(GutterTooltip.prototype);

            exports.GutterHandler = GutterHandler;
        });

        ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
                this.domEvent = domEvent;
                this.editor = editor;

                this.x = this.clientX = domEvent.clientX;
                this.y = this.clientY = domEvent.clientY;

                this.$pos = null;
                this.$inSelection = null;

                this.propagationStopped = false;
                this.defaultPrevented = false;
            };

            (function () {

                this.stopPropagation = function () {
                    event.stopPropagation(this.domEvent);
                    this.propagationStopped = true;
                };

                this.preventDefault = function () {
                    event.preventDefault(this.domEvent);
                    this.defaultPrevented = true;
                };

                this.stop = function () {
                    this.stopPropagation();
                    this.preventDefault();
                };
                this.getDocumentPosition = function () {
                    if (this.$pos) return this.$pos;

                    this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                    return this.$pos;
                };
                this.inSelection = function () {
                    if (this.$inSelection !== null) return this.$inSelection;

                    var editor = this.editor;

                    var selectionRange = editor.getSelectionRange();
                    if (selectionRange.isEmpty()) this.$inSelection = false;else {
                        var pos = this.getDocumentPosition();
                        this.$inSelection = selectionRange.contains(pos.row, pos.column);
                    }

                    return this.$inSelection;
                };
                this.getButton = function () {
                    return event.getButton(this.domEvent);
                };
                this.getShiftKey = function () {
                    return this.domEvent.shiftKey;
                };

                this.getAccelKey = useragent.isMac ? function () {
                    return this.domEvent.metaKey;
                } : function () {
                    return this.domEvent.ctrlKey;
                };
            }).call(MouseEvent.prototype);
        });

        ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var event = require("../lib/event");
            var useragent = require("../lib/useragent");

            var AUTOSCROLL_DELAY = 200;
            var SCROLL_CURSOR_DELAY = 200;
            var SCROLL_CURSOR_HYSTERESIS = 5;

            function DragdropHandler(mouseHandler) {

                var editor = mouseHandler.editor;

                var blankImage = dom.createElement("img");
                blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                if (useragent.isOpera) blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

                var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

                exports.forEach(function (x) {
                    mouseHandler[x] = this[x];
                }, this);
                editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));

                var mouseTarget = editor.container;
                var dragSelectionMarker, x, y;
                var timerId, range;
                var dragCursor,
                    counter = 0;
                var dragOperation;
                var isInternal;
                var autoScrollStartTime;
                var cursorMovedTime;
                var cursorPointOnCaretMoved;

                this.onDragStart = function (e) {
                    if (this.cancelDrag || !mouseTarget.draggable) {
                        var self = this;
                        setTimeout(function () {
                            self.startSelect();
                            self.captureMouse(e);
                        }, 0);
                        return e.preventDefault();
                    }
                    range = editor.getSelectionRange();

                    var dataTransfer = e.dataTransfer;
                    dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
                    if (useragent.isOpera) {
                        editor.container.appendChild(blankImage);
                        blankImage.scrollTop = 0;
                    }
                    dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
                    if (useragent.isOpera) {
                        editor.container.removeChild(blankImage);
                    }
                    dataTransfer.clearData();
                    dataTransfer.setData("Text", editor.session.getTextRange());

                    isInternal = true;
                    this.setState("drag");
                };

                this.onDragEnd = function (e) {
                    mouseTarget.draggable = false;
                    isInternal = false;
                    this.setState(null);
                    if (!editor.getReadOnly()) {
                        var dropEffect = e.dataTransfer.dropEffect;
                        if (!dragOperation && dropEffect == "move") editor.session.remove(editor.getSelectionRange());
                        editor.renderer.$cursorLayer.setBlinking(true);
                    }
                    this.editor.unsetStyle("ace_dragging");
                    this.editor.renderer.setCursorStyle("");
                };

                this.onDragEnter = function (e) {
                    if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                    x = e.clientX;
                    y = e.clientY;
                    if (!dragSelectionMarker) addDragMarker();
                    counter++;
                    e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                    return event.preventDefault(e);
                };

                this.onDragOver = function (e) {
                    if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
                    x = e.clientX;
                    y = e.clientY;
                    if (!dragSelectionMarker) {
                        addDragMarker();
                        counter++;
                    }
                    if (onMouseMoveTimer !== null) onMouseMoveTimer = null;

                    e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                    return event.preventDefault(e);
                };

                this.onDragLeave = function (e) {
                    counter--;
                    if (counter <= 0 && dragSelectionMarker) {
                        clearDragMarker();
                        dragOperation = null;
                        return event.preventDefault(e);
                    }
                };

                this.onDrop = function (e) {
                    if (!dragCursor) return;
                    var dataTransfer = e.dataTransfer;
                    if (isInternal) {
                        switch (dragOperation) {
                            case "move":
                                if (range.contains(dragCursor.row, dragCursor.column)) {
                                    range = {
                                        start: dragCursor,
                                        end: dragCursor
                                    };
                                } else {
                                    range = editor.moveText(range, dragCursor);
                                }
                                break;
                            case "copy":
                                range = editor.moveText(range, dragCursor, true);
                                break;
                        }
                    } else {
                        var dropData = dataTransfer.getData('Text');
                        range = {
                            start: dragCursor,
                            end: editor.session.insert(dragCursor, dropData)
                        };
                        editor.focus();
                        dragOperation = null;
                    }
                    clearDragMarker();
                    return event.preventDefault(e);
                };

                event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
                event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
                event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
                event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
                event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
                event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

                function scrollCursorIntoView(cursor, prevCursor) {
                    var now = Date.now();
                    var vMovement = !prevCursor || cursor.row != prevCursor.row;
                    var hMovement = !prevCursor || cursor.column != prevCursor.column;
                    if (!cursorMovedTime || vMovement || hMovement) {
                        editor.$blockScrolling += 1;
                        editor.moveCursorToPosition(cursor);
                        editor.$blockScrolling -= 1;
                        cursorMovedTime = now;
                        cursorPointOnCaretMoved = { x: x, y: y };
                    } else {
                        var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                        if (distance > SCROLL_CURSOR_HYSTERESIS) {
                            cursorMovedTime = null;
                        } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                            editor.renderer.scrollCursorIntoView();
                            cursorMovedTime = null;
                        }
                    }
                }

                function autoScroll(cursor, prevCursor) {
                    var now = Date.now();
                    var lineHeight = editor.renderer.layerConfig.lineHeight;
                    var characterWidth = editor.renderer.layerConfig.characterWidth;
                    var editorRect = editor.renderer.scroller.getBoundingClientRect();
                    var offsets = {
                        x: {
                            left: x - editorRect.left,
                            right: editorRect.right - x
                        },
                        y: {
                            top: y - editorRect.top,
                            bottom: editorRect.bottom - y
                        }
                    };
                    var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
                    var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
                    var scrollCursor = { row: cursor.row, column: cursor.column };
                    if (nearestXOffset / characterWidth <= 2) {
                        scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : +2;
                    }
                    if (nearestYOffset / lineHeight <= 1) {
                        scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : +1;
                    }
                    var vScroll = cursor.row != scrollCursor.row;
                    var hScroll = cursor.column != scrollCursor.column;
                    var vMovement = !prevCursor || cursor.row != prevCursor.row;
                    if (vScroll || hScroll && !vMovement) {
                        if (!autoScrollStartTime) autoScrollStartTime = now;else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY) editor.renderer.scrollCursorIntoView(scrollCursor);
                    } else {
                        autoScrollStartTime = null;
                    }
                }

                function onDragInterval() {
                    var prevCursor = dragCursor;
                    dragCursor = editor.renderer.screenToTextCoordinates(x, y);
                    scrollCursorIntoView(dragCursor, prevCursor);
                    autoScroll(dragCursor, prevCursor);
                }

                function addDragMarker() {
                    range = editor.selection.toOrientedRange();
                    dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
                    editor.clearSelection();
                    if (editor.isFocused()) editor.renderer.$cursorLayer.setBlinking(false);
                    clearInterval(timerId);
                    onDragInterval();
                    timerId = setInterval(onDragInterval, 20);
                    counter = 0;
                    event.addListener(document, "mousemove", onMouseMove);
                }

                function clearDragMarker() {
                    clearInterval(timerId);
                    editor.session.removeMarker(dragSelectionMarker);
                    dragSelectionMarker = null;
                    editor.$blockScrolling += 1;
                    editor.selection.fromOrientedRange(range);
                    editor.$blockScrolling -= 1;
                    if (editor.isFocused() && !isInternal) editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
                    range = null;
                    dragCursor = null;
                    counter = 0;
                    autoScrollStartTime = null;
                    cursorMovedTime = null;
                    event.removeListener(document, "mousemove", onMouseMove);
                }
                var onMouseMoveTimer = null;
                function onMouseMove() {
                    if (onMouseMoveTimer == null) {
                        onMouseMoveTimer = setTimeout(function () {
                            if (onMouseMoveTimer != null && dragSelectionMarker) clearDragMarker();
                        }, 20);
                    }
                }

                function canAccept(dataTransfer) {
                    var types = dataTransfer.types;
                    return !types || Array.prototype.some.call(types, function (type) {
                        return type == 'text/plain' || type == 'Text';
                    });
                }

                function getDropEffect(e) {
                    var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
                    var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

                    var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
                    var effectAllowed = "uninitialized";
                    try {
                        effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
                    } catch (e) {}
                    var dropEffect = "none";

                    if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";else if (moveAllowed.indexOf(effectAllowed) >= 0) dropEffect = "move";else if (copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";

                    return dropEffect;
                }
            }

            (function () {

                this.dragWait = function () {
                    var interval = Date.now() - this.mousedownEvent.time;
                    if (interval > this.editor.getDragDelay()) this.startDrag();
                };

                this.dragWaitEnd = function () {
                    var target = this.editor.container;
                    target.draggable = false;
                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                    this.selectEnd();
                };

                this.dragReadyEnd = function (e) {
                    this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
                    this.editor.unsetStyle("ace_dragging");
                    this.editor.renderer.setCursorStyle("");
                    this.dragWaitEnd();
                };

                this.startDrag = function () {
                    this.cancelDrag = false;
                    var editor = this.editor;
                    var target = editor.container;
                    target.draggable = true;
                    editor.renderer.$cursorLayer.setBlinking(false);
                    editor.setStyle("ace_dragging");
                    var cursorStyle = useragent.isWin ? "default" : "move";
                    editor.renderer.setCursorStyle(cursorStyle);
                    this.setState("dragReady");
                };

                this.onMouseDrag = function (e) {
                    var target = this.editor.container;
                    if (useragent.isIE && this.state == "dragReady") {
                        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                        if (distance > 3) target.dragDrop();
                    }
                    if (this.state === "dragWait") {
                        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                        if (distance > 0) {
                            target.draggable = false;
                            this.startSelect(this.mousedownEvent.getDocumentPosition());
                        }
                    }
                };

                this.onMouseDown = function (e) {
                    if (!this.$dragEnabled) return;
                    this.mousedownEvent = e;
                    var editor = this.editor;

                    var inSelection = e.inSelection();
                    var button = e.getButton();
                    var clickCount = e.domEvent.detail || 1;
                    if (clickCount === 1 && button === 0 && inSelection) {
                        if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
                        this.mousedownEvent.time = Date.now();
                        var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                        if ("unselectable" in eventTarget) eventTarget.unselectable = "on";
                        if (editor.getDragDelay()) {
                            if (useragent.isWebKit) {
                                this.cancelDrag = true;
                                var mouseTarget = editor.container;
                                mouseTarget.draggable = true;
                            }
                            this.setState("dragWait");
                        } else {
                            this.startDrag();
                        }
                        this.captureMouse(e, this.onMouseDrag.bind(this));
                        e.defaultPrevented = true;
                    }
                };
            }).call(DragdropHandler.prototype);

            function calcDistance(ax, ay, bx, by) {
                return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
            }

            exports.DragdropHandler = DragdropHandler;
        });

        ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var dom = require("./dom");

            exports.get = function (url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        callback(xhr.responseText);
                    }
                };
                xhr.send(null);
            };

            exports.loadScript = function (path, callback) {
                var head = dom.getDocumentHead();
                var s = document.createElement('script');

                s.src = path;
                head.appendChild(s);

                s.onload = s.onreadystatechange = function (_, isAbort) {
                    if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                        s = s.onload = s.onreadystatechange = null;
                        if (!isAbort) callback();
                    }
                };
            };
            exports.qualifyURL = function (url) {
                var a = document.createElement('a');
                a.href = url;
                return a.href;
            };
        });

        ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var EventEmitter = {};
            var stopPropagation = function () {
                this.propagationStopped = true;
            };
            var preventDefault = function () {
                this.defaultPrevented = true;
            };

            EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
                this._eventRegistry || (this._eventRegistry = {});
                this._defaultHandlers || (this._defaultHandlers = {});

                var listeners = this._eventRegistry[eventName] || [];
                var defaultHandler = this._defaultHandlers[eventName];
                if (!listeners.length && !defaultHandler) return;

                if (typeof e != "object" || !e) e = {};

                if (!e.type) e.type = eventName;
                if (!e.stopPropagation) e.stopPropagation = stopPropagation;
                if (!e.preventDefault) e.preventDefault = preventDefault;

                listeners = listeners.slice();
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i](e, this);
                    if (e.propagationStopped) break;
                }

                if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
            };

            EventEmitter._signal = function (eventName, e) {
                var listeners = (this._eventRegistry || {})[eventName];
                if (!listeners) return;
                listeners = listeners.slice();
                for (var i = 0; i < listeners.length; i++) listeners[i](e, this);
            };

            EventEmitter.once = function (eventName, callback) {
                var _self = this;
                callback && this.addEventListener(eventName, function newCallback() {
                    _self.removeEventListener(eventName, newCallback);
                    callback.apply(null, arguments);
                });
            };

            EventEmitter.setDefaultHandler = function (eventName, callback) {
                var handlers = this._defaultHandlers;
                if (!handlers) handlers = this._defaultHandlers = { _disabled_: {} };

                if (handlers[eventName]) {
                    var old = handlers[eventName];
                    var disabled = handlers._disabled_[eventName];
                    if (!disabled) handlers._disabled_[eventName] = disabled = [];
                    disabled.push(old);
                    var i = disabled.indexOf(callback);
                    if (i != -1) disabled.splice(i, 1);
                }
                handlers[eventName] = callback;
            };
            EventEmitter.removeDefaultHandler = function (eventName, callback) {
                var handlers = this._defaultHandlers;
                if (!handlers) return;
                var disabled = handlers._disabled_[eventName];

                if (handlers[eventName] == callback) {
                    var old = handlers[eventName];
                    if (disabled) this.setDefaultHandler(eventName, disabled.pop());
                } else if (disabled) {
                    var i = disabled.indexOf(callback);
                    if (i != -1) disabled.splice(i, 1);
                }
            };

            EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
                this._eventRegistry = this._eventRegistry || {};

                var listeners = this._eventRegistry[eventName];
                if (!listeners) listeners = this._eventRegistry[eventName] = [];

                if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
                return callback;
            };

            EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
                this._eventRegistry = this._eventRegistry || {};

                var listeners = this._eventRegistry[eventName];
                if (!listeners) return;

                var index = listeners.indexOf(callback);
                if (index !== -1) listeners.splice(index, 1);
            };

            EventEmitter.removeAllListeners = function (eventName) {
                if (this._eventRegistry) this._eventRegistry[eventName] = [];
            };

            exports.EventEmitter = EventEmitter;
        });

        ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "no use strict";

            var oop = require("./oop");
            var EventEmitter = require("./event_emitter").EventEmitter;

            var optionsProvider = {
                setOptions: function (optList) {
                    Object.keys(optList).forEach(function (key) {
                        this.setOption(key, optList[key]);
                    }, this);
                },
                getOptions: function (optionNames) {
                    var result = {};
                    if (!optionNames) {
                        optionNames = Object.keys(this.$options);
                    } else if (!Array.isArray(optionNames)) {
                        result = optionNames;
                        optionNames = Object.keys(result);
                    }
                    optionNames.forEach(function (key) {
                        result[key] = this.getOption(key);
                    }, this);
                    return result;
                },
                setOption: function (name, value) {
                    if (this["$" + name] === value) return;
                    var opt = this.$options[name];
                    if (!opt) {
                        return warn('misspelled option "' + name + '"');
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

                    if (!opt.handlesSet) this["$" + name] = value;
                    if (opt && opt.set) opt.set.call(this, value);
                },
                getOption: function (name) {
                    var opt = this.$options[name];
                    if (!opt) {
                        return warn('misspelled option "' + name + '"');
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                    return opt && opt.get ? opt.get.call(this) : this["$" + name];
                }
            };

            function warn(message) {
                if (typeof console != "undefined" && console.warn) console.warn.apply(console, arguments);
            }

            function reportError(msg, data) {
                var e = new Error(msg);
                e.data = data;
                if (typeof console == "object" && console.error) console.error(e);
                setTimeout(function () {
                    throw e;
                });
            }

            var AppConfig = function () {
                this.$defaultOptions = {};
            };

            (function () {
                oop.implement(this, EventEmitter);
                this.defineOptions = function (obj, path, options) {
                    if (!obj.$options) this.$defaultOptions[path] = obj.$options = {};

                    Object.keys(options).forEach(function (key) {
                        var opt = options[key];
                        if (typeof opt == "string") opt = { forwardTo: opt };

                        opt.name || (opt.name = key);
                        obj.$options[opt.name] = opt;
                        if ("initialValue" in opt) obj["$" + opt.name] = opt.initialValue;
                    });
                    oop.implement(obj, optionsProvider);

                    return this;
                };

                this.resetOptions = function (obj) {
                    Object.keys(obj.$options).forEach(function (key) {
                        var opt = obj.$options[key];
                        if ("value" in opt) obj.setOption(key, opt.value);
                    });
                };

                this.setDefaultValue = function (path, name, value) {
                    var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                    if (opts[name]) {
                        if (opts.forwardTo) this.setDefaultValue(opts.forwardTo, name, value);else opts[name].value = value;
                    }
                };

                this.setDefaultValues = function (path, optionHash) {
                    Object.keys(optionHash).forEach(function (key) {
                        this.setDefaultValue(path, key, optionHash[key]);
                    }, this);
                };

                this.warn = warn;
                this.reportError = reportError;
            }).call(AppConfig.prototype);

            exports.AppConfig = AppConfig;
        });

        ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function (require, exports, module) {
            "no use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var net = require("./lib/net");
            var AppConfig = require("./lib/app_config").AppConfig;

            module.exports = exports = new AppConfig();

            var global = function () {
                return this || typeof window != "undefined" && window;
            }();

            var options = {
                packaged: false,
                workerPath: null,
                modePath: null,
                themePath: null,
                basePath: "",
                suffix: ".js",
                $moduleUrls: {}
            };

            exports.get = function (key) {
                if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);

                return options[key];
            };

            exports.set = function (key, value) {
                if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);

                options[key] = value;
            };

            exports.all = function () {
                return lang.copyObject(options);
            };
            exports.moduleUrl = function (name, component) {
                if (options.$moduleUrls[name]) return options.$moduleUrls[name];

                var parts = name.split("/");
                component = component || parts[parts.length - 2] || "";
                var sep = component == "snippets" ? "/" : "-";
                var base = parts[parts.length - 1];
                if (component == "worker" && sep == "-") {
                    var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
                    base = base.replace(re, "");
                }

                if ((!base || base == component) && parts.length > 1) base = parts[parts.length - 2];
                var path = options[component + "Path"];
                if (path == null) {
                    path = options.basePath;
                } else if (sep == "/") {
                    component = sep = "";
                }
                if (path && path.slice(-1) != "/") path += "/";
                return path + component + sep + base + this.get("suffix");
            };

            exports.setModuleUrl = function (name, subst) {
                return options.$moduleUrls[name] = subst;
            };

            exports.$loading = {};
            exports.loadModule = function (moduleName, onLoad) {
                var module, moduleType;
                if (Array.isArray(moduleName)) {
                    moduleType = moduleName[0];
                    moduleName = moduleName[1];
                }

                try {
                    module = require(moduleName);
                } catch (e) {}
                if (module && !exports.$loading[moduleName]) return onLoad && onLoad(module);

                if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];

                exports.$loading[moduleName].push(onLoad);

                if (exports.$loading[moduleName].length > 1) return;

                var afterLoad = function () {
                    require([moduleName], function (module) {
                        exports._emit("load.module", { name: moduleName, module: module });
                        var listeners = exports.$loading[moduleName];
                        exports.$loading[moduleName] = null;
                        listeners.forEach(function (onLoad) {
                            onLoad && onLoad(module);
                        });
                    });
                };

                if (!exports.get("packaged")) return afterLoad();
                net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
            };
            init(true);function init(packaged) {

                if (!global || !global.document) return;

                options.packaged = packaged || require.packaged || module.packaged || global.define && define.packaged;

                var scriptOptions = {};
                var scriptUrl = "";
                var currentScript = document.currentScript || document._currentScript; // native or polyfill
                var currentDocument = currentScript && currentScript.ownerDocument || document;

                var scripts = currentDocument.getElementsByTagName("script");
                for (var i = 0; i < scripts.length; i++) {
                    var script = scripts[i];

                    var src = script.src || script.getAttribute("src");
                    if (!src) continue;

                    var attributes = script.attributes;
                    for (var j = 0, l = attributes.length; j < l; j++) {
                        var attr = attributes[j];
                        if (attr.name.indexOf("data-ace-") === 0) {
                            scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                        }
                    }

                    var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
                    if (m) scriptUrl = m[1];
                }

                if (scriptUrl) {
                    scriptOptions.base = scriptOptions.base || scriptUrl;
                    scriptOptions.packaged = true;
                }

                scriptOptions.basePath = scriptOptions.base;
                scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
                scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
                scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
                delete scriptOptions.base;

                for (var key in scriptOptions) if (typeof scriptOptions[key] !== "undefined") exports.set(key, scriptOptions[key]);
            }

            exports.init = init;

            function deHyphenate(str) {
                return str.replace(/-(.)/g, function (m, m1) {
                    return m1.toUpperCase();
                });
            }
        });

        ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function (require, exports, module) {
            "use strict";

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            var DefaultHandlers = require("./default_handlers").DefaultHandlers;
            var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
            var MouseEvent = require("./mouse_event").MouseEvent;
            var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
            var config = require("../config");

            var MouseHandler = function (editor) {
                var _self = this;
                this.editor = editor;

                new DefaultHandlers(this);
                new DefaultGutterHandler(this);
                new DragdropHandler(this);

                var focusEditor = function (e) {
                    var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
                    if (windowBlurred) window.focus();
                    editor.focus();
                };

                var mouseTarget = editor.renderer.getMouseEventTarget();
                event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
                event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
                event.addMultiMouseDownListener([mouseTarget, editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner, editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner, editor.textInput && editor.textInput.getElement()].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
                event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
                event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

                var gutterEl = editor.renderer.$gutter;
                event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
                event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
                event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
                event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

                event.addListener(mouseTarget, "mousedown", focusEditor);
                event.addListener(gutterEl, "mousedown", focusEditor);
                if (useragent.isIE && editor.renderer.scrollBarV) {
                    event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
                    event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
                }

                editor.on("mousemove", function (e) {
                    if (_self.state || _self.$dragDelay || !_self.$dragEnabled) return;

                    var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                    var range = editor.session.selection.getRange();
                    var renderer = editor.renderer;

                    if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                        renderer.setCursorStyle("default");
                    } else {
                        renderer.setCursorStyle("");
                    }
                });
            };

            (function () {
                this.onMouseEvent = function (name, e) {
                    this.editor._emit(name, new MouseEvent(e, this.editor));
                };

                this.onMouseMove = function (name, e) {
                    var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
                    if (!listeners || !listeners.length) return;

                    this.editor._emit(name, new MouseEvent(e, this.editor));
                };

                this.onMouseWheel = function (name, e) {
                    var mouseEvent = new MouseEvent(e, this.editor);
                    mouseEvent.speed = this.$scrollSpeed * 2;
                    mouseEvent.wheelX = e.wheelX;
                    mouseEvent.wheelY = e.wheelY;

                    this.editor._emit(name, mouseEvent);
                };

                this.onTouchMove = function (name, e) {
                    var mouseEvent = new MouseEvent(e, this.editor);
                    mouseEvent.speed = 1; //this.$scrollSpeed * 2;
                    mouseEvent.wheelX = e.wheelX;
                    mouseEvent.wheelY = e.wheelY;
                    this.editor._emit(name, mouseEvent);
                };

                this.setState = function (state) {
                    this.state = state;
                };

                this.captureMouse = function (ev, mouseMoveHandler) {
                    this.x = ev.x;
                    this.y = ev.y;

                    this.isMousePressed = true;
                    var renderer = this.editor.renderer;
                    if (renderer.$keepTextAreaAtCursor) renderer.$keepTextAreaAtCursor = null;

                    var self = this;
                    var onMouseMove = function (e) {
                        if (!e) return;
                        if (useragent.isWebKit && !e.which && self.releaseMouse) return self.releaseMouse();

                        self.x = e.clientX;
                        self.y = e.clientY;
                        mouseMoveHandler && mouseMoveHandler(e);
                        self.mouseEvent = new MouseEvent(e, self.editor);
                        self.$mouseMoved = true;
                    };

                    var onCaptureEnd = function (e) {
                        clearInterval(timerId);
                        onCaptureInterval();
                        self[self.state + "End"] && self[self.state + "End"](e);
                        self.state = "";
                        if (renderer.$keepTextAreaAtCursor == null) {
                            renderer.$keepTextAreaAtCursor = true;
                            renderer.$moveTextAreaToCursor();
                        }
                        self.isMousePressed = false;
                        self.$onCaptureMouseMove = self.releaseMouse = null;
                        e && self.onMouseEvent("mouseup", e);
                    };

                    var onCaptureInterval = function () {
                        self[self.state] && self[self.state]();
                        self.$mouseMoved = false;
                    };

                    if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                        return setTimeout(function () {
                            onCaptureEnd(ev);
                        });
                    }

                    self.$onCaptureMouseMove = onMouseMove;
                    self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                    var timerId = setInterval(onCaptureInterval, 20);
                };
                this.releaseMouse = null;
                this.cancelContextMenu = function () {
                    var stop = function (e) {
                        if (e && e.domEvent && e.domEvent.type != "contextmenu") return;
                        this.editor.off("nativecontextmenu", stop);
                        if (e && e.domEvent) event.stopEvent(e.domEvent);
                    }.bind(this);
                    setTimeout(stop, 10);
                    this.editor.on("nativecontextmenu", stop);
                };
            }).call(MouseHandler.prototype);

            config.defineOptions(MouseHandler.prototype, "mouseHandler", {
                scrollSpeed: { initialValue: 2 },
                dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
                dragEnabled: { initialValue: true },
                focusTimout: { initialValue: 0 },
                tooltipFollowsMouse: { initialValue: true }
            });

            exports.MouseHandler = MouseHandler;
        });

        ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            function FoldHandler(editor) {

                editor.on("click", function (e) {
                    var position = e.getDocumentPosition();
                    var session = editor.session;
                    var fold = session.getFoldAt(position.row, position.column, 1);
                    if (fold) {
                        if (e.getAccelKey()) session.removeFold(fold);else session.expandFold(fold);

                        e.stop();
                    }
                });

                editor.on("gutterclick", function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

                    if (gutterRegion == "foldWidgets") {
                        var row = e.getDocumentPosition().row;
                        var session = editor.session;
                        if (session.foldWidgets && session.foldWidgets[row]) editor.session.onFoldWidgetClick(row, e);
                        if (!editor.isFocused()) editor.focus();
                        e.stop();
                    }
                });

                editor.on("gutterdblclick", function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

                    if (gutterRegion == "foldWidgets") {
                        var row = e.getDocumentPosition().row;
                        var session = editor.session;
                        var data = session.getParentFoldRangeData(row, true);
                        var range = data.range || data.firstRange;

                        if (range) {
                            row = range.start.row;
                            var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                            if (fold) {
                                session.removeFold(fold);
                            } else {
                                session.addFold("...", range);
                                editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                            }
                        }
                        e.stop();
                    }
                });
            }

            exports.FoldHandler = FoldHandler;
        });

        ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function (require, exports, module) {
            "use strict";

            var keyUtil = require("../lib/keys");
            var event = require("../lib/event");

            var KeyBinding = function (editor) {
                this.$editor = editor;
                this.$data = { editor: editor };
                this.$handlers = [];
                this.setDefaultHandler(editor.commands);
            };

            (function () {
                this.setDefaultHandler = function (kb) {
                    this.removeKeyboardHandler(this.$defaultHandler);
                    this.$defaultHandler = kb;
                    this.addKeyboardHandler(kb, 0);
                };

                this.setKeyboardHandler = function (kb) {
                    var h = this.$handlers;
                    if (h[h.length - 1] == kb) return;

                    while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler) this.removeKeyboardHandler(h[h.length - 1]);

                    this.addKeyboardHandler(kb, 1);
                };

                this.addKeyboardHandler = function (kb, pos) {
                    if (!kb) return;
                    if (typeof kb == "function" && !kb.handleKeyboard) kb.handleKeyboard = kb;
                    var i = this.$handlers.indexOf(kb);
                    if (i != -1) this.$handlers.splice(i, 1);

                    if (pos == undefined) this.$handlers.push(kb);else this.$handlers.splice(pos, 0, kb);

                    if (i == -1 && kb.attach) kb.attach(this.$editor);
                };

                this.removeKeyboardHandler = function (kb) {
                    var i = this.$handlers.indexOf(kb);
                    if (i == -1) return false;
                    this.$handlers.splice(i, 1);
                    kb.detach && kb.detach(this.$editor);
                    return true;
                };

                this.getKeyboardHandler = function () {
                    return this.$handlers[this.$handlers.length - 1];
                };

                this.getStatusText = function () {
                    var data = this.$data;
                    var editor = data.editor;
                    return this.$handlers.map(function (h) {
                        return h.getStatusText && h.getStatusText(editor, data) || "";
                    }).filter(Boolean).join(" ");
                };

                this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
                    var toExecute;
                    var success = false;
                    var commands = this.$editor.commands;

                    for (var i = this.$handlers.length; i--;) {
                        toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                        if (!toExecute || !toExecute.command) continue;
                        if (toExecute.command == "null") {
                            success = true;
                        } else {
                            success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                        }
                        if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                            event.stopEvent(e);
                        }
                        if (success) break;
                    }

                    if (!success && hashId == -1) {
                        toExecute = { command: "insertstring" };
                        success = commands.exec("insertstring", this.$editor, keyString);
                    }

                    if (success && this.$editor._signal) this.$editor._signal("keyboardActivity", toExecute);

                    return success;
                };

                this.onCommandKey = function (e, hashId, keyCode) {
                    var keyString = keyUtil.keyCodeToString(keyCode);
                    this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                };

                this.onTextInput = function (text) {
                    this.$callKeyboardHandlers(-1, text);
                };
            }).call(KeyBinding.prototype);

            exports.KeyBinding = KeyBinding;
        });

        ace.define("ace/range", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var comparePoints = function (p1, p2) {
                return p1.row - p2.row || p1.column - p2.column;
            };
            var Range = function (startRow, startColumn, endRow, endColumn) {
                this.start = {
                    row: startRow,
                    column: startColumn
                };

                this.end = {
                    row: endRow,
                    column: endColumn
                };
            };

            (function () {
                this.isEqual = function (range) {
                    return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
                };
                this.toString = function () {
                    return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
                };

                this.contains = function (row, column) {
                    return this.compare(row, column) == 0;
                };
                this.compareRange = function (range) {
                    var cmp,
                        end = range.end,
                        start = range.start;

                    cmp = this.compare(end.row, end.column);
                    if (cmp == 1) {
                        cmp = this.compare(start.row, start.column);
                        if (cmp == 1) {
                            return 2;
                        } else if (cmp == 0) {
                            return 1;
                        } else {
                            return 0;
                        }
                    } else if (cmp == -1) {
                        return -2;
                    } else {
                        cmp = this.compare(start.row, start.column);
                        if (cmp == -1) {
                            return -1;
                        } else if (cmp == 1) {
                            return 42;
                        } else {
                            return 0;
                        }
                    }
                };
                this.comparePoint = function (p) {
                    return this.compare(p.row, p.column);
                };
                this.containsRange = function (range) {
                    return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
                };
                this.intersects = function (range) {
                    var cmp = this.compareRange(range);
                    return cmp == -1 || cmp == 0 || cmp == 1;
                };
                this.isEnd = function (row, column) {
                    return this.end.row == row && this.end.column == column;
                };
                this.isStart = function (row, column) {
                    return this.start.row == row && this.start.column == column;
                };
                this.setStart = function (row, column) {
                    if (typeof row == "object") {
                        this.start.column = row.column;
                        this.start.row = row.row;
                    } else {
                        this.start.row = row;
                        this.start.column = column;
                    }
                };
                this.setEnd = function (row, column) {
                    if (typeof row == "object") {
                        this.end.column = row.column;
                        this.end.row = row.row;
                    } else {
                        this.end.row = row;
                        this.end.column = column;
                    }
                };
                this.inside = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isEnd(row, column) || this.isStart(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.insideStart = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isEnd(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.insideEnd = function (row, column) {
                    if (this.compare(row, column) == 0) {
                        if (this.isStart(row, column)) {
                            return false;
                        } else {
                            return true;
                        }
                    }
                    return false;
                };
                this.compare = function (row, column) {
                    if (!this.isMultiLine()) {
                        if (row === this.start.row) {
                            return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
                        }
                    }

                    if (row < this.start.row) return -1;

                    if (row > this.end.row) return 1;

                    if (this.start.row === row) return column >= this.start.column ? 0 : -1;

                    if (this.end.row === row) return column <= this.end.column ? 0 : 1;

                    return 0;
                };
                this.compareStart = function (row, column) {
                    if (this.start.row == row && this.start.column == column) {
                        return -1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.compareEnd = function (row, column) {
                    if (this.end.row == row && this.end.column == column) {
                        return 1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.compareInside = function (row, column) {
                    if (this.end.row == row && this.end.column == column) {
                        return 1;
                    } else if (this.start.row == row && this.start.column == column) {
                        return -1;
                    } else {
                        return this.compare(row, column);
                    }
                };
                this.clipRows = function (firstRow, lastRow) {
                    if (this.end.row > lastRow) var end = { row: lastRow + 1, column: 0 };else if (this.end.row < firstRow) var end = { row: firstRow, column: 0 };

                    if (this.start.row > lastRow) var start = { row: lastRow + 1, column: 0 };else if (this.start.row < firstRow) var start = { row: firstRow, column: 0 };

                    return Range.fromPoints(start || this.start, end || this.end);
                };
                this.extend = function (row, column) {
                    var cmp = this.compare(row, column);

                    if (cmp == 0) return this;else if (cmp == -1) var start = { row: row, column: column };else var end = { row: row, column: column };

                    return Range.fromPoints(start || this.start, end || this.end);
                };

                this.isEmpty = function () {
                    return this.start.row === this.end.row && this.start.column === this.end.column;
                };
                this.isMultiLine = function () {
                    return this.start.row !== this.end.row;
                };
                this.clone = function () {
                    return Range.fromPoints(this.start, this.end);
                };
                this.collapseRows = function () {
                    if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
                };
                this.toScreenRange = function (session) {
                    var screenPosStart = session.documentToScreenPosition(this.start);
                    var screenPosEnd = session.documentToScreenPosition(this.end);

                    return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
                };
                this.moveBy = function (row, column) {
                    this.start.row += row;
                    this.start.column += column;
                    this.end.row += row;
                    this.end.column += column;
                };
            }).call(Range.prototype);
            Range.fromPoints = function (start, end) {
                return new Range(start.row, start.column, end.row, end.column);
            };
            Range.comparePoints = comparePoints;

            Range.comparePoints = function (p1, p2) {
                return p1.row - p2.row || p1.column - p2.column;
            };

            exports.Range = Range;
        });

        ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var lang = require("./lib/lang");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Range = require("./range").Range;
            var Selection = function (session) {
                this.session = session;
                this.doc = session.getDocument();

                this.clearSelection();
                this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
                this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

                var self = this;
                this.lead.on("change", function (e) {
                    self._emit("changeCursor");
                    if (!self.$isEmpty) self._emit("changeSelection");
                    if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column) self.$desiredColumn = null;
                });

                this.selectionAnchor.on("change", function () {
                    if (!self.$isEmpty) self._emit("changeSelection");
                });
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.isEmpty = function () {
                    return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
                };
                this.isMultiLine = function () {
                    if (this.isEmpty()) {
                        return false;
                    }

                    return this.getRange().isMultiLine();
                };
                this.getCursor = function () {
                    return this.lead.getPosition();
                };
                this.setSelectionAnchor = function (row, column) {
                    this.anchor.setPosition(row, column);

                    if (this.$isEmpty) {
                        this.$isEmpty = false;
                        this._emit("changeSelection");
                    }
                };
                this.getSelectionAnchor = function () {
                    if (this.$isEmpty) return this.getSelectionLead();else return this.anchor.getPosition();
                };
                this.getSelectionLead = function () {
                    return this.lead.getPosition();
                };
                this.shiftSelection = function (columns) {
                    if (this.$isEmpty) {
                        this.moveCursorTo(this.lead.row, this.lead.column + columns);
                        return;
                    }

                    var anchor = this.getSelectionAnchor();
                    var lead = this.getSelectionLead();

                    var isBackwards = this.isBackwards();

                    if (!isBackwards || anchor.column !== 0) this.setSelectionAnchor(anchor.row, anchor.column + columns);

                    if (isBackwards || lead.column !== 0) {
                        this.$moveSelection(function () {
                            this.moveCursorTo(lead.row, lead.column + columns);
                        });
                    }
                };
                this.isBackwards = function () {
                    var anchor = this.anchor;
                    var lead = this.lead;
                    return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
                };
                this.getRange = function () {
                    var anchor = this.anchor;
                    var lead = this.lead;

                    if (this.isEmpty()) return Range.fromPoints(lead, lead);

                    if (this.isBackwards()) {
                        return Range.fromPoints(lead, anchor);
                    } else {
                        return Range.fromPoints(anchor, lead);
                    }
                };
                this.clearSelection = function () {
                    if (!this.$isEmpty) {
                        this.$isEmpty = true;
                        this._emit("changeSelection");
                    }
                };
                this.selectAll = function () {
                    var lastRow = this.doc.getLength() - 1;
                    this.setSelectionAnchor(0, 0);
                    this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
                };
                this.setRange = this.setSelectionRange = function (range, reverse) {
                    if (reverse) {
                        this.setSelectionAnchor(range.end.row, range.end.column);
                        this.selectTo(range.start.row, range.start.column);
                    } else {
                        this.setSelectionAnchor(range.start.row, range.start.column);
                        this.selectTo(range.end.row, range.end.column);
                    }
                    if (this.getRange().isEmpty()) this.$isEmpty = true;
                    this.$desiredColumn = null;
                };

                this.$moveSelection = function (mover) {
                    var lead = this.lead;
                    if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);

                    mover.call(this);
                };
                this.selectTo = function (row, column) {
                    this.$moveSelection(function () {
                        this.moveCursorTo(row, column);
                    });
                };
                this.selectToPosition = function (pos) {
                    this.$moveSelection(function () {
                        this.moveCursorToPosition(pos);
                    });
                };
                this.moveTo = function (row, column) {
                    this.clearSelection();
                    this.moveCursorTo(row, column);
                };
                this.moveToPosition = function (pos) {
                    this.clearSelection();
                    this.moveCursorToPosition(pos);
                };
                this.selectUp = function () {
                    this.$moveSelection(this.moveCursorUp);
                };
                this.selectDown = function () {
                    this.$moveSelection(this.moveCursorDown);
                };
                this.selectRight = function () {
                    this.$moveSelection(this.moveCursorRight);
                };
                this.selectLeft = function () {
                    this.$moveSelection(this.moveCursorLeft);
                };
                this.selectLineStart = function () {
                    this.$moveSelection(this.moveCursorLineStart);
                };
                this.selectLineEnd = function () {
                    this.$moveSelection(this.moveCursorLineEnd);
                };
                this.selectFileEnd = function () {
                    this.$moveSelection(this.moveCursorFileEnd);
                };
                this.selectFileStart = function () {
                    this.$moveSelection(this.moveCursorFileStart);
                };
                this.selectWordRight = function () {
                    this.$moveSelection(this.moveCursorWordRight);
                };
                this.selectWordLeft = function () {
                    this.$moveSelection(this.moveCursorWordLeft);
                };
                this.getWordRange = function (row, column) {
                    if (typeof column == "undefined") {
                        var cursor = row || this.lead;
                        row = cursor.row;
                        column = cursor.column;
                    }
                    return this.session.getWordRange(row, column);
                };
                this.selectWord = function () {
                    this.setSelectionRange(this.getWordRange());
                };
                this.selectAWord = function () {
                    var cursor = this.getCursor();
                    var range = this.session.getAWordRange(cursor.row, cursor.column);
                    this.setSelectionRange(range);
                };

                this.getLineRange = function (row, excludeLastChar) {
                    var rowStart = typeof row == "number" ? row : this.lead.row;
                    var rowEnd;

                    var foldLine = this.session.getFoldLine(rowStart);
                    if (foldLine) {
                        rowStart = foldLine.start.row;
                        rowEnd = foldLine.end.row;
                    } else {
                        rowEnd = rowStart;
                    }
                    if (excludeLastChar === true) return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);else return new Range(rowStart, 0, rowEnd + 1, 0);
                };
                this.selectLine = function () {
                    this.setSelectionRange(this.getLineRange());
                };
                this.moveCursorUp = function () {
                    this.moveCursorBy(-1, 0);
                };
                this.moveCursorDown = function () {
                    this.moveCursorBy(1, 0);
                };
                this.moveCursorLeft = function () {
                    var cursor = this.lead.getPosition(),
                        fold;

                    if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                        this.moveCursorTo(fold.start.row, fold.start.column);
                    } else if (cursor.column === 0) {
                        if (cursor.row > 0) {
                            this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                        }
                    } else {
                        var tabSize = this.session.getTabSize();
                        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 == tabSize) this.moveCursorBy(0, -tabSize);else this.moveCursorBy(0, -1);
                    }
                };
                this.moveCursorRight = function () {
                    var cursor = this.lead.getPosition(),
                        fold;
                    if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                        this.moveCursorTo(fold.end.row, fold.end.column);
                    } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                        if (this.lead.row < this.doc.getLength() - 1) {
                            this.moveCursorTo(this.lead.row + 1, 0);
                        }
                    } else {
                        var tabSize = this.session.getTabSize();
                        var cursor = this.lead;
                        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 == tabSize) this.moveCursorBy(0, tabSize);else this.moveCursorBy(0, 1);
                    }
                };
                this.moveCursorLineStart = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var screenRow = this.session.documentToScreenRow(row, column);
                    var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
                    var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);

                    var leadingSpace = beforeCursor.match(/^\s*/);
                    if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart) firstColumnPosition.column += leadingSpace[0].length;
                    this.moveCursorToPosition(firstColumnPosition);
                };
                this.moveCursorLineEnd = function () {
                    var lead = this.lead;
                    var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
                    if (this.lead.column == lineEnd.column) {
                        var line = this.session.getLine(lineEnd.row);
                        if (lineEnd.column == line.length) {
                            var textEnd = line.search(/\s+$/);
                            if (textEnd > 0) lineEnd.column = textEnd;
                        }
                    }

                    this.moveCursorTo(lineEnd.row, lineEnd.column);
                };
                this.moveCursorFileEnd = function () {
                    var row = this.doc.getLength() - 1;
                    var column = this.doc.getLine(row).length;
                    this.moveCursorTo(row, column);
                };
                this.moveCursorFileStart = function () {
                    this.moveCursorTo(0, 0);
                };
                this.moveCursorLongWordRight = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var line = this.doc.getLine(row);
                    var rightOfCursor = line.substring(column);

                    var match;
                    this.session.nonTokenRe.lastIndex = 0;
                    this.session.tokenRe.lastIndex = 0;
                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) {
                        this.moveCursorTo(fold.end.row, fold.end.column);
                        return;
                    }
                    if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
                        column += this.session.nonTokenRe.lastIndex;
                        this.session.nonTokenRe.lastIndex = 0;
                        rightOfCursor = line.substring(column);
                    }
                    if (column >= line.length) {
                        this.moveCursorTo(row, line.length);
                        this.moveCursorRight();
                        if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
                        return;
                    }
                    if (match = this.session.tokenRe.exec(rightOfCursor)) {
                        column += this.session.tokenRe.lastIndex;
                        this.session.tokenRe.lastIndex = 0;
                    }

                    this.moveCursorTo(row, column);
                };
                this.moveCursorLongWordLeft = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var fold;
                    if (fold = this.session.getFoldAt(row, column, -1)) {
                        this.moveCursorTo(fold.start.row, fold.start.column);
                        return;
                    }

                    var str = this.session.getFoldStringAt(row, column, -1);
                    if (str == null) {
                        str = this.doc.getLine(row).substring(0, column);
                    }

                    var leftOfCursor = lang.stringReverse(str);
                    var match;
                    this.session.nonTokenRe.lastIndex = 0;
                    this.session.tokenRe.lastIndex = 0;
                    if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
                        column -= this.session.nonTokenRe.lastIndex;
                        leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                        this.session.nonTokenRe.lastIndex = 0;
                    }
                    if (column <= 0) {
                        this.moveCursorTo(row, 0);
                        this.moveCursorLeft();
                        if (row > 0) this.moveCursorWordLeft();
                        return;
                    }
                    if (match = this.session.tokenRe.exec(leftOfCursor)) {
                        column -= this.session.tokenRe.lastIndex;
                        this.session.tokenRe.lastIndex = 0;
                    }

                    this.moveCursorTo(row, column);
                };

                this.$shortWordEndIndex = function (rightOfCursor) {
                    var match,
                        index = 0,
                        ch;
                    var whitespaceRe = /\s/;
                    var tokenRe = this.session.tokenRe;

                    tokenRe.lastIndex = 0;
                    if (match = this.session.tokenRe.exec(rightOfCursor)) {
                        index = this.session.tokenRe.lastIndex;
                    } else {
                        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;

                        if (index < 1) {
                            tokenRe.lastIndex = 0;
                            while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                                tokenRe.lastIndex = 0;
                                index++;
                                if (whitespaceRe.test(ch)) {
                                    if (index > 2) {
                                        index--;
                                        break;
                                    } else {
                                        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
                                        if (index > 2) break;
                                    }
                                }
                            }
                        }
                    }
                    tokenRe.lastIndex = 0;

                    return index;
                };

                this.moveCursorShortWordRight = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;
                    var line = this.doc.getLine(row);
                    var rightOfCursor = line.substring(column);

                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);

                    if (column == line.length) {
                        var l = this.doc.getLength();
                        do {
                            row++;
                            rightOfCursor = this.doc.getLine(row);
                        } while (row < l && /^\s*$/.test(rightOfCursor));

                        if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
                        column = 0;
                    }

                    var index = this.$shortWordEndIndex(rightOfCursor);

                    this.moveCursorTo(row, column + index);
                };

                this.moveCursorShortWordLeft = function () {
                    var row = this.lead.row;
                    var column = this.lead.column;

                    var fold;
                    if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);

                    var line = this.session.getLine(row).substring(0, column);
                    if (column === 0) {
                        do {
                            row--;
                            line = this.doc.getLine(row);
                        } while (row > 0 && /^\s*$/.test(line));

                        column = line.length;
                        if (!/\s+$/.test(line)) line = "";
                    }

                    var leftOfCursor = lang.stringReverse(line);
                    var index = this.$shortWordEndIndex(leftOfCursor);

                    return this.moveCursorTo(row, column - index);
                };

                this.moveCursorWordRight = function () {
                    if (this.session.$selectLongWords) this.moveCursorLongWordRight();else this.moveCursorShortWordRight();
                };

                this.moveCursorWordLeft = function () {
                    if (this.session.$selectLongWords) this.moveCursorLongWordLeft();else this.moveCursorShortWordLeft();
                };
                this.moveCursorBy = function (rows, chars) {
                    var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);

                    if (chars === 0) {
                        if (this.$desiredColumn) screenPos.column = this.$desiredColumn;else this.$desiredColumn = screenPos.column;
                    }

                    var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);

                    if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
                        if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                            if (docPos.row > 0 || rows > 0) docPos.row++;
                        }
                    }
                    this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
                };
                this.moveCursorToPosition = function (position) {
                    this.moveCursorTo(position.row, position.column);
                };
                this.moveCursorTo = function (row, column, keepDesiredColumn) {
                    var fold = this.session.getFoldAt(row, column, 1);
                    if (fold) {
                        row = fold.start.row;
                        column = fold.start.column;
                    }

                    this.$keepDesiredColumnOnChange = true;
                    this.lead.setPosition(row, column);
                    this.$keepDesiredColumnOnChange = false;

                    if (!keepDesiredColumn) this.$desiredColumn = null;
                };
                this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
                    var pos = this.session.screenToDocumentPosition(row, column);
                    this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
                };
                this.detach = function () {
                    this.lead.detach();
                    this.anchor.detach();
                    this.session = this.doc = null;
                };

                this.fromOrientedRange = function (range) {
                    this.setSelectionRange(range, range.cursor == range.start);
                    this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
                };

                this.toOrientedRange = function (range) {
                    var r = this.getRange();
                    if (range) {
                        range.start.column = r.start.column;
                        range.start.row = r.start.row;
                        range.end.column = r.end.column;
                        range.end.row = r.end.row;
                    } else {
                        range = r;
                    }

                    range.cursor = this.isBackwards() ? range.start : range.end;
                    range.desiredColumn = this.$desiredColumn;
                    return range;
                };
                this.getRangeOfMovements = function (func) {
                    var start = this.getCursor();
                    try {
                        func(this);
                        var end = this.getCursor();
                        return Range.fromPoints(start, end);
                    } catch (e) {
                        return Range.fromPoints(start, start);
                    } finally {
                        this.moveCursorToPosition(start);
                    }
                };

                this.toJSON = function () {
                    if (this.rangeCount) {
                        var data = this.ranges.map(function (r) {
                            var r1 = r.clone();
                            r1.isBackwards = r.cursor == r.start;
                            return r1;
                        });
                    } else {
                        var data = this.getRange();
                        data.isBackwards = this.isBackwards();
                    }
                    return data;
                };

                this.fromJSON = function (data) {
                    if (data.start == undefined) {
                        if (this.rangeList) {
                            this.toSingleRange(data[0]);
                            for (var i = data.length; i--;) {
                                var r = Range.fromPoints(data[i].start, data[i].end);
                                if (data[i].isBackwards) r.cursor = r.start;
                                this.addRange(r, true);
                            }
                            return;
                        } else data = data[0];
                    }
                    if (this.rangeList) this.toSingleRange(data);
                    this.setSelectionRange(data, data.isBackwards);
                };

                this.isEqual = function (data) {
                    if ((data.length || this.rangeCount) && data.length != this.rangeCount) return false;
                    if (!data.length || !this.ranges) return this.getRange().isEqual(data);

                    for (var i = this.ranges.length; i--;) {
                        if (!this.ranges[i].isEqual(data[i])) return false;
                    }
                    return true;
                };
            }).call(Selection.prototype);

            exports.Selection = Selection;
        });

        ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function (require, exports, module) {
            "use strict";

            var config = require("./config");
            var MAX_TOKEN_COUNT = 2000;
            var Tokenizer = function (rules) {
                this.states = rules;

                this.regExps = {};
                this.matchMappings = {};
                for (var key in this.states) {
                    var state = this.states[key];
                    var ruleRegExps = [];
                    var matchTotal = 0;
                    var mapping = this.matchMappings[key] = { defaultToken: "text" };
                    var flag = "g";

                    var splitterRurles = [];
                    for (var i = 0; i < state.length; i++) {
                        var rule = state[i];
                        if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
                        if (rule.caseInsensitive) flag = "gi";
                        if (rule.regex == null) continue;

                        if (rule.regex instanceof RegExp) rule.regex = rule.regex.toString().slice(1, -1);
                        var adjustedregex = rule.regex;
                        var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                        if (Array.isArray(rule.token)) {
                            if (rule.token.length == 1 || matchcount == 1) {
                                rule.token = rule.token[0];
                            } else if (matchcount - 1 != rule.token.length) {
                                this.reportError("number of classes and regexp groups doesn't match", {
                                    rule: rule,
                                    groupCount: matchcount - 1
                                });
                                rule.token = rule.token[0];
                            } else {
                                rule.tokenArray = rule.token;
                                rule.token = null;
                                rule.onMatch = this.$arrayTokens;
                            }
                        } else if (typeof rule.token == "function" && !rule.onMatch) {
                            if (matchcount > 1) rule.onMatch = this.$applyToken;else rule.onMatch = rule.token;
                        }

                        if (matchcount > 1) {
                            if (/\\\d/.test(rule.regex)) {
                                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                                    return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                                });
                            } else {
                                matchcount = 1;
                                adjustedregex = this.removeCapturingGroups(rule.regex);
                            }
                            if (!rule.splitRegex && typeof rule.token != "string") splitterRurles.push(rule); // flag will be known only at the very end
                        }

                        mapping[matchTotal] = i;
                        matchTotal += matchcount;

                        ruleRegExps.push(adjustedregex);
                        if (!rule.onMatch) rule.onMatch = null;
                    }

                    if (!ruleRegExps.length) {
                        mapping[0] = 0;
                        ruleRegExps.push("$");
                    }

                    splitterRurles.forEach(function (rule) {
                        rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                    }, this);

                    this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
                }
            };

            (function () {
                this.$setMaxTokenCount = function (m) {
                    MAX_TOKEN_COUNT = m | 0;
                };

                this.$applyToken = function (str) {
                    var values = this.splitRegex.exec(str).slice(1);
                    var types = this.token.apply(this, values);
                    if (typeof types === "string") return [{ type: types, value: str }];

                    var tokens = [];
                    for (var i = 0, l = types.length; i < l; i++) {
                        if (values[i]) tokens[tokens.length] = {
                            type: types[i],
                            value: values[i]
                        };
                    }
                    return tokens;
                };

                this.$arrayTokens = function (str) {
                    if (!str) return [];
                    var values = this.splitRegex.exec(str);
                    if (!values) return "text";
                    var tokens = [];
                    var types = this.tokenArray;
                    for (var i = 0, l = types.length; i < l; i++) {
                        if (values[i + 1]) tokens[tokens.length] = {
                            type: types[i],
                            value: values[i + 1]
                        };
                    }
                    return tokens;
                };

                this.removeCapturingGroups = function (src) {
                    var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) {
                        return y ? "(?:" : x;
                    });
                    return r;
                };

                this.createSplitterRegexp = function (src, flag) {
                    if (src.indexOf("(?=") != -1) {
                        var stack = 0;
                        var inChClass = false;
                        var lastCapture = {};
                        src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                            if (inChClass) {
                                inChClass = square != "]";
                            } else if (square) {
                                inChClass = true;
                            } else if (parenClose) {
                                if (stack == lastCapture.stack) {
                                    lastCapture.end = index + 1;
                                    lastCapture.stack = -1;
                                }
                                stack--;
                            } else if (parenOpen) {
                                stack++;
                                if (parenOpen.length != 1) {
                                    lastCapture.stack = stack;
                                    lastCapture.start = index;
                                }
                            }
                            return m;
                        });

                        if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
                    }
                    if (src.charAt(0) != "^") src = "^" + src;
                    if (src.charAt(src.length - 1) != "$") src += "$";

                    return new RegExp(src, (flag || "").replace("g", ""));
                };
                this.getLineTokens = function (line, startState) {
                    if (startState && typeof startState != "string") {
                        var stack = startState.slice(0);
                        startState = stack[0];
                        if (startState === "#tmp") {
                            stack.shift();
                            startState = stack.shift();
                        }
                    } else var stack = [];

                    var currentState = startState || "start";
                    var state = this.states[currentState];
                    if (!state) {
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    var mapping = this.matchMappings[currentState];
                    var re = this.regExps[currentState];
                    re.lastIndex = 0;

                    var match,
                        tokens = [];
                    var lastIndex = 0;
                    var matchAttempts = 0;

                    var token = { type: null, value: "" };

                    while (match = re.exec(line)) {
                        var type = mapping.defaultToken;
                        var rule = null;
                        var value = match[0];
                        var index = re.lastIndex;

                        if (index - value.length > lastIndex) {
                            var skipped = line.substring(lastIndex, index - value.length);
                            if (token.type == type) {
                                token.value += skipped;
                            } else {
                                if (token.type) tokens.push(token);
                                token = { type: type, value: skipped };
                            }
                        }

                        for (var i = 0; i < match.length - 2; i++) {
                            if (match[i + 1] === undefined) continue;

                            rule = state[mapping[i]];

                            if (rule.onMatch) type = rule.onMatch(value, currentState, stack);else type = rule.token;

                            if (rule.next) {
                                if (typeof rule.next == "string") {
                                    currentState = rule.next;
                                } else {
                                    currentState = rule.next(currentState, stack);
                                }

                                state = this.states[currentState];
                                if (!state) {
                                    this.reportError("state doesn't exist", currentState);
                                    currentState = "start";
                                    state = this.states[currentState];
                                }
                                mapping = this.matchMappings[currentState];
                                lastIndex = index;
                                re = this.regExps[currentState];
                                re.lastIndex = index;
                            }
                            break;
                        }

                        if (value) {
                            if (typeof type === "string") {
                                if ((!rule || rule.merge !== false) && token.type === type) {
                                    token.value += value;
                                } else {
                                    if (token.type) tokens.push(token);
                                    token = { type: type, value: value };
                                }
                            } else if (type) {
                                if (token.type) tokens.push(token);
                                token = { type: null, value: "" };
                                for (var i = 0; i < type.length; i++) tokens.push(type[i]);
                            }
                        }

                        if (lastIndex == line.length) break;

                        lastIndex = index;

                        if (matchAttempts++ > MAX_TOKEN_COUNT) {
                            if (matchAttempts > 2 * line.length) {
                                this.reportError("infinite loop with in ace tokenizer", {
                                    startState: startState,
                                    line: line
                                });
                            }
                            while (lastIndex < line.length) {
                                if (token.type) tokens.push(token);
                                token = {
                                    value: line.substring(lastIndex, lastIndex += 2000),
                                    type: "overflow"
                                };
                            }
                            currentState = "start";
                            stack = [];
                            break;
                        }
                    }

                    if (token.type) tokens.push(token);

                    if (stack.length > 1) {
                        if (stack[0] !== currentState) stack.unshift("#tmp", currentState);
                    }
                    return {
                        tokens: tokens,
                        state: stack.length ? stack : currentState
                    };
                };

                this.reportError = config.reportError;
            }).call(Tokenizer.prototype);

            exports.Tokenizer = Tokenizer;
        });

        ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var lang = require("../lib/lang");

            var TextHighlightRules = function () {

                this.$rules = {
                    "start": [{
                        token: "empty_line",
                        regex: '^$'
                    }, {
                        defaultToken: "text"
                    }]
                };
            };

            (function () {

                this.addRules = function (rules, prefix) {
                    if (!prefix) {
                        for (var key in rules) this.$rules[key] = rules[key];
                        return;
                    }
                    for (var key in rules) {
                        var state = rules[key];
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            if (rule.next || rule.onMatch) {
                                if (typeof rule.next == "string") {
                                    if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                                }
                                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
                            }
                        }
                        this.$rules[prefix + key] = state;
                    }
                };

                this.getRules = function () {
                    return this.$rules;
                };

                this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
                    var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
                    if (states) {
                        for (var i = 0; i < states.length; i++) states[i] = prefix + states[i];
                    } else {
                        states = [];
                        for (var key in embedRules) states.push(prefix + key);
                    }

                    this.addRules(embedRules, prefix);

                    if (escapeRules) {
                        var addRules = Array.prototype[append ? "push" : "unshift"];
                        for (var i = 0; i < states.length; i++) addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
                    }

                    if (!this.$embeds) this.$embeds = [];
                    this.$embeds.push(prefix);
                };

                this.getEmbeds = function () {
                    return this.$embeds;
                };

                var pushState = function (currentState, stack) {
                    if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
                    return this.nextState;
                };
                var popState = function (currentState, stack) {
                    stack.shift();
                    return stack.shift() || "start";
                };

                this.normalizeRules = function () {
                    var id = 0;
                    var rules = this.$rules;
                    function processState(key) {
                        var state = rules[key];
                        state.processed = true;
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            var toInsert = null;
                            if (Array.isArray(rule)) {
                                toInsert = rule;
                                rule = {};
                            }
                            if (!rule.regex && rule.start) {
                                rule.regex = rule.start;
                                if (!rule.next) rule.next = [];
                                rule.next.push({
                                    defaultToken: rule.token
                                }, {
                                    token: rule.token + ".end",
                                    regex: rule.end || rule.start,
                                    next: "pop"
                                });
                                rule.token = rule.token + ".start";
                                rule.push = true;
                            }
                            var next = rule.next || rule.push;
                            if (next && Array.isArray(next)) {
                                var stateName = rule.stateName;
                                if (!stateName) {
                                    stateName = rule.token;
                                    if (typeof stateName != "string") stateName = stateName[0] || "";
                                    if (rules[stateName]) stateName += id++;
                                }
                                rules[stateName] = next;
                                rule.next = stateName;
                                processState(stateName);
                            } else if (next == "pop") {
                                rule.next = popState;
                            }

                            if (rule.push) {
                                rule.nextState = rule.next || rule.push;
                                rule.next = pushState;
                                delete rule.push;
                            }

                            if (rule.rules) {
                                for (var r in rule.rules) {
                                    if (rules[r]) {
                                        if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                                    } else {
                                        rules[r] = rule.rules[r];
                                    }
                                }
                            }
                            var includeName = typeof rule == "string" ? rule : typeof rule.include == "string" ? rule.include : "";
                            if (includeName) {
                                toInsert = rules[includeName];
                            }

                            if (toInsert) {
                                var args = [i, 1].concat(toInsert);
                                if (rule.noEscape) args = args.filter(function (x) {
                                    return !x.next;
                                });
                                state.splice.apply(state, args);
                                i--;
                            }

                            if (rule.keywordMap) {
                                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                                delete rule.defaultToken;
                            }
                        }
                    }
                    Object.keys(rules).forEach(processState, this);
                };

                this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
                    var keywords = Object.create(null);
                    Object.keys(map).forEach(function (className) {
                        var a = map[className];
                        if (ignoreCase) a = a.toLowerCase();
                        var list = a.split(splitChar || "|");
                        for (var i = list.length; i--;) keywords[list[i]] = className;
                    });
                    if (Object.getPrototypeOf(keywords)) {
                        keywords.__proto__ = null;
                    }
                    this.$keywordList = Object.keys(keywords);
                    map = null;
                    return ignoreCase ? function (value) {
                        return keywords[value.toLowerCase()] || defaultToken;
                    } : function (value) {
                        return keywords[value] || defaultToken;
                    };
                };

                this.getKeywords = function () {
                    return this.$keywords;
                };
            }).call(TextHighlightRules.prototype);

            exports.TextHighlightRules = TextHighlightRules;
        });

        ace.define("ace/mode/behaviour", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var Behaviour = function () {
                this.$behaviours = {};
            };

            (function () {

                this.add = function (name, action, callback) {
                    switch (undefined) {
                        case this.$behaviours:
                            this.$behaviours = {};
                        case this.$behaviours[name]:
                            this.$behaviours[name] = {};
                    }
                    this.$behaviours[name][action] = callback;
                };

                this.addBehaviours = function (behaviours) {
                    for (var key in behaviours) {
                        for (var action in behaviours[key]) {
                            this.add(key, action, behaviours[key][action]);
                        }
                    }
                };

                this.remove = function (name) {
                    if (this.$behaviours && this.$behaviours[name]) {
                        delete this.$behaviours[name];
                    }
                };

                this.inherit = function (mode, filter) {
                    if (typeof mode === "function") {
                        var behaviours = new mode().getBehaviours(filter);
                    } else {
                        var behaviours = mode.getBehaviours(filter);
                    }
                    this.addBehaviours(behaviours);
                };

                this.getBehaviours = function (filter) {
                    if (!filter) {
                        return this.$behaviours;
                    } else {
                        var ret = {};
                        for (var i = 0; i < filter.length; i++) {
                            if (this.$behaviours[filter[i]]) {
                                ret[filter[i]] = this.$behaviours[filter[i]];
                            }
                        }
                        return ret;
                    }
                };
            }).call(Behaviour.prototype);

            exports.Behaviour = Behaviour;
        });

        ace.define("ace/token_iterator", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var TokenIterator = function (session, initialRow, initialColumn) {
                this.$session = session;
                this.$row = initialRow;
                this.$rowTokens = session.getTokens(initialRow);

                var token = session.getTokenAt(initialRow, initialColumn);
                this.$tokenIndex = token ? token.index : -1;
            };

            (function () {
                this.stepBackward = function () {
                    this.$tokenIndex -= 1;

                    while (this.$tokenIndex < 0) {
                        this.$row -= 1;
                        if (this.$row < 0) {
                            this.$row = 0;
                            return null;
                        }

                        this.$rowTokens = this.$session.getTokens(this.$row);
                        this.$tokenIndex = this.$rowTokens.length - 1;
                    }

                    return this.$rowTokens[this.$tokenIndex];
                };
                this.stepForward = function () {
                    this.$tokenIndex += 1;
                    var rowCount;
                    while (this.$tokenIndex >= this.$rowTokens.length) {
                        this.$row += 1;
                        if (!rowCount) rowCount = this.$session.getLength();
                        if (this.$row >= rowCount) {
                            this.$row = rowCount - 1;
                            return null;
                        }

                        this.$rowTokens = this.$session.getTokens(this.$row);
                        this.$tokenIndex = 0;
                    }

                    return this.$rowTokens[this.$tokenIndex];
                };
                this.getCurrentToken = function () {
                    return this.$rowTokens[this.$tokenIndex];
                };
                this.getCurrentTokenRow = function () {
                    return this.$row;
                };
                this.getCurrentTokenColumn = function () {
                    var rowTokens = this.$rowTokens;
                    var tokenIndex = this.$tokenIndex;
                    var column = rowTokens[tokenIndex].start;
                    if (column !== undefined) return column;

                    column = 0;
                    while (tokenIndex > 0) {
                        tokenIndex -= 1;
                        column += rowTokens[tokenIndex].value.length;
                    }

                    return column;
                };
                this.getCurrentTokenPosition = function () {
                    return { row: this.$row, column: this.getCurrentTokenColumn() };
                };
            }).call(TokenIterator.prototype);

            exports.TokenIterator = TokenIterator;
        });

        ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (require, exports, module) {
            "use strict";

            var oop = require("../../lib/oop");
            var Behaviour = require("../behaviour").Behaviour;
            var TokenIterator = require("../../token_iterator").TokenIterator;
            var lang = require("../../lib/lang");

            var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
            var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];

            var context;
            var contextCache = {};
            var initContext = function (editor) {
                var id = -1;
                if (editor.multiSelect) {
                    id = editor.selection.index;
                    if (contextCache.rangeCount != editor.multiSelect.rangeCount) contextCache = { rangeCount: editor.multiSelect.rangeCount };
                }
                if (contextCache[id]) return context = contextCache[id];
                context = contextCache[id] = {
                    autoInsertedBrackets: 0,
                    autoInsertedRow: -1,
                    autoInsertedLineEnd: "",
                    maybeInsertedBrackets: 0,
                    maybeInsertedRow: -1,
                    maybeInsertedLineStart: "",
                    maybeInsertedLineEnd: ""
                };
            };

            var getWrapped = function (selection, selected, opening, closing) {
                var rowDiff = selection.end.row - selection.start.row;
                return {
                    text: opening + selected + closing,
                    selection: [0, selection.start.column + 1, rowDiff, selection.end.column + (rowDiff ? 0 : 1)]
                };
            };

            var CstyleBehaviour = function () {
                this.add("braces", "insertion", function (state, action, editor, session, text) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    if (text == '{') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '{', '}');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                                return {
                                    text: '{}',
                                    selection: [1, 1]
                                };
                            } else {
                                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                                return {
                                    text: '{',
                                    selection: [1, 1]
                                };
                            }
                        }
                    } else if (text == '}') {
                        initContext(editor);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == '}') {
                            var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    } else if (text == "\n" || text == "\r\n") {
                        initContext(editor);
                        var closing = "";
                        if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                            closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                            CstyleBehaviour.clearMaybeInsertedClosing();
                        }
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar === '}') {
                            var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
                            if (!openBracePos) return null;
                            var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                        } else if (closing) {
                            var next_indent = this.$getIndent(line);
                        } else {
                            CstyleBehaviour.clearMaybeInsertedClosing();
                            return;
                        }
                        var indent = next_indent + session.getTabString();

                        return {
                            text: '\n' + indent + '\n' + next_indent + closing,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    } else {
                        CstyleBehaviour.clearMaybeInsertedClosing();
                    }
                });

                this.add("braces", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '{') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.end.column, range.end.column + 1);
                        if (rightChar == '}') {
                            range.end.column++;
                            return range;
                        } else {
                            context.maybeInsertedBrackets--;
                        }
                    }
                });

                this.add("parens", "insertion", function (state, action, editor, session, text) {
                    if (text == '(') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '(', ')');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            CstyleBehaviour.recordAutoInsert(editor, session, ")");
                            return {
                                text: '()',
                                selection: [1, 1]
                            };
                        }
                    } else if (text == ')') {
                        initContext(editor);
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == ')') {
                            var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("parens", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '(') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == ')') {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("brackets", "insertion", function (state, action, editor, session, text) {
                    if (text == '[') {
                        initContext(editor);
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, '[', ']');
                        } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                            CstyleBehaviour.recordAutoInsert(editor, session, "]");
                            return {
                                text: '[]',
                                selection: [1, 1]
                            };
                        }
                    } else if (text == ']') {
                        initContext(editor);
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        var rightChar = line.substring(cursor.column, cursor.column + 1);
                        if (rightChar == ']') {
                            var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
                            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                CstyleBehaviour.popAutoInsertedClosing();
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    }
                });

                this.add("brackets", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && selected == '[') {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == ']') {
                            range.end.column++;
                            return range;
                        }
                    }
                });

                this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                    if (text == '"' || text == "'") {
                        if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) return;
                        initContext(editor);
                        var quote = text;
                        var selection = editor.getSelectionRange();
                        var selected = session.doc.getTextRange(selection);
                        if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                            return getWrapped(selection, selected, quote, quote);
                        } else if (!selected) {
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var leftChar = line.substring(cursor.column - 1, cursor.column);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);

                            var token = session.getTokenAt(cursor.row, cursor.column);
                            var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                            if (leftChar == "\\" && token && /escape/.test(token.type)) return null;

                            var stringBefore = token && /string|escape/.test(token.type);
                            var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                            var pair;
                            if (rightChar == quote) {
                                pair = stringBefore !== stringAfter;
                                if (pair && /string\.end/.test(rightToken.type)) pair = false;
                            } else {
                                if (stringBefore && !stringAfter) return null; // wrap string with different quote
                                if (stringBefore && stringAfter) return null; // do not pair quotes inside strings
                                var wordRe = session.$mode.tokenRe;
                                wordRe.lastIndex = 0;
                                var isWordBefore = wordRe.test(leftChar);
                                wordRe.lastIndex = 0;
                                var isWordAfter = wordRe.test(leftChar);
                                if (isWordBefore || isWordAfter) return null; // before or after alphanumeric
                                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar)) return null; // there is rightChar and it isn't closing
                                pair = true;
                            }
                            return {
                                text: pair ? quote + quote : "",
                                selection: [1, 1]
                            };
                        }
                    }
                });

                this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                    var selected = session.doc.getTextRange(range);
                    if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
                        initContext(editor);
                        var line = session.doc.getLine(range.start.row);
                        var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                        if (rightChar == selected) {
                            range.end.column++;
                            return range;
                        }
                    }
                });
            };

            CstyleBehaviour.isSaneInsertion = function (editor, session) {
                var cursor = editor.getCursorPosition();
                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
                    var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
                    if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) return false;
                }
                iterator.stepForward();
                return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
            };

            CstyleBehaviour.$matchTokenType = function (token, types) {
                return types.indexOf(token.type || token) > -1;
            };

            CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) context.autoInsertedBrackets = 0;
                context.autoInsertedRow = cursor.row;
                context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
                context.autoInsertedBrackets++;
            };

            CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                if (!this.isMaybeInsertedClosing(cursor, line)) context.maybeInsertedBrackets = 0;
                context.maybeInsertedRow = cursor.row;
                context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
                context.maybeInsertedLineEnd = line.substr(cursor.column);
                context.maybeInsertedBrackets++;
            };

            CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
                return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
            };

            CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
                return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
            };

            CstyleBehaviour.popAutoInsertedClosing = function () {
                context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
                context.autoInsertedBrackets--;
            };

            CstyleBehaviour.clearMaybeInsertedClosing = function () {
                if (context) {
                    context.maybeInsertedBrackets = 0;
                    context.maybeInsertedRow = -1;
                }
            };

            oop.inherits(CstyleBehaviour, Behaviour);

            exports.CstyleBehaviour = CstyleBehaviour;
        });

        ace.define("ace/unicode", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            exports.packages = {};

            addUnicodePackage({
                L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
                Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
                Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
                Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
                Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
                Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
                Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
                Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
                N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
                No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
                P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
                Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
                Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
                Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
                Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
                Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
                Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
                Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
                S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
                Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
                Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
                Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
                So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
                Z: "002000A01680180E2000-200A20282029202F205F3000",
                Zs: "002000A01680180E2000-200A202F205F3000",
                Zl: "2028",
                Zp: "2029",
                C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
                Cc: "0000-001F007F-009F",
                Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
                Co: "E000-F8FF",
                Cs: "D800-DFFF",
                Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
            });

            function addUnicodePackage(pack) {
                var codePoint = /\w{4}/g;
                for (var name in pack) exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
            }
        });

        ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function (require, exports, module) {
            "use strict";

            var Tokenizer = require("../tokenizer").Tokenizer;
            var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
            var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
            var unicode = require("../unicode");
            var lang = require("../lib/lang");
            var TokenIterator = require("../token_iterator").TokenIterator;
            var Range = require("../range").Range;

            var Mode = function () {
                this.HighlightRules = TextHighlightRules;
            };

            (function () {
                this.$behaviour = new CstyleBehaviour();

                this.tokenRe = new RegExp("^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+", "g");

                this.nonTokenRe = new RegExp("^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+", "g");

                this.getTokenizer = function () {
                    if (!this.$tokenizer) {
                        this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                        this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
                    }
                    return this.$tokenizer;
                };

                this.lineCommentStart = "";
                this.blockComment = "";

                this.toggleCommentLines = function (state, session, startRow, endRow) {
                    var doc = session.doc;

                    var ignoreBlankLines = true;
                    var shouldRemove = true;
                    var minIndent = Infinity;
                    var tabSize = session.getTabSize();
                    var insertAtTabStop = false;

                    if (!this.lineCommentStart) {
                        if (!this.blockComment) return false;
                        var lineCommentStart = this.blockComment.start;
                        var lineCommentEnd = this.blockComment.end;
                        var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                        var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

                        var comment = function (line, i) {
                            if (testRemove(line, i)) return;
                            if (!ignoreBlankLines || /\S/.test(line)) {
                                doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                                doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                            }
                        };

                        var uncomment = function (line, i) {
                            var m;
                            if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
                            if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
                        };

                        var testRemove = function (line, row) {
                            if (regexpStart.test(line)) return true;
                            var tokens = session.getTokens(row);
                            for (var i = 0; i < tokens.length; i++) {
                                if (tokens[i].type === "comment") return true;
                            }
                        };
                    } else {
                        if (Array.isArray(this.lineCommentStart)) {
                            var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                            var lineCommentStart = this.lineCommentStart[0];
                        } else {
                            var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                            var lineCommentStart = this.lineCommentStart;
                        }
                        regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");

                        insertAtTabStop = session.getUseSoftTabs();

                        var uncomment = function (line, i) {
                            var m = line.match(regexpStart);
                            if (!m) return;
                            var start = m[1].length,
                                end = m[0].length;
                            if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
                            doc.removeInLine(i, start, end);
                        };
                        var commentWithSpace = lineCommentStart + " ";
                        var comment = function (line, i) {
                            if (!ignoreBlankLines || /\S/.test(line)) {
                                if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);else doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                            }
                        };
                        var testRemove = function (line, i) {
                            return regexpStart.test(line);
                        };

                        var shouldInsertSpace = function (line, before, after) {
                            var spaces = 0;
                            while (before-- && line.charAt(before) == " ") spaces++;
                            if (spaces % tabSize != 0) return false;
                            var spaces = 0;
                            while (line.charAt(after++) == " ") spaces++;
                            if (tabSize > 2) return spaces % tabSize != tabSize - 1;else return spaces % tabSize == 0;
                            return true;
                        };
                    }

                    function iter(fun) {
                        for (var i = startRow; i <= endRow; i++) fun(doc.getLine(i), i);
                    }

                    var minEmptyLength = Infinity;
                    iter(function (line, i) {
                        var indent = line.search(/\S/);
                        if (indent !== -1) {
                            if (indent < minIndent) minIndent = indent;
                            if (shouldRemove && !testRemove(line, i)) shouldRemove = false;
                        } else if (minEmptyLength > line.length) {
                            minEmptyLength = line.length;
                        }
                    });

                    if (minIndent == Infinity) {
                        minIndent = minEmptyLength;
                        ignoreBlankLines = false;
                        shouldRemove = false;
                    }

                    if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;

                    iter(shouldRemove ? uncomment : comment);
                };

                this.toggleBlockComment = function (state, session, range, cursor) {
                    var comment = this.blockComment;
                    if (!comment) return;
                    if (!comment.start && comment[0]) comment = comment[0];

                    var iterator = new TokenIterator(session, cursor.row, cursor.column);
                    var token = iterator.getCurrentToken();

                    var sel = session.selection;
                    var initialRange = session.selection.toOrientedRange();
                    var startRow, colDiff;

                    if (token && /comment/.test(token.type)) {
                        var startRange, endRange;
                        while (token && /comment/.test(token.type)) {
                            var i = token.value.indexOf(comment.start);
                            if (i != -1) {
                                var row = iterator.getCurrentTokenRow();
                                var column = iterator.getCurrentTokenColumn() + i;
                                startRange = new Range(row, column, row, column + comment.start.length);
                                break;
                            }
                            token = iterator.stepBackward();
                        }

                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        while (token && /comment/.test(token.type)) {
                            var i = token.value.indexOf(comment.end);
                            if (i != -1) {
                                var row = iterator.getCurrentTokenRow();
                                var column = iterator.getCurrentTokenColumn() + i;
                                endRange = new Range(row, column, row, column + comment.end.length);
                                break;
                            }
                            token = iterator.stepForward();
                        }
                        if (endRange) session.remove(endRange);
                        if (startRange) {
                            session.remove(startRange);
                            startRow = startRange.start.row;
                            colDiff = -comment.start.length;
                        }
                    } else {
                        colDiff = comment.start.length;
                        startRow = range.start.row;
                        session.insert(range.end, comment.end);
                        session.insert(range.start, comment.start);
                    }
                    if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
                    if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
                    session.selection.fromOrientedRange(initialRange);
                };

                this.getNextLineIndent = function (state, line, tab) {
                    return this.$getIndent(line);
                };

                this.checkOutdent = function (state, line, input) {
                    return false;
                };

                this.autoOutdent = function (state, doc, row) {};

                this.$getIndent = function (line) {
                    return line.match(/^\s*/)[0];
                };

                this.createWorker = function (session) {
                    return null;
                };

                this.createModeDelegates = function (mapping) {
                    this.$embeds = [];
                    this.$modes = {};
                    for (var i in mapping) {
                        if (mapping[i]) {
                            this.$embeds.push(i);
                            this.$modes[i] = new mapping[i]();
                        }
                    }

                    var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

                    for (var i = 0; i < delegations.length; i++) {
                        (function (scope) {
                            var functionName = delegations[i];
                            var defaultHandler = scope[functionName];
                            scope[delegations[i]] = function () {
                                return this.$delegator(functionName, arguments, defaultHandler);
                            };
                        })(this);
                    }
                };

                this.$delegator = function (method, args, defaultHandler) {
                    var state = args[0];
                    if (typeof state != "string") state = state[0];
                    for (var i = 0; i < this.$embeds.length; i++) {
                        if (!this.$modes[this.$embeds[i]]) continue;

                        var split = state.split(this.$embeds[i]);
                        if (!split[0] && split[1]) {
                            args[0] = split[1];
                            var mode = this.$modes[this.$embeds[i]];
                            return mode[method].apply(mode, args);
                        }
                    }
                    var ret = defaultHandler.apply(this, args);
                    return defaultHandler ? ret : undefined;
                };

                this.transformAction = function (state, action, editor, session, param) {
                    if (this.$behaviour) {
                        var behaviours = this.$behaviour.getBehaviours();
                        for (var key in behaviours) {
                            if (behaviours[key][action]) {
                                var ret = behaviours[key][action].apply(this, arguments);
                                if (ret) {
                                    return ret;
                                }
                            }
                        }
                    }
                };

                this.getKeywords = function (append) {
                    if (!this.completionKeywords) {
                        var rules = this.$tokenizer.rules;
                        var completionKeywords = [];
                        for (var rule in rules) {
                            var ruleItr = rules[rule];
                            for (var r = 0, l = ruleItr.length; r < l; r++) {
                                if (typeof ruleItr[r].token === "string") {
                                    if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                                } else if (typeof ruleItr[r].token === "object") {
                                    for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                                        if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                            var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                            completionKeywords.push(rule.substr(1, rule.length - 2));
                                        }
                                    }
                                }
                            }
                        }
                        this.completionKeywords = completionKeywords;
                    }
                    if (!append) return this.$keywordList;
                    return completionKeywords.concat(this.$keywordList || []);
                };

                this.$createKeywordList = function () {
                    if (!this.$highlightRules) this.getTokenizer();
                    return this.$keywordList = this.$highlightRules.$keywordList || [];
                };

                this.getCompletions = function (state, session, pos, prefix) {
                    var keywords = this.$keywordList || this.$createKeywordList();
                    return keywords.map(function (word) {
                        return {
                            name: word,
                            value: word,
                            score: 0,
                            meta: "keyword"
                        };
                    });
                };

                this.$id = "ace/mode/text";
            }).call(Mode.prototype);

            exports.Mode = Mode;
        });

        ace.define("ace/apply_delta", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            function throwDeltaError(delta, errorText) {
                console.log("Invalid Delta:", delta);
                throw "Invalid Delta: " + errorText;
            }

            function positionInDocument(docLines, position) {
                return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
            }

            function validateDelta(docLines, delta) {
                if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
                if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
                if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
                var start = delta.start;
                if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
                var end = delta.end;
                if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
                var numRangeRows = end.row - start.row;
                var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
                if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
            }

            exports.applyDelta = function (docLines, delta, doNotValidate) {

                var row = delta.start.row;
                var startColumn = delta.start.column;
                var line = docLines[row] || "";
                switch (delta.action) {
                    case "insert":
                        var lines = delta.lines;
                        if (lines.length === 1) {
                            docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                        } else {
                            var args = [row, 1].concat(delta.lines);
                            docLines.splice.apply(docLines, args);
                            docLines[row] = line.substring(0, startColumn) + docLines[row];
                            docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                        }
                        break;
                    case "remove":
                        var endColumn = delta.end.column;
                        var endRow = delta.end.row;
                        if (row === endRow) {
                            docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                        } else {
                            docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
                        }
                        break;
                }
            };
        });

        ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;

            var Anchor = exports.Anchor = function (doc, row, column) {
                this.$onChange = this.onChange.bind(this);
                this.attach(doc);

                if (typeof column == "undefined") this.setPosition(row.row, row.column);else this.setPosition(row, column);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.getPosition = function () {
                    return this.$clipPositionToDocument(this.row, this.column);
                };
                this.getDocument = function () {
                    return this.document;
                };
                this.$insertRight = false;
                this.onChange = function (delta) {
                    if (delta.start.row == delta.end.row && delta.start.row != this.row) return;

                    if (delta.start.row > this.row) return;

                    var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
                    this.setPosition(point.row, point.column, true);
                };

                function $pointsInOrder(point1, point2, equalPointsInOrder) {
                    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
                    return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
                }

                function $getTransformedPoint(delta, point, moveIfEqual) {
                    var deltaIsInsert = delta.action == "insert";
                    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
                    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
                    var deltaStart = delta.start;
                    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
                    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                        return {
                            row: point.row,
                            column: point.column
                        };
                    }
                    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                        return {
                            row: point.row + deltaRowShift,
                            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                        };
                    }

                    return {
                        row: deltaStart.row,
                        column: deltaStart.column
                    };
                }
                this.setPosition = function (row, column, noClip) {
                    var pos;
                    if (noClip) {
                        pos = {
                            row: row,
                            column: column
                        };
                    } else {
                        pos = this.$clipPositionToDocument(row, column);
                    }

                    if (this.row == pos.row && this.column == pos.column) return;

                    var old = {
                        row: this.row,
                        column: this.column
                    };

                    this.row = pos.row;
                    this.column = pos.column;
                    this._signal("change", {
                        old: old,
                        value: pos
                    });
                };
                this.detach = function () {
                    this.document.removeEventListener("change", this.$onChange);
                };
                this.attach = function (doc) {
                    this.document = doc || this.document;
                    this.document.on("change", this.$onChange);
                };
                this.$clipPositionToDocument = function (row, column) {
                    var pos = {};

                    if (row >= this.document.getLength()) {
                        pos.row = Math.max(0, this.document.getLength() - 1);
                        pos.column = this.document.getLine(pos.row).length;
                    } else if (row < 0) {
                        pos.row = 0;
                        pos.column = 0;
                    } else {
                        pos.row = row;
                        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
                    }

                    if (column < 0) pos.column = 0;

                    return pos;
                };
            }).call(Anchor.prototype);
        });

        ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var applyDelta = require("./apply_delta").applyDelta;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Range = require("./range").Range;
            var Anchor = require("./anchor").Anchor;

            var Document = function (textOrLines) {
                this.$lines = [""];
                if (textOrLines.length === 0) {
                    this.$lines = [""];
                } else if (Array.isArray(textOrLines)) {
                    this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
                } else {
                    this.insert({ row: 0, column: 0 }, textOrLines);
                }
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setValue = function (text) {
                    var len = this.getLength() - 1;
                    this.remove(new Range(0, 0, len, this.getLine(len).length));
                    this.insert({ row: 0, column: 0 }, text);
                };
                this.getValue = function () {
                    return this.getAllLines().join(this.getNewLineCharacter());
                };
                this.createAnchor = function (row, column) {
                    return new Anchor(this, row, column);
                };
                if ("aaa".split(/a/).length === 0) {
                    this.$split = function (text) {
                        return text.replace(/\r\n|\r/g, "\n").split("\n");
                    };
                } else {
                    this.$split = function (text) {
                        return text.split(/\r\n|\r|\n/);
                    };
                }

                this.$detectNewLine = function (text) {
                    var match = text.match(/^.*?(\r\n|\r|\n)/m);
                    this.$autoNewLine = match ? match[1] : "\n";
                    this._signal("changeNewLineMode");
                };
                this.getNewLineCharacter = function () {
                    switch (this.$newLineMode) {
                        case "windows":
                            return "\r\n";
                        case "unix":
                            return "\n";
                        default:
                            return this.$autoNewLine || "\n";
                    }
                };

                this.$autoNewLine = "";
                this.$newLineMode = "auto";
                this.setNewLineMode = function (newLineMode) {
                    if (this.$newLineMode === newLineMode) return;

                    this.$newLineMode = newLineMode;
                    this._signal("changeNewLineMode");
                };
                this.getNewLineMode = function () {
                    return this.$newLineMode;
                };
                this.isNewLine = function (text) {
                    return text == "\r\n" || text == "\r" || text == "\n";
                };
                this.getLine = function (row) {
                    return this.$lines[row] || "";
                };
                this.getLines = function (firstRow, lastRow) {
                    return this.$lines.slice(firstRow, lastRow + 1);
                };
                this.getAllLines = function () {
                    return this.getLines(0, this.getLength());
                };
                this.getLength = function () {
                    return this.$lines.length;
                };
                this.getTextRange = function (range) {
                    return this.getLinesForRange(range).join(this.getNewLineCharacter());
                };
                this.getLinesForRange = function (range) {
                    var lines;
                    if (range.start.row === range.end.row) {
                        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
                    } else {
                        lines = this.getLines(range.start.row, range.end.row);
                        lines[0] = (lines[0] || "").substring(range.start.column);
                        var l = lines.length - 1;
                        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
                    }
                    return lines;
                };
                this.insertLines = function (row, lines) {
                    console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
                    return this.insertFullLines(row, lines);
                };
                this.removeLines = function (firstRow, lastRow) {
                    console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
                    return this.removeFullLines(firstRow, lastRow);
                };
                this.insertNewLine = function (position) {
                    console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
                    return this.insertMergedLines(position, ["", ""]);
                };
                this.insert = function (position, text) {
                    if (this.getLength() <= 1) this.$detectNewLine(text);

                    return this.insertMergedLines(position, this.$split(text));
                };
                this.insertInLine = function (position, text) {
                    var start = this.clippedPos(position.row, position.column);
                    var end = this.pos(position.row, position.column + text.length);

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "insert",
                        lines: [text]
                    }, true);

                    return this.clonePos(end);
                };

                this.clippedPos = function (row, column) {
                    var length = this.getLength();
                    if (row === undefined) {
                        row = length;
                    } else if (row < 0) {
                        row = 0;
                    } else if (row >= length) {
                        row = length - 1;
                        column = undefined;
                    }
                    var line = this.getLine(row);
                    if (column == undefined) column = line.length;
                    column = Math.min(Math.max(column, 0), line.length);
                    return { row: row, column: column };
                };

                this.clonePos = function (pos) {
                    return { row: pos.row, column: pos.column };
                };

                this.pos = function (row, column) {
                    return { row: row, column: column };
                };

                this.$clipPosition = function (position) {
                    var length = this.getLength();
                    if (position.row >= length) {
                        position.row = Math.max(0, length - 1);
                        position.column = this.getLine(length - 1).length;
                    } else {
                        position.row = Math.max(0, position.row);
                        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
                    }
                    return position;
                };
                this.insertFullLines = function (row, lines) {
                    row = Math.min(Math.max(row, 0), this.getLength());
                    var column = 0;
                    if (row < this.getLength()) {
                        lines = lines.concat([""]);
                        column = 0;
                    } else {
                        lines = [""].concat(lines);
                        row--;
                        column = this.$lines[row].length;
                    }
                    this.insertMergedLines({ row: row, column: column }, lines);
                };
                this.insertMergedLines = function (position, lines) {
                    var start = this.clippedPos(position.row, position.column);
                    var end = {
                        row: start.row + lines.length - 1,
                        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
                    };

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "insert",
                        lines: lines
                    });

                    return this.clonePos(end);
                };
                this.remove = function (range) {
                    var start = this.clippedPos(range.start.row, range.start.column);
                    var end = this.clippedPos(range.end.row, range.end.column);
                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "remove",
                        lines: this.getLinesForRange({ start: start, end: end })
                    });
                    return this.clonePos(start);
                };
                this.removeInLine = function (row, startColumn, endColumn) {
                    var start = this.clippedPos(row, startColumn);
                    var end = this.clippedPos(row, endColumn);

                    this.applyDelta({
                        start: start,
                        end: end,
                        action: "remove",
                        lines: this.getLinesForRange({ start: start, end: end })
                    }, true);

                    return this.clonePos(start);
                };
                this.removeFullLines = function (firstRow, lastRow) {
                    firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
                    lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
                    var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
                    var deleteLastNewLine = lastRow < this.getLength() - 1;
                    var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
                    var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
                    var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
                    var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
                    var range = new Range(startRow, startCol, endRow, endCol);
                    var deletedLines = this.$lines.slice(firstRow, lastRow + 1);

                    this.applyDelta({
                        start: range.start,
                        end: range.end,
                        action: "remove",
                        lines: this.getLinesForRange(range)
                    });
                    return deletedLines;
                };
                this.removeNewLine = function (row) {
                    if (row < this.getLength() - 1 && row >= 0) {
                        this.applyDelta({
                            start: this.pos(row, this.getLine(row).length),
                            end: this.pos(row + 1, 0),
                            action: "remove",
                            lines: ["", ""]
                        });
                    }
                };
                this.replace = function (range, text) {
                    if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
                    if (text.length === 0 && range.isEmpty()) return range.start;
                    if (text == this.getTextRange(range)) return range.end;

                    this.remove(range);
                    var end;
                    if (text) {
                        end = this.insert(range.start, text);
                    } else {
                        end = range.start;
                    }

                    return end;
                };
                this.applyDeltas = function (deltas) {
                    for (var i = 0; i < deltas.length; i++) {
                        this.applyDelta(deltas[i]);
                    }
                };
                this.revertDeltas = function (deltas) {
                    for (var i = deltas.length - 1; i >= 0; i--) {
                        this.revertDelta(deltas[i]);
                    }
                };
                this.applyDelta = function (delta, doNotValidate) {
                    var isInsert = delta.action == "insert";
                    if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
                        return;
                    }

                    if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
                    applyDelta(this.$lines, delta, doNotValidate);
                    this._signal("change", delta);
                };

                this.$splitAndapplyLargeDelta = function (delta, MAX) {
                    var lines = delta.lines;
                    var l = lines.length;
                    var row = delta.start.row;
                    var column = delta.start.column;
                    var from = 0,
                        to = 0;
                    do {
                        from = to;
                        to += MAX - 1;
                        var chunk = lines.slice(from, to);
                        if (to > l) {
                            delta.lines = chunk;
                            delta.start.row = row + from;
                            delta.start.column = column;
                            break;
                        }
                        chunk.push("");
                        this.applyDelta({
                            start: this.pos(row + from, column),
                            end: this.pos(row + to, column = 0),
                            action: delta.action,
                            lines: chunk
                        }, true);
                    } while (true);
                };
                this.revertDelta = function (delta) {
                    this.applyDelta({
                        start: this.clonePos(delta.start),
                        end: this.clonePos(delta.end),
                        action: delta.action == "insert" ? "remove" : "insert",
                        lines: delta.lines.slice()
                    });
                };
                this.indexToPosition = function (index, startRow) {
                    var lines = this.$lines || this.getAllLines();
                    var newlineLength = this.getNewLineCharacter().length;
                    for (var i = startRow || 0, l = lines.length; i < l; i++) {
                        index -= lines[i].length + newlineLength;
                        if (index < 0) return { row: i, column: index + lines[i].length + newlineLength };
                    }
                    return { row: l - 1, column: lines[l - 1].length };
                };
                this.positionToIndex = function (pos, startRow) {
                    var lines = this.$lines || this.getAllLines();
                    var newlineLength = this.getNewLineCharacter().length;
                    var index = 0;
                    var row = Math.min(pos.row, lines.length);
                    for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;

                    return index + pos.column;
                };
            }).call(Document.prototype);

            exports.Document = Document;
        });

        ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;

            var BackgroundTokenizer = function (tokenizer, editor) {
                this.running = false;
                this.lines = [];
                this.states = [];
                this.currentLine = 0;
                this.tokenizer = tokenizer;

                var self = this;

                this.$worker = function () {
                    if (!self.running) {
                        return;
                    }

                    var workerStart = new Date();
                    var currentLine = self.currentLine;
                    var endLine = -1;
                    var doc = self.doc;

                    var startLine = currentLine;
                    while (self.lines[currentLine]) currentLine++;

                    var len = doc.getLength();
                    var processedLines = 0;
                    self.running = false;
                    while (currentLine < len) {
                        self.$tokenizeRow(currentLine);
                        endLine = currentLine;
                        do {
                            currentLine++;
                        } while (self.lines[currentLine]);
                        processedLines++;
                        if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
                            self.running = setTimeout(self.$worker, 20);
                            break;
                        }
                    }
                    self.currentLine = currentLine;

                    if (startLine <= endLine) self.fireUpdateEvent(startLine, endLine);
                };
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setTokenizer = function (tokenizer) {
                    this.tokenizer = tokenizer;
                    this.lines = [];
                    this.states = [];

                    this.start(0);
                };
                this.setDocument = function (doc) {
                    this.doc = doc;
                    this.lines = [];
                    this.states = [];

                    this.stop();
                };
                this.fireUpdateEvent = function (firstRow, lastRow) {
                    var data = {
                        first: firstRow,
                        last: lastRow
                    };
                    this._signal("update", { data: data });
                };
                this.start = function (startRow) {
                    this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
                    this.lines.splice(this.currentLine, this.lines.length);
                    this.states.splice(this.currentLine, this.states.length);

                    this.stop();
                    this.running = setTimeout(this.$worker, 700);
                };

                this.scheduleStart = function () {
                    if (!this.running) this.running = setTimeout(this.$worker, 700);
                };

                this.$updateOnChange = function (delta) {
                    var startRow = delta.start.row;
                    var len = delta.end.row - startRow;

                    if (len === 0) {
                        this.lines[startRow] = null;
                    } else if (delta.action == "remove") {
                        this.lines.splice(startRow, len + 1, null);
                        this.states.splice(startRow, len + 1, null);
                    } else {
                        var args = Array(len + 1);
                        args.unshift(startRow, 1);
                        this.lines.splice.apply(this.lines, args);
                        this.states.splice.apply(this.states, args);
                    }

                    this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

                    this.stop();
                };
                this.stop = function () {
                    if (this.running) clearTimeout(this.running);
                    this.running = false;
                };
                this.getTokens = function (row) {
                    return this.lines[row] || this.$tokenizeRow(row);
                };
                this.getState = function (row) {
                    if (this.currentLine == row) this.$tokenizeRow(row);
                    return this.states[row] || "start";
                };

                this.$tokenizeRow = function (row) {
                    var line = this.doc.getLine(row);
                    var state = this.states[row - 1];

                    var data = this.tokenizer.getLineTokens(line, state, row);

                    if (this.states[row] + "" !== data.state + "") {
                        this.states[row] = data.state;
                        this.lines[row + 1] = null;
                        if (this.currentLine > row + 1) this.currentLine = row + 1;
                    } else if (this.currentLine == row) {
                        this.currentLine = row + 1;
                    }

                    return this.lines[row] = data.tokens;
                };
            }).call(BackgroundTokenizer.prototype);

            exports.BackgroundTokenizer = BackgroundTokenizer;
        });

        ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var Range = require("./range").Range;

            var SearchHighlight = function (regExp, clazz, type) {
                this.setRegexp(regExp);
                this.clazz = clazz;
                this.type = type || "text";
            };

            (function () {
                this.MAX_RANGES = 500;

                this.setRegexp = function (regExp) {
                    if (this.regExp + "" == regExp + "") return;
                    this.regExp = regExp;
                    this.cache = [];
                };

                this.update = function (html, markerLayer, session, config) {
                    if (!this.regExp) return;
                    var start = config.firstRow,
                        end = config.lastRow;

                    for (var i = start; i <= end; i++) {
                        var ranges = this.cache[i];
                        if (ranges == null) {
                            ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                            if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
                            ranges = ranges.map(function (match) {
                                return new Range(i, match.offset, i, match.offset + match.length);
                            });
                            this.cache[i] = ranges.length ? ranges : "";
                        }

                        for (var j = ranges.length; j--;) {
                            markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
                        }
                    }
                };
            }).call(SearchHighlight.prototype);

            exports.SearchHighlight = SearchHighlight;
        });

        ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            function FoldLine(foldData, folds) {
                this.foldData = foldData;
                if (Array.isArray(folds)) {
                    this.folds = folds;
                } else {
                    folds = this.folds = [folds];
                }

                var last = folds[folds.length - 1];
                this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
                this.start = this.range.start;
                this.end = this.range.end;

                this.folds.forEach(function (fold) {
                    fold.setFoldLine(this);
                }, this);
            }

            (function () {
                this.shiftRow = function (shift) {
                    this.start.row += shift;
                    this.end.row += shift;
                    this.folds.forEach(function (fold) {
                        fold.start.row += shift;
                        fold.end.row += shift;
                    });
                };

                this.addFold = function (fold) {
                    if (fold.sameRow) {
                        if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                            throw new Error("Can't add a fold to this FoldLine as it has no connection");
                        }
                        this.folds.push(fold);
                        this.folds.sort(function (a, b) {
                            return -a.range.compareEnd(b.start.row, b.start.column);
                        });
                        if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                            this.end.row = fold.end.row;
                            this.end.column = fold.end.column;
                        } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                            this.start.row = fold.start.row;
                            this.start.column = fold.start.column;
                        }
                    } else if (fold.start.row == this.end.row) {
                        this.folds.push(fold);
                        this.end.row = fold.end.row;
                        this.end.column = fold.end.column;
                    } else if (fold.end.row == this.start.row) {
                        this.folds.unshift(fold);
                        this.start.row = fold.start.row;
                        this.start.column = fold.start.column;
                    } else {
                        throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
                    }
                    fold.foldLine = this;
                };

                this.containsRow = function (row) {
                    return row >= this.start.row && row <= this.end.row;
                };

                this.walk = function (callback, endRow, endColumn) {
                    var lastEnd = 0,
                        folds = this.folds,
                        fold,
                        cmp,
                        stop,
                        isNewRow = true;

                    if (endRow == null) {
                        endRow = this.end.row;
                        endColumn = this.end.column;
                    }

                    for (var i = 0; i < folds.length; i++) {
                        fold = folds[i];

                        cmp = fold.range.compareStart(endRow, endColumn);
                        if (cmp == -1) {
                            callback(null, endRow, endColumn, lastEnd, isNewRow);
                            return;
                        }

                        stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                        stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                        if (stop || cmp === 0) {
                            return;
                        }
                        isNewRow = !fold.sameRow;
                        lastEnd = fold.end.column;
                    }
                    callback(null, endRow, endColumn, lastEnd, isNewRow);
                };

                this.getNextFoldTo = function (row, column) {
                    var fold, cmp;
                    for (var i = 0; i < this.folds.length; i++) {
                        fold = this.folds[i];
                        cmp = fold.range.compareEnd(row, column);
                        if (cmp == -1) {
                            return {
                                fold: fold,
                                kind: "after"
                            };
                        } else if (cmp === 0) {
                            return {
                                fold: fold,
                                kind: "inside"
                            };
                        }
                    }
                    return null;
                };

                this.addRemoveChars = function (row, column, len) {
                    var ret = this.getNextFoldTo(row, column),
                        fold,
                        folds;
                    if (ret) {
                        fold = ret.fold;
                        if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                            window.console && window.console.log(row, column, fold);
                        } else if (fold.start.row == row) {
                            folds = this.folds;
                            var i = folds.indexOf(fold);
                            if (i === 0) {
                                this.start.column += len;
                            }
                            for (i; i < folds.length; i++) {
                                fold = folds[i];
                                fold.start.column += len;
                                if (!fold.sameRow) {
                                    return;
                                }
                                fold.end.column += len;
                            }
                            this.end.column += len;
                        }
                    }
                };

                this.split = function (row, column) {
                    var pos = this.getNextFoldTo(row, column);

                    if (!pos || pos.kind == "inside") return null;

                    var fold = pos.fold;
                    var folds = this.folds;
                    var foldData = this.foldData;

                    var i = folds.indexOf(fold);
                    var foldBefore = folds[i - 1];
                    this.end.row = foldBefore.end.row;
                    this.end.column = foldBefore.end.column;
                    folds = folds.splice(i, folds.length - i);

                    var newFoldLine = new FoldLine(foldData, folds);
                    foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
                    return newFoldLine;
                };

                this.merge = function (foldLineNext) {
                    var folds = foldLineNext.folds;
                    for (var i = 0; i < folds.length; i++) {
                        this.addFold(folds[i]);
                    }
                    var foldData = this.foldData;
                    foldData.splice(foldData.indexOf(foldLineNext), 1);
                };

                this.toString = function () {
                    var ret = [this.range.toString() + ": ["];

                    this.folds.forEach(function (fold) {
                        ret.push("  " + fold.toString());
                    });
                    ret.push("]");
                    return ret.join("\n");
                };

                this.idxToPosition = function (idx) {
                    var lastFoldEndColumn = 0;

                    for (var i = 0; i < this.folds.length; i++) {
                        var fold = this.folds[i];

                        idx -= fold.start.column - lastFoldEndColumn;
                        if (idx < 0) {
                            return {
                                row: fold.start.row,
                                column: fold.start.column + idx
                            };
                        }

                        idx -= fold.placeholder.length;
                        if (idx < 0) {
                            return fold.start;
                        }

                        lastFoldEndColumn = fold.end.column;
                    }

                    return {
                        row: this.end.row,
                        column: this.end.column + idx
                    };
                };
            }).call(FoldLine.prototype);

            exports.FoldLine = FoldLine;
        });

        ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("./range").Range;
            var comparePoints = Range.comparePoints;

            var RangeList = function () {
                this.ranges = [];
            };

            (function () {
                this.comparePoints = comparePoints;

                this.pointIndex = function (pos, excludeEdges, startIndex) {
                    var list = this.ranges;

                    for (var i = startIndex || 0; i < list.length; i++) {
                        var range = list[i];
                        var cmpEnd = comparePoints(pos, range.end);
                        if (cmpEnd > 0) continue;
                        var cmpStart = comparePoints(pos, range.start);
                        if (cmpEnd === 0) return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                        if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) return i;

                        return -i - 1;
                    }
                    return -i - 1;
                };

                this.add = function (range) {
                    var excludeEdges = !range.isEmpty();
                    var startIndex = this.pointIndex(range.start, excludeEdges);
                    if (startIndex < 0) startIndex = -startIndex - 1;

                    var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

                    if (endIndex < 0) endIndex = -endIndex - 1;else endIndex++;
                    return this.ranges.splice(startIndex, endIndex - startIndex, range);
                };

                this.addList = function (list) {
                    var removed = [];
                    for (var i = list.length; i--;) {
                        removed.push.apply(removed, this.add(list[i]));
                    }
                    return removed;
                };

                this.substractPoint = function (pos) {
                    var i = this.pointIndex(pos);

                    if (i >= 0) return this.ranges.splice(i, 1);
                };
                this.merge = function () {
                    var removed = [];
                    var list = this.ranges;

                    list = list.sort(function (a, b) {
                        return comparePoints(a.start, b.start);
                    });

                    var next = list[0],
                        range;
                    for (var i = 1; i < list.length; i++) {
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;

                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;

                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }

                        list.splice(i, 1);
                        removed.push(next);
                        next = range;
                        i--;
                    }

                    this.ranges = list;

                    return removed;
                };

                this.contains = function (row, column) {
                    return this.pointIndex({ row: row, column: column }) >= 0;
                };

                this.containsPoint = function (pos) {
                    return this.pointIndex(pos) >= 0;
                };

                this.rangeAtPoint = function (pos) {
                    var i = this.pointIndex(pos);
                    if (i >= 0) return this.ranges[i];
                };

                this.clipRows = function (startRow, endRow) {
                    var list = this.ranges;
                    if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) return [];

                    var startIndex = this.pointIndex({ row: startRow, column: 0 });
                    if (startIndex < 0) startIndex = -startIndex - 1;
                    var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
                    if (endIndex < 0) endIndex = -endIndex - 1;

                    var clipped = [];
                    for (var i = startIndex; i < endIndex; i++) {
                        clipped.push(list[i]);
                    }
                    return clipped;
                };

                this.removeAll = function () {
                    return this.ranges.splice(0, this.ranges.length);
                };

                this.attach = function (session) {
                    if (this.session) this.detach();

                    this.session = session;
                    this.onChange = this.$onChange.bind(this);

                    this.session.on('change', this.onChange);
                };

                this.detach = function () {
                    if (!this.session) return;
                    this.session.removeListener('change', this.onChange);
                    this.session = null;
                };

                this.$onChange = function (delta) {
                    if (delta.action == "insert") {
                        var start = delta.start;
                        var end = delta.end;
                    } else {
                        var end = delta.start;
                        var start = delta.end;
                    }
                    var startRow = start.row;
                    var endRow = end.row;
                    var lineDif = endRow - startRow;

                    var colDiff = -start.column + end.column;
                    var ranges = this.ranges;

                    for (var i = 0, n = ranges.length; i < n; i++) {
                        var r = ranges[i];
                        if (r.end.row < startRow) continue;
                        if (r.start.row > startRow) break;

                        if (r.start.row == startRow && r.start.column >= start.column) {
                            if (r.start.column == start.column && this.$insertRight) {} else {
                                r.start.column += colDiff;
                                r.start.row += lineDif;
                            }
                        }
                        if (r.end.row == startRow && r.end.column >= start.column) {
                            if (r.end.column == start.column && this.$insertRight) {
                                continue;
                            }
                            if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) r.end.column -= colDiff;
                            }
                            r.end.column += colDiff;
                            r.end.row += lineDif;
                        }
                    }

                    if (lineDif != 0 && i < n) {
                        for (; i < n; i++) {
                            var r = ranges[i];
                            r.start.row += lineDif;
                            r.end.row += lineDif;
                        }
                    }
                };
            }).call(RangeList.prototype);

            exports.RangeList = RangeList;
        });

        ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var RangeList = require("../range_list").RangeList;
            var oop = require("../lib/oop");
            var Fold = exports.Fold = function (range, placeholder) {
                this.foldLine = null;
                this.placeholder = placeholder;
                this.range = range;
                this.start = range.start;
                this.end = range.end;

                this.sameRow = range.start.row == range.end.row;
                this.subFolds = this.ranges = [];
            };

            oop.inherits(Fold, RangeList);

            (function () {

                this.toString = function () {
                    return '"' + this.placeholder + '" ' + this.range.toString();
                };

                this.setFoldLine = function (foldLine) {
                    this.foldLine = foldLine;
                    this.subFolds.forEach(function (fold) {
                        fold.setFoldLine(foldLine);
                    });
                };

                this.clone = function () {
                    var range = this.range.clone();
                    var fold = new Fold(range, this.placeholder);
                    this.subFolds.forEach(function (subFold) {
                        fold.subFolds.push(subFold.clone());
                    });
                    fold.collapseChildren = this.collapseChildren;
                    return fold;
                };

                this.addSubFold = function (fold) {
                    if (this.range.isEqual(fold)) return;

                    if (!this.range.containsRange(fold)) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
                    consumeRange(fold, this.start);

                    var row = fold.start.row,
                        column = fold.start.column;
                    for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                        cmp = this.subFolds[i].range.compare(row, column);
                        if (cmp != 1) break;
                    }
                    var afterStart = this.subFolds[i];

                    if (cmp == 0) return afterStart.addSubFold(fold);
                    var row = fold.range.end.row,
                        column = fold.range.end.column;
                    for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                        cmp = this.subFolds[j].range.compare(row, column);
                        if (cmp != 1) break;
                    }
                    var afterEnd = this.subFolds[j];

                    if (cmp == 0) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

                    var consumedFolds = this.subFolds.splice(i, j - i, fold);
                    fold.setFoldLine(this.foldLine);

                    return fold;
                };

                this.restoreRange = function (range) {
                    return restoreRange(range, this.start);
                };
            }).call(Fold.prototype);

            function consumePoint(point, anchor) {
                point.row -= anchor.row;
                if (point.row == 0) point.column -= anchor.column;
            }
            function consumeRange(range, anchor) {
                consumePoint(range.start, anchor);
                consumePoint(range.end, anchor);
            }
            function restorePoint(point, anchor) {
                if (point.row == 0) point.column += anchor.column;
                point.row += anchor.row;
            }
            function restoreRange(range, anchor) {
                restorePoint(range.start, anchor);
                restorePoint(range.end, anchor);
            }
        });

        ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var FoldLine = require("./fold_line").FoldLine;
            var Fold = require("./fold").Fold;
            var TokenIterator = require("../token_iterator").TokenIterator;

            function Folding() {
                this.getFoldAt = function (row, column, side) {
                    var foldLine = this.getFoldLine(row);
                    if (!foldLine) return null;

                    var folds = foldLine.folds;
                    for (var i = 0; i < folds.length; i++) {
                        var fold = folds[i];
                        if (fold.range.contains(row, column)) {
                            if (side == 1 && fold.range.isEnd(row, column)) {
                                continue;
                            } else if (side == -1 && fold.range.isStart(row, column)) {
                                continue;
                            }
                            return fold;
                        }
                    }
                };
                this.getFoldsInRange = function (range) {
                    var start = range.start;
                    var end = range.end;
                    var foldLines = this.$foldData;
                    var foundFolds = [];

                    start.column += 1;
                    end.column -= 1;

                    for (var i = 0; i < foldLines.length; i++) {
                        var cmp = foldLines[i].range.compareRange(range);
                        if (cmp == 2) {
                            continue;
                        } else if (cmp == -2) {
                            break;
                        }

                        var folds = foldLines[i].folds;
                        for (var j = 0; j < folds.length; j++) {
                            var fold = folds[j];
                            cmp = fold.range.compareRange(range);
                            if (cmp == -2) {
                                break;
                            } else if (cmp == 2) {
                                continue;
                            } else if (cmp == 42) {
                                break;
                            }
                            foundFolds.push(fold);
                        }
                    }
                    start.column -= 1;
                    end.column += 1;

                    return foundFolds;
                };

                this.getFoldsInRangeList = function (ranges) {
                    if (Array.isArray(ranges)) {
                        var folds = [];
                        ranges.forEach(function (range) {
                            folds = folds.concat(this.getFoldsInRange(range));
                        }, this);
                    } else {
                        var folds = this.getFoldsInRange(ranges);
                    }
                    return folds;
                };
                this.getAllFolds = function () {
                    var folds = [];
                    var foldLines = this.$foldData;

                    for (var i = 0; i < foldLines.length; i++) for (var j = 0; j < foldLines[i].folds.length; j++) folds.push(foldLines[i].folds[j]);

                    return folds;
                };
                this.getFoldStringAt = function (row, column, trim, foldLine) {
                    foldLine = foldLine || this.getFoldLine(row);
                    if (!foldLine) return null;

                    var lastFold = {
                        end: { column: 0 }
                    };
                    var str, fold;
                    for (var i = 0; i < foldLine.folds.length; i++) {
                        fold = foldLine.folds[i];
                        var cmp = fold.range.compareEnd(row, column);
                        if (cmp == -1) {
                            str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                            break;
                        } else if (cmp === 0) {
                            return null;
                        }
                        lastFold = fold;
                    }
                    if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);

                    if (trim == -1) return str.substring(0, column - lastFold.end.column);else if (trim == 1) return str.substring(column - lastFold.end.column);else return str;
                };

                this.getFoldLine = function (docRow, startFoldLine) {
                    var foldData = this.$foldData;
                    var i = 0;
                    if (startFoldLine) i = foldData.indexOf(startFoldLine);
                    if (i == -1) i = 0;
                    for (i; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                            return foldLine;
                        } else if (foldLine.end.row > docRow) {
                            return null;
                        }
                    }
                    return null;
                };
                this.getNextFoldLine = function (docRow, startFoldLine) {
                    var foldData = this.$foldData;
                    var i = 0;
                    if (startFoldLine) i = foldData.indexOf(startFoldLine);
                    if (i == -1) i = 0;
                    for (i; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (foldLine.end.row >= docRow) {
                            return foldLine;
                        }
                    }
                    return null;
                };

                this.getFoldedRowCount = function (first, last) {
                    var foldData = this.$foldData,
                        rowCount = last - first + 1;
                    for (var i = 0; i < foldData.length; i++) {
                        var foldLine = foldData[i],
                            end = foldLine.end.row,
                            start = foldLine.start.row;
                        if (end >= last) {
                            if (start < last) {
                                if (start >= first) rowCount -= last - start;else rowCount = 0; // in one fold
                            }
                            break;
                        } else if (end >= first) {
                            if (start >= first) // fold inside range
                                rowCount -= end - start;else rowCount -= end - first + 1;
                        }
                    }
                    return rowCount;
                };

                this.$addFoldLine = function (foldLine) {
                    this.$foldData.push(foldLine);
                    this.$foldData.sort(function (a, b) {
                        return a.start.row - b.start.row;
                    });
                    return foldLine;
                };
                this.addFold = function (placeholder, range) {
                    var foldData = this.$foldData;
                    var added = false;
                    var fold;

                    if (placeholder instanceof Fold) fold = placeholder;else {
                        fold = new Fold(range, placeholder);
                        fold.collapseChildren = range.collapseChildren;
                    }
                    this.$clipRangeToDocument(fold.range);

                    var startRow = fold.start.row;
                    var startColumn = fold.start.column;
                    var endRow = fold.end.row;
                    var endColumn = fold.end.column;
                    if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2)) throw new Error("The range has to be at least 2 characters width");

                    var startFold = this.getFoldAt(startRow, startColumn, 1);
                    var endFold = this.getFoldAt(endRow, endColumn, -1);
                    if (startFold && endFold == startFold) return startFold.addSubFold(fold);

                    if (startFold && !startFold.range.isStart(startRow, startColumn)) this.removeFold(startFold);

                    if (endFold && !endFold.range.isEnd(endRow, endColumn)) this.removeFold(endFold);
                    var folds = this.getFoldsInRange(fold.range);
                    if (folds.length > 0) {
                        this.removeFolds(folds);
                        folds.forEach(function (subFold) {
                            fold.addSubFold(subFold);
                        });
                    }

                    for (var i = 0; i < foldData.length; i++) {
                        var foldLine = foldData[i];
                        if (endRow == foldLine.start.row) {
                            foldLine.addFold(fold);
                            added = true;
                            break;
                        } else if (startRow == foldLine.end.row) {
                            foldLine.addFold(fold);
                            added = true;
                            if (!fold.sameRow) {
                                var foldLineNext = foldData[i + 1];
                                if (foldLineNext && foldLineNext.start.row == endRow) {
                                    foldLine.merge(foldLineNext);
                                    break;
                                }
                            }
                            break;
                        } else if (endRow <= foldLine.start.row) {
                            break;
                        }
                    }

                    if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

                    if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
                    this.$modified = true;
                    this._signal("changeFold", { data: fold, action: "add" });

                    return fold;
                };

                this.addFolds = function (folds) {
                    folds.forEach(function (fold) {
                        this.addFold(fold);
                    }, this);
                };

                this.removeFold = function (fold) {
                    var foldLine = fold.foldLine;
                    var startRow = foldLine.start.row;
                    var endRow = foldLine.end.row;

                    var foldLines = this.$foldData;
                    var folds = foldLine.folds;
                    if (folds.length == 1) {
                        foldLines.splice(foldLines.indexOf(foldLine), 1);
                    } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                        folds.pop();
                        foldLine.end.row = folds[folds.length - 1].end.row;
                        foldLine.end.column = folds[folds.length - 1].end.column;
                    } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                        folds.shift();
                        foldLine.start.row = folds[0].start.row;
                        foldLine.start.column = folds[0].start.column;
                    } else if (fold.sameRow) {
                        folds.splice(folds.indexOf(fold), 1);
                    } else {
                        var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                        folds = newFoldLine.folds;
                        folds.shift();
                        newFoldLine.start.row = folds[0].start.row;
                        newFoldLine.start.column = folds[0].start.column;
                    }

                    if (!this.$updating) {
                        if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);else this.$updateRowLengthCache(startRow, endRow);
                    }
                    this.$modified = true;
                    this._signal("changeFold", { data: fold, action: "remove" });
                };

                this.removeFolds = function (folds) {
                    var cloneFolds = [];
                    for (var i = 0; i < folds.length; i++) {
                        cloneFolds.push(folds[i]);
                    }

                    cloneFolds.forEach(function (fold) {
                        this.removeFold(fold);
                    }, this);
                    this.$modified = true;
                };

                this.expandFold = function (fold) {
                    this.removeFold(fold);
                    fold.subFolds.forEach(function (subFold) {
                        fold.restoreRange(subFold);
                        this.addFold(subFold);
                    }, this);
                    if (fold.collapseChildren > 0) {
                        this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
                    }
                    fold.subFolds = [];
                };

                this.expandFolds = function (folds) {
                    folds.forEach(function (fold) {
                        this.expandFold(fold);
                    }, this);
                };

                this.unfold = function (location, expandInner) {
                    var range, folds;
                    if (location == null) {
                        range = new Range(0, 0, this.getLength(), 0);
                        expandInner = true;
                    } else if (typeof location == "number") range = new Range(location, 0, location, this.getLine(location).length);else if ("row" in location) range = Range.fromPoints(location, location);else range = location;

                    folds = this.getFoldsInRangeList(range);
                    if (expandInner) {
                        this.removeFolds(folds);
                    } else {
                        var subFolds = folds;
                        while (subFolds.length) {
                            this.expandFolds(subFolds);
                            subFolds = this.getFoldsInRangeList(range);
                        }
                    }
                    if (folds.length) return folds;
                };
                this.isRowFolded = function (docRow, startFoldRow) {
                    return !!this.getFoldLine(docRow, startFoldRow);
                };

                this.getRowFoldEnd = function (docRow, startFoldRow) {
                    var foldLine = this.getFoldLine(docRow, startFoldRow);
                    return foldLine ? foldLine.end.row : docRow;
                };

                this.getRowFoldStart = function (docRow, startFoldRow) {
                    var foldLine = this.getFoldLine(docRow, startFoldRow);
                    return foldLine ? foldLine.start.row : docRow;
                };

                this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
                    if (startRow == null) startRow = foldLine.start.row;
                    if (startColumn == null) startColumn = 0;
                    if (endRow == null) endRow = foldLine.end.row;
                    if (endColumn == null) endColumn = this.getLine(endRow).length;
                    var doc = this.doc;
                    var textLine = "";

                    foldLine.walk(function (placeholder, row, column, lastColumn) {
                        if (row < startRow) return;
                        if (row == startRow) {
                            if (column < startColumn) return;
                            lastColumn = Math.max(startColumn, lastColumn);
                        }

                        if (placeholder != null) {
                            textLine += placeholder;
                        } else {
                            textLine += doc.getLine(row).substring(lastColumn, column);
                        }
                    }, endRow, endColumn);
                    return textLine;
                };

                this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
                    var foldLine = this.getFoldLine(row);

                    if (!foldLine) {
                        var line;
                        line = this.doc.getLine(row);
                        return line.substring(startColumn || 0, endColumn || line.length);
                    } else {
                        return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
                    }
                };

                this.$cloneFoldData = function () {
                    var fd = [];
                    fd = this.$foldData.map(function (foldLine) {
                        var folds = foldLine.folds.map(function (fold) {
                            return fold.clone();
                        });
                        return new FoldLine(fd, folds);
                    });

                    return fd;
                };

                this.toggleFold = function (tryToUnfold) {
                    var selection = this.selection;
                    var range = selection.getRange();
                    var fold;
                    var bracketPos;

                    if (range.isEmpty()) {
                        var cursor = range.start;
                        fold = this.getFoldAt(cursor.row, cursor.column);

                        if (fold) {
                            this.expandFold(fold);
                            return;
                        } else if (bracketPos = this.findMatchingBracket(cursor)) {
                            if (range.comparePoint(bracketPos) == 1) {
                                range.end = bracketPos;
                            } else {
                                range.start = bracketPos;
                                range.start.column++;
                                range.end.column--;
                            }
                        } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                            if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;else range.start = bracketPos;

                            range.start.column++;
                        } else {
                            range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                        }
                    } else {
                        var folds = this.getFoldsInRange(range);
                        if (tryToUnfold && folds.length) {
                            this.expandFolds(folds);
                            return;
                        } else if (folds.length == 1) {
                            fold = folds[0];
                        }
                    }

                    if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);

                    if (fold && fold.range.toString() == range.toString()) {
                        this.expandFold(fold);
                        return;
                    }

                    var placeholder = "...";
                    if (!range.isMultiLine()) {
                        placeholder = this.getTextRange(range);
                        if (placeholder.length < 4) return;
                        placeholder = placeholder.trim().substring(0, 2) + "..";
                    }

                    this.addFold(placeholder, range);
                };

                this.getCommentFoldRange = function (row, column, dir) {
                    var iterator = new TokenIterator(this, row, column);
                    var token = iterator.getCurrentToken();
                    if (token && /^comment|string/.test(token.type)) {
                        var range = new Range();
                        var re = new RegExp(token.type.replace(/\..*/, "\\."));
                        if (dir != 1) {
                            do {
                                token = iterator.stepBackward();
                            } while (token && re.test(token.type));
                            iterator.stepForward();
                        }

                        range.start.row = iterator.getCurrentTokenRow();
                        range.start.column = iterator.getCurrentTokenColumn() + 2;

                        iterator = new TokenIterator(this, row, column);

                        if (dir != -1) {
                            do {
                                token = iterator.stepForward();
                            } while (token && re.test(token.type));
                            token = iterator.stepBackward();
                        } else token = iterator.getCurrentToken();

                        range.end.row = iterator.getCurrentTokenRow();
                        range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                        return range;
                    }
                };

                this.foldAll = function (startRow, endRow, depth) {
                    if (depth == undefined) depth = 100000; // JSON.stringify doesn't hanle Infinity
                    var foldWidgets = this.foldWidgets;
                    if (!foldWidgets) return; // mode doesn't support folding
                    endRow = endRow || this.getLength();
                    startRow = startRow || 0;
                    for (var row = startRow; row < endRow; row++) {
                        if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
                        if (foldWidgets[row] != "start") continue;

                        var range = this.getFoldWidgetRange(row);
                        if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                            row = range.end.row;
                            try {
                                var fold = this.addFold("...", range);
                                if (fold) fold.collapseChildren = depth;
                            } catch (e) {}
                        }
                    }
                };
                this.$foldStyles = {
                    "manual": 1,
                    "markbegin": 1,
                    "markbeginend": 1
                };
                this.$foldStyle = "markbegin";
                this.setFoldStyle = function (style) {
                    if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");

                    if (this.$foldStyle == style) return;

                    this.$foldStyle = style;

                    if (style == "manual") this.unfold();
                    var mode = this.$foldMode;
                    this.$setFolding(null);
                    this.$setFolding(mode);
                };

                this.$setFolding = function (foldMode) {
                    if (this.$foldMode == foldMode) return;

                    this.$foldMode = foldMode;

                    this.off('change', this.$updateFoldWidgets);
                    this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
                    this._signal("changeAnnotation");

                    if (!foldMode || this.$foldStyle == "manual") {
                        this.foldWidgets = null;
                        return;
                    }

                    this.foldWidgets = [];
                    this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
                    this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);

                    this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
                    this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
                    this.on('change', this.$updateFoldWidgets);
                    this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
                };

                this.getParentFoldRangeData = function (row, ignoreCurrent) {
                    var fw = this.foldWidgets;
                    if (!fw || ignoreCurrent && fw[row]) return {};

                    var i = row - 1,
                        firstRange;
                    while (i >= 0) {
                        var c = fw[i];
                        if (c == null) c = fw[i] = this.getFoldWidget(i);

                        if (c == "start") {
                            var range = this.getFoldWidgetRange(i);
                            if (!firstRange) firstRange = range;
                            if (range && range.end.row >= row) break;
                        }
                        i--;
                    }

                    return {
                        range: i !== -1 && range,
                        firstRange: firstRange
                    };
                };

                this.onFoldWidgetClick = function (row, e) {
                    e = e.domEvent;
                    var options = {
                        children: e.shiftKey,
                        all: e.ctrlKey || e.metaKey,
                        siblings: e.altKey
                    };

                    var range = this.$toggleFoldWidget(row, options);
                    if (!range) {
                        var el = e.target || e.srcElement;
                        if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
                    }
                };

                this.$toggleFoldWidget = function (row, options) {
                    if (!this.getFoldWidget) return;
                    var type = this.getFoldWidget(row);
                    var line = this.getLine(row);

                    var dir = type === "end" ? -1 : 1;
                    var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

                    if (fold) {
                        if (options.children || options.all) this.removeFold(fold);else this.expandFold(fold);
                        return fold;
                    }

                    var range = this.getFoldWidgetRange(row, true);
                    if (range && !range.isMultiLine()) {
                        fold = this.getFoldAt(range.start.row, range.start.column, 1);
                        if (fold && range.isEqual(fold.range)) {
                            this.removeFold(fold);
                            return fold;
                        }
                    }

                    if (options.siblings) {
                        var data = this.getParentFoldRangeData(row);
                        if (data.range) {
                            var startRow = data.range.start.row + 1;
                            var endRow = data.range.end.row;
                        }
                        this.foldAll(startRow, endRow, options.all ? 10000 : 0);
                    } else if (options.children) {
                        endRow = range ? range.end.row : this.getLength();
                        this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
                    } else if (range) {
                        if (options.all) range.collapseChildren = 10000;
                        this.addFold("...", range);
                    }

                    return range;
                };

                this.toggleFoldWidget = function (toggleParent) {
                    var row = this.selection.getCursor().row;
                    row = this.getRowFoldStart(row);
                    var range = this.$toggleFoldWidget(row, {});

                    if (range) return;
                    var data = this.getParentFoldRangeData(row, true);
                    range = data.range || data.firstRange;

                    if (range) {
                        row = range.start.row;
                        var fold = this.getFoldAt(row, this.getLine(row).length, 1);

                        if (fold) {
                            this.removeFold(fold);
                        } else {
                            this.addFold("...", range);
                        }
                    }
                };

                this.updateFoldWidgets = function (delta) {
                    var firstRow = delta.start.row;
                    var len = delta.end.row - firstRow;

                    if (len === 0) {
                        this.foldWidgets[firstRow] = null;
                    } else if (delta.action == 'remove') {
                        this.foldWidgets.splice(firstRow, len + 1, null);
                    } else {
                        var args = Array(len + 1);
                        args.unshift(firstRow, 1);
                        this.foldWidgets.splice.apply(this.foldWidgets, args);
                    }
                };
                this.tokenizerUpdateFoldWidgets = function (e) {
                    var rows = e.data;
                    if (rows.first != rows.last) {
                        if (this.foldWidgets.length > rows.first) this.foldWidgets.splice(rows.first, this.foldWidgets.length);
                    }
                };
            }

            exports.Folding = Folding;
        });

        ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function (require, exports, module) {
            "use strict";

            var TokenIterator = require("../token_iterator").TokenIterator;
            var Range = require("../range").Range;

            function BracketMatch() {

                this.findMatchingBracket = function (position, chr) {
                    if (position.column == 0) return null;

                    var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
                    if (charBeforeCursor == "") return null;

                    var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
                    if (!match) return null;

                    if (match[1]) return this.$findClosingBracket(match[1], position);else return this.$findOpeningBracket(match[2], position);
                };

                this.getBracketRange = function (pos) {
                    var line = this.getLine(pos.row);
                    var before = true,
                        range;

                    var chr = line.charAt(pos.column - 1);
                    var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                    if (!match) {
                        chr = line.charAt(pos.column);
                        pos = { row: pos.row, column: pos.column + 1 };
                        match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                        before = false;
                    }
                    if (!match) return null;

                    if (match[1]) {
                        var bracketPos = this.$findClosingBracket(match[1], pos);
                        if (!bracketPos) return null;
                        range = Range.fromPoints(pos, bracketPos);
                        if (!before) {
                            range.end.column++;
                            range.start.column--;
                        }
                        range.cursor = range.end;
                    } else {
                        var bracketPos = this.$findOpeningBracket(match[2], pos);
                        if (!bracketPos) return null;
                        range = Range.fromPoints(bracketPos, pos);
                        if (!before) {
                            range.start.column++;
                            range.end.column--;
                        }
                        range.cursor = range.start;
                    }

                    return range;
                };

                this.$brackets = {
                    ")": "(",
                    "(": ")",
                    "]": "[",
                    "[": "]",
                    "{": "}",
                    "}": "{"
                };

                this.$findOpeningBracket = function (bracket, position, typeRe) {
                    var openBracket = this.$brackets[bracket];
                    var depth = 1;

                    var iterator = new TokenIterator(this, position.row, position.column);
                    var token = iterator.getCurrentToken();
                    if (!token) token = iterator.stepForward();
                    if (!token) return;

                    if (!typeRe) {
                        typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+");
                    }
                    var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
                    var value = token.value;

                    while (true) {

                        while (valueIndex >= 0) {
                            var chr = value.charAt(valueIndex);
                            if (chr == openBracket) {
                                depth -= 1;
                                if (depth == 0) {
                                    return { row: iterator.getCurrentTokenRow(),
                                        column: valueIndex + iterator.getCurrentTokenColumn() };
                                }
                            } else if (chr == bracket) {
                                depth += 1;
                            }
                            valueIndex -= 1;
                        }
                        do {
                            token = iterator.stepBackward();
                        } while (token && !typeRe.test(token.type));

                        if (token == null) break;

                        value = token.value;
                        valueIndex = value.length - 1;
                    }

                    return null;
                };

                this.$findClosingBracket = function (bracket, position, typeRe) {
                    var closingBracket = this.$brackets[bracket];
                    var depth = 1;

                    var iterator = new TokenIterator(this, position.row, position.column);
                    var token = iterator.getCurrentToken();
                    if (!token) token = iterator.stepForward();
                    if (!token) return;

                    if (!typeRe) {
                        typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+");
                    }
                    var valueIndex = position.column - iterator.getCurrentTokenColumn();

                    while (true) {

                        var value = token.value;
                        var valueLength = value.length;
                        while (valueIndex < valueLength) {
                            var chr = value.charAt(valueIndex);
                            if (chr == closingBracket) {
                                depth -= 1;
                                if (depth == 0) {
                                    return { row: iterator.getCurrentTokenRow(),
                                        column: valueIndex + iterator.getCurrentTokenColumn() };
                                }
                            } else if (chr == bracket) {
                                depth += 1;
                            }
                            valueIndex += 1;
                        }
                        do {
                            token = iterator.stepForward();
                        } while (token && !typeRe.test(token.type));

                        if (token == null) break;

                        valueIndex = 0;
                    }

                    return null;
                };
            }
            exports.BracketMatch = BracketMatch;
        });

        ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var lang = require("./lib/lang");
            var config = require("./config");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var Selection = require("./selection").Selection;
            var TextMode = require("./mode/text").Mode;
            var Range = require("./range").Range;
            var Document = require("./document").Document;
            var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
            var SearchHighlight = require("./search_highlight").SearchHighlight;

            var EditSession = function (text, mode) {
                this.$breakpoints = [];
                this.$decorations = [];
                this.$frontMarkers = {};
                this.$backMarkers = {};
                this.$markerId = 1;
                this.$undoSelect = true;

                this.$foldData = [];
                this.id = "session" + ++EditSession.$uid;
                this.$foldData.toString = function () {
                    return this.join("\n");
                };
                this.on("changeFold", this.onChangeFold.bind(this));
                this.$onChange = this.onChange.bind(this);

                if (typeof text != "object" || !text.getLine) text = new Document(text);

                this.setDocument(text);
                this.selection = new Selection(this);

                config.resetOptions(this);
                this.setMode(mode);
                config._signal("session", this);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setDocument = function (doc) {
                    if (this.doc) this.doc.removeListener("change", this.$onChange);

                    this.doc = doc;
                    doc.on("change", this.$onChange);

                    if (this.bgTokenizer) this.bgTokenizer.setDocument(this.getDocument());

                    this.resetCaches();
                };
                this.getDocument = function () {
                    return this.doc;
                };
                this.$resetRowCache = function (docRow) {
                    if (!docRow) {
                        this.$docRowCache = [];
                        this.$screenRowCache = [];
                        return;
                    }
                    var l = this.$docRowCache.length;
                    var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
                    if (l > i) {
                        this.$docRowCache.splice(i, l);
                        this.$screenRowCache.splice(i, l);
                    }
                };

                this.$getRowCacheIndex = function (cacheArray, val) {
                    var low = 0;
                    var hi = cacheArray.length - 1;

                    while (low <= hi) {
                        var mid = low + hi >> 1;
                        var c = cacheArray[mid];

                        if (val > c) low = mid + 1;else if (val < c) hi = mid - 1;else return mid;
                    }

                    return low - 1;
                };

                this.resetCaches = function () {
                    this.$modified = true;
                    this.$wrapData = [];
                    this.$rowLengthCache = [];
                    this.$resetRowCache(0);
                    if (this.bgTokenizer) this.bgTokenizer.start(0);
                };

                this.onChangeFold = function (e) {
                    var fold = e.data;
                    this.$resetRowCache(fold.start.row);
                };

                this.onChange = function (delta) {
                    this.$modified = true;

                    this.$resetRowCache(delta.start.row);

                    var removedFolds = this.$updateInternalDataOnChange(delta);
                    if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
                        this.$deltasDoc.push(delta);
                        if (removedFolds && removedFolds.length != 0) {
                            this.$deltasFold.push({
                                action: "removeFolds",
                                folds: removedFolds
                            });
                        }

                        this.$informUndoManager.schedule();
                    }

                    this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
                    this._signal("change", delta);
                };
                this.setValue = function (text) {
                    this.doc.setValue(text);
                    this.selection.moveTo(0, 0);

                    this.$resetRowCache(0);
                    this.$deltas = [];
                    this.$deltasDoc = [];
                    this.$deltasFold = [];
                    this.setUndoManager(this.$undoManager);
                    this.getUndoManager().reset();
                };
                this.getValue = this.toString = function () {
                    return this.doc.getValue();
                };
                this.getSelection = function () {
                    return this.selection;
                };
                this.getState = function (row) {
                    return this.bgTokenizer.getState(row);
                };
                this.getTokens = function (row) {
                    return this.bgTokenizer.getTokens(row);
                };
                this.getTokenAt = function (row, column) {
                    var tokens = this.bgTokenizer.getTokens(row);
                    var token,
                        c = 0;
                    if (column == null) {
                        i = tokens.length - 1;
                        c = this.getLine(row).length;
                    } else {
                        for (var i = 0; i < tokens.length; i++) {
                            c += tokens[i].value.length;
                            if (c >= column) break;
                        }
                    }
                    token = tokens[i];
                    if (!token) return null;
                    token.index = i;
                    token.start = c - token.value.length;
                    return token;
                };
                this.setUndoManager = function (undoManager) {
                    this.$undoManager = undoManager;
                    this.$deltas = [];
                    this.$deltasDoc = [];
                    this.$deltasFold = [];

                    if (this.$informUndoManager) this.$informUndoManager.cancel();

                    if (undoManager) {
                        var self = this;

                        this.$syncInformUndoManager = function () {
                            self.$informUndoManager.cancel();

                            if (self.$deltasFold.length) {
                                self.$deltas.push({
                                    group: "fold",
                                    deltas: self.$deltasFold
                                });
                                self.$deltasFold = [];
                            }

                            if (self.$deltasDoc.length) {
                                self.$deltas.push({
                                    group: "doc",
                                    deltas: self.$deltasDoc
                                });
                                self.$deltasDoc = [];
                            }

                            if (self.$deltas.length > 0) {
                                undoManager.execute({
                                    action: "aceupdate",
                                    args: [self.$deltas, self],
                                    merge: self.mergeUndoDeltas
                                });
                            }
                            self.mergeUndoDeltas = false;
                            self.$deltas = [];
                        };
                        this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
                    }
                };
                this.markUndoGroup = function () {
                    if (this.$syncInformUndoManager) this.$syncInformUndoManager();
                };

                this.$defaultUndoManager = {
                    undo: function () {},
                    redo: function () {},
                    reset: function () {}
                };
                this.getUndoManager = function () {
                    return this.$undoManager || this.$defaultUndoManager;
                };
                this.getTabString = function () {
                    if (this.getUseSoftTabs()) {
                        return lang.stringRepeat(" ", this.getTabSize());
                    } else {
                        return "\t";
                    }
                };
                this.setUseSoftTabs = function (val) {
                    this.setOption("useSoftTabs", val);
                };
                this.getUseSoftTabs = function () {
                    return this.$useSoftTabs && !this.$mode.$indentWithTabs;
                };
                this.setTabSize = function (tabSize) {
                    this.setOption("tabSize", tabSize);
                };
                this.getTabSize = function () {
                    return this.$tabSize;
                };
                this.isTabStop = function (position) {
                    return this.$useSoftTabs && position.column % this.$tabSize === 0;
                };

                this.$overwrite = false;
                this.setOverwrite = function (overwrite) {
                    this.setOption("overwrite", overwrite);
                };
                this.getOverwrite = function () {
                    return this.$overwrite;
                };
                this.toggleOverwrite = function () {
                    this.setOverwrite(!this.$overwrite);
                };
                this.addGutterDecoration = function (row, className) {
                    if (!this.$decorations[row]) this.$decorations[row] = "";
                    this.$decorations[row] += " " + className;
                    this._signal("changeBreakpoint", {});
                };
                this.removeGutterDecoration = function (row, className) {
                    this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
                    this._signal("changeBreakpoint", {});
                };
                this.getBreakpoints = function () {
                    return this.$breakpoints;
                };
                this.setBreakpoints = function (rows) {
                    this.$breakpoints = [];
                    for (var i = 0; i < rows.length; i++) {
                        this.$breakpoints[rows[i]] = "ace_breakpoint";
                    }
                    this._signal("changeBreakpoint", {});
                };
                this.clearBreakpoints = function () {
                    this.$breakpoints = [];
                    this._signal("changeBreakpoint", {});
                };
                this.setBreakpoint = function (row, className) {
                    if (className === undefined) className = "ace_breakpoint";
                    if (className) this.$breakpoints[row] = className;else delete this.$breakpoints[row];
                    this._signal("changeBreakpoint", {});
                };
                this.clearBreakpoint = function (row) {
                    delete this.$breakpoints[row];
                    this._signal("changeBreakpoint", {});
                };
                this.addMarker = function (range, clazz, type, inFront) {
                    var id = this.$markerId++;

                    var marker = {
                        range: range,
                        type: type || "line",
                        renderer: typeof type == "function" ? type : null,
                        clazz: clazz,
                        inFront: !!inFront,
                        id: id
                    };

                    if (inFront) {
                        this.$frontMarkers[id] = marker;
                        this._signal("changeFrontMarker");
                    } else {
                        this.$backMarkers[id] = marker;
                        this._signal("changeBackMarker");
                    }

                    return id;
                };
                this.addDynamicMarker = function (marker, inFront) {
                    if (!marker.update) return;
                    var id = this.$markerId++;
                    marker.id = id;
                    marker.inFront = !!inFront;

                    if (inFront) {
                        this.$frontMarkers[id] = marker;
                        this._signal("changeFrontMarker");
                    } else {
                        this.$backMarkers[id] = marker;
                        this._signal("changeBackMarker");
                    }

                    return marker;
                };
                this.removeMarker = function (markerId) {
                    var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
                    if (!marker) return;

                    var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
                    if (marker) {
                        delete markers[markerId];
                        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
                    }
                };
                this.getMarkers = function (inFront) {
                    return inFront ? this.$frontMarkers : this.$backMarkers;
                };

                this.highlight = function (re) {
                    if (!this.$searchHighlight) {
                        var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                        this.$searchHighlight = this.addDynamicMarker(highlight);
                    }
                    this.$searchHighlight.setRegexp(re);
                };
                this.highlightLines = function (startRow, endRow, clazz, inFront) {
                    if (typeof endRow != "number") {
                        clazz = endRow;
                        endRow = startRow;
                    }
                    if (!clazz) clazz = "ace_step";

                    var range = new Range(startRow, 0, endRow, Infinity);
                    range.id = this.addMarker(range, clazz, "fullLine", inFront);
                    return range;
                };
                this.setAnnotations = function (annotations) {
                    this.$annotations = annotations;
                    this._signal("changeAnnotation", {});
                };
                this.getAnnotations = function () {
                    return this.$annotations || [];
                };
                this.clearAnnotations = function () {
                    this.setAnnotations([]);
                };
                this.$detectNewLine = function (text) {
                    var match = text.match(/^.*?(\r?\n)/m);
                    if (match) {
                        this.$autoNewLine = match[1];
                    } else {
                        this.$autoNewLine = "\n";
                    }
                };
                this.getWordRange = function (row, column) {
                    var line = this.getLine(row);

                    var inToken = false;
                    if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);

                    if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);

                    if (inToken) var re = this.tokenRe;else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;else var re = this.nonTokenRe;

                    var start = column;
                    if (start > 0) {
                        do {
                            start--;
                        } while (start >= 0 && line.charAt(start).match(re));
                        start++;
                    }

                    var end = column;
                    while (end < line.length && line.charAt(end).match(re)) {
                        end++;
                    }

                    return new Range(row, start, row, end);
                };
                this.getAWordRange = function (row, column) {
                    var wordRange = this.getWordRange(row, column);
                    var line = this.getLine(wordRange.end.row);

                    while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                        wordRange.end.column += 1;
                    }
                    return wordRange;
                };
                this.setNewLineMode = function (newLineMode) {
                    this.doc.setNewLineMode(newLineMode);
                };
                this.getNewLineMode = function () {
                    return this.doc.getNewLineMode();
                };
                this.setUseWorker = function (useWorker) {
                    this.setOption("useWorker", useWorker);
                };
                this.getUseWorker = function () {
                    return this.$useWorker;
                };
                this.onReloadTokenizer = function (e) {
                    var rows = e.data;
                    this.bgTokenizer.start(rows.first);
                    this._signal("tokenizerUpdate", e);
                };

                this.$modes = {};
                this.$mode = null;
                this.$modeId = null;
                this.setMode = function (mode, cb) {
                    if (mode && typeof mode === "object") {
                        if (mode.getTokenizer) return this.$onChangeMode(mode);
                        var options = mode;
                        var path = options.path;
                    } else {
                        path = mode || "ace/mode/text";
                    }
                    if (!this.$modes["ace/mode/text"]) this.$modes["ace/mode/text"] = new TextMode();

                    if (this.$modes[path] && !options) {
                        this.$onChangeMode(this.$modes[path]);
                        cb && cb();
                        return;
                    }
                    this.$modeId = path;
                    config.loadModule(["mode", path], function (m) {
                        if (this.$modeId !== path) return cb && cb();
                        if (this.$modes[path] && !options) {
                            this.$onChangeMode(this.$modes[path]);
                        } else if (m && m.Mode) {
                            m = new m.Mode(options);
                            if (!options) {
                                this.$modes[path] = m;
                                m.$id = path;
                            }
                            this.$onChangeMode(m);
                        }
                        cb && cb();
                    }.bind(this));
                    if (!this.$mode) this.$onChangeMode(this.$modes["ace/mode/text"], true);
                };

                this.$onChangeMode = function (mode, $isPlaceholder) {
                    if (!$isPlaceholder) this.$modeId = mode.$id;
                    if (this.$mode === mode) return;

                    this.$mode = mode;

                    this.$stopWorker();

                    if (this.$useWorker) this.$startWorker();

                    var tokenizer = mode.getTokenizer();

                    if (tokenizer.addEventListener !== undefined) {
                        var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                        tokenizer.addEventListener("update", onReloadTokenizer);
                    }

                    if (!this.bgTokenizer) {
                        this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                        var _self = this;
                        this.bgTokenizer.addEventListener("update", function (e) {
                            _self._signal("tokenizerUpdate", e);
                        });
                    } else {
                        this.bgTokenizer.setTokenizer(tokenizer);
                    }

                    this.bgTokenizer.setDocument(this.getDocument());

                    this.tokenRe = mode.tokenRe;
                    this.nonTokenRe = mode.nonTokenRe;

                    if (!$isPlaceholder) {
                        if (mode.attachToSession) mode.attachToSession(this);
                        this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                        this.$setFolding(mode.foldingRules);
                        this.bgTokenizer.start(0);
                        this._emit("changeMode");
                    }
                };

                this.$stopWorker = function () {
                    if (this.$worker) {
                        this.$worker.terminate();
                        this.$worker = null;
                    }
                };

                this.$startWorker = function () {
                    try {
                        this.$worker = this.$mode.createWorker(this);
                    } catch (e) {
                        config.warn("Could not load worker", e);
                        this.$worker = null;
                    }
                };
                this.getMode = function () {
                    return this.$mode;
                };

                this.$scrollTop = 0;
                this.setScrollTop = function (scrollTop) {
                    if (this.$scrollTop === scrollTop || isNaN(scrollTop)) return;

                    this.$scrollTop = scrollTop;
                    this._signal("changeScrollTop", scrollTop);
                };
                this.getScrollTop = function () {
                    return this.$scrollTop;
                };

                this.$scrollLeft = 0;
                this.setScrollLeft = function (scrollLeft) {
                    if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;

                    this.$scrollLeft = scrollLeft;
                    this._signal("changeScrollLeft", scrollLeft);
                };
                this.getScrollLeft = function () {
                    return this.$scrollLeft;
                };
                this.getScreenWidth = function () {
                    this.$computeWidth();
                    if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
                    return this.screenWidth;
                };

                this.getLineWidgetMaxWidth = function () {
                    if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
                    var width = 0;
                    this.lineWidgets.forEach(function (w) {
                        if (w && w.screenWidth > width) width = w.screenWidth;
                    });
                    return this.lineWidgetWidth = width;
                };

                this.$computeWidth = function (force) {
                    if (this.$modified || force) {
                        this.$modified = false;

                        if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;

                        var lines = this.doc.getAllLines();
                        var cache = this.$rowLengthCache;
                        var longestScreenLine = 0;
                        var foldIndex = 0;
                        var foldLine = this.$foldData[foldIndex];
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        var len = lines.length;

                        for (var i = 0; i < len; i++) {
                            if (i > foldStart) {
                                i = foldLine.end.row + 1;
                                if (i >= len) break;
                                foldLine = this.$foldData[foldIndex++];
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }

                            if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];

                            if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
                        }
                        this.screenWidth = longestScreenLine;
                    }
                };
                this.getLine = function (row) {
                    return this.doc.getLine(row);
                };
                this.getLines = function (firstRow, lastRow) {
                    return this.doc.getLines(firstRow, lastRow);
                };
                this.getLength = function () {
                    return this.doc.getLength();
                };
                this.getTextRange = function (range) {
                    return this.doc.getTextRange(range || this.selection.getRange());
                };
                this.insert = function (position, text) {
                    return this.doc.insert(position, text);
                };
                this.remove = function (range) {
                    return this.doc.remove(range);
                };
                this.removeFullLines = function (firstRow, lastRow) {
                    return this.doc.removeFullLines(firstRow, lastRow);
                };
                this.undoChanges = function (deltas, dontSelect) {
                    if (!deltas.length) return;

                    this.$fromUndo = true;
                    var lastUndoRange = null;
                    for (var i = deltas.length - 1; i != -1; i--) {
                        var delta = deltas[i];
                        if (delta.group == "doc") {
                            this.doc.revertDeltas(delta.deltas);
                            lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
                        } else {
                            delta.deltas.forEach(function (foldDelta) {
                                this.addFolds(foldDelta.folds);
                            }, this);
                        }
                    }
                    this.$fromUndo = false;
                    lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                    return lastUndoRange;
                };
                this.redoChanges = function (deltas, dontSelect) {
                    if (!deltas.length) return;

                    this.$fromUndo = true;
                    var lastUndoRange = null;
                    for (var i = 0; i < deltas.length; i++) {
                        var delta = deltas[i];
                        if (delta.group == "doc") {
                            this.doc.applyDeltas(delta.deltas);
                            lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
                        }
                    }
                    this.$fromUndo = false;
                    lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                    return lastUndoRange;
                };
                this.setUndoSelect = function (enable) {
                    this.$undoSelect = enable;
                };

                this.$getUndoSelection = function (deltas, isUndo, lastUndoRange) {
                    function isInsert(delta) {
                        return isUndo ? delta.action !== "insert" : delta.action === "insert";
                    }

                    var delta = deltas[0];
                    var range, point;
                    var lastDeltaIsInsert = false;
                    if (isInsert(delta)) {
                        range = Range.fromPoints(delta.start, delta.end);
                        lastDeltaIsInsert = true;
                    } else {
                        range = Range.fromPoints(delta.start, delta.start);
                        lastDeltaIsInsert = false;
                    }

                    for (var i = 1; i < deltas.length; i++) {
                        delta = deltas[i];
                        if (isInsert(delta)) {
                            point = delta.start;
                            if (range.compare(point.row, point.column) == -1) {
                                range.setStart(point);
                            }
                            point = delta.end;
                            if (range.compare(point.row, point.column) == 1) {
                                range.setEnd(point);
                            }
                            lastDeltaIsInsert = true;
                        } else {
                            point = delta.start;
                            if (range.compare(point.row, point.column) == -1) {
                                range = Range.fromPoints(delta.start, delta.start);
                            }
                            lastDeltaIsInsert = false;
                        }
                    }
                    if (lastUndoRange != null) {
                        if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                            lastUndoRange.start.column += range.end.column - range.start.column;
                            lastUndoRange.end.column += range.end.column - range.start.column;
                        }

                        var cmp = lastUndoRange.compareRange(range);
                        if (cmp == 1) {
                            range.setStart(lastUndoRange.start);
                        } else if (cmp == -1) {
                            range.setEnd(lastUndoRange.end);
                        }
                    }

                    return range;
                };
                this.replace = function (range, text) {
                    return this.doc.replace(range, text);
                };
                this.moveText = function (fromRange, toPosition, copy) {
                    var text = this.getTextRange(fromRange);
                    var folds = this.getFoldsInRange(fromRange);

                    var toRange = Range.fromPoints(toPosition, toPosition);
                    if (!copy) {
                        this.remove(fromRange);
                        var rowDiff = fromRange.start.row - fromRange.end.row;
                        var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                        if (collDiff) {
                            if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) toRange.start.column += collDiff;
                            if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) toRange.end.column += collDiff;
                        }
                        if (rowDiff && toRange.start.row >= fromRange.end.row) {
                            toRange.start.row += rowDiff;
                            toRange.end.row += rowDiff;
                        }
                    }

                    toRange.end = this.insert(toRange.start, text);
                    if (folds.length) {
                        var oldStart = fromRange.start;
                        var newStart = toRange.start;
                        var rowDiff = newStart.row - oldStart.row;
                        var collDiff = newStart.column - oldStart.column;
                        this.addFolds(folds.map(function (x) {
                            x = x.clone();
                            if (x.start.row == oldStart.row) x.start.column += collDiff;
                            if (x.end.row == oldStart.row) x.end.column += collDiff;
                            x.start.row += rowDiff;
                            x.end.row += rowDiff;
                            return x;
                        }));
                    }

                    return toRange;
                };
                this.indentRows = function (startRow, endRow, indentString) {
                    indentString = indentString.replace(/\t/g, this.getTabString());
                    for (var row = startRow; row <= endRow; row++) this.doc.insertInLine({ row: row, column: 0 }, indentString);
                };
                this.outdentRows = function (range) {
                    var rowRange = range.collapseRows();
                    var deleteRange = new Range(0, 0, 0, 0);
                    var size = this.getTabSize();

                    for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                        var line = this.getLine(i);

                        deleteRange.start.row = i;
                        deleteRange.end.row = i;
                        for (var j = 0; j < size; ++j) if (line.charAt(j) != ' ') break;
                        if (j < size && line.charAt(j) == '\t') {
                            deleteRange.start.column = j;
                            deleteRange.end.column = j + 1;
                        } else {
                            deleteRange.start.column = 0;
                            deleteRange.end.column = j;
                        }
                        this.remove(deleteRange);
                    }
                };

                this.$moveLines = function (firstRow, lastRow, dir) {
                    firstRow = this.getRowFoldStart(firstRow);
                    lastRow = this.getRowFoldEnd(lastRow);
                    if (dir < 0) {
                        var row = this.getRowFoldStart(firstRow + dir);
                        if (row < 0) return 0;
                        var diff = row - firstRow;
                    } else if (dir > 0) {
                        var row = this.getRowFoldEnd(lastRow + dir);
                        if (row > this.doc.getLength() - 1) return 0;
                        var diff = row - lastRow;
                    } else {
                        firstRow = this.$clipRowToDocument(firstRow);
                        lastRow = this.$clipRowToDocument(lastRow);
                        var diff = lastRow - firstRow + 1;
                    }

                    var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
                    var folds = this.getFoldsInRange(range).map(function (x) {
                        x = x.clone();
                        x.start.row += diff;
                        x.end.row += diff;
                        return x;
                    });

                    var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
                    this.doc.insertFullLines(firstRow + diff, lines);
                    folds.length && this.addFolds(folds);
                    return diff;
                };
                this.moveLinesUp = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, -1);
                };
                this.moveLinesDown = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, 1);
                };
                this.duplicateLines = function (firstRow, lastRow) {
                    return this.$moveLines(firstRow, lastRow, 0);
                };

                this.$clipRowToDocument = function (row) {
                    return Math.max(0, Math.min(row, this.doc.getLength() - 1));
                };

                this.$clipColumnToRow = function (row, column) {
                    if (column < 0) return 0;
                    return Math.min(this.doc.getLine(row).length, column);
                };

                this.$clipPositionToDocument = function (row, column) {
                    column = Math.max(0, column);

                    if (row < 0) {
                        row = 0;
                        column = 0;
                    } else {
                        var len = this.doc.getLength();
                        if (row >= len) {
                            row = len - 1;
                            column = this.doc.getLine(len - 1).length;
                        } else {
                            column = Math.min(this.doc.getLine(row).length, column);
                        }
                    }

                    return {
                        row: row,
                        column: column
                    };
                };

                this.$clipRangeToDocument = function (range) {
                    if (range.start.row < 0) {
                        range.start.row = 0;
                        range.start.column = 0;
                    } else {
                        range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
                    }

                    var len = this.doc.getLength() - 1;
                    if (range.end.row > len) {
                        range.end.row = len;
                        range.end.column = this.doc.getLine(len).length;
                    } else {
                        range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
                    }
                    return range;
                };
                this.$wrapLimit = 80;
                this.$useWrapMode = false;
                this.$wrapLimitRange = {
                    min: null,
                    max: null
                };
                this.setUseWrapMode = function (useWrapMode) {
                    if (useWrapMode != this.$useWrapMode) {
                        this.$useWrapMode = useWrapMode;
                        this.$modified = true;
                        this.$resetRowCache(0);
                        if (useWrapMode) {
                            var len = this.getLength();
                            this.$wrapData = Array(len);
                            this.$updateWrapData(0, len - 1);
                        }

                        this._signal("changeWrapMode");
                    }
                };
                this.getUseWrapMode = function () {
                    return this.$useWrapMode;
                };
                this.setWrapLimitRange = function (min, max) {
                    if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                        this.$wrapLimitRange = { min: min, max: max };
                        this.$modified = true;
                        if (this.$useWrapMode) this._signal("changeWrapMode");
                    }
                };
                this.adjustWrapLimit = function (desiredLimit, $printMargin) {
                    var limits = this.$wrapLimitRange;
                    if (limits.max < 0) limits = { min: $printMargin, max: $printMargin };
                    var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
                    if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                        this.$wrapLimit = wrapLimit;
                        this.$modified = true;
                        if (this.$useWrapMode) {
                            this.$updateWrapData(0, this.getLength() - 1);
                            this.$resetRowCache(0);
                            this._signal("changeWrapLimit");
                        }
                        return true;
                    }
                    return false;
                };

                this.$constrainWrapLimit = function (wrapLimit, min, max) {
                    if (min) wrapLimit = Math.max(min, wrapLimit);

                    if (max) wrapLimit = Math.min(max, wrapLimit);

                    return wrapLimit;
                };
                this.getWrapLimit = function () {
                    return this.$wrapLimit;
                };
                this.setWrapLimit = function (limit) {
                    this.setWrapLimitRange(limit, limit);
                };
                this.getWrapLimitRange = function () {
                    return {
                        min: this.$wrapLimitRange.min,
                        max: this.$wrapLimitRange.max
                    };
                };

                this.$updateInternalDataOnChange = function (delta) {
                    var useWrapMode = this.$useWrapMode;
                    var action = delta.action;
                    var start = delta.start;
                    var end = delta.end;
                    var firstRow = start.row;
                    var lastRow = end.row;
                    var len = lastRow - firstRow;
                    var removedFolds = null;

                    this.$updating = true;
                    if (len != 0) {
                        if (action === "remove") {
                            this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                            var foldLines = this.$foldData;
                            removedFolds = this.getFoldsInRange(delta);
                            this.removeFolds(removedFolds);

                            var foldLine = this.getFoldLine(end.row);
                            var idx = 0;
                            if (foldLine) {
                                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                                foldLine.shiftRow(-len);

                                var foldLineBefore = this.getFoldLine(firstRow);
                                if (foldLineBefore && foldLineBefore !== foldLine) {
                                    foldLineBefore.merge(foldLine);
                                    foldLine = foldLineBefore;
                                }
                                idx = foldLines.indexOf(foldLine) + 1;
                            }

                            for (idx; idx < foldLines.length; idx++) {
                                var foldLine = foldLines[idx];
                                if (foldLine.start.row >= end.row) {
                                    foldLine.shiftRow(-len);
                                }
                            }

                            lastRow = firstRow;
                        } else {
                            var args = Array(len);
                            args.unshift(firstRow, 0);
                            var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                            arr.splice.apply(arr, args);
                            var foldLines = this.$foldData;
                            var foldLine = this.getFoldLine(firstRow);
                            var idx = 0;
                            if (foldLine) {
                                var cmp = foldLine.range.compareInside(start.row, start.column);
                                if (cmp == 0) {
                                    foldLine = foldLine.split(start.row, start.column);
                                    if (foldLine) {
                                        foldLine.shiftRow(len);
                                        foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                                    }
                                } else if (cmp == -1) {
                                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                                    foldLine.shiftRow(len);
                                }
                                idx = foldLines.indexOf(foldLine) + 1;
                            }

                            for (idx; idx < foldLines.length; idx++) {
                                var foldLine = foldLines[idx];
                                if (foldLine.start.row >= firstRow) {
                                    foldLine.shiftRow(len);
                                }
                            }
                        }
                    } else {
                        len = Math.abs(delta.start.column - delta.end.column);
                        if (action === "remove") {
                            removedFolds = this.getFoldsInRange(delta);
                            this.removeFolds(removedFolds);

                            len = -len;
                        }
                        var foldLine = this.getFoldLine(firstRow);
                        if (foldLine) {
                            foldLine.addRemoveChars(firstRow, start.column, len);
                        }
                    }

                    if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                        console.error("doc.getLength() and $wrapData.length have to be the same!");
                    }
                    this.$updating = false;

                    if (useWrapMode) this.$updateWrapData(firstRow, lastRow);else this.$updateRowLengthCache(firstRow, lastRow);

                    return removedFolds;
                };

                this.$updateRowLengthCache = function (firstRow, lastRow, b) {
                    this.$rowLengthCache[firstRow] = null;
                    this.$rowLengthCache[lastRow] = null;
                };

                this.$updateWrapData = function (firstRow, lastRow) {
                    var lines = this.doc.getAllLines();
                    var tabSize = this.getTabSize();
                    var wrapData = this.$wrapData;
                    var wrapLimit = this.$wrapLimit;
                    var tokens;
                    var foldLine;

                    var row = firstRow;
                    lastRow = Math.min(lastRow, lines.length - 1);
                    while (row <= lastRow) {
                        foldLine = this.getFoldLine(row, foldLine);
                        if (!foldLine) {
                            tokens = this.$getDisplayTokens(lines[row]);
                            wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                            row++;
                        } else {
                            tokens = [];
                            foldLine.walk(function (placeholder, row, column, lastColumn) {
                                var walkTokens;
                                if (placeholder != null) {
                                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                                    walkTokens[0] = PLACEHOLDER_START;
                                    for (var i = 1; i < walkTokens.length; i++) {
                                        walkTokens[i] = PLACEHOLDER_BODY;
                                    }
                                } else {
                                    walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                                }
                                tokens = tokens.concat(walkTokens);
                            }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);

                            wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                            row = foldLine.end.row + 1;
                        }
                    }
                };
                var CHAR = 1,
                    CHAR_EXT = 2,
                    PLACEHOLDER_START = 3,
                    PLACEHOLDER_BODY = 4,
                    PUNCTUATION = 9,
                    SPACE = 10,
                    TAB = 11,
                    TAB_SPACE = 12;

                this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
                    if (tokens.length == 0) {
                        return [];
                    }

                    var splits = [];
                    var displayLength = tokens.length;
                    var lastSplit = 0,
                        lastDocSplit = 0;

                    var isCode = this.$wrapAsCode;

                    var indentedSoftWrap = this.$indentedSoftWrap;
                    var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

                    function getWrapIndent() {
                        var indentation = 0;
                        if (maxIndent === 0) return indentation;
                        if (indentedSoftWrap) {
                            for (var i = 0; i < tokens.length; i++) {
                                var token = tokens[i];
                                if (token == SPACE) indentation += 1;else if (token == TAB) indentation += tabSize;else if (token == TAB_SPACE) continue;else break;
                            }
                        }
                        if (isCode && indentedSoftWrap !== false) indentation += tabSize;
                        return Math.min(indentation, maxIndent);
                    }
                    function addSplit(screenPos) {
                        var displayed = tokens.slice(lastSplit, screenPos);
                        var len = displayed.length;
                        displayed.join("").replace(/12/g, function () {
                            len -= 1;
                        }).replace(/2/g, function () {
                            len -= 1;
                        });

                        if (!splits.length) {
                            indent = getWrapIndent();
                            splits.indent = indent;
                        }
                        lastDocSplit += len;
                        splits.push(lastDocSplit);
                        lastSplit = screenPos;
                    }
                    var indent = 0;
                    while (displayLength - lastSplit > wrapLimit - indent) {
                        var split = lastSplit + wrapLimit - indent;
                        if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                            addSplit(split);
                            continue;
                        }
                        if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                            for (split; split != lastSplit - 1; split--) {
                                if (tokens[split] == PLACEHOLDER_START) {
                                    break;
                                }
                            }
                            if (split > lastSplit) {
                                addSplit(split);
                                continue;
                            }
                            split = lastSplit + wrapLimit;
                            for (split; split < tokens.length; split++) {
                                if (tokens[split] != PLACEHOLDER_BODY) {
                                    break;
                                }
                            }
                            if (split == tokens.length) {
                                break; // Breaks the while-loop.
                            }
                            addSplit(split);
                            continue;
                        }
                        var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                        while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                            split--;
                        }
                        if (isCode) {
                            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                                split--;
                            }
                            while (split > minSplit && tokens[split] == PUNCTUATION) {
                                split--;
                            }
                        } else {
                            while (split > minSplit && tokens[split] < SPACE) {
                                split--;
                            }
                        }
                        if (split > minSplit) {
                            addSplit(++split);
                            continue;
                        }
                        split = lastSplit + wrapLimit;
                        if (tokens[split] == CHAR_EXT) split--;
                        addSplit(split - indent);
                    }
                    return splits;
                };
                this.$getDisplayTokens = function (str, offset) {
                    var arr = [];
                    var tabSize;
                    offset = offset || 0;

                    for (var i = 0; i < str.length; i++) {
                        var c = str.charCodeAt(i);
                        if (c == 9) {
                            tabSize = this.getScreenTabSize(arr.length + offset);
                            arr.push(TAB);
                            for (var n = 1; n < tabSize; n++) {
                                arr.push(TAB_SPACE);
                            }
                        } else if (c == 32) {
                            arr.push(SPACE);
                        } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                            arr.push(PUNCTUATION);
                        } else if (c >= 0x1100 && isFullWidth(c)) {
                            arr.push(CHAR, CHAR_EXT);
                        } else {
                            arr.push(CHAR);
                        }
                    }
                    return arr;
                };
                this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                    if (maxScreenColumn == 0) return [0, 0];
                    if (maxScreenColumn == null) maxScreenColumn = Infinity;
                    screenColumn = screenColumn || 0;

                    var c, column;
                    for (column = 0; column < str.length; column++) {
                        c = str.charCodeAt(column);
                        if (c == 9) {
                            screenColumn += this.getScreenTabSize(screenColumn);
                        } else if (c >= 0x1100 && isFullWidth(c)) {
                            screenColumn += 2;
                        } else {
                            screenColumn += 1;
                        }
                        if (screenColumn > maxScreenColumn) {
                            break;
                        }
                    }

                    return [screenColumn, column];
                };

                this.lineWidgets = null;
                this.getRowLength = function (row) {
                    if (this.lineWidgets) var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1 + h;
                    } else {
                        return this.$wrapData[row].length + 1 + h;
                    }
                };
                this.getRowLineCount = function (row) {
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1;
                    } else {
                        return this.$wrapData[row].length + 1;
                    }
                };

                this.getRowWrapIndent = function (screenRow) {
                    if (this.$useWrapMode) {
                        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                        var splits = this.$wrapData[pos.row];
                        return splits.length && splits[0] < pos.column ? splits.indent : 0;
                    } else {
                        return 0;
                    }
                };
                this.getScreenLastRowColumn = function (screenRow) {
                    var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                    return this.documentToScreenColumn(pos.row, pos.column);
                };
                this.getDocumentLastRowColumn = function (docRow, docColumn) {
                    var screenRow = this.documentToScreenRow(docRow, docColumn);
                    return this.getScreenLastRowColumn(screenRow);
                };
                this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
                    var screenRow = this.documentToScreenRow(docRow, docColumn);
                    return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
                };
                this.getRowSplitData = function (row) {
                    if (!this.$useWrapMode) {
                        return undefined;
                    } else {
                        return this.$wrapData[row];
                    }
                };
                this.getScreenTabSize = function (screenColumn) {
                    return this.$tabSize - screenColumn % this.$tabSize;
                };

                this.screenToDocumentRow = function (screenRow, screenColumn) {
                    return this.screenToDocumentPosition(screenRow, screenColumn).row;
                };

                this.screenToDocumentColumn = function (screenRow, screenColumn) {
                    return this.screenToDocumentPosition(screenRow, screenColumn).column;
                };
                this.screenToDocumentPosition = function (screenRow, screenColumn) {
                    if (screenRow < 0) return { row: 0, column: 0 };

                    var line;
                    var docRow = 0;
                    var docColumn = 0;
                    var column;
                    var row = 0;
                    var rowLength = 0;

                    var rowCache = this.$screenRowCache;
                    var i = this.$getRowCacheIndex(rowCache, screenRow);
                    var l = rowCache.length;
                    if (l && i >= 0) {
                        var row = rowCache[i];
                        var docRow = this.$docRowCache[i];
                        var doCache = screenRow > rowCache[l - 1];
                    } else {
                        var doCache = !l;
                    }

                    var maxRow = this.getLength() - 1;
                    var foldLine = this.getNextFoldLine(docRow);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (row <= screenRow) {
                        rowLength = this.getRowLength(docRow);
                        if (row + rowLength > screenRow || docRow >= maxRow) {
                            break;
                        } else {
                            row += rowLength;
                            docRow++;
                            if (docRow > foldStart) {
                                docRow = foldLine.end.row + 1;
                                foldLine = this.getNextFoldLine(docRow, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }
                        }

                        if (doCache) {
                            this.$docRowCache.push(docRow);
                            this.$screenRowCache.push(row);
                        }
                    }

                    if (foldLine && foldLine.start.row <= docRow) {
                        line = this.getFoldDisplayLine(foldLine);
                        docRow = foldLine.start.row;
                    } else if (row + rowLength <= screenRow || docRow > maxRow) {
                        return {
                            row: maxRow,
                            column: this.getLine(maxRow).length
                        };
                    } else {
                        line = this.getLine(docRow);
                        foldLine = null;
                    }
                    var wrapIndent = 0;
                    if (this.$useWrapMode) {
                        var splits = this.$wrapData[docRow];
                        if (splits) {
                            var splitIndex = Math.floor(screenRow - row);
                            column = splits[splitIndex];
                            if (splitIndex > 0 && splits.length) {
                                wrapIndent = splits.indent;
                                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                                line = line.substring(docColumn);
                            }
                        }
                    }

                    docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
                    if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;

                    if (foldLine) return foldLine.idxToPosition(docColumn);

                    return { row: docRow, column: docColumn };
                };
                this.documentToScreenPosition = function (docRow, docColumn) {
                    if (typeof docColumn === "undefined") var pos = this.$clipPositionToDocument(docRow.row, docRow.column);else pos = this.$clipPositionToDocument(docRow, docColumn);

                    docRow = pos.row;
                    docColumn = pos.column;

                    var screenRow = 0;
                    var foldStartRow = null;
                    var fold = null;
                    fold = this.getFoldAt(docRow, docColumn, 1);
                    if (fold) {
                        docRow = fold.start.row;
                        docColumn = fold.start.column;
                    }

                    var rowEnd,
                        row = 0;

                    var rowCache = this.$docRowCache;
                    var i = this.$getRowCacheIndex(rowCache, docRow);
                    var l = rowCache.length;
                    if (l && i >= 0) {
                        var row = rowCache[i];
                        var screenRow = this.$screenRowCache[i];
                        var doCache = docRow > rowCache[l - 1];
                    } else {
                        var doCache = !l;
                    }

                    var foldLine = this.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (row < docRow) {
                        if (row >= foldStart) {
                            rowEnd = foldLine.end.row + 1;
                            if (rowEnd > docRow) break;
                            foldLine = this.getNextFoldLine(rowEnd, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        } else {
                            rowEnd = row + 1;
                        }

                        screenRow += this.getRowLength(row);
                        row = rowEnd;

                        if (doCache) {
                            this.$docRowCache.push(row);
                            this.$screenRowCache.push(screenRow);
                        }
                    }
                    var textLine = "";
                    if (foldLine && row >= foldStart) {
                        textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                        foldStartRow = foldLine.start.row;
                    } else {
                        textLine = this.getLine(docRow).substring(0, docColumn);
                        foldStartRow = docRow;
                    }
                    var wrapIndent = 0;
                    if (this.$useWrapMode) {
                        var wrapRow = this.$wrapData[foldStartRow];
                        if (wrapRow) {
                            var screenRowOffset = 0;
                            while (textLine.length >= wrapRow[screenRowOffset]) {
                                screenRow++;
                                screenRowOffset++;
                            }
                            textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                            wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                        }
                    }

                    return {
                        row: screenRow,
                        column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
                    };
                };
                this.documentToScreenColumn = function (row, docColumn) {
                    return this.documentToScreenPosition(row, docColumn).column;
                };
                this.documentToScreenRow = function (docRow, docColumn) {
                    return this.documentToScreenPosition(docRow, docColumn).row;
                };
                this.getScreenLength = function () {
                    var screenRows = 0;
                    var fold = null;
                    if (!this.$useWrapMode) {
                        screenRows = this.getLength();
                        var foldData = this.$foldData;
                        for (var i = 0; i < foldData.length; i++) {
                            fold = foldData[i];
                            screenRows -= fold.end.row - fold.start.row;
                        }
                    } else {
                        var lastRow = this.$wrapData.length;
                        var row = 0,
                            i = 0;
                        var fold = this.$foldData[i++];
                        var foldStart = fold ? fold.start.row : Infinity;

                        while (row < lastRow) {
                            var splits = this.$wrapData[row];
                            screenRows += splits ? splits.length + 1 : 1;
                            row++;
                            if (row > foldStart) {
                                row = fold.end.row + 1;
                                fold = this.$foldData[i++];
                                foldStart = fold ? fold.start.row : Infinity;
                            }
                        }
                    }
                    if (this.lineWidgets) screenRows += this.$getWidgetScreenLength();

                    return screenRows;
                };
                this.$setFontMetrics = function (fm) {
                    if (!this.$enableVarChar) return;
                    this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                        if (maxScreenColumn === 0) return [0, 0];
                        if (!maxScreenColumn) maxScreenColumn = Infinity;
                        screenColumn = screenColumn || 0;

                        var c, column;
                        for (column = 0; column < str.length; column++) {
                            c = str.charAt(column);
                            if (c === "\t") {
                                screenColumn += this.getScreenTabSize(screenColumn);
                            } else {
                                screenColumn += fm.getCharacterWidth(c);
                            }
                            if (screenColumn > maxScreenColumn) {
                                break;
                            }
                        }

                        return [screenColumn, column];
                    };
                };

                this.destroy = function () {
                    if (this.bgTokenizer) {
                        this.bgTokenizer.setDocument(null);
                        this.bgTokenizer = null;
                    }
                    this.$stopWorker();
                };
                function isFullWidth(c) {
                    if (c < 0x1100) return false;
                    return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
                }
            }).call(EditSession.prototype);

            require("./edit_session/folding").Folding.call(EditSession.prototype);
            require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);

            config.defineOptions(EditSession.prototype, "session", {
                wrap: {
                    set: function (value) {
                        if (!value || value == "off") value = false;else if (value == "free") value = true;else if (value == "printMargin") value = -1;else if (typeof value == "string") value = parseInt(value, 10) || false;

                        if (this.$wrap == value) return;
                        this.$wrap = value;
                        if (!value) {
                            this.setUseWrapMode(false);
                        } else {
                            var col = typeof value == "number" ? value : null;
                            this.setWrapLimitRange(col, col);
                            this.setUseWrapMode(true);
                        }
                    },
                    get: function () {
                        if (this.getUseWrapMode()) {
                            if (this.$wrap == -1) return "printMargin";
                            if (!this.getWrapLimitRange().min) return "free";
                            return this.$wrap;
                        }
                        return "off";
                    },
                    handlesSet: true
                },
                wrapMethod: {
                    set: function (val) {
                        val = val == "auto" ? this.$mode.type != "text" : val != "text";
                        if (val != this.$wrapAsCode) {
                            this.$wrapAsCode = val;
                            if (this.$useWrapMode) {
                                this.$modified = true;
                                this.$resetRowCache(0);
                                this.$updateWrapData(0, this.getLength() - 1);
                            }
                        }
                    },
                    initialValue: "auto"
                },
                indentedSoftWrap: { initialValue: true },
                firstLineNumber: {
                    set: function () {
                        this._signal("changeBreakpoint");
                    },
                    initialValue: 1
                },
                useWorker: {
                    set: function (useWorker) {
                        this.$useWorker = useWorker;

                        this.$stopWorker();
                        if (useWorker) this.$startWorker();
                    },
                    initialValue: true
                },
                useSoftTabs: { initialValue: true },
                tabSize: {
                    set: function (tabSize) {
                        if (isNaN(tabSize) || this.$tabSize === tabSize) return;

                        this.$modified = true;
                        this.$rowLengthCache = [];
                        this.$tabSize = tabSize;
                        this._signal("changeTabSize");
                    },
                    initialValue: 4,
                    handlesSet: true
                },
                overwrite: {
                    set: function (val) {
                        this._signal("changeOverwrite");
                    },
                    initialValue: false
                },
                newLineMode: {
                    set: function (val) {
                        this.doc.setNewLineMode(val);
                    },
                    get: function () {
                        return this.doc.getNewLineMode();
                    },
                    handlesSet: true
                },
                mode: {
                    set: function (val) {
                        this.setMode(val);
                    },
                    get: function () {
                        return this.$modeId;
                    }
                }
            });

            exports.EditSession = EditSession;
        });

        ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("./lib/lang");
            var oop = require("./lib/oop");
            var Range = require("./range").Range;

            var Search = function () {
                this.$options = {};
            };

            (function () {
                this.set = function (options) {
                    oop.mixin(this.$options, options);
                    return this;
                };
                this.getOptions = function () {
                    return lang.copyObject(this.$options);
                };
                this.setOptions = function (options) {
                    this.$options = options;
                };
                this.find = function (session) {
                    var options = this.$options;
                    var iterator = this.$matchIterator(session, options);
                    if (!iterator) return false;

                    var firstRange = null;
                    iterator.forEach(function (range, row, offset) {
                        if (!range.start) {
                            var column = range.offset + (offset || 0);
                            firstRange = new Range(row, column, row, column + range.length);
                            if (!range.length && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                                firstRange = null;
                                return false;
                            }
                        } else firstRange = range;
                        return true;
                    });

                    return firstRange;
                };
                this.findAll = function (session) {
                    var options = this.$options;
                    if (!options.needle) return [];
                    this.$assembleRegExp(options);

                    var range = options.range;
                    var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();

                    var ranges = [];
                    var re = options.re;
                    if (options.$isMultiLine) {
                        var len = re.length;
                        var maxRow = lines.length - len;
                        var prevRange;
                        outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                            for (var j = 0; j < len; j++) if (lines[row + j].search(re[j]) == -1) continue outer;

                            var startLine = lines[row];
                            var line = lines[row + len - 1];
                            var startIndex = startLine.length - startLine.match(re[0])[0].length;
                            var endIndex = line.match(re[len - 1])[0].length;

                            if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                                continue;
                            }
                            ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                            if (len > 2) row = row + len - 2;
                        }
                    } else {
                        for (var i = 0; i < lines.length; i++) {
                            var matches = lang.getMatchOffsets(lines[i], re);
                            for (var j = 0; j < matches.length; j++) {
                                var match = matches[j];
                                ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                            }
                        }
                    }

                    if (range) {
                        var startColumn = range.start.column;
                        var endColumn = range.start.column;
                        var i = 0,
                            j = ranges.length - 1;
                        while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row) i++;

                        while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row) j--;

                        ranges = ranges.slice(i, j + 1);
                        for (i = 0, j = ranges.length; i < j; i++) {
                            ranges[i].start.row += range.start.row;
                            ranges[i].end.row += range.start.row;
                        }
                    }

                    return ranges;
                };
                this.replace = function (input, replacement) {
                    var options = this.$options;

                    var re = this.$assembleRegExp(options);
                    if (options.$isMultiLine) return replacement;

                    if (!re) return;

                    var match = re.exec(input);
                    if (!match || match[0].length != input.length) return null;

                    replacement = input.replace(re, replacement);
                    if (options.preserveCase) {
                        replacement = replacement.split("");
                        for (var i = Math.min(input.length, input.length); i--;) {
                            var ch = input[i];
                            if (ch && ch.toLowerCase() != ch) replacement[i] = replacement[i].toUpperCase();else replacement[i] = replacement[i].toLowerCase();
                        }
                        replacement = replacement.join("");
                    }

                    return replacement;
                };

                this.$matchIterator = function (session, options) {
                    var re = this.$assembleRegExp(options);
                    if (!re) return false;

                    var callback;
                    if (options.$isMultiLine) {
                        var len = re.length;
                        var matchIterator = function (line, row, offset) {
                            var startIndex = line.search(re[0]);
                            if (startIndex == -1) return;
                            for (var i = 1; i < len; i++) {
                                line = session.getLine(row + i);
                                if (line.search(re[i]) == -1) return;
                            }

                            var endIndex = line.match(re[len - 1])[0].length;

                            var range = new Range(row, startIndex, row + len - 1, endIndex);
                            if (re.offset == 1) {
                                range.start.row--;
                                range.start.column = Number.MAX_VALUE;
                            } else if (offset) range.start.column += offset;

                            if (callback(range)) return true;
                        };
                    } else if (options.backwards) {
                        var matchIterator = function (line, row, startIndex) {
                            var matches = lang.getMatchOffsets(line, re);
                            for (var i = matches.length - 1; i >= 0; i--) if (callback(matches[i], row, startIndex)) return true;
                        };
                    } else {
                        var matchIterator = function (line, row, startIndex) {
                            var matches = lang.getMatchOffsets(line, re);
                            for (var i = 0; i < matches.length; i++) if (callback(matches[i], row, startIndex)) return true;
                        };
                    }

                    var lineIterator = this.$lineIterator(session, options);

                    return {
                        forEach: function (_callback) {
                            callback = _callback;
                            lineIterator.forEach(matchIterator);
                        }
                    };
                };

                this.$assembleRegExp = function (options, $disableFakeMultiline) {
                    if (options.needle instanceof RegExp) return options.re = options.needle;

                    var needle = options.needle;

                    if (!options.needle) return options.re = false;

                    if (!options.regExp) needle = lang.escapeRegExp(needle);

                    if (options.wholeWord) needle = "\\b" + needle + "\\b";

                    var modifier = options.caseSensitive ? "gm" : "gmi";

                    options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
                    if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needle, modifier);

                    try {
                        var re = new RegExp(needle, modifier);
                    } catch (e) {
                        re = false;
                    }
                    return options.re = re;
                };

                this.$assembleMultilineRegExp = function (needle, modifier) {
                    var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
                    var re = [];
                    for (var i = 0; i < parts.length; i++) try {
                        re.push(new RegExp(parts[i], modifier));
                    } catch (e) {
                        return false;
                    }
                    if (parts[0] == "") {
                        re.shift();
                        re.offset = 1;
                    } else {
                        re.offset = 0;
                    }
                    return re;
                };

                this.$lineIterator = function (session, options) {
                    var backwards = options.backwards == true;
                    var skipCurrent = options.skipCurrent != false;

                    var range = options.range;
                    var start = options.start;
                    if (!start) start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();

                    if (start.start) start = start[skipCurrent != backwards ? "end" : "start"];

                    var firstRow = range ? range.start.row : 0;
                    var lastRow = range ? range.end.row : session.getLength() - 1;

                    var forEach = backwards ? function (callback) {
                        var row = start.row;

                        var line = session.getLine(row).substring(0, start.column);
                        if (callback(line, row)) return;

                        for (row--; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;

                        if (options.wrap == false) return;

                        for (row = lastRow, firstRow = start.row; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;
                    } : function (callback) {
                        var row = start.row;

                        var line = session.getLine(row).substr(start.column);
                        if (callback(line, row, start.column)) return;

                        for (row = row + 1; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;

                        if (options.wrap == false) return;

                        for (row = firstRow, lastRow = start.row; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;
                    };

                    return { forEach: forEach };
                };
            }).call(Search.prototype);

            exports.Search = Search;
        });

        ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (require, exports, module) {
            "use strict";

            var keyUtil = require("../lib/keys");
            var useragent = require("../lib/useragent");
            var KEY_MODS = keyUtil.KEY_MODS;

            function HashHandler(config, platform) {
                this.platform = platform || (useragent.isMac ? "mac" : "win");
                this.commands = {};
                this.commandKeyBinding = {};
                this.addCommands(config);
                this.$singleCommand = true;
            }

            function MultiHashHandler(config, platform) {
                HashHandler.call(this, config, platform);
                this.$singleCommand = false;
            }

            MultiHashHandler.prototype = HashHandler.prototype;

            (function () {

                this.addCommand = function (command) {
                    if (this.commands[command.name]) this.removeCommand(command);

                    this.commands[command.name] = command;

                    if (command.bindKey) this._buildKeyHash(command);
                };

                this.removeCommand = function (command, keepCommand) {
                    var name = command && (typeof command === 'string' ? command : command.name);
                    command = this.commands[name];
                    if (!keepCommand) delete this.commands[name];
                    var ckb = this.commandKeyBinding;
                    for (var keyId in ckb) {
                        var cmdGroup = ckb[keyId];
                        if (cmdGroup == command) {
                            delete ckb[keyId];
                        } else if (Array.isArray(cmdGroup)) {
                            var i = cmdGroup.indexOf(command);
                            if (i != -1) {
                                cmdGroup.splice(i, 1);
                                if (cmdGroup.length == 1) ckb[keyId] = cmdGroup[0];
                            }
                        }
                    }
                };

                this.bindKey = function (key, command, position) {
                    if (typeof key == "object" && key) {
                        if (position == undefined) position = key.position;
                        key = key[this.platform];
                    }
                    if (!key) return;
                    if (typeof command == "function") return this.addCommand({ exec: command, bindKey: key, name: command.name || key });

                    key.split("|").forEach(function (keyPart) {
                        var chain = "";
                        if (keyPart.indexOf(" ") != -1) {
                            var parts = keyPart.split(/\s+/);
                            keyPart = parts.pop();
                            parts.forEach(function (keyPart) {
                                var binding = this.parseKeys(keyPart);
                                var id = KEY_MODS[binding.hashId] + binding.key;
                                chain += (chain ? " " : "") + id;
                                this._addCommandToBinding(chain, "chainKeys");
                            }, this);
                            chain += " ";
                        }
                        var binding = this.parseKeys(keyPart);
                        var id = KEY_MODS[binding.hashId] + binding.key;
                        this._addCommandToBinding(chain + id, command, position);
                    }, this);
                };

                function getPosition(command) {
                    return typeof command == "object" && command.bindKey && command.bindKey.position || 0;
                }
                this._addCommandToBinding = function (keyId, command, position) {
                    var ckb = this.commandKeyBinding,
                        i;
                    if (!command) {
                        delete ckb[keyId];
                    } else if (!ckb[keyId] || this.$singleCommand) {
                        ckb[keyId] = command;
                    } else {
                        if (!Array.isArray(ckb[keyId])) {
                            ckb[keyId] = [ckb[keyId]];
                        } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                            ckb[keyId].splice(i, 1);
                        }

                        if (typeof position != "number") {
                            if (position || command.isDefault) position = -100;else position = getPosition(command);
                        }
                        var commands = ckb[keyId];
                        for (i = 0; i < commands.length; i++) {
                            var other = commands[i];
                            var otherPos = getPosition(other);
                            if (otherPos > position) break;
                        }
                        commands.splice(i, 0, command);
                    }
                };

                this.addCommands = function (commands) {
                    commands && Object.keys(commands).forEach(function (name) {
                        var command = commands[name];
                        if (!command) return;

                        if (typeof command === "string") return this.bindKey(command, name);

                        if (typeof command === "function") command = { exec: command };

                        if (typeof command !== "object") return;

                        if (!command.name) command.name = name;

                        this.addCommand(command);
                    }, this);
                };

                this.removeCommands = function (commands) {
                    Object.keys(commands).forEach(function (name) {
                        this.removeCommand(commands[name]);
                    }, this);
                };

                this.bindKeys = function (keyList) {
                    Object.keys(keyList).forEach(function (key) {
                        this.bindKey(key, keyList[key]);
                    }, this);
                };

                this._buildKeyHash = function (command) {
                    this.bindKey(command.bindKey, command);
                };
                this.parseKeys = function (keys) {
                    var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) {
                        return x;
                    });
                    var key = parts.pop();

                    var keyCode = keyUtil[key];
                    if (keyUtil.FUNCTION_KEYS[keyCode]) key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();else if (!parts.length) return { key: key, hashId: -1 };else if (parts.length == 1 && parts[0] == "shift") return { key: key.toUpperCase(), hashId: -1 };

                    var hashId = 0;
                    for (var i = parts.length; i--;) {
                        var modifier = keyUtil.KEY_MODS[parts[i]];
                        if (modifier == null) {
                            if (typeof console != "undefined") console.error("invalid modifier " + parts[i] + " in " + keys);
                            return false;
                        }
                        hashId |= modifier;
                    }
                    return { key: key, hashId: hashId };
                };

                this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                    var key = KEY_MODS[hashId] + keyString;
                    return this.commandKeyBinding[key];
                };

                this.handleKeyboard = function (data, hashId, keyString, keyCode) {
                    if (keyCode < 0) return;
                    var key = KEY_MODS[hashId] + keyString;
                    var command = this.commandKeyBinding[key];
                    if (data.$keyChain) {
                        data.$keyChain += " " + key;
                        command = this.commandKeyBinding[data.$keyChain] || command;
                    }

                    if (command) {
                        if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                            data.$keyChain = data.$keyChain || key;
                            return { command: "null" };
                        }
                    }

                    if (data.$keyChain) {
                        if ((!hashId || hashId == 4) && keyString.length == 1) data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                        else if (hashId == -1 || keyCode > 0) data.$keyChain = ""; // reset keyChain
                    }
                    return { command: command };
                };

                this.getStatusText = function (editor, data) {
                    return data.$keyChain || "";
                };
            }).call(HashHandler.prototype);

            exports.HashHandler = HashHandler;
            exports.MultiHashHandler = MultiHashHandler;
        });

        ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var CommandManager = function (platform, commands) {
                MultiHashHandler.call(this, commands, platform);
                this.byName = this.commands;
                this.setDefaultHandler("exec", function (e) {
                    return e.command.exec(e.editor, e.args || {});
                });
            };

            oop.inherits(CommandManager, MultiHashHandler);

            (function () {

                oop.implement(this, EventEmitter);

                this.exec = function (command, editor, args) {
                    if (Array.isArray(command)) {
                        for (var i = command.length; i--;) {
                            if (this.exec(command[i], editor, args)) return true;
                        }
                        return false;
                    }

                    if (typeof command === "string") command = this.commands[command];

                    if (!command) return false;

                    if (editor && editor.$readOnly && !command.readOnly) return false;

                    var e = { editor: editor, command: command, args: args };
                    e.returnValue = this._emit("exec", e);
                    this._signal("afterExec", e);

                    return e.returnValue === false ? false : true;
                };

                this.toggleRecording = function (editor) {
                    if (this.$inReplay) return;

                    editor && editor._emit("changeStatus");
                    if (this.recording) {
                        this.macro.pop();
                        this.removeEventListener("exec", this.$addCommandToMacro);

                        if (!this.macro.length) this.macro = this.oldMacro;

                        return this.recording = false;
                    }
                    if (!this.$addCommandToMacro) {
                        this.$addCommandToMacro = function (e) {
                            this.macro.push([e.command, e.args]);
                        }.bind(this);
                    }

                    this.oldMacro = this.macro;
                    this.macro = [];
                    this.on("exec", this.$addCommandToMacro);
                    return this.recording = true;
                };

                this.replay = function (editor) {
                    if (this.$inReplay || !this.macro) return;

                    if (this.recording) return this.toggleRecording(editor);

                    try {
                        this.$inReplay = true;
                        this.macro.forEach(function (x) {
                            if (typeof x == "string") this.exec(x, editor);else this.exec(x[0], editor, x[1]);
                        }, this);
                    } finally {
                        this.$inReplay = false;
                    }
                };

                this.trimMacro = function (m) {
                    return m.map(function (x) {
                        if (typeof x[0] != "string") x[0] = x[0].name;
                        if (!x[1]) x = x[0];
                        return x;
                    });
                };
            }).call(CommandManager.prototype);

            exports.CommandManager = CommandManager;
        });

        ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function (require, exports, module) {
            "use strict";

            var lang = require("../lib/lang");
            var config = require("../config");
            var Range = require("../range").Range;

            function bindKey(win, mac) {
                return { win: win, mac: mac };
            }
            exports.commands = [{
                name: "showSettingsMenu",
                bindKey: bindKey("Ctrl-,", "Command-,"),
                exec: function (editor) {
                    config.loadModule("ace/ext/settings_menu", function (module) {
                        module.init(editor);
                        editor.showSettingsMenu();
                    });
                },
                readOnly: true
            }, {
                name: "goToNextError",
                bindKey: bindKey("Alt-E", "Ctrl-E"),
                exec: function (editor) {
                    config.loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, 1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "goToPreviousError",
                bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
                exec: function (editor) {
                    config.loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, -1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selectall",
                bindKey: bindKey("Ctrl-A", "Command-A"),
                exec: function (editor) {
                    editor.selectAll();
                },
                readOnly: true
            }, {
                name: "centerselection",
                bindKey: bindKey(null, "Ctrl-L"),
                exec: function (editor) {
                    editor.centerSelection();
                },
                readOnly: true
            }, {
                name: "gotoline",
                bindKey: bindKey("Ctrl-L", "Command-L"),
                exec: function (editor) {
                    var line = parseInt(prompt("Enter line number:"), 10);
                    if (!isNaN(line)) {
                        editor.gotoLine(line);
                    }
                },
                readOnly: true
            }, {
                name: "fold",
                bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
                exec: function (editor) {
                    editor.session.toggleFold(false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfold",
                bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
                exec: function (editor) {
                    editor.session.toggleFold(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleFoldWidget",
                bindKey: bindKey("F2", "F2"),
                exec: function (editor) {
                    editor.session.toggleFoldWidget();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleParentFoldWidget",
                bindKey: bindKey("Alt-F2", "Alt-F2"),
                exec: function (editor) {
                    editor.session.toggleFoldWidget(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldall",
                bindKey: bindKey(null, "Ctrl-Command-Option-0"),
                exec: function (editor) {
                    editor.session.foldAll();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldOther",
                bindKey: bindKey("Alt-0", "Command-Option-0"),
                exec: function (editor) {
                    editor.session.foldAll();
                    editor.session.unfold(editor.selection.getAllRanges());
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfoldall",
                bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
                exec: function (editor) {
                    editor.session.unfold();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findnext",
                bindKey: bindKey("Ctrl-K", "Command-G"),
                exec: function (editor) {
                    editor.findNext();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findprevious",
                bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
                exec: function (editor) {
                    editor.findPrevious();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "selectOrFindNext",
                bindKey: bindKey("Alt-K", "Ctrl-G"),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findNext();
                },
                readOnly: true
            }, {
                name: "selectOrFindPrevious",
                bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) editor.selection.selectWord();else editor.findPrevious();
                },
                readOnly: true
            }, {
                name: "find",
                bindKey: bindKey("Ctrl-F", "Command-F"),
                exec: function (editor) {
                    config.loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor);
                    });
                },
                readOnly: true
            }, {
                name: "overwrite",
                bindKey: "Insert",
                exec: function (editor) {
                    editor.toggleOverwrite();
                },
                readOnly: true
            }, {
                name: "selecttostart",
                bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
                exec: function (editor) {
                    editor.getSelection().selectFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotostart",
                bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
                exec: function (editor) {
                    editor.navigateFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectup",
                bindKey: bindKey("Shift-Up", "Shift-Up"),
                exec: function (editor) {
                    editor.getSelection().selectUp();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golineup",
                bindKey: bindKey("Up", "Up|Ctrl-P"),
                exec: function (editor, args) {
                    editor.navigateUp(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttoend",
                bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
                exec: function (editor) {
                    editor.getSelection().selectFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotoend",
                bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
                exec: function (editor) {
                    editor.navigateFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectdown",
                bindKey: bindKey("Shift-Down", "Shift-Down"),
                exec: function (editor) {
                    editor.getSelection().selectDown();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golinedown",
                bindKey: bindKey("Down", "Down|Ctrl-N"),
                exec: function (editor, args) {
                    editor.navigateDown(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordleft",
                bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordleft",
                bindKey: bindKey("Ctrl-Left", "Option-Left"),
                exec: function (editor) {
                    editor.navigateWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolinestart",
                bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolinestart",
                bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
                exec: function (editor) {
                    editor.navigateLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectleft",
                bindKey: bindKey("Shift-Left", "Shift-Left"),
                exec: function (editor) {
                    editor.getSelection().selectLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoleft",
                bindKey: bindKey("Left", "Left|Ctrl-B"),
                exec: function (editor, args) {
                    editor.navigateLeft(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordright",
                bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordright",
                bindKey: bindKey("Ctrl-Right", "Option-Right"),
                exec: function (editor) {
                    editor.navigateWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolineend",
                bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolineend",
                bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
                exec: function (editor) {
                    editor.navigateLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectright",
                bindKey: bindKey("Shift-Right", "Shift-Right"),
                exec: function (editor) {
                    editor.getSelection().selectRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoright",
                bindKey: bindKey("Right", "Right|Ctrl-F"),
                exec: function (editor, args) {
                    editor.navigateRight(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectpagedown",
                bindKey: "Shift-PageDown",
                exec: function (editor) {
                    editor.selectPageDown();
                },
                readOnly: true
            }, {
                name: "pagedown",
                bindKey: bindKey(null, "Option-PageDown"),
                exec: function (editor) {
                    editor.scrollPageDown();
                },
                readOnly: true
            }, {
                name: "gotopagedown",
                bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
                exec: function (editor) {
                    editor.gotoPageDown();
                },
                readOnly: true
            }, {
                name: "selectpageup",
                bindKey: "Shift-PageUp",
                exec: function (editor) {
                    editor.selectPageUp();
                },
                readOnly: true
            }, {
                name: "pageup",
                bindKey: bindKey(null, "Option-PageUp"),
                exec: function (editor) {
                    editor.scrollPageUp();
                },
                readOnly: true
            }, {
                name: "gotopageup",
                bindKey: "PageUp",
                exec: function (editor) {
                    editor.gotoPageUp();
                },
                readOnly: true
            }, {
                name: "scrollup",
                bindKey: bindKey("Ctrl-Up", null),
                exec: function (e) {
                    e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "scrolldown",
                bindKey: bindKey("Ctrl-Down", null),
                exec: function (e) {
                    e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "selectlinestart",
                bindKey: "Shift-Home",
                exec: function (editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectlineend",
                bindKey: "Shift-End",
                exec: function (editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "togglerecording",
                bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
                exec: function (editor) {
                    editor.commands.toggleRecording(editor);
                },
                readOnly: true
            }, {
                name: "replaymacro",
                bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
                exec: function (editor) {
                    editor.commands.replay(editor);
                },
                readOnly: true
            }, {
                name: "jumptomatching",
                bindKey: bindKey("Ctrl-P", "Ctrl-P"),
                exec: function (editor) {
                    editor.jumpToMatching();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selecttomatching",
                bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
                exec: function (editor) {
                    editor.jumpToMatching(true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "expandToMatching",
                bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
                exec: function (editor) {
                    editor.jumpToMatching(true, true);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "passKeysToBrowser",
                bindKey: bindKey(null, null),
                exec: function () {},
                passEvent: true,
                readOnly: true
            }, {
                name: "copy",
                exec: function (editor) {},
                readOnly: true
            }, {
                name: "cut",
                exec: function (editor) {
                    var range = editor.getSelectionRange();
                    editor._emit("cut", range);

                    if (!editor.selection.isEmpty()) {
                        editor.session.remove(range);
                        editor.clearSelection();
                    }
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "paste",
                exec: function (editor, args) {
                    editor.$handlePaste(args);
                },
                scrollIntoView: "cursor"
            }, {
                name: "removeline",
                bindKey: bindKey("Ctrl-D", "Command-D"),
                exec: function (editor) {
                    editor.removeLines();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEachLine"
            }, {
                name: "duplicateSelection",
                bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
                exec: function (editor) {
                    editor.duplicateSelection();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "sortlines",
                bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
                exec: function (editor) {
                    editor.sortLines();
                },
                scrollIntoView: "selection",
                multiSelectAction: "forEachLine"
            }, {
                name: "togglecomment",
                bindKey: bindKey("Ctrl-/", "Command-/"),
                exec: function (editor) {
                    editor.toggleCommentLines();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "toggleBlockComment",
                bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
                exec: function (editor) {
                    editor.toggleBlockComment();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "modifyNumberUp",
                bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
                exec: function (editor) {
                    editor.modifyNumber(1);
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "modifyNumberDown",
                bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
                exec: function (editor) {
                    editor.modifyNumber(-1);
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "replace",
                bindKey: bindKey("Ctrl-H", "Command-Option-F"),
                exec: function (editor) {
                    config.loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor, true);
                    });
                }
            }, {
                name: "undo",
                bindKey: bindKey("Ctrl-Z", "Command-Z"),
                exec: function (editor) {
                    editor.undo();
                }
            }, {
                name: "redo",
                bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
                exec: function (editor) {
                    editor.redo();
                }
            }, {
                name: "copylinesup",
                bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
                exec: function (editor) {
                    editor.copyLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesup",
                bindKey: bindKey("Alt-Up", "Option-Up"),
                exec: function (editor) {
                    editor.moveLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "copylinesdown",
                bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
                exec: function (editor) {
                    editor.copyLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesdown",
                bindKey: bindKey("Alt-Down", "Option-Down"),
                exec: function (editor) {
                    editor.moveLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "del",
                bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
                exec: function (editor) {
                    editor.remove("right");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "backspace",
                bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
                exec: function (editor) {
                    editor.remove("left");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "cut_or_delete",
                bindKey: bindKey("Shift-Delete", null),
                exec: function (editor) {
                    if (editor.selection.isEmpty()) {
                        editor.remove("left");
                    } else {
                        return false;
                    }
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolinestart",
                bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
                exec: function (editor) {
                    editor.removeToLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolineend",
                bindKey: bindKey("Alt-Delete", "Ctrl-K"),
                exec: function (editor) {
                    editor.removeToLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordleft",
                bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
                exec: function (editor) {
                    editor.removeWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordright",
                bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
                exec: function (editor) {
                    editor.removeWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "outdent",
                bindKey: bindKey("Shift-Tab", "Shift-Tab"),
                exec: function (editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "indent",
                bindKey: bindKey("Tab", "Tab"),
                exec: function (editor) {
                    editor.indent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockoutdent",
                bindKey: bindKey("Ctrl-[", "Ctrl-["),
                exec: function (editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockindent",
                bindKey: bindKey("Ctrl-]", "Ctrl-]"),
                exec: function (editor) {
                    editor.blockIndent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "insertstring",
                exec: function (editor, str) {
                    editor.insert(str);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "inserttext",
                exec: function (editor, args) {
                    editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "splitline",
                bindKey: bindKey(null, "Ctrl-O"),
                exec: function (editor) {
                    editor.splitLine();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "transposeletters",
                bindKey: bindKey("Ctrl-T", "Ctrl-T"),
                exec: function (editor) {
                    editor.transposeLetters();
                },
                multiSelectAction: function (editor) {
                    editor.transposeSelections(1);
                },
                scrollIntoView: "cursor"
            }, {
                name: "touppercase",
                bindKey: bindKey("Ctrl-U", "Ctrl-U"),
                exec: function (editor) {
                    editor.toUpperCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "tolowercase",
                bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
                exec: function (editor) {
                    editor.toLowerCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "expandtoline",
                bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
                exec: function (editor) {
                    var range = editor.selection.getRange();

                    range.start.column = range.end.column = 0;
                    range.end.row++;
                    editor.selection.setRange(range, false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "joinlines",
                bindKey: bindKey(null, null),
                exec: function (editor) {
                    var isBackwards = editor.selection.isBackwards();
                    var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                    var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                    var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                    var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                    var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                    var insertLine = editor.session.doc.getLine(selectionStart.row);

                    for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                        var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                        if (curLine.length !== 0) {
                            curLine = " " + curLine;
                        }
                        insertLine += curLine;
                    }

                    if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
                        insertLine += editor.session.doc.getNewLineCharacter();
                    }

                    editor.clearSelection();
                    editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

                    if (selectedCount > 0) {
                        editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                        editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                    } else {
                        firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                        editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                    }
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "invertSelection",
                bindKey: bindKey(null, null),
                exec: function (editor) {
                    var endRow = editor.session.doc.getLength() - 1;
                    var endCol = editor.session.doc.getLine(endRow).length;
                    var ranges = editor.selection.rangeList.ranges;
                    var newRanges = [];
                    if (ranges.length < 1) {
                        ranges = [editor.selection.getRange()];
                    }

                    for (var i = 0; i < ranges.length; i++) {
                        if (i == ranges.length - 1) {
                            if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                            }
                        }

                        if (i === 0) {
                            if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                            }
                        } else {
                            newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                        }
                    }

                    editor.exitMultiSelectMode();
                    editor.clearSelection();

                    for (var i = 0; i < newRanges.length; i++) {
                        editor.selection.addRange(newRanges[i], false);
                    }
                },
                readOnly: true,
                scrollIntoView: "none"
            }];
        });

        ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function (require, exports, module) {
            "use strict";

            require("./lib/fixoldbrowsers");

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var lang = require("./lib/lang");
            var useragent = require("./lib/useragent");
            var TextInput = require("./keyboard/textinput").TextInput;
            var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
            var FoldHandler = require("./mouse/fold_handler").FoldHandler;
            var KeyBinding = require("./keyboard/keybinding").KeyBinding;
            var EditSession = require("./edit_session").EditSession;
            var Search = require("./search").Search;
            var Range = require("./range").Range;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var CommandManager = require("./commands/command_manager").CommandManager;
            var defaultCommands = require("./commands/default_commands").commands;
            var config = require("./config");
            var TokenIterator = require("./token_iterator").TokenIterator;
            var Editor = function (renderer, session) {
                var container = renderer.getContainerElement();
                this.container = container;
                this.renderer = renderer;

                this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
                this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
                this.renderer.textarea = this.textInput.getElement();
                this.keyBinding = new KeyBinding(this);
                this.$mouseHandler = new MouseHandler(this);
                new FoldHandler(this);

                this.$blockScrolling = 0;
                this.$search = new Search().set({
                    wrap: true
                });

                this.$historyTracker = this.$historyTracker.bind(this);
                this.commands.on("exec", this.$historyTracker);

                this.$initOperationListeners();

                this._$emitInputEvent = lang.delayedCall(function () {
                    this._signal("input", {});
                    if (this.session && this.session.bgTokenizer) this.session.bgTokenizer.scheduleStart();
                }.bind(this));

                this.on("change", function (_, _self) {
                    _self._$emitInputEvent.schedule(31);
                });

                this.setSession(session || new EditSession(""));
                config.resetOptions(this);
                config._signal("editor", this);
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.$initOperationListeners = function () {
                    function last(a) {
                        return a[a.length - 1];
                    }

                    this.selections = [];
                    this.commands.on("exec", this.startOperation.bind(this), true);
                    this.commands.on("afterExec", this.endOperation.bind(this), true);

                    this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

                    this.on("change", function () {
                        this.curOp || this.startOperation();
                        this.curOp.docChanged = true;
                    }.bind(this), true);

                    this.on("changeSelection", function () {
                        this.curOp || this.startOperation();
                        this.curOp.selectionChanged = true;
                    }.bind(this), true);
                };

                this.curOp = null;
                this.prevOp = {};
                this.startOperation = function (commadEvent) {
                    if (this.curOp) {
                        if (!commadEvent || this.curOp.command) return;
                        this.prevOp = this.curOp;
                    }
                    if (!commadEvent) {
                        this.previousCommand = null;
                        commadEvent = {};
                    }

                    this.$opResetTimer.schedule();
                    this.curOp = {
                        command: commadEvent.command || {},
                        args: commadEvent.args,
                        scrollTop: this.renderer.scrollTop
                    };
                    if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined) this.$blockScrolling++;
                };

                this.endOperation = function (e) {
                    if (this.curOp) {
                        if (e && e.returnValue === false) return this.curOp = null;
                        this._signal("beforeEndOperation");
                        var command = this.curOp.command;
                        if (command.name && this.$blockScrolling > 0) this.$blockScrolling--;
                        var scrollIntoView = command && command.scrollIntoView;
                        if (scrollIntoView) {
                            switch (scrollIntoView) {
                                case "center-animate":
                                    scrollIntoView = "animate";
                                case "center":
                                    this.renderer.scrollCursorIntoView(null, 0.5);
                                    break;
                                case "animate":
                                case "cursor":
                                    this.renderer.scrollCursorIntoView();
                                    break;
                                case "selectionPart":
                                    var range = this.selection.getRange();
                                    var config = this.renderer.layerConfig;
                                    if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                        this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                                    }
                                    break;
                                default:
                                    break;
                            }
                            if (scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
                        }

                        this.prevOp = this.curOp;
                        this.curOp = null;
                    }
                };
                this.$mergeableCommands = ["backspace", "del", "insertstring"];
                this.$historyTracker = function (e) {
                    if (!this.$mergeUndoDeltas) return;

                    var prev = this.prevOp;
                    var mergeableCommands = this.$mergeableCommands;
                    var shouldMerge = prev.command && e.command.name == prev.command.name;
                    if (e.command.name == "insertstring") {
                        var text = e.args;
                        if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;

                        shouldMerge = shouldMerge && this.mergeNextCommand // previous command allows to coalesce with
                        && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

                        this.mergeNextCommand = true;
                    } else {
                        shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
                    }

                    if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
                        shouldMerge = false; // the sequence is too long
                    }

                    if (shouldMerge) this.session.mergeUndoDeltas = true;else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
                };
                this.setKeyboardHandler = function (keyboardHandler, cb) {
                    if (keyboardHandler && typeof keyboardHandler === "string") {
                        this.$keybindingId = keyboardHandler;
                        var _self = this;
                        config.loadModule(["keybinding", keyboardHandler], function (module) {
                            if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module && module.handler);
                            cb && cb();
                        });
                    } else {
                        this.$keybindingId = null;
                        this.keyBinding.setKeyboardHandler(keyboardHandler);
                        cb && cb();
                    }
                };
                this.getKeyboardHandler = function () {
                    return this.keyBinding.getKeyboardHandler();
                };
                this.setSession = function (session) {
                    if (this.session == session) return;
                    if (this.curOp) this.endOperation();
                    this.curOp = {};

                    var oldSession = this.session;
                    if (oldSession) {
                        this.session.off("change", this.$onDocumentChange);
                        this.session.off("changeMode", this.$onChangeMode);
                        this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                        this.session.off("changeTabSize", this.$onChangeTabSize);
                        this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                        this.session.off("changeWrapMode", this.$onChangeWrapMode);
                        this.session.off("changeFold", this.$onChangeFold);
                        this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                        this.session.off("changeBackMarker", this.$onChangeBackMarker);
                        this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                        this.session.off("changeAnnotation", this.$onChangeAnnotation);
                        this.session.off("changeOverwrite", this.$onCursorChange);
                        this.session.off("changeScrollTop", this.$onScrollTopChange);
                        this.session.off("changeScrollLeft", this.$onScrollLeftChange);

                        var selection = this.session.getSelection();
                        selection.off("changeCursor", this.$onCursorChange);
                        selection.off("changeSelection", this.$onSelectionChange);
                    }

                    this.session = session;
                    if (session) {
                        this.$onDocumentChange = this.onDocumentChange.bind(this);
                        session.on("change", this.$onDocumentChange);
                        this.renderer.setSession(session);

                        this.$onChangeMode = this.onChangeMode.bind(this);
                        session.on("changeMode", this.$onChangeMode);

                        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                        session.on("tokenizerUpdate", this.$onTokenizerUpdate);

                        this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                        session.on("changeTabSize", this.$onChangeTabSize);

                        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                        session.on("changeWrapLimit", this.$onChangeWrapLimit);

                        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                        session.on("changeWrapMode", this.$onChangeWrapMode);

                        this.$onChangeFold = this.onChangeFold.bind(this);
                        session.on("changeFold", this.$onChangeFold);

                        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                        this.session.on("changeFrontMarker", this.$onChangeFrontMarker);

                        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                        this.session.on("changeBackMarker", this.$onChangeBackMarker);

                        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                        this.session.on("changeBreakpoint", this.$onChangeBreakpoint);

                        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                        this.session.on("changeAnnotation", this.$onChangeAnnotation);

                        this.$onCursorChange = this.onCursorChange.bind(this);
                        this.session.on("changeOverwrite", this.$onCursorChange);

                        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                        this.session.on("changeScrollTop", this.$onScrollTopChange);

                        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                        this.session.on("changeScrollLeft", this.$onScrollLeftChange);

                        this.selection = session.getSelection();
                        this.selection.on("changeCursor", this.$onCursorChange);

                        this.$onSelectionChange = this.onSelectionChange.bind(this);
                        this.selection.on("changeSelection", this.$onSelectionChange);

                        this.onChangeMode();

                        this.$blockScrolling += 1;
                        this.onCursorChange();
                        this.$blockScrolling -= 1;

                        this.onScrollTopChange();
                        this.onScrollLeftChange();
                        this.onSelectionChange();
                        this.onChangeFrontMarker();
                        this.onChangeBackMarker();
                        this.onChangeBreakpoint();
                        this.onChangeAnnotation();
                        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                        this.renderer.updateFull();
                    } else {
                        this.selection = null;
                        this.renderer.setSession(session);
                    }

                    this._signal("changeSession", {
                        session: session,
                        oldSession: oldSession
                    });

                    this.curOp = null;

                    oldSession && oldSession._signal("changeEditor", { oldEditor: this });
                    session && session._signal("changeEditor", { editor: this });
                };
                this.getSession = function () {
                    return this.session;
                };
                this.setValue = function (val, cursorPos) {
                    this.session.doc.setValue(val);

                    if (!cursorPos) this.selectAll();else if (cursorPos == 1) this.navigateFileEnd();else if (cursorPos == -1) this.navigateFileStart();

                    return val;
                };
                this.getValue = function () {
                    return this.session.getValue();
                };
                this.getSelection = function () {
                    return this.selection;
                };
                this.resize = function (force) {
                    this.renderer.onResize(force);
                };
                this.setTheme = function (theme, cb) {
                    this.renderer.setTheme(theme, cb);
                };
                this.getTheme = function () {
                    return this.renderer.getTheme();
                };
                this.setStyle = function (style) {
                    this.renderer.setStyle(style);
                };
                this.unsetStyle = function (style) {
                    this.renderer.unsetStyle(style);
                };
                this.getFontSize = function () {
                    return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
                };
                this.setFontSize = function (size) {
                    this.setOption("fontSize", size);
                };

                this.$highlightBrackets = function () {
                    if (this.session.$bracketHighlight) {
                        this.session.removeMarker(this.session.$bracketHighlight);
                        this.session.$bracketHighlight = null;
                    }

                    if (this.$highlightPending) {
                        return;
                    }
                    var self = this;
                    this.$highlightPending = true;
                    setTimeout(function () {
                        self.$highlightPending = false;
                        var session = self.session;
                        if (!session || !session.bgTokenizer) return;
                        var pos = session.findMatchingBracket(self.getCursorPosition());
                        if (pos) {
                            var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
                        } else if (session.$mode.getMatching) {
                            var range = session.$mode.getMatching(self.session);
                        }
                        if (range) session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
                    }, 50);
                };
                this.$highlightTags = function () {
                    if (this.$highlightTagPending) return;
                    var self = this;
                    this.$highlightTagPending = true;
                    setTimeout(function () {
                        self.$highlightTagPending = false;

                        var session = self.session;
                        if (!session || !session.bgTokenizer) return;

                        var pos = self.getCursorPosition();
                        var iterator = new TokenIterator(self.session, pos.row, pos.column);
                        var token = iterator.getCurrentToken();

                        if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                            return;
                        }

                        if (token.type.indexOf("tag-open") != -1) {
                            token = iterator.stepForward();
                            if (!token) return;
                        }

                        var tag = token.value;
                        var depth = 0;
                        var prevToken = iterator.stepBackward();

                        if (prevToken.value == '<') {
                            do {
                                prevToken = token;
                                token = iterator.stepForward();

                                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } while (token && depth >= 0);
                        } else {
                            do {
                                token = prevToken;
                                prevToken = iterator.stepBackward();

                                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                    if (prevToken.value === '<') {
                                        depth++;
                                    } else if (prevToken.value === '</') {
                                        depth--;
                                    }
                                }
                            } while (prevToken && depth <= 0);
                            iterator.stepForward();
                        }

                        if (!token) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                            return;
                        }

                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn();
                        var range = new Range(row, column, row, column + token.value.length);
                        if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
                            session.removeMarker(session.$tagHighlight);
                            session.$tagHighlight = null;
                        }

                        if (range && !session.$tagHighlight) session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
                    }, 50);
                };
                this.focus = function () {
                    var _self = this;
                    setTimeout(function () {
                        _self.textInput.focus();
                    });
                    this.textInput.focus();
                };
                this.isFocused = function () {
                    return this.textInput.isFocused();
                };
                this.blur = function () {
                    this.textInput.blur();
                };
                this.onFocus = function (e) {
                    if (this.$isFocused) return;
                    this.$isFocused = true;
                    this.renderer.showCursor();
                    this.renderer.visualizeFocus();
                    this._emit("focus", e);
                };
                this.onBlur = function (e) {
                    if (!this.$isFocused) return;
                    this.$isFocused = false;
                    this.renderer.hideCursor();
                    this.renderer.visualizeBlur();
                    this._emit("blur", e);
                };

                this.$cursorChange = function () {
                    this.renderer.updateCursor();
                };
                this.onDocumentChange = function (delta) {
                    var wrap = this.session.$useWrapMode;
                    var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
                    this.renderer.updateLines(delta.start.row, lastRow, wrap);

                    this._signal("change", delta);
                    this.$cursorChange();
                    this.$updateHighlightActiveLine();
                };

                this.onTokenizerUpdate = function (e) {
                    var rows = e.data;
                    this.renderer.updateLines(rows.first, rows.last);
                };

                this.onScrollTopChange = function () {
                    this.renderer.scrollToY(this.session.getScrollTop());
                };

                this.onScrollLeftChange = function () {
                    this.renderer.scrollToX(this.session.getScrollLeft());
                };
                this.onCursorChange = function () {
                    this.$cursorChange();

                    if (!this.$blockScrolling) {
                        config.warn("Automatically scrolling cursor into view after selection change", "this will be disabled in the next version", "set editor.$blockScrolling = Infinity to disable this message");
                        this.renderer.scrollCursorIntoView();
                    }

                    this.$highlightBrackets();
                    this.$highlightTags();
                    this.$updateHighlightActiveLine();
                    this._signal("changeSelection");
                };

                this.$updateHighlightActiveLine = function () {
                    var session = this.getSession();

                    var highlight;
                    if (this.$highlightActiveLine) {
                        if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) highlight = this.getCursorPosition();
                        if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1)) highlight = false;
                    }

                    if (session.$highlightLineMarker && !highlight) {
                        session.removeMarker(session.$highlightLineMarker.id);
                        session.$highlightLineMarker = null;
                    } else if (!session.$highlightLineMarker && highlight) {
                        var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                        range.id = session.addMarker(range, "ace_active-line", "screenLine");
                        session.$highlightLineMarker = range;
                    } else if (highlight) {
                        session.$highlightLineMarker.start.row = highlight.row;
                        session.$highlightLineMarker.end.row = highlight.row;
                        session.$highlightLineMarker.start.column = highlight.column;
                        session._signal("changeBackMarker");
                    }
                };

                this.onSelectionChange = function (e) {
                    var session = this.session;

                    if (session.$selectionMarker) {
                        session.removeMarker(session.$selectionMarker);
                    }
                    session.$selectionMarker = null;

                    if (!this.selection.isEmpty()) {
                        var range = this.selection.getRange();
                        var style = this.getSelectionStyle();
                        session.$selectionMarker = session.addMarker(range, "ace_selection", style);
                    } else {
                        this.$updateHighlightActiveLine();
                    }

                    var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
                    this.session.highlight(re);

                    this._signal("changeSelection");
                };

                this.$getSelectionHighLightRegexp = function () {
                    var session = this.session;

                    var selection = this.getSelectionRange();
                    if (selection.isEmpty() || selection.isMultiLine()) return;

                    var startOuter = selection.start.column - 1;
                    var endOuter = selection.end.column + 1;
                    var line = session.getLine(selection.start.row);
                    var lineCols = line.length;
                    var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
                    if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle)) return;

                    needle = line.substring(selection.start.column, selection.end.column);
                    if (!/^[\w\d]+$/.test(needle)) return;

                    var re = this.$search.$assembleRegExp({
                        wholeWord: true,
                        caseSensitive: true,
                        needle: needle
                    });

                    return re;
                };

                this.onChangeFrontMarker = function () {
                    this.renderer.updateFrontMarkers();
                };

                this.onChangeBackMarker = function () {
                    this.renderer.updateBackMarkers();
                };

                this.onChangeBreakpoint = function () {
                    this.renderer.updateBreakpoints();
                };

                this.onChangeAnnotation = function () {
                    this.renderer.setAnnotations(this.session.getAnnotations());
                };

                this.onChangeMode = function (e) {
                    this.renderer.updateText();
                    this._emit("changeMode", e);
                };

                this.onChangeWrapLimit = function () {
                    this.renderer.updateFull();
                };

                this.onChangeWrapMode = function () {
                    this.renderer.onResize(true);
                };

                this.onChangeFold = function () {
                    this.$updateHighlightActiveLine();
                    this.renderer.updateFull();
                };
                this.getSelectedText = function () {
                    return this.session.getTextRange(this.getSelectionRange());
                };
                this.getCopyText = function () {
                    var text = this.getSelectedText();
                    this._signal("copy", text);
                    return text;
                };
                this.onCopy = function () {
                    this.commands.exec("copy", this);
                };
                this.onCut = function () {
                    this.commands.exec("cut", this);
                };
                this.onPaste = function (text, event) {
                    var e = { text: text, event: event };
                    this.commands.exec("paste", this, e);
                };

                this.$handlePaste = function (e) {
                    if (typeof e == "string") e = { text: e };
                    this._signal("paste", e);
                    var text = e.text;
                    if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                        this.insert(text);
                    } else {
                        var lines = text.split(/\r\n|\r|\n/);
                        var ranges = this.selection.rangeList.ranges;

                        if (lines.length > ranges.length || lines.length < 2 || !lines[1]) return this.commands.exec("insertstring", this, text);

                        for (var i = ranges.length; i--;) {
                            var range = ranges[i];
                            if (!range.isEmpty()) this.session.remove(range);

                            this.session.insert(range.start, lines[i]);
                        }
                    }
                };

                this.execCommand = function (command, args) {
                    return this.commands.exec(command, this, args);
                };
                this.insert = function (text, pasted) {
                    var session = this.session;
                    var mode = session.getMode();
                    var cursor = this.getCursorPosition();

                    if (this.getBehavioursEnabled() && !pasted) {
                        var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                        if (transform) {
                            if (text !== transform.text) {
                                this.session.mergeUndoDeltas = false;
                                this.$mergeNextCommand = false;
                            }
                            text = transform.text;
                        }
                    }

                    if (text == "\t") text = this.session.getTabString();
                    if (!this.selection.isEmpty()) {
                        var range = this.getSelectionRange();
                        cursor = this.session.remove(range);
                        this.clearSelection();
                    } else if (this.session.getOverwrite()) {
                        var range = new Range.fromPoints(cursor, cursor);
                        range.end.column += text.length;
                        this.session.remove(range);
                    }

                    if (text == "\n" || text == "\r\n") {
                        var line = session.getLine(cursor.row);
                        if (cursor.column > line.search(/\S|$/)) {
                            var d = line.substr(cursor.column).search(/\S|$/);
                            session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                        }
                    }
                    this.clearSelection();

                    var start = cursor.column;
                    var lineState = session.getState(cursor.row);
                    var line = session.getLine(cursor.row);
                    var shouldOutdent = mode.checkOutdent(lineState, line, text);
                    var end = session.insert(cursor, text);

                    if (transform && transform.selection) {
                        if (transform.selection.length == 2) {
                            // Transform relative to the current column
                            this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                        } else {
                            // Transform relative to the current row.
                            this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
                        }
                    }

                    if (session.getDocument().isNewLine(text)) {
                        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

                        session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
                    }
                    if (shouldOutdent) mode.autoOutdent(lineState, session, cursor.row);
                };

                this.onTextInput = function (text) {
                    this.keyBinding.onTextInput(text);
                };

                this.onCommandKey = function (e, hashId, keyCode) {
                    this.keyBinding.onCommandKey(e, hashId, keyCode);
                };
                this.setOverwrite = function (overwrite) {
                    this.session.setOverwrite(overwrite);
                };
                this.getOverwrite = function () {
                    return this.session.getOverwrite();
                };
                this.toggleOverwrite = function () {
                    this.session.toggleOverwrite();
                };
                this.setScrollSpeed = function (speed) {
                    this.setOption("scrollSpeed", speed);
                };
                this.getScrollSpeed = function () {
                    return this.getOption("scrollSpeed");
                };
                this.setDragDelay = function (dragDelay) {
                    this.setOption("dragDelay", dragDelay);
                };
                this.getDragDelay = function () {
                    return this.getOption("dragDelay");
                };
                this.setSelectionStyle = function (val) {
                    this.setOption("selectionStyle", val);
                };
                this.getSelectionStyle = function () {
                    return this.getOption("selectionStyle");
                };
                this.setHighlightActiveLine = function (shouldHighlight) {
                    this.setOption("highlightActiveLine", shouldHighlight);
                };
                this.getHighlightActiveLine = function () {
                    return this.getOption("highlightActiveLine");
                };
                this.setHighlightGutterLine = function (shouldHighlight) {
                    this.setOption("highlightGutterLine", shouldHighlight);
                };

                this.getHighlightGutterLine = function () {
                    return this.getOption("highlightGutterLine");
                };
                this.setHighlightSelectedWord = function (shouldHighlight) {
                    this.setOption("highlightSelectedWord", shouldHighlight);
                };
                this.getHighlightSelectedWord = function () {
                    return this.$highlightSelectedWord;
                };

                this.setAnimatedScroll = function (shouldAnimate) {
                    this.renderer.setAnimatedScroll(shouldAnimate);
                };

                this.getAnimatedScroll = function () {
                    return this.renderer.getAnimatedScroll();
                };
                this.setShowInvisibles = function (showInvisibles) {
                    this.renderer.setShowInvisibles(showInvisibles);
                };
                this.getShowInvisibles = function () {
                    return this.renderer.getShowInvisibles();
                };

                this.setDisplayIndentGuides = function (display) {
                    this.renderer.setDisplayIndentGuides(display);
                };

                this.getDisplayIndentGuides = function () {
                    return this.renderer.getDisplayIndentGuides();
                };
                this.setShowPrintMargin = function (showPrintMargin) {
                    this.renderer.setShowPrintMargin(showPrintMargin);
                };
                this.getShowPrintMargin = function () {
                    return this.renderer.getShowPrintMargin();
                };
                this.setPrintMarginColumn = function (showPrintMargin) {
                    this.renderer.setPrintMarginColumn(showPrintMargin);
                };
                this.getPrintMarginColumn = function () {
                    return this.renderer.getPrintMarginColumn();
                };
                this.setReadOnly = function (readOnly) {
                    this.setOption("readOnly", readOnly);
                };
                this.getReadOnly = function () {
                    return this.getOption("readOnly");
                };
                this.setBehavioursEnabled = function (enabled) {
                    this.setOption("behavioursEnabled", enabled);
                };
                this.getBehavioursEnabled = function () {
                    return this.getOption("behavioursEnabled");
                };
                this.setWrapBehavioursEnabled = function (enabled) {
                    this.setOption("wrapBehavioursEnabled", enabled);
                };
                this.getWrapBehavioursEnabled = function () {
                    return this.getOption("wrapBehavioursEnabled");
                };
                this.setShowFoldWidgets = function (show) {
                    this.setOption("showFoldWidgets", show);
                };
                this.getShowFoldWidgets = function () {
                    return this.getOption("showFoldWidgets");
                };

                this.setFadeFoldWidgets = function (fade) {
                    this.setOption("fadeFoldWidgets", fade);
                };

                this.getFadeFoldWidgets = function () {
                    return this.getOption("fadeFoldWidgets");
                };
                this.remove = function (dir) {
                    if (this.selection.isEmpty()) {
                        if (dir == "left") this.selection.selectLeft();else this.selection.selectRight();
                    }

                    var range = this.getSelectionRange();
                    if (this.getBehavioursEnabled()) {
                        var session = this.session;
                        var state = session.getState(range.start.row);
                        var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

                        if (range.end.column === 0) {
                            var text = session.getTextRange(range);
                            if (text[text.length - 1] == "\n") {
                                var line = session.getLine(range.end.row);
                                if (/^\s+$/.test(line)) {
                                    range.end.column = line.length;
                                }
                            }
                        }
                        if (new_range) range = new_range;
                    }

                    this.session.remove(range);
                    this.clearSelection();
                };
                this.removeWordRight = function () {
                    if (this.selection.isEmpty()) this.selection.selectWordRight();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeWordLeft = function () {
                    if (this.selection.isEmpty()) this.selection.selectWordLeft();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeToLineStart = function () {
                    if (this.selection.isEmpty()) this.selection.selectLineStart();

                    this.session.remove(this.getSelectionRange());
                    this.clearSelection();
                };
                this.removeToLineEnd = function () {
                    if (this.selection.isEmpty()) this.selection.selectLineEnd();

                    var range = this.getSelectionRange();
                    if (range.start.column == range.end.column && range.start.row == range.end.row) {
                        range.end.column = 0;
                        range.end.row++;
                    }

                    this.session.remove(range);
                    this.clearSelection();
                };
                this.splitLine = function () {
                    if (!this.selection.isEmpty()) {
                        this.session.remove(this.getSelectionRange());
                        this.clearSelection();
                    }

                    var cursor = this.getCursorPosition();
                    this.insert("\n");
                    this.moveCursorToPosition(cursor);
                };
                this.transposeLetters = function () {
                    if (!this.selection.isEmpty()) {
                        return;
                    }

                    var cursor = this.getCursorPosition();
                    var column = cursor.column;
                    if (column === 0) return;

                    var line = this.session.getLine(cursor.row);
                    var swap, range;
                    if (column < line.length) {
                        swap = line.charAt(column) + line.charAt(column - 1);
                        range = new Range(cursor.row, column - 1, cursor.row, column + 1);
                    } else {
                        swap = line.charAt(column - 1) + line.charAt(column - 2);
                        range = new Range(cursor.row, column - 2, cursor.row, column);
                    }
                    this.session.replace(range, swap);
                };
                this.toLowerCase = function () {
                    var originalRange = this.getSelectionRange();
                    if (this.selection.isEmpty()) {
                        this.selection.selectWord();
                    }

                    var range = this.getSelectionRange();
                    var text = this.session.getTextRange(range);
                    this.session.replace(range, text.toLowerCase());
                    this.selection.setSelectionRange(originalRange);
                };
                this.toUpperCase = function () {
                    var originalRange = this.getSelectionRange();
                    if (this.selection.isEmpty()) {
                        this.selection.selectWord();
                    }

                    var range = this.getSelectionRange();
                    var text = this.session.getTextRange(range);
                    this.session.replace(range, text.toUpperCase());
                    this.selection.setSelectionRange(originalRange);
                };
                this.indent = function () {
                    var session = this.session;
                    var range = this.getSelectionRange();

                    if (range.start.row < range.end.row) {
                        var rows = this.$getSelectedRows();
                        session.indentRows(rows.first, rows.last, "\t");
                        return;
                    } else if (range.start.column < range.end.column) {
                        var text = session.getTextRange(range);
                        if (!/^\s+$/.test(text)) {
                            var rows = this.$getSelectedRows();
                            session.indentRows(rows.first, rows.last, "\t");
                            return;
                        }
                    }

                    var line = session.getLine(range.start.row);
                    var position = range.start;
                    var size = session.getTabSize();
                    var column = session.documentToScreenColumn(position.row, position.column);

                    if (this.session.getUseSoftTabs()) {
                        var count = size - column % size;
                        var indentString = lang.stringRepeat(" ", count);
                    } else {
                        var count = column % size;
                        while (line[range.start.column - 1] == " " && count) {
                            range.start.column--;
                            count--;
                        }
                        this.selection.setSelectionRange(range);
                        indentString = "\t";
                    }
                    return this.insert(indentString);
                };
                this.blockIndent = function () {
                    var rows = this.$getSelectedRows();
                    this.session.indentRows(rows.first, rows.last, "\t");
                };
                this.blockOutdent = function () {
                    var selection = this.session.getSelection();
                    this.session.outdentRows(selection.getRange());
                };
                this.sortLines = function () {
                    var rows = this.$getSelectedRows();
                    var session = this.session;

                    var lines = [];
                    for (i = rows.first; i <= rows.last; i++) lines.push(session.getLine(i));

                    lines.sort(function (a, b) {
                        if (a.toLowerCase() < b.toLowerCase()) return -1;
                        if (a.toLowerCase() > b.toLowerCase()) return 1;
                        return 0;
                    });

                    var deleteRange = new Range(0, 0, 0, 0);
                    for (var i = rows.first; i <= rows.last; i++) {
                        var line = session.getLine(i);
                        deleteRange.start.row = i;
                        deleteRange.end.row = i;
                        deleteRange.end.column = line.length;
                        session.replace(deleteRange, lines[i - rows.first]);
                    }
                };
                this.toggleCommentLines = function () {
                    var state = this.session.getState(this.getCursorPosition().row);
                    var rows = this.$getSelectedRows();
                    this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
                };

                this.toggleBlockComment = function () {
                    var cursor = this.getCursorPosition();
                    var state = this.session.getState(cursor.row);
                    var range = this.getSelectionRange();
                    this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
                };
                this.getNumberAt = function (row, column) {
                    var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
                    _numberRx.lastIndex = 0;

                    var s = this.session.getLine(row);
                    while (_numberRx.lastIndex < column) {
                        var m = _numberRx.exec(s);
                        if (m.index <= column && m.index + m[0].length >= column) {
                            var number = {
                                value: m[0],
                                start: m.index,
                                end: m.index + m[0].length
                            };
                            return number;
                        }
                    }
                    return null;
                };
                this.modifyNumber = function (amount) {
                    var row = this.selection.getCursor().row;
                    var column = this.selection.getCursor().column;
                    var charRange = new Range(row, column - 1, row, column);

                    var c = this.session.getTextRange(charRange);
                    if (!isNaN(parseFloat(c)) && isFinite(c)) {
                        var nr = this.getNumberAt(row, column);
                        if (nr) {
                            var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                            var decimals = nr.start + nr.value.length - fp;

                            var t = parseFloat(nr.value);
                            t *= Math.pow(10, decimals);

                            if (fp !== nr.end && column < fp) {
                                amount *= Math.pow(10, nr.end - column - 1);
                            } else {
                                amount *= Math.pow(10, nr.end - column);
                            }

                            t += amount;
                            t /= Math.pow(10, decimals);
                            var nnr = t.toFixed(decimals);
                            var replaceRange = new Range(row, nr.start, row, nr.end);
                            this.session.replace(replaceRange, nnr);
                            this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                        }
                    }
                };
                this.removeLines = function () {
                    var rows = this.$getSelectedRows();
                    this.session.removeFullLines(rows.first, rows.last);
                    this.clearSelection();
                };

                this.duplicateSelection = function () {
                    var sel = this.selection;
                    var doc = this.session;
                    var range = sel.getRange();
                    var reverse = sel.isBackwards();
                    if (range.isEmpty()) {
                        var row = range.start.row;
                        doc.duplicateLines(row, row);
                    } else {
                        var point = reverse ? range.start : range.end;
                        var endPoint = doc.insert(point, doc.getTextRange(range), false);
                        range.start = point;
                        range.end = endPoint;

                        sel.setSelectionRange(range, reverse);
                    }
                };
                this.moveLinesDown = function () {
                    this.$moveLines(1, false);
                };
                this.moveLinesUp = function () {
                    this.$moveLines(-1, false);
                };
                this.moveText = function (range, toPosition, copy) {
                    return this.session.moveText(range, toPosition, copy);
                };
                this.copyLinesUp = function () {
                    this.$moveLines(-1, true);
                };
                this.copyLinesDown = function () {
                    this.$moveLines(1, true);
                };
                this.$moveLines = function (dir, copy) {
                    var rows, moved;
                    var selection = this.selection;
                    if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                        var range = selection.toOrientedRange();
                        rows = this.$getSelectedRows(range);
                        moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                        if (copy && dir == -1) moved = 0;
                        range.moveBy(moved, 0);
                        selection.fromOrientedRange(range);
                    } else {
                        var ranges = selection.rangeList.ranges;
                        selection.rangeList.detach(this.session);
                        this.inVirtualSelectionMode = true;

                        var diff = 0;
                        var totalDiff = 0;
                        var l = ranges.length;
                        for (var i = 0; i < l; i++) {
                            var rangeIndex = i;
                            ranges[i].moveBy(diff, 0);
                            rows = this.$getSelectedRows(ranges[i]);
                            var first = rows.first;
                            var last = rows.last;
                            while (++i < l) {
                                if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                                var subRows = this.$getSelectedRows(ranges[i]);
                                if (copy && subRows.first != last) break;else if (!copy && subRows.first > last + 1) break;
                                last = subRows.last;
                            }
                            i--;
                            diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                            if (copy && dir == -1) rangeIndex = i + 1;
                            while (rangeIndex <= i) {
                                ranges[rangeIndex].moveBy(diff, 0);
                                rangeIndex++;
                            }
                            if (!copy) diff = 0;
                            totalDiff += diff;
                        }

                        selection.fromOrientedRange(selection.ranges[0]);
                        selection.rangeList.attach(this.session);
                        this.inVirtualSelectionMode = false;
                    }
                };
                this.$getSelectedRows = function (range) {
                    range = (range || this.getSelectionRange()).collapseRows();

                    return {
                        first: this.session.getRowFoldStart(range.start.row),
                        last: this.session.getRowFoldEnd(range.end.row)
                    };
                };

                this.onCompositionStart = function (text) {
                    this.renderer.showComposition(this.getCursorPosition());
                };

                this.onCompositionUpdate = function (text) {
                    this.renderer.setCompositionText(text);
                };

                this.onCompositionEnd = function () {
                    this.renderer.hideComposition();
                };
                this.getFirstVisibleRow = function () {
                    return this.renderer.getFirstVisibleRow();
                };
                this.getLastVisibleRow = function () {
                    return this.renderer.getLastVisibleRow();
                };
                this.isRowVisible = function (row) {
                    return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
                };
                this.isRowFullyVisible = function (row) {
                    return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
                };
                this.$getVisibleRowCount = function () {
                    return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
                };

                this.$moveByPage = function (dir, select) {
                    var renderer = this.renderer;
                    var config = this.renderer.layerConfig;
                    var rows = dir * Math.floor(config.height / config.lineHeight);

                    this.$blockScrolling++;
                    if (select === true) {
                        this.selection.$moveSelection(function () {
                            this.moveCursorBy(rows, 0);
                        });
                    } else if (select === false) {
                        this.selection.moveCursorBy(rows, 0);
                        this.selection.clearSelection();
                    }
                    this.$blockScrolling--;

                    var scrollTop = renderer.scrollTop;

                    renderer.scrollBy(0, rows * config.lineHeight);
                    if (select != null) renderer.scrollCursorIntoView(null, 0.5);

                    renderer.animateScrolling(scrollTop);
                };
                this.selectPageDown = function () {
                    this.$moveByPage(1, true);
                };
                this.selectPageUp = function () {
                    this.$moveByPage(-1, true);
                };
                this.gotoPageDown = function () {
                    this.$moveByPage(1, false);
                };
                this.gotoPageUp = function () {
                    this.$moveByPage(-1, false);
                };
                this.scrollPageDown = function () {
                    this.$moveByPage(1);
                };
                this.scrollPageUp = function () {
                    this.$moveByPage(-1);
                };
                this.scrollToRow = function (row) {
                    this.renderer.scrollToRow(row);
                };
                this.scrollToLine = function (line, center, animate, callback) {
                    this.renderer.scrollToLine(line, center, animate, callback);
                };
                this.centerSelection = function () {
                    var range = this.getSelectionRange();
                    var pos = {
                        row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                        column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                    };
                    this.renderer.alignCursor(pos, 0.5);
                };
                this.getCursorPosition = function () {
                    return this.selection.getCursor();
                };
                this.getCursorPositionScreen = function () {
                    return this.session.documentToScreenPosition(this.getCursorPosition());
                };
                this.getSelectionRange = function () {
                    return this.selection.getRange();
                };
                this.selectAll = function () {
                    this.$blockScrolling += 1;
                    this.selection.selectAll();
                    this.$blockScrolling -= 1;
                };
                this.clearSelection = function () {
                    this.selection.clearSelection();
                };
                this.moveCursorTo = function (row, column) {
                    this.selection.moveCursorTo(row, column);
                };
                this.moveCursorToPosition = function (pos) {
                    this.selection.moveCursorToPosition(pos);
                };
                this.jumpToMatching = function (select, expand) {
                    var cursor = this.getCursorPosition();
                    var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
                    var prevToken = iterator.getCurrentToken();
                    var token = prevToken || iterator.stepForward();

                    if (!token) return;
                    var matchType;
                    var found = false;
                    var depth = {};
                    var i = cursor.column - token.start;
                    var bracketType;
                    var brackets = {
                        ")": "(",
                        "(": "(",
                        "]": "[",
                        "[": "[",
                        "{": "{",
                        "}": "{"
                    };

                    do {
                        if (token.value.match(/[{}()\[\]]/g)) {
                            for (; i < token.value.length && !found; i++) {
                                if (!brackets[token.value[i]]) {
                                    continue;
                                }

                                bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                                if (isNaN(depth[bracketType])) {
                                    depth[bracketType] = 0;
                                }

                                switch (token.value[i]) {
                                    case '(':
                                    case '[':
                                    case '{':
                                        depth[bracketType]++;
                                        break;
                                    case ')':
                                    case ']':
                                    case '}':
                                        depth[bracketType]--;

                                        if (depth[bracketType] === -1) {
                                            matchType = 'bracket';
                                            found = true;
                                        }
                                        break;
                                }
                            }
                        } else if (token && token.type.indexOf('tag-name') !== -1) {
                            if (isNaN(depth[token.value])) {
                                depth[token.value] = 0;
                            }

                            if (prevToken.value === '<') {
                                depth[token.value]++;
                            } else if (prevToken.value === '</') {
                                depth[token.value]--;
                            }

                            if (depth[token.value] === -1) {
                                matchType = 'tag';
                                found = true;
                            }
                        }

                        if (!found) {
                            prevToken = token;
                            token = iterator.stepForward();
                            i = 0;
                        }
                    } while (token && !found);
                    if (!matchType) return;

                    var range, pos;
                    if (matchType === 'bracket') {
                        range = this.session.getBracketRange(cursor);
                        if (!range) {
                            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                            pos = range.start;
                            if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
                        }
                    } else if (matchType === 'tag') {
                        if (token && token.type.indexOf('tag-name') !== -1) var tag = token.value;else return;

                        range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                        if (range.compare(cursor.row, cursor.column) === 0) {
                            found = false;
                            do {
                                token = prevToken;
                                prevToken = iterator.stepBackward();

                                if (prevToken) {
                                    if (prevToken.type.indexOf('tag-close') !== -1) {
                                        range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                                    }

                                    if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                        if (prevToken.value === '<') {
                                            depth[tag]++;
                                        } else if (prevToken.value === '</') {
                                            depth[tag]--;
                                        }

                                        if (depth[tag] === 0) found = true;
                                    }
                                }
                            } while (prevToken && !found);
                        }
                        if (token && token.type.indexOf('tag-name')) {
                            pos = range.start;
                            if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2) pos = range.end;
                        }
                    }

                    pos = range && range.cursor || pos;
                    if (pos) {
                        if (select) {
                            if (range && expand) {
                                this.selection.setRange(range);
                            } else if (range && range.isEqual(this.getSelectionRange())) {
                                this.clearSelection();
                            } else {
                                this.selection.selectTo(pos.row, pos.column);
                            }
                        } else {
                            this.selection.moveTo(pos.row, pos.column);
                        }
                    }
                };
                this.gotoLine = function (lineNumber, column, animate) {
                    this.selection.clearSelection();
                    this.session.unfold({ row: lineNumber - 1, column: column || 0 });

                    this.$blockScrolling += 1;
                    this.exitMultiSelectMode && this.exitMultiSelectMode();
                    this.moveCursorTo(lineNumber - 1, column || 0);
                    this.$blockScrolling -= 1;

                    if (!this.isRowFullyVisible(lineNumber - 1)) this.scrollToLine(lineNumber - 1, true, animate);
                };
                this.navigateTo = function (row, column) {
                    this.selection.moveTo(row, column);
                };
                this.navigateUp = function (times) {
                    if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                        var selectionStart = this.selection.anchor.getPosition();
                        return this.moveCursorToPosition(selectionStart);
                    }
                    this.selection.clearSelection();
                    this.selection.moveCursorBy(-times || -1, 0);
                };
                this.navigateDown = function (times) {
                    if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                        var selectionEnd = this.selection.anchor.getPosition();
                        return this.moveCursorToPosition(selectionEnd);
                    }
                    this.selection.clearSelection();
                    this.selection.moveCursorBy(times || 1, 0);
                };
                this.navigateLeft = function (times) {
                    if (!this.selection.isEmpty()) {
                        var selectionStart = this.getSelectionRange().start;
                        this.moveCursorToPosition(selectionStart);
                    } else {
                        times = times || 1;
                        while (times--) {
                            this.selection.moveCursorLeft();
                        }
                    }
                    this.clearSelection();
                };
                this.navigateRight = function (times) {
                    if (!this.selection.isEmpty()) {
                        var selectionEnd = this.getSelectionRange().end;
                        this.moveCursorToPosition(selectionEnd);
                    } else {
                        times = times || 1;
                        while (times--) {
                            this.selection.moveCursorRight();
                        }
                    }
                    this.clearSelection();
                };
                this.navigateLineStart = function () {
                    this.selection.moveCursorLineStart();
                    this.clearSelection();
                };
                this.navigateLineEnd = function () {
                    this.selection.moveCursorLineEnd();
                    this.clearSelection();
                };
                this.navigateFileEnd = function () {
                    this.selection.moveCursorFileEnd();
                    this.clearSelection();
                };
                this.navigateFileStart = function () {
                    this.selection.moveCursorFileStart();
                    this.clearSelection();
                };
                this.navigateWordRight = function () {
                    this.selection.moveCursorWordRight();
                    this.clearSelection();
                };
                this.navigateWordLeft = function () {
                    this.selection.moveCursorWordLeft();
                    this.clearSelection();
                };
                this.replace = function (replacement, options) {
                    if (options) this.$search.set(options);

                    var range = this.$search.find(this.session);
                    var replaced = 0;
                    if (!range) return replaced;

                    if (this.$tryReplace(range, replacement)) {
                        replaced = 1;
                    }
                    if (range !== null) {
                        this.selection.setSelectionRange(range);
                        this.renderer.scrollSelectionIntoView(range.start, range.end);
                    }

                    return replaced;
                };
                this.replaceAll = function (replacement, options) {
                    if (options) {
                        this.$search.set(options);
                    }

                    var ranges = this.$search.findAll(this.session);
                    var replaced = 0;
                    if (!ranges.length) return replaced;

                    this.$blockScrolling += 1;

                    var selection = this.getSelectionRange();
                    this.selection.moveTo(0, 0);

                    for (var i = ranges.length - 1; i >= 0; --i) {
                        if (this.$tryReplace(ranges[i], replacement)) {
                            replaced++;
                        }
                    }

                    this.selection.setSelectionRange(selection);
                    this.$blockScrolling -= 1;

                    return replaced;
                };

                this.$tryReplace = function (range, replacement) {
                    var input = this.session.getTextRange(range);
                    replacement = this.$search.replace(input, replacement);
                    if (replacement !== null) {
                        range.end = this.session.replace(range, replacement);
                        return range;
                    } else {
                        return null;
                    }
                };
                this.getLastSearchOptions = function () {
                    return this.$search.getOptions();
                };
                this.find = function (needle, options, animate) {
                    if (!options) options = {};

                    if (typeof needle == "string" || needle instanceof RegExp) options.needle = needle;else if (typeof needle == "object") oop.mixin(options, needle);

                    var range = this.selection.getRange();
                    if (options.needle == null) {
                        needle = this.session.getTextRange(range) || this.$search.$options.needle;
                        if (!needle) {
                            range = this.session.getWordRange(range.start.row, range.start.column);
                            needle = this.session.getTextRange(range);
                        }
                        this.$search.set({ needle: needle });
                    }

                    this.$search.set(options);
                    if (!options.start) this.$search.set({ start: range });

                    var newRange = this.$search.find(this.session);
                    if (options.preventScroll) return newRange;
                    if (newRange) {
                        this.revealRange(newRange, animate);
                        return newRange;
                    }
                    if (options.backwards) range.start = range.end;else range.end = range.start;
                    this.selection.setRange(range);
                };
                this.findNext = function (options, animate) {
                    this.find({ skipCurrent: true, backwards: false }, options, animate);
                };
                this.findPrevious = function (options, animate) {
                    this.find(options, { skipCurrent: true, backwards: true }, animate);
                };

                this.revealRange = function (range, animate) {
                    this.$blockScrolling += 1;
                    this.session.unfold(range);
                    this.selection.setSelectionRange(range);
                    this.$blockScrolling -= 1;

                    var scrollTop = this.renderer.scrollTop;
                    this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
                    if (animate !== false) this.renderer.animateScrolling(scrollTop);
                };
                this.undo = function () {
                    this.$blockScrolling++;
                    this.session.getUndoManager().undo();
                    this.$blockScrolling--;
                    this.renderer.scrollCursorIntoView(null, 0.5);
                };
                this.redo = function () {
                    this.$blockScrolling++;
                    this.session.getUndoManager().redo();
                    this.$blockScrolling--;
                    this.renderer.scrollCursorIntoView(null, 0.5);
                };
                this.destroy = function () {
                    this.renderer.destroy();
                    this._signal("destroy", this);
                    if (this.session) {
                        this.session.destroy();
                    }
                };
                this.setAutoScrollEditorIntoView = function (enable) {
                    if (!enable) return;
                    var rect;
                    var self = this;
                    var shouldScroll = false;
                    if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
                    var scrollAnchor = this.$scrollAnchor;
                    scrollAnchor.style.cssText = "position:absolute";
                    this.container.insertBefore(scrollAnchor, this.container.firstChild);
                    var onChangeSelection = this.on("changeSelection", function () {
                        shouldScroll = true;
                    });
                    var onBeforeRender = this.renderer.on("beforeRender", function () {
                        if (shouldScroll) rect = self.renderer.container.getBoundingClientRect();
                    });
                    var onAfterRender = this.renderer.on("afterRender", function () {
                        if (shouldScroll && rect && (self.isFocused() || self.searchBox && self.searchBox.isFocused())) {
                            var renderer = self.renderer;
                            var pos = renderer.$cursorLayer.$pixelPos;
                            var config = renderer.layerConfig;
                            var top = pos.top - config.offset;
                            if (pos.top >= 0 && top + rect.top < 0) {
                                shouldScroll = true;
                            } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                                shouldScroll = false;
                            } else {
                                shouldScroll = null;
                            }
                            if (shouldScroll != null) {
                                scrollAnchor.style.top = top + "px";
                                scrollAnchor.style.left = pos.left + "px";
                                scrollAnchor.style.height = config.lineHeight + "px";
                                scrollAnchor.scrollIntoView(shouldScroll);
                            }
                            shouldScroll = rect = null;
                        }
                    });
                    this.setAutoScrollEditorIntoView = function (enable) {
                        if (enable) return;
                        delete this.setAutoScrollEditorIntoView;
                        this.off("changeSelection", onChangeSelection);
                        this.renderer.off("afterRender", onAfterRender);
                        this.renderer.off("beforeRender", onBeforeRender);
                    };
                };

                this.$resetCursorStyle = function () {
                    var style = this.$cursorStyle || "ace";
                    var cursorLayer = this.renderer.$cursorLayer;
                    if (!cursorLayer) return;
                    cursorLayer.setSmoothBlinking(/smooth/.test(style));
                    cursorLayer.isBlinking = !this.$readOnly && style != "wide";
                    dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
                };
            }).call(Editor.prototype);

            config.defineOptions(Editor.prototype, "editor", {
                selectionStyle: {
                    set: function (style) {
                        this.onSelectionChange();
                        this._signal("changeSelectionStyle", { data: style });
                    },
                    initialValue: "line"
                },
                highlightActiveLine: {
                    set: function () {
                        this.$updateHighlightActiveLine();
                    },
                    initialValue: true
                },
                highlightSelectedWord: {
                    set: function (shouldHighlight) {
                        this.$onSelectionChange();
                    },
                    initialValue: true
                },
                readOnly: {
                    set: function (readOnly) {
                        this.$resetCursorStyle();
                    },
                    initialValue: false
                },
                cursorStyle: {
                    set: function (val) {
                        this.$resetCursorStyle();
                    },
                    values: ["ace", "slim", "smooth", "wide"],
                    initialValue: "ace"
                },
                mergeUndoDeltas: {
                    values: [false, true, "always"],
                    initialValue: true
                },
                behavioursEnabled: { initialValue: true },
                wrapBehavioursEnabled: { initialValue: true },
                autoScrollEditorIntoView: {
                    set: function (val) {
                        this.setAutoScrollEditorIntoView(val);
                    }
                },
                keyboardHandler: {
                    set: function (val) {
                        this.setKeyboardHandler(val);
                    },
                    get: function () {
                        return this.keybindingId;
                    },
                    handlesSet: true
                },

                hScrollBarAlwaysVisible: "renderer",
                vScrollBarAlwaysVisible: "renderer",
                highlightGutterLine: "renderer",
                animatedScroll: "renderer",
                showInvisibles: "renderer",
                showPrintMargin: "renderer",
                printMarginColumn: "renderer",
                printMargin: "renderer",
                fadeFoldWidgets: "renderer",
                showFoldWidgets: "renderer",
                showLineNumbers: "renderer",
                showGutter: "renderer",
                displayIndentGuides: "renderer",
                fontSize: "renderer",
                fontFamily: "renderer",
                maxLines: "renderer",
                minLines: "renderer",
                scrollPastEnd: "renderer",
                fixedWidthGutter: "renderer",
                theme: "renderer",

                scrollSpeed: "$mouseHandler",
                dragDelay: "$mouseHandler",
                dragEnabled: "$mouseHandler",
                focusTimout: "$mouseHandler",
                tooltipFollowsMouse: "$mouseHandler",

                firstLineNumber: "session",
                overwrite: "session",
                newLineMode: "session",
                useWorker: "session",
                useSoftTabs: "session",
                tabSize: "session",
                wrap: "session",
                indentedSoftWrap: "session",
                foldStyle: "session",
                mode: "session"
            });

            exports.Editor = Editor;
        });

        ace.define("ace/undomanager", ["require", "exports", "module"], function (require, exports, module) {
            "use strict";

            var UndoManager = function () {
                this.reset();
            };

            (function () {
                this.execute = function (options) {
                    var deltaSets = options.args[0];
                    this.$doc = options.args[1];
                    if (options.merge && this.hasUndo()) {
                        this.dirtyCounter--;
                        deltaSets = this.$undoStack.pop().concat(deltaSets);
                    }
                    this.$undoStack.push(deltaSets);
                    this.$redoStack = [];
                    if (this.dirtyCounter < 0) {
                        this.dirtyCounter = NaN;
                    }
                    this.dirtyCounter++;
                };
                this.undo = function (dontSelect) {
                    var deltaSets = this.$undoStack.pop();
                    var undoSelectionRange = null;
                    if (deltaSets) {
                        undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
                        this.$redoStack.push(deltaSets);
                        this.dirtyCounter--;
                    }

                    return undoSelectionRange;
                };
                this.redo = function (dontSelect) {
                    var deltaSets = this.$redoStack.pop();
                    var redoSelectionRange = null;
                    if (deltaSets) {
                        redoSelectionRange = this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
                        this.$undoStack.push(deltaSets);
                        this.dirtyCounter++;
                    }
                    return redoSelectionRange;
                };
                this.reset = function () {
                    this.$undoStack = [];
                    this.$redoStack = [];
                    this.dirtyCounter = 0;
                };
                this.hasUndo = function () {
                    return this.$undoStack.length > 0;
                };
                this.hasRedo = function () {
                    return this.$redoStack.length > 0;
                };
                this.markClean = function () {
                    this.dirtyCounter = 0;
                };
                this.isClean = function () {
                    return this.dirtyCounter === 0;
                };
                this.$serializeDeltas = function (deltaSets) {
                    return cloneDeltaSetsObj(deltaSets, $serializeDelta);
                };
                this.$deserializeDeltas = function (deltaSets) {
                    return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
                };

                function $serializeDelta(delta) {
                    return {
                        action: delta.action,
                        start: delta.start,
                        end: delta.end,
                        lines: delta.lines.length == 1 ? null : delta.lines,
                        text: delta.lines.length == 1 ? delta.lines[0] : null
                    };
                }

                function $deserializeDelta(delta) {
                    return {
                        action: delta.action,
                        start: delta.start,
                        end: delta.end,
                        lines: delta.lines || [delta.text]
                    };
                }

                function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
                    var deltaSets_new = new Array(deltaSets_old.length);
                    for (var i = 0; i < deltaSets_old.length; i++) {
                        var deltaSet_old = deltaSets_old[i];
                        var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length) };

                        for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                            var delta_old = deltaSet_old.deltas[j];
                            deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
                        }

                        deltaSets_new[i] = deltaSet_new;
                    }
                    return deltaSets_new;
                }
            }).call(UndoManager.prototype);

            exports.UndoManager = UndoManager;
        });

        ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var oop = require("../lib/oop");
            var lang = require("../lib/lang");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var Gutter = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_gutter-layer";
                parentEl.appendChild(this.element);
                this.setShowFoldWidgets(this.$showFoldWidgets);

                this.gutterWidth = 0;

                this.$annotations = [];
                this.$updateAnnotations = this.$updateAnnotations.bind(this);

                this.$cells = [];
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.setSession = function (session) {
                    if (this.session) this.session.removeEventListener("change", this.$updateAnnotations);
                    this.session = session;
                    if (session) session.on("change", this.$updateAnnotations);
                };

                this.addGutterDecoration = function (row, className) {
                    if (window.console) console.warn && console.warn("deprecated use session.addGutterDecoration");
                    this.session.addGutterDecoration(row, className);
                };

                this.removeGutterDecoration = function (row, className) {
                    if (window.console) console.warn && console.warn("deprecated use session.removeGutterDecoration");
                    this.session.removeGutterDecoration(row, className);
                };

                this.setAnnotations = function (annotations) {
                    this.$annotations = [];
                    for (var i = 0; i < annotations.length; i++) {
                        var annotation = annotations[i];
                        var row = annotation.row;
                        var rowInfo = this.$annotations[row];
                        if (!rowInfo) rowInfo = this.$annotations[row] = { text: [] };

                        var annoText = annotation.text;
                        annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

                        if (rowInfo.text.indexOf(annoText) === -1) rowInfo.text.push(annoText);

                        var type = annotation.type;
                        if (type == "error") rowInfo.className = " ace_error";else if (type == "warning" && rowInfo.className != " ace_error") rowInfo.className = " ace_warning";else if (type == "info" && !rowInfo.className) rowInfo.className = " ace_info";
                    }
                };

                this.$updateAnnotations = function (delta) {
                    if (!this.$annotations.length) return;
                    var firstRow = delta.start.row;
                    var len = delta.end.row - firstRow;
                    if (len === 0) {} else if (delta.action == 'remove') {
                        this.$annotations.splice(firstRow, len + 1, null);
                    } else {
                        var args = new Array(len + 1);
                        args.unshift(firstRow, 1);
                        this.$annotations.splice.apply(this.$annotations, args);
                    }
                };

                this.update = function (config) {
                    var session = this.session;
                    var firstRow = config.firstRow;
                    var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
                    session.getLength() - 1);
                    var fold = session.getNextFoldLine(firstRow);
                    var foldStart = fold ? fold.start.row : Infinity;
                    var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
                    var breakpoints = session.$breakpoints;
                    var decorations = session.$decorations;
                    var firstLineNumber = session.$firstLineNumber;
                    var lastLineNumber = 0;

                    var gutterRenderer = session.gutterRenderer || this.$renderer;

                    var cell = null;
                    var index = -1;
                    var row = firstRow;
                    while (true) {
                        if (row > foldStart) {
                            row = fold.end.row + 1;
                            fold = session.getNextFoldLine(row, fold);
                            foldStart = fold ? fold.start.row : Infinity;
                        }
                        if (row > lastRow) {
                            while (this.$cells.length > index + 1) {
                                cell = this.$cells.pop();
                                this.element.removeChild(cell.element);
                            }
                            break;
                        }

                        cell = this.$cells[++index];
                        if (!cell) {
                            cell = { element: null, textNode: null, foldWidget: null };
                            cell.element = dom.createElement("div");
                            cell.textNode = document.createTextNode('');
                            cell.element.appendChild(cell.textNode);
                            this.element.appendChild(cell.element);
                            this.$cells[index] = cell;
                        }

                        var className = "ace_gutter-cell ";
                        if (breakpoints[row]) className += breakpoints[row];
                        if (decorations[row]) className += decorations[row];
                        if (this.$annotations[row]) className += this.$annotations[row].className;
                        if (cell.element.className != className) cell.element.className = className;

                        var height = session.getRowLength(row) * config.lineHeight + "px";
                        if (height != cell.element.style.height) cell.element.style.height = height;

                        if (foldWidgets) {
                            var c = foldWidgets[row];
                            if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
                        }

                        if (c) {
                            if (!cell.foldWidget) {
                                cell.foldWidget = dom.createElement("span");
                                cell.element.appendChild(cell.foldWidget);
                            }
                            var className = "ace_fold-widget ace_" + c;
                            if (c == "start" && row == foldStart && row < fold.end.row) className += " ace_closed";else className += " ace_open";
                            if (cell.foldWidget.className != className) cell.foldWidget.className = className;

                            var height = config.lineHeight + "px";
                            if (cell.foldWidget.style.height != height) cell.foldWidget.style.height = height;
                        } else {
                            if (cell.foldWidget) {
                                cell.element.removeChild(cell.foldWidget);
                                cell.foldWidget = null;
                            }
                        }

                        var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
                        if (text != cell.textNode.data) cell.textNode.data = text;

                        row++;
                    }

                    this.element.style.height = config.minHeight + "px";

                    if (this.$fixedWidth || session.$useWrapMode) lastLineNumber = session.getLength() + firstLineNumber;

                    var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;

                    var padding = this.$padding || this.$computePadding();
                    gutterWidth += padding.left + padding.right;
                    if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                        this.gutterWidth = gutterWidth;
                        this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                        this._emit("changeGutterWidth", gutterWidth);
                    }
                };

                this.$fixedWidth = false;

                this.$showLineNumbers = true;
                this.$renderer = "";
                this.setShowLineNumbers = function (show) {
                    this.$renderer = !show && {
                        getWidth: function () {
                            return "";
                        },
                        getText: function () {
                            return "";
                        }
                    };
                };

                this.getShowLineNumbers = function () {
                    return this.$showLineNumbers;
                };

                this.$showFoldWidgets = true;
                this.setShowFoldWidgets = function (show) {
                    if (show) dom.addCssClass(this.element, "ace_folding-enabled");else dom.removeCssClass(this.element, "ace_folding-enabled");

                    this.$showFoldWidgets = show;
                    this.$padding = null;
                };

                this.getShowFoldWidgets = function () {
                    return this.$showFoldWidgets;
                };

                this.$computePadding = function () {
                    if (!this.element.firstChild) return { left: 0, right: 0 };
                    var style = dom.computedStyle(this.element.firstChild);
                    this.$padding = {};
                    this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
                    this.$padding.right = parseInt(style.paddingRight) || 0;
                    return this.$padding;
                };

                this.getRegion = function (point) {
                    var padding = this.$padding || this.$computePadding();
                    var rect = this.element.getBoundingClientRect();
                    if (point.x < padding.left + rect.left) return "markers";
                    if (this.$showFoldWidgets && point.x > rect.right - padding.right) return "foldWidgets";
                };
            }).call(Gutter.prototype);

            exports.Gutter = Gutter;
        });

        ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var Range = require("../range").Range;
            var dom = require("../lib/dom");

            var Marker = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_marker-layer";
                parentEl.appendChild(this.element);
            };

            (function () {

                this.$padding = 0;

                this.setPadding = function (padding) {
                    this.$padding = padding;
                };
                this.setSession = function (session) {
                    this.session = session;
                };

                this.setMarkers = function (markers) {
                    this.markers = markers;
                };

                this.update = function (config) {
                    var config = config || this.config;
                    if (!config) return;

                    this.config = config;

                    var html = [];
                    for (var key in this.markers) {
                        var marker = this.markers[key];

                        if (!marker.range) {
                            marker.update(html, this, this.session, config);
                            continue;
                        }

                        var range = marker.range.clipRows(config.firstRow, config.lastRow);
                        if (range.isEmpty()) continue;

                        range = range.toScreenRange(this.session);
                        if (marker.renderer) {
                            var top = this.$getTop(range.start.row, config);
                            var left = this.$padding + range.start.column * config.characterWidth;
                            marker.renderer(html, range, left, top, config);
                        } else if (marker.type == "fullLine") {
                            this.drawFullLineMarker(html, range, marker.clazz, config);
                        } else if (marker.type == "screenLine") {
                            this.drawScreenLineMarker(html, range, marker.clazz, config);
                        } else if (range.isMultiLine()) {
                            if (marker.type == "text") this.drawTextMarker(html, range, marker.clazz, config);else this.drawMultiLineMarker(html, range, marker.clazz, config);
                        } else {
                            this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                        }
                    }
                    this.element.innerHTML = html.join("");
                };

                this.$getTop = function (row, layerConfig) {
                    return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
                };

                function getBorderClass(tl, tr, br, bl) {
                    return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
                }
                this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
                    var session = this.session;
                    var start = range.start.row;
                    var end = range.end.row;
                    var row = start;
                    var prev = 0;
                    var curr = 0;
                    var next = session.getScreenLastRowColumn(row);
                    var lineRange = new Range(row, range.start.column, row, curr);
                    for (; row <= end; row++) {
                        lineRange.start.row = lineRange.end.row = row;
                        lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                        lineRange.end.column = next;
                        prev = curr;
                        curr = next;
                        next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
                    }
                };
                this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var padding = this.$padding;
                    var height = config.lineHeight;
                    var top = this.$getTop(range.start.row, config);
                    var left = padding + range.start.column * config.characterWidth;
                    extraStyle = extraStyle || "";

                    stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
                    top = this.$getTop(range.end.row, config);
                    var width = range.end.column * config.characterWidth;

                    stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                    height = (range.end.row - range.start.row - 1) * config.lineHeight;
                    if (height <= 0) return;
                    top = this.$getTop(range.start.row + 1, config);

                    var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

                    stringBuilder.push("<div class='", clazz, radiusClass ? " ace_br" + radiusClass : "", "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                };
                this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
                    var height = config.lineHeight;
                    var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

                    var top = this.$getTop(range.start.row, config);
                    var left = this.$padding + range.start.column * config.characterWidth;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
                };

                this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var top = this.$getTop(range.start.row, config);
                    var height = config.lineHeight;
                    if (range.start.row != range.end.row) height += this.$getTop(range.end.row, config) - top;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                };

                this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
                    var top = this.$getTop(range.start.row, config);
                    var height = config.lineHeight;

                    stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                };
            }).call(Marker.prototype);

            exports.Marker = Marker;
        });

        ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var useragent = require("../lib/useragent");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var Text = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_text-layer";
                parentEl.appendChild(this.element);
                this.$updateEolChar = this.$updateEolChar.bind(this);
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.EOF_CHAR = "\xB6";
                this.EOL_CHAR_LF = "\xAC";
                this.EOL_CHAR_CRLF = "\xa4";
                this.EOL_CHAR = this.EOL_CHAR_LF;
                this.TAB_CHAR = "\u2014"; //"\u21E5";
                this.SPACE_CHAR = "\xB7";
                this.$padding = 0;

                this.$updateEolChar = function () {
                    var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
                    if (this.EOL_CHAR != EOL_CHAR) {
                        this.EOL_CHAR = EOL_CHAR;
                        return true;
                    }
                };

                this.setPadding = function (padding) {
                    this.$padding = padding;
                    this.element.style.padding = "0 " + padding + "px";
                };

                this.getLineHeight = function () {
                    return this.$fontMetrics.$characterSize.height || 0;
                };

                this.getCharacterWidth = function () {
                    return this.$fontMetrics.$characterSize.width || 0;
                };

                this.$setFontMetrics = function (measure) {
                    this.$fontMetrics = measure;
                    this.$fontMetrics.on("changeCharacterSize", function (e) {
                        this._signal("changeCharacterSize", e);
                    }.bind(this));
                    this.$pollSizeChanges();
                };

                this.checkForSizeChanges = function () {
                    this.$fontMetrics.checkForSizeChanges();
                };
                this.$pollSizeChanges = function () {
                    return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
                };
                this.setSession = function (session) {
                    this.session = session;
                    if (session) this.$computeTabString();
                };

                this.showInvisibles = false;
                this.setShowInvisibles = function (showInvisibles) {
                    if (this.showInvisibles == showInvisibles) return false;

                    this.showInvisibles = showInvisibles;
                    this.$computeTabString();
                    return true;
                };

                this.displayIndentGuides = true;
                this.setDisplayIndentGuides = function (display) {
                    if (this.displayIndentGuides == display) return false;

                    this.displayIndentGuides = display;
                    this.$computeTabString();
                    return true;
                };

                this.$tabStrings = [];
                this.onChangeTabSize = this.$computeTabString = function () {
                    var tabSize = this.session.getTabSize();
                    this.tabSize = tabSize;
                    var tabStr = this.$tabStrings = [0];
                    for (var i = 1; i < tabSize + 1; i++) {
                        if (this.showInvisibles) {
                            tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + lang.stringRepeat(this.TAB_CHAR, i) + "</span>");
                        } else {
                            tabStr.push(lang.stringRepeat(" ", i));
                        }
                    }
                    if (this.displayIndentGuides) {
                        this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                        var className = "ace_indent-guide";
                        var spaceClass = "";
                        var tabClass = "";
                        if (this.showInvisibles) {
                            className += " ace_invisible";
                            spaceClass = " ace_invisible_space";
                            tabClass = " ace_invisible_tab";
                            var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                            var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
                        } else {
                            var spaceContent = lang.stringRepeat(" ", this.tabSize);
                            var tabContent = spaceContent;
                        }

                        this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
                        this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
                    }
                };

                this.updateLines = function (config, firstRow, lastRow) {
                    if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
                        this.scrollLines(config);
                    }
                    this.config = config;

                    var first = Math.max(firstRow, config.firstRow);
                    var last = Math.min(lastRow, config.lastRow);

                    var lineElements = this.element.childNodes;
                    var lineElementsIdx = 0;

                    for (var row = config.firstRow; row < first; row++) {
                        var foldLine = this.session.getFoldLine(row);
                        if (foldLine) {
                            if (foldLine.containsRow(first)) {
                                first = foldLine.start.row;
                                break;
                            } else {
                                row = foldLine.end.row;
                            }
                        }
                        lineElementsIdx++;
                    }

                    var row = first;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > last) break;

                        var lineElement = lineElements[lineElementsIdx++];
                        if (lineElement) {
                            var html = [];
                            this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
                            lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                            lineElement.innerHTML = html.join("");
                        }
                        row++;
                    }
                };

                this.scrollLines = function (config) {
                    var oldConfig = this.config;
                    this.config = config;

                    if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);

                    if (config.lastRow < oldConfig.firstRow) return this.update(config);

                    var el = this.element;
                    if (oldConfig.firstRow < config.firstRow) for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--) el.removeChild(el.firstChild);

                    if (oldConfig.lastRow > config.lastRow) for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--) el.removeChild(el.lastChild);

                    if (config.firstRow < oldConfig.firstRow) {
                        var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
                        if (el.firstChild) el.insertBefore(fragment, el.firstChild);else el.appendChild(fragment);
                    }

                    if (config.lastRow > oldConfig.lastRow) {
                        var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
                        el.appendChild(fragment);
                    }
                };

                this.$renderLinesFragment = function (config, firstRow, lastRow) {
                    var fragment = this.element.ownerDocument.createDocumentFragment();
                    var row = firstRow;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > lastRow) break;

                        var container = dom.createElement("div");

                        var html = [];
                        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                        container.innerHTML = html.join("");
                        if (this.$useLineGroups()) {
                            container.className = 'ace_line_group';
                            fragment.appendChild(container);
                            container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                        } else {
                            while (container.firstChild) fragment.appendChild(container.firstChild);
                        }

                        row++;
                    }
                    return fragment;
                };

                this.update = function (config) {
                    this.config = config;

                    var html = [];
                    var firstRow = config.firstRow,
                        lastRow = config.lastRow;

                    var row = firstRow;
                    var foldLine = this.session.getNextFoldLine(row);
                    var foldStart = foldLine ? foldLine.start.row : Infinity;

                    while (true) {
                        if (row > foldStart) {
                            row = foldLine.end.row + 1;
                            foldLine = this.session.getNextFoldLine(row, foldLine);
                            foldStart = foldLine ? foldLine.start.row : Infinity;
                        }
                        if (row > lastRow) break;

                        if (this.$useLineGroups()) html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");

                        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

                        if (this.$useLineGroups()) html.push("</div>"); // end the line group

                        row++;
                    }
                    this.element.innerHTML = html.join("");
                };

                this.$textToken = {
                    "text": true,
                    "rparen": true,
                    "lparen": true
                };

                this.$renderToken = function (stringBuilder, screenColumn, token, value) {
                    var self = this;
                    var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
                    var replaceFunc = function (c, a, b, tabIdx, idx4) {
                        if (a) {
                            return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : c;
                        } else if (c == "&") {
                            return "&#38;";
                        } else if (c == "<") {
                            return "&#60;";
                        } else if (c == ">") {
                            return "&#62;";
                        } else if (c == "\t") {
                            var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                            screenColumn += tabSize - 1;
                            return self.$tabStrings[tabSize];
                        } else if (c == "\u3000") {
                            var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                            var space = self.showInvisibles ? self.SPACE_CHAR : "";
                            screenColumn += 1;
                            return "<span class='" + classToUse + "' style='width:" + self.config.characterWidth * 2 + "px'>" + space + "</span>";
                        } else if (b) {
                            return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
                        } else {
                            screenColumn += 1;
                            return "<span class='ace_cjk' style='width:" + self.config.characterWidth * 2 + "px'>" + c + "</span>";
                        }
                    };

                    var output = value.replace(replaceReg, replaceFunc);

                    if (!this.$textToken[token.type]) {
                        var classes = "ace_" + token.type.replace(/\./g, " ace_");
                        var style = "";
                        if (token.type == "fold") style = " style='width:" + token.value.length * this.config.characterWidth + "px;' ";
                        stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
                    } else {
                        stringBuilder.push(output);
                    }
                    return screenColumn + value.length;
                };

                this.renderIndentGuide = function (stringBuilder, value, max) {
                    var cols = value.search(this.$indentGuideRe);
                    if (cols <= 0 || cols >= max) return value;
                    if (value[0] == " ") {
                        cols -= cols % this.tabSize;
                        stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
                        return value.substr(cols);
                    } else if (value[0] == "\t") {
                        stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
                        return value.substr(cols);
                    }
                    return value;
                };

                this.$renderWrappedLine = function (stringBuilder, tokens, splits, onlyContents) {
                    var chars = 0;
                    var split = 0;
                    var splitChars = splits[0];
                    var screenColumn = 0;

                    for (var i = 0; i < tokens.length; i++) {
                        var token = tokens[i];
                        var value = token.value;
                        if (i == 0 && this.displayIndentGuides) {
                            chars = value.length;
                            value = this.renderIndentGuide(stringBuilder, value, splitChars);
                            if (!value) continue;
                            chars -= value.length;
                        }

                        if (chars + value.length < splitChars) {
                            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                            chars += value.length;
                        } else {
                            while (chars + value.length >= splitChars) {
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                                value = value.substring(splitChars - chars);
                                chars = splitChars;

                                if (!onlyContents) {
                                    stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                                }

                                stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

                                split++;
                                screenColumn = 0;
                                splitChars = splits[split] || Number.MAX_VALUE;
                            }
                            if (value.length != 0) {
                                chars += value.length;
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                            }
                        }
                    }
                };

                this.$renderSimpleLine = function (stringBuilder, tokens) {
                    var screenColumn = 0;
                    var token = tokens[0];
                    var value = token.value;
                    if (this.displayIndentGuides) value = this.renderIndentGuide(stringBuilder, value);
                    if (value) screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                    for (var i = 1; i < tokens.length; i++) {
                        token = tokens[i];
                        value = token.value;
                        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                    }
                };
                this.$renderLine = function (stringBuilder, row, onlyContents, foldLine) {
                    if (!foldLine && foldLine != false) foldLine = this.session.getFoldLine(row);

                    if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);else var tokens = this.session.getTokens(row);

                    if (!onlyContents) {
                        stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
                    }

                    if (tokens.length) {
                        var splits = this.session.getRowSplitData(row);
                        if (splits && splits.length) this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);else this.$renderSimpleLine(stringBuilder, tokens);
                    }

                    if (this.showInvisibles) {
                        if (foldLine) row = foldLine.end.row;

                        stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
                    }
                    if (!onlyContents) stringBuilder.push("</div>");
                };

                this.$getFoldLineTokens = function (row, foldLine) {
                    var session = this.session;
                    var renderTokens = [];

                    function addTokens(tokens, from, to) {
                        var idx = 0,
                            col = 0;
                        while (col + tokens[idx].value.length < from) {
                            col += tokens[idx].value.length;
                            idx++;

                            if (idx == tokens.length) return;
                        }
                        if (col != from) {
                            var value = tokens[idx].value.substring(from - col);
                            if (value.length > to - from) value = value.substring(0, to - from);

                            renderTokens.push({
                                type: tokens[idx].type,
                                value: value
                            });

                            col = from + value.length;
                            idx += 1;
                        }

                        while (col < to && idx < tokens.length) {
                            var value = tokens[idx].value;
                            if (value.length + col > to) {
                                renderTokens.push({
                                    type: tokens[idx].type,
                                    value: value.substring(0, to - col)
                                });
                            } else renderTokens.push(tokens[idx]);
                            col += value.length;
                            idx += 1;
                        }
                    }

                    var tokens = session.getTokens(row);
                    foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
                        if (placeholder != null) {
                            renderTokens.push({
                                type: "fold",
                                value: placeholder
                            });
                        } else {
                            if (isNewRow) tokens = session.getTokens(row);

                            if (tokens.length) addTokens(tokens, lastColumn, column);
                        }
                    }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

                    return renderTokens;
                };

                this.$useLineGroups = function () {
                    return this.session.getUseWrapMode();
                };

                this.destroy = function () {
                    clearInterval(this.$pollSizeChangesTimer);
                    if (this.$measureNode) this.$measureNode.parentNode.removeChild(this.$measureNode);
                    delete this.$measureNode;
                };
            }).call(Text.prototype);

            exports.Text = Text;
        });

        ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            var dom = require("../lib/dom");
            var isIE8;

            var Cursor = function (parentEl) {
                this.element = dom.createElement("div");
                this.element.className = "ace_layer ace_cursor-layer";
                parentEl.appendChild(this.element);

                if (isIE8 === undefined) isIE8 = !("opacity" in this.element.style);

                this.isVisible = false;
                this.isBlinking = true;
                this.blinkInterval = 1000;
                this.smoothBlinking = false;

                this.cursors = [];
                this.cursor = this.addCursor();
                dom.addCssClass(this.element, "ace_hidden-cursors");
                this.$updateCursors = (isIE8 ? this.$updateVisibility : this.$updateOpacity).bind(this);
            };

            (function () {

                this.$updateVisibility = function (val) {
                    var cursors = this.cursors;
                    for (var i = cursors.length; i--;) cursors[i].style.visibility = val ? "" : "hidden";
                };
                this.$updateOpacity = function (val) {
                    var cursors = this.cursors;
                    for (var i = cursors.length; i--;) cursors[i].style.opacity = val ? "" : "0";
                };

                this.$padding = 0;
                this.setPadding = function (padding) {
                    this.$padding = padding;
                };

                this.setSession = function (session) {
                    this.session = session;
                };

                this.setBlinking = function (blinking) {
                    if (blinking != this.isBlinking) {
                        this.isBlinking = blinking;
                        this.restartTimer();
                    }
                };

                this.setBlinkInterval = function (blinkInterval) {
                    if (blinkInterval != this.blinkInterval) {
                        this.blinkInterval = blinkInterval;
                        this.restartTimer();
                    }
                };

                this.setSmoothBlinking = function (smoothBlinking) {
                    if (smoothBlinking != this.smoothBlinking && !isIE8) {
                        this.smoothBlinking = smoothBlinking;
                        dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                        this.$updateCursors(true);
                        this.$updateCursors = this.$updateOpacity.bind(this);
                        this.restartTimer();
                    }
                };

                this.addCursor = function () {
                    var el = dom.createElement("div");
                    el.className = "ace_cursor";
                    this.element.appendChild(el);
                    this.cursors.push(el);
                    return el;
                };

                this.removeCursor = function () {
                    if (this.cursors.length > 1) {
                        var el = this.cursors.pop();
                        el.parentNode.removeChild(el);
                        return el;
                    }
                };

                this.hideCursor = function () {
                    this.isVisible = false;
                    dom.addCssClass(this.element, "ace_hidden-cursors");
                    this.restartTimer();
                };

                this.showCursor = function () {
                    this.isVisible = true;
                    dom.removeCssClass(this.element, "ace_hidden-cursors");
                    this.restartTimer();
                };

                this.restartTimer = function () {
                    var update = this.$updateCursors;
                    clearInterval(this.intervalId);
                    clearTimeout(this.timeoutId);
                    if (this.smoothBlinking) {
                        dom.removeCssClass(this.element, "ace_smooth-blinking");
                    }

                    update(true);

                    if (!this.isBlinking || !this.blinkInterval || !this.isVisible) return;

                    if (this.smoothBlinking) {
                        setTimeout(function () {
                            dom.addCssClass(this.element, "ace_smooth-blinking");
                        }.bind(this));
                    }

                    var blink = function () {
                        this.timeoutId = setTimeout(function () {
                            update(false);
                        }, 0.6 * this.blinkInterval);
                    }.bind(this);

                    this.intervalId = setInterval(function () {
                        update(true);
                        blink();
                    }, this.blinkInterval);

                    blink();
                };

                this.getPixelPosition = function (position, onScreen) {
                    if (!this.config || !this.session) return { left: 0, top: 0 };

                    if (!position) position = this.session.selection.getCursor();
                    var pos = this.session.documentToScreenPosition(position);
                    var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
                    var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;

                    return { left: cursorLeft, top: cursorTop };
                };

                this.update = function (config) {
                    this.config = config;

                    var selections = this.session.$selectionMarkers;
                    var i = 0,
                        cursorIndex = 0;

                    if (selections === undefined || selections.length === 0) {
                        selections = [{ cursor: null }];
                    }

                    for (var i = 0, n = selections.length; i < n; i++) {
                        var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                        if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                            continue;
                        }

                        var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

                        if (!this.drawCursor) {
                            style.left = pixelPos.left + "px";
                            style.top = pixelPos.top + "px";
                            style.width = config.characterWidth + "px";
                            style.height = config.lineHeight + "px";
                        } else {
                            this.drawCursor(style, pixelPos, config, selections[i], this.session);
                        }
                    }
                    while (this.cursors.length > cursorIndex) this.removeCursor();

                    var overwrite = this.session.getOverwrite();
                    this.$setOverwrite(overwrite);
                    this.$pixelPos = pixelPos;
                    this.restartTimer();
                };

                this.drawCursor = null;

                this.$setOverwrite = function (overwrite) {
                    if (overwrite != this.overwrite) {
                        this.overwrite = overwrite;
                        if (overwrite) dom.addCssClass(this.element, "ace_overwrite-cursors");else dom.removeCssClass(this.element, "ace_overwrite-cursors");
                    }
                };

                this.destroy = function () {
                    clearInterval(this.intervalId);
                    clearTimeout(this.timeoutId);
                };
            }).call(Cursor.prototype);

            exports.Cursor = Cursor;
        });

        ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var event = require("./lib/event");
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var MAX_SCROLL_H = 0x8000;
            var ScrollBar = function (parent) {
                this.element = dom.createElement("div");
                this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

                this.inner = dom.createElement("div");
                this.inner.className = "ace_scrollbar-inner";
                this.element.appendChild(this.inner);

                parent.appendChild(this.element);

                this.setVisible(false);
                this.skipEvent = false;

                event.addListener(this.element, "scroll", this.onScroll.bind(this));
                event.addListener(this.element, "mousedown", event.preventDefault);
            };

            (function () {
                oop.implement(this, EventEmitter);

                this.setVisible = function (isVisible) {
                    this.element.style.display = isVisible ? "" : "none";
                    this.isVisible = isVisible;
                    this.coeff = 1;
                };
            }).call(ScrollBar.prototype);
            var VScrollBar = function (parent, renderer) {
                ScrollBar.call(this, parent);
                this.scrollTop = 0;
                this.scrollHeight = 0;
                renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
                this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
            };

            oop.inherits(VScrollBar, ScrollBar);

            (function () {

                this.classSuffix = '-v';
                this.onScroll = function () {
                    if (!this.skipEvent) {
                        this.scrollTop = this.element.scrollTop;
                        if (this.coeff != 1) {
                            var h = this.element.clientHeight / this.scrollHeight;
                            this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                        }
                        this._emit("scroll", { data: this.scrollTop });
                    }
                    this.skipEvent = false;
                };
                this.getWidth = function () {
                    return this.isVisible ? this.width : 0;
                };
                this.setHeight = function (height) {
                    this.element.style.height = height + "px";
                };
                this.setInnerHeight = this.setScrollHeight = function (height) {
                    this.scrollHeight = height;
                    if (height > MAX_SCROLL_H) {
                        this.coeff = MAX_SCROLL_H / height;
                        height = MAX_SCROLL_H;
                    } else if (this.coeff != 1) {
                        this.coeff = 1;
                    }
                    this.inner.style.height = height + "px";
                };
                this.setScrollTop = function (scrollTop) {
                    if (this.scrollTop != scrollTop) {
                        this.skipEvent = true;
                        this.scrollTop = scrollTop;
                        this.element.scrollTop = scrollTop * this.coeff;
                    }
                };
            }).call(VScrollBar.prototype);
            var HScrollBar = function (parent, renderer) {
                ScrollBar.call(this, parent);
                this.scrollLeft = 0;
                this.height = renderer.$scrollbarWidth;
                this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
            };

            oop.inherits(HScrollBar, ScrollBar);

            (function () {

                this.classSuffix = '-h';
                this.onScroll = function () {
                    if (!this.skipEvent) {
                        this.scrollLeft = this.element.scrollLeft;
                        this._emit("scroll", { data: this.scrollLeft });
                    }
                    this.skipEvent = false;
                };
                this.getHeight = function () {
                    return this.isVisible ? this.height : 0;
                };
                this.setWidth = function (width) {
                    this.element.style.width = width + "px";
                };
                this.setInnerWidth = function (width) {
                    this.inner.style.width = width + "px";
                };
                this.setScrollWidth = function (width) {
                    this.inner.style.width = width + "px";
                };
                this.setScrollLeft = function (scrollLeft) {
                    if (this.scrollLeft != scrollLeft) {
                        this.skipEvent = true;
                        this.scrollLeft = this.element.scrollLeft = scrollLeft;
                    }
                };
            }).call(HScrollBar.prototype);

            exports.ScrollBar = VScrollBar; // backward compatibility
            exports.ScrollBarV = VScrollBar; // backward compatibility
            exports.ScrollBarH = HScrollBar; // backward compatibility

            exports.VScrollBar = VScrollBar;
            exports.HScrollBar = HScrollBar;
        });

        ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function (require, exports, module) {
            "use strict";

            var event = require("./lib/event");

            var RenderLoop = function (onRender, win) {
                this.onRender = onRender;
                this.pending = false;
                this.changes = 0;
                this.window = win || window;
            };

            (function () {

                this.schedule = function (change) {
                    this.changes = this.changes | change;
                    if (!this.pending && this.changes) {
                        this.pending = true;
                        var _self = this;
                        event.nextFrame(function () {
                            _self.pending = false;
                            var changes;
                            while (changes = _self.changes) {
                                _self.changes = 0;
                                _self.onRender(changes);
                            }
                        }, this.window);
                    }
                };
            }).call(RenderLoop.prototype);

            exports.RenderLoop = RenderLoop;
        });

        ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (require, exports, module) {

            var oop = require("../lib/oop");
            var dom = require("../lib/dom");
            var lang = require("../lib/lang");
            var useragent = require("../lib/useragent");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;

            var CHAR_COUNT = 0;

            var FontMetrics = exports.FontMetrics = function (parentEl) {
                this.el = dom.createElement("div");
                this.$setMeasureNodeStyles(this.el.style, true);

                this.$main = dom.createElement("div");
                this.$setMeasureNodeStyles(this.$main.style);

                this.$measureNode = dom.createElement("div");
                this.$setMeasureNodeStyles(this.$measureNode.style);

                this.el.appendChild(this.$main);
                this.el.appendChild(this.$measureNode);
                parentEl.appendChild(this.el);

                if (!CHAR_COUNT) this.$testFractionalRect();
                this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);

                this.$characterSize = { width: 0, height: 0 };
                this.checkForSizeChanges();
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.$characterSize = { width: 0, height: 0 };

                this.$testFractionalRect = function () {
                    var el = dom.createElement("div");
                    this.$setMeasureNodeStyles(el.style);
                    el.style.width = "0.2px";
                    document.documentElement.appendChild(el);
                    var w = el.getBoundingClientRect().width;
                    if (w > 0 && w < 1) CHAR_COUNT = 50;else CHAR_COUNT = 100;
                    el.parentNode.removeChild(el);
                };

                this.$setMeasureNodeStyles = function (style, isRoot) {
                    style.width = style.height = "auto";
                    style.left = style.top = "0px";
                    style.visibility = "hidden";
                    style.position = "absolute";
                    style.whiteSpace = "pre";

                    if (useragent.isIE < 8) {
                        style["font-family"] = "inherit";
                    } else {
                        style.font = "inherit";
                    }
                    style.overflow = isRoot ? "hidden" : "visible";
                };

                this.checkForSizeChanges = function () {
                    var size = this.$measureSizes();
                    if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                        this.$measureNode.style.fontWeight = "bold";
                        var boldSize = this.$measureSizes();
                        this.$measureNode.style.fontWeight = "";
                        this.$characterSize = size;
                        this.charSizes = Object.create(null);
                        this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                        this._emit("changeCharacterSize", { data: size });
                    }
                };

                this.$pollSizeChanges = function () {
                    if (this.$pollSizeChangesTimer) return this.$pollSizeChangesTimer;
                    var self = this;
                    return this.$pollSizeChangesTimer = setInterval(function () {
                        self.checkForSizeChanges();
                    }, 500);
                };

                this.setPolling = function (val) {
                    if (val) {
                        this.$pollSizeChanges();
                    } else if (this.$pollSizeChangesTimer) {
                        clearInterval(this.$pollSizeChangesTimer);
                        this.$pollSizeChangesTimer = 0;
                    }
                };

                this.$measureSizes = function () {
                    if (CHAR_COUNT === 50) {
                        var rect = null;
                        try {
                            rect = this.$measureNode.getBoundingClientRect();
                        } catch (e) {
                            rect = { width: 0, height: 0 };
                        }
                        var size = {
                            height: rect.height,
                            width: rect.width / CHAR_COUNT
                        };
                    } else {
                        var size = {
                            height: this.$measureNode.clientHeight,
                            width: this.$measureNode.clientWidth / CHAR_COUNT
                        };
                    }
                    if (size.width === 0 || size.height === 0) return null;
                    return size;
                };

                this.$measureCharWidth = function (ch) {
                    this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
                    var rect = this.$main.getBoundingClientRect();
                    return rect.width / CHAR_COUNT;
                };

                this.getCharacterWidth = function (ch) {
                    var w = this.charSizes[ch];
                    if (w === undefined) {
                        w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
                    }
                    return w;
                };

                this.destroy = function () {
                    clearInterval(this.$pollSizeChangesTimer);
                    if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);
                };
            }).call(FontMetrics.prototype);
        });

        ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var config = require("./config");
            var useragent = require("./lib/useragent");
            var GutterLayer = require("./layer/gutter").Gutter;
            var MarkerLayer = require("./layer/marker").Marker;
            var TextLayer = require("./layer/text").Text;
            var CursorLayer = require("./layer/cursor").Cursor;
            var HScrollBar = require("./scrollbar").HScrollBar;
            var VScrollBar = require("./scrollbar").VScrollBar;
            var RenderLoop = require("./renderloop").RenderLoop;
            var FontMetrics = require("./layer/font_metrics").FontMetrics;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
";

            dom.importCssString(editorCss, "ace_editor.css");

            var VirtualRenderer = function (container, theme) {
                var _self = this;

                this.container = container || dom.createElement("div");
                this.$keepTextAreaAtCursor = !useragent.isOldIE;

                dom.addCssClass(this.container, "ace_editor");

                this.setTheme(theme);

                this.$gutter = dom.createElement("div");
                this.$gutter.className = "ace_gutter";
                this.container.appendChild(this.$gutter);

                this.scroller = dom.createElement("div");
                this.scroller.className = "ace_scroller";
                this.container.appendChild(this.scroller);

                this.content = dom.createElement("div");
                this.content.className = "ace_content";
                this.scroller.appendChild(this.content);

                this.$gutterLayer = new GutterLayer(this.$gutter);
                this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

                this.$markerBack = new MarkerLayer(this.content);

                var textLayer = this.$textLayer = new TextLayer(this.content);
                this.canvas = textLayer.element;

                this.$markerFront = new MarkerLayer(this.content);

                this.$cursorLayer = new CursorLayer(this.content);
                this.$horizScroll = false;
                this.$vScroll = false;

                this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
                this.scrollBarH = new HScrollBar(this.container, this);
                this.scrollBarV.addEventListener("scroll", function (e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                });
                this.scrollBarH.addEventListener("scroll", function (e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                });

                this.scrollTop = 0;
                this.scrollLeft = 0;

                this.cursorPos = {
                    row: 0,
                    column: 0
                };

                this.$fontMetrics = new FontMetrics(this.container);
                this.$textLayer.$setFontMetrics(this.$fontMetrics);
                this.$textLayer.addEventListener("changeCharacterSize", function (e) {
                    _self.updateCharacterSize();
                    _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
                    _self._signal("changeCharacterSize", e);
                });

                this.$size = {
                    width: 0,
                    height: 0,
                    scrollerHeight: 0,
                    scrollerWidth: 0,
                    $dirty: true
                };

                this.layerConfig = {
                    width: 1,
                    padding: 0,
                    firstRow: 0,
                    firstRowScreen: 0,
                    lastRow: 0,
                    lineHeight: 0,
                    characterWidth: 0,
                    minHeight: 1,
                    maxHeight: 1,
                    offset: 0,
                    height: 1,
                    gutterOffset: 1
                };

                this.scrollMargin = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    v: 0,
                    h: 0
                };

                this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                this.$loop.schedule(this.CHANGE_FULL);

                this.updateCharacterSize();
                this.setPadding(4);
                config.resetOptions(this);
                config._emit("renderer", this);
            };

            (function () {

                this.CHANGE_CURSOR = 1;
                this.CHANGE_MARKER = 2;
                this.CHANGE_GUTTER = 4;
                this.CHANGE_SCROLL = 8;
                this.CHANGE_LINES = 16;
                this.CHANGE_TEXT = 32;
                this.CHANGE_SIZE = 64;
                this.CHANGE_MARKER_BACK = 128;
                this.CHANGE_MARKER_FRONT = 256;
                this.CHANGE_FULL = 512;
                this.CHANGE_H_SCROLL = 1024;

                oop.implement(this, EventEmitter);

                this.updateCharacterSize = function () {
                    if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                        this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                        this.setStyle("ace_nobold", !this.$allowBoldFonts);
                    }

                    this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
                    this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
                    this.$updatePrintMargin();
                };
                this.setSession = function (session) {
                    if (this.session) this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);

                    this.session = session;
                    if (session && this.scrollMargin.top && session.getScrollTop() <= 0) session.setScrollTop(-this.scrollMargin.top);

                    this.$cursorLayer.setSession(session);
                    this.$markerBack.setSession(session);
                    this.$markerFront.setSession(session);
                    this.$gutterLayer.setSession(session);
                    this.$textLayer.setSession(session);
                    if (!session) return;

                    this.$loop.schedule(this.CHANGE_FULL);
                    this.session.$setFontMetrics(this.$fontMetrics);
                    this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;

                    this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
                    this.onChangeNewLineMode();
                    this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
                };
                this.updateLines = function (firstRow, lastRow, force) {
                    if (lastRow === undefined) lastRow = Infinity;

                    if (!this.$changedLines) {
                        this.$changedLines = {
                            firstRow: firstRow,
                            lastRow: lastRow
                        };
                    } else {
                        if (this.$changedLines.firstRow > firstRow) this.$changedLines.firstRow = firstRow;

                        if (this.$changedLines.lastRow < lastRow) this.$changedLines.lastRow = lastRow;
                    }
                    if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                        if (force) this.$changedLines.lastRow = this.layerConfig.lastRow;else return;
                    }
                    if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
                    this.$loop.schedule(this.CHANGE_LINES);
                };

                this.onChangeNewLineMode = function () {
                    this.$loop.schedule(this.CHANGE_TEXT);
                    this.$textLayer.$updateEolChar();
                };

                this.onChangeTabSize = function () {
                    this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
                    this.$textLayer.onChangeTabSize();
                };
                this.updateText = function () {
                    this.$loop.schedule(this.CHANGE_TEXT);
                };
                this.updateFull = function (force) {
                    if (force) this.$renderChanges(this.CHANGE_FULL, true);else this.$loop.schedule(this.CHANGE_FULL);
                };
                this.updateFontSize = function () {
                    this.$textLayer.checkForSizeChanges();
                };

                this.$changes = 0;
                this.$updateSizeAsync = function () {
                    if (this.$loop.pending) this.$size.$dirty = true;else this.onResize();
                };
                this.onResize = function (force, gutterWidth, width, height) {
                    if (this.resizing > 2) return;else if (this.resizing > 0) this.resizing++;else this.resizing = force ? 1 : 0;
                    var el = this.container;
                    if (!height) height = el.clientHeight || el.scrollHeight;
                    if (!width) width = el.clientWidth || el.scrollWidth;
                    var changes = this.$updateCachedSize(force, gutterWidth, width, height);

                    if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;

                    if (force) this.$gutterLayer.$padding = null;

                    if (force) this.$renderChanges(changes | this.$changes, true);else this.$loop.schedule(changes | this.$changes);

                    if (this.resizing) this.resizing = 0;
                    this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
                };

                this.$updateCachedSize = function (force, gutterWidth, width, height) {
                    height -= this.$extraHeight || 0;
                    var changes = 0;
                    var size = this.$size;
                    var oldSize = {
                        width: size.width,
                        height: size.height,
                        scrollerHeight: size.scrollerHeight,
                        scrollerWidth: size.scrollerWidth
                    };
                    if (height && (force || size.height != height)) {
                        size.height = height;
                        changes |= this.CHANGE_SIZE;

                        size.scrollerHeight = size.height;
                        if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.getHeight();
                        this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

                        changes = changes | this.CHANGE_SCROLL;
                    }

                    if (width && (force || size.width != width)) {
                        changes |= this.CHANGE_SIZE;
                        size.width = width;

                        if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;

                        this.gutterWidth = gutterWidth;

                        this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
                        size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());

                        this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                        this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

                        if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) changes |= this.CHANGE_FULL;
                    }

                    size.$dirty = !width || !height;

                    if (changes) this._signal("resize", oldSize);

                    return changes;
                };

                this.onGutterResize = function () {
                    var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                    if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

                    if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                        this.$loop.schedule(this.CHANGE_FULL);
                    } else if (this.$size.$dirty) {
                        this.$loop.schedule(this.CHANGE_FULL);
                    } else {
                        this.$computeLayerConfig();
                        this.$loop.schedule(this.CHANGE_MARKER);
                    }
                };
                this.adjustWrapLimit = function () {
                    var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
                    var limit = Math.floor(availableWidth / this.characterWidth);
                    return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
                };
                this.setAnimatedScroll = function (shouldAnimate) {
                    this.setOption("animatedScroll", shouldAnimate);
                };
                this.getAnimatedScroll = function () {
                    return this.$animatedScroll;
                };
                this.setShowInvisibles = function (showInvisibles) {
                    this.setOption("showInvisibles", showInvisibles);
                };
                this.getShowInvisibles = function () {
                    return this.getOption("showInvisibles");
                };
                this.getDisplayIndentGuides = function () {
                    return this.getOption("displayIndentGuides");
                };

                this.setDisplayIndentGuides = function (display) {
                    this.setOption("displayIndentGuides", display);
                };
                this.setShowPrintMargin = function (showPrintMargin) {
                    this.setOption("showPrintMargin", showPrintMargin);
                };
                this.getShowPrintMargin = function () {
                    return this.getOption("showPrintMargin");
                };
                this.setPrintMarginColumn = function (showPrintMargin) {
                    this.setOption("printMarginColumn", showPrintMargin);
                };
                this.getPrintMarginColumn = function () {
                    return this.getOption("printMarginColumn");
                };
                this.getShowGutter = function () {
                    return this.getOption("showGutter");
                };
                this.setShowGutter = function (show) {
                    return this.setOption("showGutter", show);
                };

                this.getFadeFoldWidgets = function () {
                    return this.getOption("fadeFoldWidgets");
                };

                this.setFadeFoldWidgets = function (show) {
                    this.setOption("fadeFoldWidgets", show);
                };

                this.setHighlightGutterLine = function (shouldHighlight) {
                    this.setOption("highlightGutterLine", shouldHighlight);
                };

                this.getHighlightGutterLine = function () {
                    return this.getOption("highlightGutterLine");
                };

                this.$updateGutterLineHighlight = function () {
                    var pos = this.$cursorLayer.$pixelPos;
                    var height = this.layerConfig.lineHeight;
                    if (this.session.getUseWrapMode()) {
                        var cursor = this.session.selection.getCursor();
                        cursor.column = 0;
                        pos = this.$cursorLayer.getPixelPosition(cursor, true);
                        height *= this.session.getRowLength(cursor.row);
                    }
                    this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
                    this.$gutterLineHighlight.style.height = height + "px";
                };

                this.$updatePrintMargin = function () {
                    if (!this.$showPrintMargin && !this.$printMarginEl) return;

                    if (!this.$printMarginEl) {
                        var containerEl = dom.createElement("div");
                        containerEl.className = "ace_layer ace_print-margin-layer";
                        this.$printMarginEl = dom.createElement("div");
                        this.$printMarginEl.className = "ace_print-margin";
                        containerEl.appendChild(this.$printMarginEl);
                        this.content.insertBefore(containerEl, this.content.firstChild);
                    }

                    var style = this.$printMarginEl.style;
                    style.left = this.characterWidth * this.$printMarginColumn + this.$padding + "px";
                    style.visibility = this.$showPrintMargin ? "visible" : "hidden";

                    if (this.session && this.session.$wrap == -1) this.adjustWrapLimit();
                };
                this.getContainerElement = function () {
                    return this.container;
                };
                this.getMouseEventTarget = function () {
                    return this.scroller;
                };
                this.getTextAreaContainer = function () {
                    return this.container;
                };
                this.$moveTextAreaToCursor = function () {
                    if (!this.$keepTextAreaAtCursor) return;
                    var config = this.layerConfig;
                    var posTop = this.$cursorLayer.$pixelPos.top;
                    var posLeft = this.$cursorLayer.$pixelPos.left;
                    posTop -= config.offset;

                    var style = this.textarea.style;
                    var h = this.lineHeight;
                    if (posTop < 0 || posTop > config.height - h) {
                        style.top = style.left = "0";
                        return;
                    }

                    var w = this.characterWidth;
                    if (this.$composition) {
                        var val = this.textarea.value.replace(/^\x01+/, "");
                        w *= this.session.$getStringScreenWidth(val)[0] + 2;
                        h += 2;
                    }
                    posLeft -= this.scrollLeft;
                    if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;

                    posLeft += this.gutterWidth;
                    style.height = h + "px";
                    style.width = w + "px";
                    style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
                    style.top = Math.min(posTop, this.$size.height - h) + "px";
                };
                this.getFirstVisibleRow = function () {
                    return this.layerConfig.firstRow;
                };
                this.getFirstFullyVisibleRow = function () {
                    return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
                };
                this.getLastFullyVisibleRow = function () {
                    var config = this.layerConfig;
                    var lastRow = config.lastRow;
                    var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
                    if (top - this.session.getScrollTop() > config.height - config.lineHeight) return lastRow - 1;
                    return lastRow;
                };
                this.getLastVisibleRow = function () {
                    return this.layerConfig.lastRow;
                };

                this.$padding = null;
                this.setPadding = function (padding) {
                    this.$padding = padding;
                    this.$textLayer.setPadding(padding);
                    this.$cursorLayer.setPadding(padding);
                    this.$markerFront.setPadding(padding);
                    this.$markerBack.setPadding(padding);
                    this.$loop.schedule(this.CHANGE_FULL);
                    this.$updatePrintMargin();
                };

                this.setScrollMargin = function (top, bottom, left, right) {
                    var sm = this.scrollMargin;
                    sm.top = top | 0;
                    sm.bottom = bottom | 0;
                    sm.right = right | 0;
                    sm.left = left | 0;
                    sm.v = sm.top + sm.bottom;
                    sm.h = sm.left + sm.right;
                    if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
                    this.updateFull();
                };
                this.getHScrollBarAlwaysVisible = function () {
                    return this.$hScrollBarAlwaysVisible;
                };
                this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
                    this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
                };
                this.getVScrollBarAlwaysVisible = function () {
                    return this.$vScrollBarAlwaysVisible;
                };
                this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
                    this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
                };

                this.$updateScrollBarV = function () {
                    var scrollHeight = this.layerConfig.maxHeight;
                    var scrollerHeight = this.$size.scrollerHeight;
                    if (!this.$maxLines && this.$scrollPastEnd) {
                        scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                        if (this.scrollTop > scrollHeight - scrollerHeight) {
                            scrollHeight = this.scrollTop + scrollerHeight;
                            this.scrollBarV.scrollTop = null;
                        }
                    }
                    this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
                    this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                };
                this.$updateScrollBarH = function () {
                    this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
                    this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                };

                this.$frozen = false;
                this.freeze = function () {
                    this.$frozen = true;
                };

                this.unfreeze = function () {
                    this.$frozen = false;
                };

                this.$renderChanges = function (changes, force) {
                    if (this.$changes) {
                        changes |= this.$changes;
                        this.$changes = 0;
                    }
                    if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                        this.$changes |= changes;
                        return;
                    }
                    if (this.$size.$dirty) {
                        this.$changes |= changes;
                        return this.onResize(true);
                    }
                    if (!this.lineHeight) {
                        this.$textLayer.checkForSizeChanges();
                    }

                    this._signal("beforeRender");
                    var config = this.layerConfig;
                    if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
                        changes |= this.$computeLayerConfig();
                        if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                            var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                            if (st > 0) {
                                this.scrollTop = st;
                                changes = changes | this.CHANGE_SCROLL;
                                changes |= this.$computeLayerConfig();
                            }
                        }
                        config = this.layerConfig;
                        this.$updateScrollBarV();
                        if (changes & this.CHANGE_H_SCROLL) this.$updateScrollBarH();
                        this.$gutterLayer.element.style.marginTop = -config.offset + "px";
                        this.content.style.marginTop = -config.offset + "px";
                        this.content.style.width = config.width + 2 * this.$padding + "px";
                        this.content.style.height = config.minHeight + "px";
                    }
                    if (changes & this.CHANGE_H_SCROLL) {
                        this.content.style.marginLeft = -this.scrollLeft + "px";
                        this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
                    }
                    if (changes & this.CHANGE_FULL) {
                        this.$textLayer.update(config);
                        if (this.$showGutter) this.$gutterLayer.update(config);
                        this.$markerBack.update(config);
                        this.$markerFront.update(config);
                        this.$cursorLayer.update(config);
                        this.$moveTextAreaToCursor();
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        this._signal("afterRender");
                        return;
                    }
                    if (changes & this.CHANGE_SCROLL) {
                        if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES) this.$textLayer.update(config);else this.$textLayer.scrollLines(config);

                        if (this.$showGutter) this.$gutterLayer.update(config);
                        this.$markerBack.update(config);
                        this.$markerFront.update(config);
                        this.$cursorLayer.update(config);
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        this.$moveTextAreaToCursor();
                        this._signal("afterRender");
                        return;
                    }

                    if (changes & this.CHANGE_TEXT) {
                        this.$textLayer.update(config);
                        if (this.$showGutter) this.$gutterLayer.update(config);
                    } else if (changes & this.CHANGE_LINES) {
                        if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
                    } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                        if (this.$showGutter) this.$gutterLayer.update(config);
                    }

                    if (changes & this.CHANGE_CURSOR) {
                        this.$cursorLayer.update(config);
                        this.$moveTextAreaToCursor();
                        this.$highlightGutterLine && this.$updateGutterLineHighlight();
                    }

                    if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                        this.$markerFront.update(config);
                    }

                    if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                        this.$markerBack.update(config);
                    }

                    this._signal("afterRender");
                };

                this.$autosize = function () {
                    var height = this.session.getScreenLength() * this.lineHeight;
                    var maxHeight = this.$maxLines * this.lineHeight;
                    var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
                    if (this.$horizScroll) desiredHeight += this.scrollBarH.getHeight();
                    if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight) desiredHeight = this.$maxPixelHeight;
                    var vScroll = height > maxHeight;

                    if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                        if (vScroll != this.$vScroll) {
                            this.$vScroll = vScroll;
                            this.scrollBarV.setVisible(vScroll);
                        }

                        var w = this.container.clientWidth;
                        this.container.style.height = desiredHeight + "px";
                        this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                        this.desiredHeight = desiredHeight;

                        this._signal("autosize");
                    }
                };

                this.$computeLayerConfig = function () {
                    var session = this.session;
                    var size = this.$size;

                    var hideScrollbars = size.height <= 2 * this.lineHeight;
                    var screenLines = this.session.getScreenLength();
                    var maxHeight = screenLines * this.lineHeight;

                    var longestLine = this.$getLongestLine();

                    var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);

                    var hScrollChanged = this.$horizScroll !== horizScroll;
                    if (hScrollChanged) {
                        this.$horizScroll = horizScroll;
                        this.scrollBarH.setVisible(horizScroll);
                    }
                    var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
                    if (this.$maxLines && this.lineHeight > 1) this.$autosize();

                    var offset = this.scrollTop % this.lineHeight;
                    var minHeight = size.scrollerHeight + this.lineHeight;

                    var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
                    maxHeight += scrollPastEnd;

                    var sm = this.scrollMargin;
                    this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

                    this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));

                    var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
                    var vScrollChanged = vScrollBefore !== vScroll;
                    if (vScrollChanged) {
                        this.$vScroll = vScroll;
                        this.scrollBarV.setVisible(vScroll);
                    }

                    var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
                    var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
                    var lastRow = firstRow + lineCount;
                    var firstRowScreen, firstRowHeight;
                    var lineHeight = this.lineHeight;
                    firstRow = session.screenToDocumentRow(firstRow, 0);
                    var foldLine = session.getFoldLine(firstRow);
                    if (foldLine) {
                        firstRow = foldLine.start.row;
                    }

                    firstRowScreen = session.documentToScreenRow(firstRow, 0);
                    firstRowHeight = session.getRowLength(firstRow) * lineHeight;

                    lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
                    minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;

                    offset = this.scrollTop - firstRowScreen * lineHeight;

                    var changes = 0;
                    if (this.layerConfig.width != longestLine) changes = this.CHANGE_H_SCROLL;
                    if (hScrollChanged || vScrollChanged) {
                        changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                        this._signal("scrollbarVisibilityChanged");
                        if (vScrollChanged) longestLine = this.$getLongestLine();
                    }

                    this.layerConfig = {
                        width: longestLine,
                        padding: this.$padding,
                        firstRow: firstRow,
                        firstRowScreen: firstRowScreen,
                        lastRow: lastRow,
                        lineHeight: lineHeight,
                        characterWidth: this.characterWidth,
                        minHeight: minHeight,
                        maxHeight: maxHeight,
                        offset: offset,
                        gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                        height: this.$size.scrollerHeight
                    };

                    return changes;
                };

                this.$updateLines = function () {
                    var firstRow = this.$changedLines.firstRow;
                    var lastRow = this.$changedLines.lastRow;
                    this.$changedLines = null;

                    var layerConfig = this.layerConfig;

                    if (firstRow > layerConfig.lastRow + 1) {
                        return;
                    }
                    if (lastRow < layerConfig.firstRow) {
                        return;
                    }
                    if (lastRow === Infinity) {
                        if (this.$showGutter) this.$gutterLayer.update(layerConfig);
                        this.$textLayer.update(layerConfig);
                        return;
                    }
                    this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
                    return true;
                };

                this.$getLongestLine = function () {
                    var charCount = this.session.getScreenWidth();
                    if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;

                    return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
                };
                this.updateFrontMarkers = function () {
                    this.$markerFront.setMarkers(this.session.getMarkers(true));
                    this.$loop.schedule(this.CHANGE_MARKER_FRONT);
                };
                this.updateBackMarkers = function () {
                    this.$markerBack.setMarkers(this.session.getMarkers());
                    this.$loop.schedule(this.CHANGE_MARKER_BACK);
                };
                this.addGutterDecoration = function (row, className) {
                    this.$gutterLayer.addGutterDecoration(row, className);
                };
                this.removeGutterDecoration = function (row, className) {
                    this.$gutterLayer.removeGutterDecoration(row, className);
                };
                this.updateBreakpoints = function (rows) {
                    this.$loop.schedule(this.CHANGE_GUTTER);
                };
                this.setAnnotations = function (annotations) {
                    this.$gutterLayer.setAnnotations(annotations);
                    this.$loop.schedule(this.CHANGE_GUTTER);
                };
                this.updateCursor = function () {
                    this.$loop.schedule(this.CHANGE_CURSOR);
                };
                this.hideCursor = function () {
                    this.$cursorLayer.hideCursor();
                };
                this.showCursor = function () {
                    this.$cursorLayer.showCursor();
                };

                this.scrollSelectionIntoView = function (anchor, lead, offset) {
                    this.scrollCursorIntoView(anchor, offset);
                    this.scrollCursorIntoView(lead, offset);
                };
                this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
                    if (this.$size.scrollerHeight === 0) return;

                    var pos = this.$cursorLayer.getPixelPosition(cursor);

                    var left = pos.left;
                    var top = pos.top;

                    var topMargin = $viewMargin && $viewMargin.top || 0;
                    var bottomMargin = $viewMargin && $viewMargin.bottom || 0;

                    var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

                    if (scrollTop + topMargin > top) {
                        if (offset && scrollTop + topMargin > top + this.lineHeight) top -= offset * this.$size.scrollerHeight;
                        if (top === 0) top = -this.scrollMargin.top;
                        this.session.setScrollTop(top);
                    } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                        if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight) top += offset * this.$size.scrollerHeight;
                        this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
                    }

                    var scrollLeft = this.scrollLeft;

                    if (scrollLeft > left) {
                        if (left < this.$padding + 2 * this.layerConfig.characterWidth) left = -this.scrollMargin.left;
                        this.session.setScrollLeft(left);
                    } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                        this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
                    } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                        this.session.setScrollLeft(0);
                    }
                };
                this.getScrollTop = function () {
                    return this.session.getScrollTop();
                };
                this.getScrollLeft = function () {
                    return this.session.getScrollLeft();
                };
                this.getScrollTopRow = function () {
                    return this.scrollTop / this.lineHeight;
                };
                this.getScrollBottomRow = function () {
                    return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
                };
                this.scrollToRow = function (row) {
                    this.session.setScrollTop(row * this.lineHeight);
                };

                this.alignCursor = function (cursor, alignment) {
                    if (typeof cursor == "number") cursor = { row: cursor, column: 0 };

                    var pos = this.$cursorLayer.getPixelPosition(cursor);
                    var h = this.$size.scrollerHeight - this.lineHeight;
                    var offset = pos.top - h * (alignment || 0);

                    this.session.setScrollTop(offset);
                    return offset;
                };

                this.STEPS = 8;
                this.$calcSteps = function (fromValue, toValue) {
                    var i = 0;
                    var l = this.STEPS;
                    var steps = [];

                    var func = function (t, x_min, dx) {
                        return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                    };

                    for (i = 0; i < l; ++i) steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

                    return steps;
                };
                this.scrollToLine = function (line, center, animate, callback) {
                    var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
                    var offset = pos.top;
                    if (center) offset -= this.$size.scrollerHeight / 2;

                    var initialScroll = this.scrollTop;
                    this.session.setScrollTop(offset);
                    if (animate !== false) this.animateScrolling(initialScroll, callback);
                };

                this.animateScrolling = function (fromValue, callback) {
                    var toValue = this.scrollTop;
                    if (!this.$animatedScroll) return;
                    var _self = this;

                    if (fromValue == toValue) return;

                    if (this.$scrollAnimation) {
                        var oldSteps = this.$scrollAnimation.steps;
                        if (oldSteps.length) {
                            fromValue = oldSteps[0];
                            if (fromValue == toValue) return;
                        }
                    }

                    var steps = _self.$calcSteps(fromValue, toValue);
                    this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };

                    clearInterval(this.$timer);

                    _self.session.setScrollTop(steps.shift());
                    _self.session.$scrollTop = toValue;
                    this.$timer = setInterval(function () {
                        if (steps.length) {
                            _self.session.setScrollTop(steps.shift());
                            _self.session.$scrollTop = toValue;
                        } else if (toValue != null) {
                            _self.session.$scrollTop = -1;
                            _self.session.setScrollTop(toValue);
                            toValue = null;
                        } else {
                            _self.$timer = clearInterval(_self.$timer);
                            _self.$scrollAnimation = null;
                            callback && callback();
                        }
                    }, 10);
                };
                this.scrollToY = function (scrollTop) {
                    if (this.scrollTop !== scrollTop) {
                        this.$loop.schedule(this.CHANGE_SCROLL);
                        this.scrollTop = scrollTop;
                    }
                };
                this.scrollToX = function (scrollLeft) {
                    if (this.scrollLeft !== scrollLeft) this.scrollLeft = scrollLeft;
                    this.$loop.schedule(this.CHANGE_H_SCROLL);
                };
                this.scrollTo = function (x, y) {
                    this.session.setScrollTop(y);
                    this.session.setScrollLeft(y);
                };
                this.scrollBy = function (deltaX, deltaY) {
                    deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
                    deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
                };
                this.isScrollableBy = function (deltaX, deltaY) {
                    if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
                    if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
                    if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
                    if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
                };

                this.pixelToScreenCoordinates = function (x, y) {
                    var canvasPos = this.scroller.getBoundingClientRect();

                    var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
                    var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                    var col = Math.round(offset);

                    return { row: row, column: col, side: offset - col > 0 ? 1 : -1 };
                };

                this.screenToTextCoordinates = function (x, y) {
                    var canvasPos = this.scroller.getBoundingClientRect();

                    var col = Math.round((x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);

                    var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

                    return this.session.screenToDocumentPosition(row, Math.max(col, 0));
                };
                this.textToScreenCoordinates = function (row, column) {
                    var canvasPos = this.scroller.getBoundingClientRect();
                    var pos = this.session.documentToScreenPosition(row, column);

                    var x = this.$padding + Math.round(pos.column * this.characterWidth);
                    var y = pos.row * this.lineHeight;

                    return {
                        pageX: canvasPos.left + x - this.scrollLeft,
                        pageY: canvasPos.top + y - this.scrollTop
                    };
                };
                this.visualizeFocus = function () {
                    dom.addCssClass(this.container, "ace_focus");
                };
                this.visualizeBlur = function () {
                    dom.removeCssClass(this.container, "ace_focus");
                };
                this.showComposition = function (position) {
                    if (!this.$composition) this.$composition = {
                        keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                        cssText: this.textarea.style.cssText
                    };

                    this.$keepTextAreaAtCursor = true;
                    dom.addCssClass(this.textarea, "ace_composition");
                    this.textarea.style.cssText = "";
                    this.$moveTextAreaToCursor();
                };
                this.setCompositionText = function (text) {
                    this.$moveTextAreaToCursor();
                };
                this.hideComposition = function () {
                    if (!this.$composition) return;

                    dom.removeCssClass(this.textarea, "ace_composition");
                    this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
                    this.textarea.style.cssText = this.$composition.cssText;
                    this.$composition = null;
                };
                this.setTheme = function (theme, cb) {
                    var _self = this;
                    this.$themeId = theme;
                    _self._dispatchEvent('themeChange', { theme: theme });

                    if (!theme || typeof theme == "string") {
                        var moduleName = theme || this.$options.theme.initialValue;
                        config.loadModule(["theme", moduleName], afterLoad);
                    } else {
                        afterLoad(theme);
                    }

                    function afterLoad(module) {
                        if (_self.$themeId != theme) return cb && cb();
                        if (!module || !module.cssClass) throw new Error("couldn't load module " + theme + " or it didn't call define");
                        dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);

                        if (_self.theme) dom.removeCssClass(_self.container, _self.theme.cssClass);

                        var padding = "padding" in module ? module.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                        if (_self.$padding && padding != _self.$padding) _self.setPadding(padding);
                        _self.$theme = module.cssClass;

                        _self.theme = module;
                        dom.addCssClass(_self.container, module.cssClass);
                        dom.setCssClass(_self.container, "ace_dark", module.isDark);
                        if (_self.$size) {
                            _self.$size.width = 0;
                            _self.$updateSizeAsync();
                        }

                        _self._dispatchEvent('themeLoaded', { theme: module });
                        cb && cb();
                    }
                };
                this.getTheme = function () {
                    return this.$themeId;
                };
                this.setStyle = function (style, include) {
                    dom.setCssClass(this.container, style, include !== false);
                };
                this.unsetStyle = function (style) {
                    dom.removeCssClass(this.container, style);
                };

                this.setCursorStyle = function (style) {
                    if (this.scroller.style.cursor != style) this.scroller.style.cursor = style;
                };
                this.setMouseCursor = function (cursorStyle) {
                    this.scroller.style.cursor = cursorStyle;
                };
                this.destroy = function () {
                    this.$textLayer.destroy();
                    this.$cursorLayer.destroy();
                };
            }).call(VirtualRenderer.prototype);

            config.defineOptions(VirtualRenderer.prototype, "renderer", {
                animatedScroll: { initialValue: false },
                showInvisibles: {
                    set: function (value) {
                        if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: false
                },
                showPrintMargin: {
                    set: function () {
                        this.$updatePrintMargin();
                    },
                    initialValue: true
                },
                printMarginColumn: {
                    set: function () {
                        this.$updatePrintMargin();
                    },
                    initialValue: 80
                },
                printMargin: {
                    set: function (val) {
                        if (typeof val == "number") this.$printMarginColumn = val;
                        this.$showPrintMargin = !!val;
                        this.$updatePrintMargin();
                    },
                    get: function () {
                        return this.$showPrintMargin && this.$printMarginColumn;
                    }
                },
                showGutter: {
                    set: function (show) {
                        this.$gutter.style.display = show ? "block" : "none";
                        this.$loop.schedule(this.CHANGE_FULL);
                        this.onGutterResize();
                    },
                    initialValue: true
                },
                fadeFoldWidgets: {
                    set: function (show) {
                        dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
                    },
                    initialValue: false
                },
                showFoldWidgets: {
                    set: function (show) {
                        this.$gutterLayer.setShowFoldWidgets(show);
                    },
                    initialValue: true
                },
                showLineNumbers: {
                    set: function (show) {
                        this.$gutterLayer.setShowLineNumbers(show);
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    },
                    initialValue: true
                },
                displayIndentGuides: {
                    set: function (show) {
                        if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: true
                },
                highlightGutterLine: {
                    set: function (shouldHighlight) {
                        if (!this.$gutterLineHighlight) {
                            this.$gutterLineHighlight = dom.createElement("div");
                            this.$gutterLineHighlight.className = "ace_gutter-active-line";
                            this.$gutter.appendChild(this.$gutterLineHighlight);
                            return;
                        }

                        this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
                        if (this.$cursorLayer.$pixelPos) this.$updateGutterLineHighlight();
                    },
                    initialValue: false,
                    value: true
                },
                hScrollBarAlwaysVisible: {
                    set: function (val) {
                        if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                vScrollBarAlwaysVisible: {
                    set: function (val) {
                        if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                fontSize: {
                    set: function (size) {
                        if (typeof size == "number") size = size + "px";
                        this.container.style.fontSize = size;
                        this.updateFontSize();
                    },
                    initialValue: 12
                },
                fontFamily: {
                    set: function (name) {
                        this.container.style.fontFamily = name;
                        this.updateFontSize();
                    }
                },
                maxLines: {
                    set: function (val) {
                        this.updateFull();
                    }
                },
                minLines: {
                    set: function (val) {
                        this.updateFull();
                    }
                },
                maxPixelHeight: {
                    set: function (val) {
                        this.updateFull();
                    },
                    initialValue: 0
                },
                scrollPastEnd: {
                    set: function (val) {
                        val = +val || 0;
                        if (this.$scrollPastEnd == val) return;
                        this.$scrollPastEnd = val;
                        this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: 0,
                    handlesSet: true
                },
                fixedWidthGutter: {
                    set: function (val) {
                        this.$gutterLayer.$fixedWidth = !!val;
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    }
                },
                theme: {
                    set: function (val) {
                        this.setTheme(val);
                    },
                    get: function () {
                        return this.$themeId || this.theme;
                    },
                    initialValue: "./theme/textmate",
                    handlesSet: true
                }
            });

            exports.VirtualRenderer = VirtualRenderer;
        });

        ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function (require, exports, module) {
            "use strict";

            var oop = require("../lib/oop");
            var net = require("../lib/net");
            var EventEmitter = require("../lib/event_emitter").EventEmitter;
            var config = require("../config");

            var WorkerClient = function (topLevelNamespaces, mod, classname, workerUrl) {
                this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                this.changeListener = this.changeListener.bind(this);
                this.onMessage = this.onMessage.bind(this);
                if (require.nameToUrl && !require.toUrl) require.toUrl = require.nameToUrl;

                if (config.get("packaged") || !require.toUrl) {
                    workerUrl = workerUrl || config.moduleUrl(mod, "worker");
                } else {
                    var normalizePath = this.$normalizePath;
                    workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

                    var tlns = {};
                    topLevelNamespaces.forEach(function (ns) {
                        tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                    });
                }

                try {
                    this.$worker = new Worker(workerUrl);
                } catch (e) {
                    if (e instanceof window.DOMException) {
                        var blob = this.$workerBlob(workerUrl);
                        var URL = window.URL || window.webkitURL;
                        var blobURL = URL.createObjectURL(blob);

                        this.$worker = new Worker(blobURL);
                        URL.revokeObjectURL(blobURL);
                    } else {
                        throw e;
                    }
                }
                this.$worker.postMessage({
                    init: true,
                    tlns: tlns,
                    module: mod,
                    classname: classname
                });

                this.callbackId = 1;
                this.callbacks = {};

                this.$worker.onmessage = this.onMessage;
            };

            (function () {

                oop.implement(this, EventEmitter);

                this.onMessage = function (e) {
                    var msg = e.data;
                    switch (msg.type) {
                        case "event":
                            this._signal(msg.name, { data: msg.data });
                            break;
                        case "call":
                            var callback = this.callbacks[msg.id];
                            if (callback) {
                                callback(msg.data);
                                delete this.callbacks[msg.id];
                            }
                            break;
                        case "error":
                            this.reportError(msg.data);
                            break;
                        case "log":
                            window.console && console.log && console.log.apply(console, msg.data);
                            break;
                    }
                };

                this.reportError = function (err) {
                    window.console && console.error && console.error(err);
                };

                this.$normalizePath = function (path) {
                    return net.qualifyURL(path);
                };

                this.terminate = function () {
                    this._signal("terminate", {});
                    this.deltaQueue = null;
                    this.$worker.terminate();
                    this.$worker = null;
                    if (this.$doc) this.$doc.off("change", this.changeListener);
                    this.$doc = null;
                };

                this.send = function (cmd, args) {
                    this.$worker.postMessage({ command: cmd, args: args });
                };

                this.call = function (cmd, args, callback) {
                    if (callback) {
                        var id = this.callbackId++;
                        this.callbacks[id] = callback;
                        args.push(id);
                    }
                    this.send(cmd, args);
                };

                this.emit = function (event, data) {
                    try {
                        this.$worker.postMessage({ event: event, data: { data: data.data } });
                    } catch (ex) {
                        console.error(ex.stack);
                    }
                };

                this.attachToDocument = function (doc) {
                    if (this.$doc) this.terminate();

                    this.$doc = doc;
                    this.call("setValue", [doc.getValue()]);
                    doc.on("change", this.changeListener);
                };

                this.changeListener = function (delta) {
                    if (!this.deltaQueue) {
                        this.deltaQueue = [];
                        setTimeout(this.$sendDeltaQueue, 0);
                    }
                    if (delta.action == "insert") this.deltaQueue.push(delta.start, delta.lines);else this.deltaQueue.push(delta.start, delta.end);
                };

                this.$sendDeltaQueue = function () {
                    var q = this.deltaQueue;
                    if (!q) return;
                    this.deltaQueue = null;
                    if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
                        this.call("setValue", [this.$doc.getValue()]);
                    } else this.emit("change", { data: q });
                };

                this.$workerBlob = function (workerUrl) {
                    var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
                    try {
                        return new Blob([script], { "type": "application/javascript" });
                    } catch (e) {
                        // Backwards-compatibility
                        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
                        var blobBuilder = new BlobBuilder();
                        blobBuilder.append(script);
                        return blobBuilder.getBlob("application/javascript");
                    }
                };
            }).call(WorkerClient.prototype);

            var UIWorkerClient = function (topLevelNamespaces, mod, classname) {
                this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                this.changeListener = this.changeListener.bind(this);
                this.callbackId = 1;
                this.callbacks = {};
                this.messageBuffer = [];

                var main = null;
                var emitSync = false;
                var sender = Object.create(EventEmitter);
                var _self = this;

                this.$worker = {};
                this.$worker.terminate = function () {};
                this.$worker.postMessage = function (e) {
                    _self.messageBuffer.push(e);
                    if (main) {
                        if (emitSync) setTimeout(processNext);else processNext();
                    }
                };
                this.setEmitSync = function (val) {
                    emitSync = val;
                };

                var processNext = function () {
                    var msg = _self.messageBuffer.shift();
                    if (msg.command) main[msg.command].apply(main, msg.args);else if (msg.event) sender._signal(msg.event, msg.data);
                };

                sender.postMessage = function (msg) {
                    _self.onMessage({ data: msg });
                };
                sender.callback = function (data, callbackId) {
                    this.postMessage({ type: "call", id: callbackId, data: data });
                };
                sender.emit = function (name, data) {
                    this.postMessage({ type: "event", name: name, data: data });
                };

                config.loadModule(["worker", mod], function (Main) {
                    main = new Main[classname](sender);
                    while (_self.messageBuffer.length) processNext();
                });
            };

            UIWorkerClient.prototype = WorkerClient.prototype;

            exports.UIWorkerClient = UIWorkerClient;
            exports.WorkerClient = WorkerClient;
        });

        ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function (require, exports, module) {
            "use strict";

            var Range = require("./range").Range;
            var EventEmitter = require("./lib/event_emitter").EventEmitter;
            var oop = require("./lib/oop");

            var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
                var _self = this;
                this.length = length;
                this.session = session;
                this.doc = session.getDocument();
                this.mainClass = mainClass;
                this.othersClass = othersClass;
                this.$onUpdate = this.onUpdate.bind(this);
                this.doc.on("change", this.$onUpdate);
                this.$others = others;

                this.$onCursorChange = function () {
                    setTimeout(function () {
                        _self.onCursorChange();
                    });
                };

                this.$pos = pos;
                var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
                this.$undoStackDepth = undoStack.length;
                this.setup();

                session.selection.on("changeCursor", this.$onCursorChange);
            };

            (function () {

                oop.implement(this, EventEmitter);
                this.setup = function () {
                    var _self = this;
                    var doc = this.doc;
                    var session = this.session;

                    this.selectionBefore = session.selection.toJSON();
                    if (session.selection.inMultiSelectMode) session.selection.toSingleRange();

                    this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
                    var pos = this.pos;
                    pos.$insertRight = true;
                    pos.detach();
                    pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
                    this.others = [];
                    this.$others.forEach(function (other) {
                        var anchor = doc.createAnchor(other.row, other.column);
                        anchor.$insertRight = true;
                        anchor.detach();
                        _self.others.push(anchor);
                    });
                    session.setUndoSelect(false);
                };
                this.showOtherMarkers = function () {
                    if (this.othersActive) return;
                    var session = this.session;
                    var _self = this;
                    this.othersActive = true;
                    this.others.forEach(function (anchor) {
                        anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
                    });
                };
                this.hideOtherMarkers = function () {
                    if (!this.othersActive) return;
                    this.othersActive = false;
                    for (var i = 0; i < this.others.length; i++) {
                        this.session.removeMarker(this.others[i].markerId);
                    }
                };
                this.onUpdate = function (delta) {
                    if (this.$updating) return this.updateAnchors(delta);

                    var range = delta;
                    if (range.start.row !== range.end.row) return;
                    if (range.start.row !== this.pos.row) return;
                    this.$updating = true;
                    var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
                    var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
                    var distanceFromStart = range.start.column - this.pos.column;

                    this.updateAnchors(delta);

                    if (inMainRange) this.length += lengthDiff;

                    if (inMainRange && !this.session.$fromUndo) {
                        if (delta.action === 'insert') {
                            for (var i = this.others.length - 1; i >= 0; i--) {
                                var otherPos = this.others[i];
                                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                                this.doc.insertMergedLines(newPos, delta.lines);
                            }
                        } else if (delta.action === 'remove') {
                            for (var i = this.others.length - 1; i >= 0; i--) {
                                var otherPos = this.others[i];
                                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                            }
                        }
                    }

                    this.$updating = false;
                    this.updateMarkers();
                };

                this.updateAnchors = function (delta) {
                    this.pos.onChange(delta);
                    for (var i = this.others.length; i--;) this.others[i].onChange(delta);
                    this.updateMarkers();
                };

                this.updateMarkers = function () {
                    if (this.$updating) return;
                    var _self = this;
                    var session = this.session;
                    var updateMarker = function (pos, className) {
                        session.removeMarker(pos.markerId);
                        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
                    };
                    updateMarker(this.pos, this.mainClass);
                    for (var i = this.others.length; i--;) updateMarker(this.others[i], this.othersClass);
                };

                this.onCursorChange = function (event) {
                    if (this.$updating || !this.session) return;
                    var pos = this.session.selection.getCursor();
                    if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                        this.showOtherMarkers();
                        this._emit("cursorEnter", event);
                    } else {
                        this.hideOtherMarkers();
                        this._emit("cursorLeave", event);
                    }
                };
                this.detach = function () {
                    this.session.removeMarker(this.pos && this.pos.markerId);
                    this.hideOtherMarkers();
                    this.doc.removeEventListener("change", this.$onUpdate);
                    this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
                    this.session.setUndoSelect(true);
                    this.session = null;
                };
                this.cancel = function () {
                    if (this.$undoStackDepth === -1) return;
                    var undoManager = this.session.getUndoManager();
                    var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
                    for (var i = 0; i < undosRequired; i++) {
                        undoManager.undo(true);
                    }
                    if (this.selectionBefore) this.session.selection.fromJSON(this.selectionBefore);
                };
            }).call(PlaceHolder.prototype);

            exports.PlaceHolder = PlaceHolder;
        });

        ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (require, exports, module) {

            var event = require("../lib/event");
            var useragent = require("../lib/useragent");
            function isSamePoint(p1, p2) {
                return p1.row == p2.row && p1.column == p2.column;
            }

            function onMouseDown(e) {
                var ev = e.domEvent;
                var alt = ev.altKey;
                var shift = ev.shiftKey;
                var ctrl = ev.ctrlKey;
                var accel = e.getAccelKey();
                var button = e.getButton();

                if (ctrl && useragent.isMac) button = ev.button;

                if (e.editor.inMultiSelectMode && button == 2) {
                    e.editor.textInput.onContextMenu(e.domEvent);
                    return;
                }

                if (!ctrl && !alt && !accel) {
                    if (button === 0 && e.editor.inMultiSelectMode) e.editor.exitMultiSelectMode();
                    return;
                }

                if (button !== 0) return;

                var editor = e.editor;
                var selection = editor.selection;
                var isMultiSelect = editor.inMultiSelectMode;
                var pos = e.getDocumentPosition();
                var cursor = selection.getCursor();
                var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);

                var mouseX = e.x,
                    mouseY = e.y;
                var onMouseSelection = function (e) {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                };

                var session = editor.session;
                var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                var screenCursor = screenAnchor;

                var selectionMode;
                if (editor.$mouseHandler.$enableJumpToDef) {
                    if (ctrl && alt || accel && alt) selectionMode = shift ? "block" : "add";else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
                } else {
                    if (accel && !alt) {
                        selectionMode = "add";
                        if (!isMultiSelect && shift) return;
                    } else if (alt && editor.$blockSelectEnabled) {
                        selectionMode = "block";
                    }
                }

                if (selectionMode && useragent.isMac && ev.ctrlKey) {
                    editor.$mouseHandler.cancelContextMenu();
                }

                if (selectionMode == "add") {
                    if (!isMultiSelect && inSelection) return; // dragging

                    if (!isMultiSelect) {
                        var range = selection.toOrientedRange();
                        editor.addSelectionMarker(range);
                    }

                    var oldRange = selection.rangeList.rangeAtPoint(pos);

                    editor.$blockScrolling++;
                    editor.inVirtualSelectionMode = true;

                    if (shift) {
                        oldRange = null;
                        range = selection.ranges[0] || range;
                        editor.removeSelectionMarker(range);
                    }
                    editor.once("mouseup", function () {
                        var tmpSel = selection.toOrientedRange();

                        if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor)) selection.substractPoint(tmpSel.cursor);else {
                            if (shift) {
                                selection.substractPoint(range.cursor);
                            } else if (range) {
                                editor.removeSelectionMarker(range);
                                selection.addRange(range);
                            }
                            selection.addRange(tmpSel);
                        }
                        editor.$blockScrolling--;
                        editor.inVirtualSelectionMode = false;
                    });
                } else if (selectionMode == "block") {
                    e.stop();
                    editor.inVirtualSelectionMode = true;
                    var initialRange;
                    var rectSel = [];
                    var blockSelect = function () {
                        var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                        var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

                        if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead)) return;
                        screenCursor = newCursor;

                        editor.$blockScrolling++;
                        editor.selection.moveToPosition(cursor);
                        editor.renderer.scrollCursorIntoView();

                        editor.removeSelectionMarkers(rectSel);
                        rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                        if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty()) rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                        rectSel.forEach(editor.addSelectionMarker, editor);
                        editor.updateSelectionMarkers();
                        editor.$blockScrolling--;
                    };
                    editor.$blockScrolling++;
                    if (isMultiSelect && !accel) {
                        selection.toSingleRange();
                    } else if (!isMultiSelect && accel) {
                        initialRange = selection.toOrientedRange();
                        editor.addSelectionMarker(initialRange);
                    }

                    if (shift) screenAnchor = session.documentToScreenPosition(selection.lead);else selection.moveToPosition(pos);
                    editor.$blockScrolling--;

                    screenCursor = { row: -1, column: -1 };

                    var onMouseSelectionEnd = function (e) {
                        clearInterval(timerId);
                        editor.removeSelectionMarkers(rectSel);
                        if (!rectSel.length) rectSel = [selection.toOrientedRange()];
                        editor.$blockScrolling++;
                        if (initialRange) {
                            editor.removeSelectionMarker(initialRange);
                            selection.toSingleRange(initialRange);
                        }
                        for (var i = 0; i < rectSel.length; i++) selection.addRange(rectSel[i]);
                        editor.inVirtualSelectionMode = false;
                        editor.$mouseHandler.$clickSelection = null;
                        editor.$blockScrolling--;
                    };

                    var onSelectionInterval = blockSelect;

                    event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
                    var timerId = setInterval(function () {
                        onSelectionInterval();
                    }, 20);

                    return e.preventDefault();
                }
            }

            exports.onMouseDown = onMouseDown;
        });

        ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function (require, exports, module) {
            exports.defaultCommands = [{
                name: "addCursorAbove",
                exec: function (editor) {
                    editor.selectMoreLines(-1);
                },
                bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorBelow",
                exec: function (editor) {
                    editor.selectMoreLines(1);
                },
                bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorAboveSkipCurrent",
                exec: function (editor) {
                    editor.selectMoreLines(-1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "addCursorBelowSkipCurrent",
                exec: function (editor) {
                    editor.selectMoreLines(1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectMoreBefore",
                exec: function (editor) {
                    editor.selectMore(-1);
                },
                bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectMoreAfter",
                exec: function (editor) {
                    editor.selectMore(1);
                },
                bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectNextBefore",
                exec: function (editor) {
                    editor.selectMore(-1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectNextAfter",
                exec: function (editor) {
                    editor.selectMore(1, true);
                },
                bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "splitIntoLines",
                exec: function (editor) {
                    editor.multiSelect.splitIntoLines();
                },
                bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
                readOnly: true
            }, {
                name: "alignCursors",
                exec: function (editor) {
                    editor.alignCursors();
                },
                bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
                scrollIntoView: "cursor"
            }, {
                name: "findAll",
                exec: function (editor) {
                    editor.findAll();
                },
                bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
                scrollIntoView: "cursor",
                readOnly: true
            }];
            exports.multiSelectCommands = [{
                name: "singleSelection",
                bindKey: "esc",
                exec: function (editor) {
                    editor.exitMultiSelectMode();
                },
                scrollIntoView: "cursor",
                readOnly: true,
                isAvailable: function (editor) {
                    return editor && editor.inMultiSelectMode;
                }
            }];

            var HashHandler = require("../keyboard/hash_handler").HashHandler;
            exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
        });

        ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function (require, exports, module) {

            var RangeList = require("./range_list").RangeList;
            var Range = require("./range").Range;
            var Selection = require("./selection").Selection;
            var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
            var event = require("./lib/event");
            var lang = require("./lib/lang");
            var commands = require("./commands/multi_select_commands");
            exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
            var Search = require("./search").Search;
            var search = new Search();

            function find(session, needle, dir) {
                search.$options.wrap = true;
                search.$options.needle = needle;
                search.$options.backwards = dir == -1;
                return search.find(session);
            }
            var EditSession = require("./edit_session").EditSession;
            (function () {
                this.getSelectionMarkers = function () {
                    return this.$selectionMarkers;
                };
            }).call(EditSession.prototype);
            (function () {
                this.ranges = null;
                this.rangeList = null;
                this.addRange = function (range, $blockChangeEvents) {
                    if (!range) return;

                    if (!this.inMultiSelectMode && this.rangeCount === 0) {
                        var oldRange = this.toOrientedRange();
                        this.rangeList.add(oldRange);
                        this.rangeList.add(range);
                        if (this.rangeList.ranges.length != 2) {
                            this.rangeList.removeAll();
                            return $blockChangeEvents || this.fromOrientedRange(range);
                        }
                        this.rangeList.removeAll();
                        this.rangeList.add(oldRange);
                        this.$onAddRange(oldRange);
                    }

                    if (!range.cursor) range.cursor = range.end;

                    var removed = this.rangeList.add(range);

                    this.$onAddRange(range);

                    if (removed.length) this.$onRemoveRange(removed);

                    if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                        this._signal("multiSelect");
                        this.inMultiSelectMode = true;
                        this.session.$undoSelect = false;
                        this.rangeList.attach(this.session);
                    }

                    return $blockChangeEvents || this.fromOrientedRange(range);
                };

                this.toSingleRange = function (range) {
                    range = range || this.ranges[0];
                    var removed = this.rangeList.removeAll();
                    if (removed.length) this.$onRemoveRange(removed);

                    range && this.fromOrientedRange(range);
                };
                this.substractPoint = function (pos) {
                    var removed = this.rangeList.substractPoint(pos);
                    if (removed) {
                        this.$onRemoveRange(removed);
                        return removed[0];
                    }
                };
                this.mergeOverlappingRanges = function () {
                    var removed = this.rangeList.merge();
                    if (removed.length) this.$onRemoveRange(removed);else if (this.ranges[0]) this.fromOrientedRange(this.ranges[0]);
                };

                this.$onAddRange = function (range) {
                    this.rangeCount = this.rangeList.ranges.length;
                    this.ranges.unshift(range);
                    this._signal("addRange", { range: range });
                };

                this.$onRemoveRange = function (removed) {
                    this.rangeCount = this.rangeList.ranges.length;
                    if (this.rangeCount == 1 && this.inMultiSelectMode) {
                        var lastRange = this.rangeList.ranges.pop();
                        removed.push(lastRange);
                        this.rangeCount = 0;
                    }

                    for (var i = removed.length; i--;) {
                        var index = this.ranges.indexOf(removed[i]);
                        this.ranges.splice(index, 1);
                    }

                    this._signal("removeRange", { ranges: removed });

                    if (this.rangeCount === 0 && this.inMultiSelectMode) {
                        this.inMultiSelectMode = false;
                        this._signal("singleSelect");
                        this.session.$undoSelect = true;
                        this.rangeList.detach(this.session);
                    }

                    lastRange = lastRange || this.ranges[0];
                    if (lastRange && !lastRange.isEqual(this.getRange())) this.fromOrientedRange(lastRange);
                };
                this.$initRangeList = function () {
                    if (this.rangeList) return;

                    this.rangeList = new RangeList();
                    this.ranges = [];
                    this.rangeCount = 0;
                };
                this.getAllRanges = function () {
                    return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
                };

                this.splitIntoLines = function () {
                    if (this.rangeCount > 1) {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);

                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    } else {
                        var range = this.getRange();
                        var isBackwards = this.isBackwards();
                        var startRow = range.start.row;
                        var endRow = range.end.row;
                        if (startRow == endRow) {
                            if (isBackwards) var start = range.end,
                                end = range.start;else var start = range.start,
                                end = range.end;

                            this.addRange(Range.fromPoints(end, end));
                            this.addRange(Range.fromPoints(start, start));
                            return;
                        }

                        var rectSel = [];
                        var r = this.getLineRange(startRow, true);
                        r.start.column = range.start.column;
                        rectSel.push(r);

                        for (var i = startRow + 1; i < endRow; i++) rectSel.push(this.getLineRange(i, true));

                        r = this.getLineRange(endRow, true);
                        r.end.column = range.end.column;
                        rectSel.push(r);

                        rectSel.forEach(this.addRange, this);
                    }
                };
                this.toggleBlockSelection = function () {
                    if (this.rangeCount > 1) {
                        var ranges = this.rangeList.ranges;
                        var lastRange = ranges[ranges.length - 1];
                        var range = Range.fromPoints(ranges[0].start, lastRange.end);

                        this.toSingleRange();
                        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                    } else {
                        var cursor = this.session.documentToScreenPosition(this.selectionLead);
                        var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

                        var rectSel = this.rectangularRangeBlock(cursor, anchor);
                        rectSel.forEach(this.addRange, this);
                    }
                };
                this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
                    var rectSel = [];

                    var xBackwards = screenCursor.column < screenAnchor.column;
                    if (xBackwards) {
                        var startColumn = screenCursor.column;
                        var endColumn = screenAnchor.column;
                    } else {
                        var startColumn = screenAnchor.column;
                        var endColumn = screenCursor.column;
                    }

                    var yBackwards = screenCursor.row < screenAnchor.row;
                    if (yBackwards) {
                        var startRow = screenCursor.row;
                        var endRow = screenAnchor.row;
                    } else {
                        var startRow = screenAnchor.row;
                        var endRow = screenCursor.row;
                    }

                    if (startColumn < 0) startColumn = 0;
                    if (startRow < 0) startRow = 0;

                    if (startRow == endRow) includeEmptyLines = true;

                    for (var row = startRow; row <= endRow; row++) {
                        var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn), this.session.screenToDocumentPosition(row, endColumn));
                        if (range.isEmpty()) {
                            if (docEnd && isSamePoint(range.end, docEnd)) break;
                            var docEnd = range.end;
                        }
                        range.cursor = xBackwards ? range.start : range.end;
                        rectSel.push(range);
                    }

                    if (yBackwards) rectSel.reverse();

                    if (!includeEmptyLines) {
                        var end = rectSel.length - 1;
                        while (rectSel[end].isEmpty() && end > 0) end--;
                        if (end > 0) {
                            var start = 0;
                            while (rectSel[start].isEmpty()) start++;
                        }
                        for (var i = end; i >= start; i--) {
                            if (rectSel[i].isEmpty()) rectSel.splice(i, 1);
                        }
                    }

                    return rectSel;
                };
            }).call(Selection.prototype);
            var Editor = require("./editor").Editor;
            (function () {
                this.updateSelectionMarkers = function () {
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };
                this.addSelectionMarker = function (orientedRange) {
                    if (!orientedRange.cursor) orientedRange.cursor = orientedRange.end;

                    var style = this.getSelectionStyle();
                    orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

                    this.session.$selectionMarkers.push(orientedRange);
                    this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                    return orientedRange;
                };
                this.removeSelectionMarker = function (range) {
                    if (!range.marker) return;
                    this.session.removeMarker(range.marker);
                    var index = this.session.$selectionMarkers.indexOf(range);
                    if (index != -1) this.session.$selectionMarkers.splice(index, 1);
                    this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                };

                this.removeSelectionMarkers = function (ranges) {
                    var markerList = this.session.$selectionMarkers;
                    for (var i = ranges.length; i--;) {
                        var range = ranges[i];
                        if (!range.marker) continue;
                        this.session.removeMarker(range.marker);
                        var index = markerList.indexOf(range);
                        if (index != -1) markerList.splice(index, 1);
                    }
                    this.session.selectionMarkerCount = markerList.length;
                };

                this.$onAddRange = function (e) {
                    this.addSelectionMarker(e.range);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onRemoveRange = function (e) {
                    this.removeSelectionMarkers(e.ranges);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onMultiSelect = function (e) {
                    if (this.inMultiSelectMode) return;
                    this.inMultiSelectMode = true;

                    this.setStyle("ace_multiselect");
                    this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
                    this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                };

                this.$onSingleSelect = function (e) {
                    if (this.session.multiSelect.inVirtualMode) return;
                    this.inMultiSelectMode = false;

                    this.unsetStyle("ace_multiselect");
                    this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

                    this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
                    this.renderer.updateCursor();
                    this.renderer.updateBackMarkers();
                    this._emit("changeSelection");
                };

                this.$onMultiSelectExec = function (e) {
                    var command = e.command;
                    var editor = e.editor;
                    if (!editor.multiSelect) return;
                    if (!command.multiSelectAction) {
                        var result = command.exec(editor, e.args || {});
                        editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                        editor.multiSelect.mergeOverlappingRanges();
                    } else if (command.multiSelectAction == "forEach") {
                        result = editor.forEachSelection(command, e.args);
                    } else if (command.multiSelectAction == "forEachLine") {
                        result = editor.forEachSelection(command, e.args, true);
                    } else if (command.multiSelectAction == "single") {
                        editor.exitMultiSelectMode();
                        result = command.exec(editor, e.args || {});
                    } else {
                        result = command.multiSelectAction(editor, e.args || {});
                    }
                    return result;
                };
                this.forEachSelection = function (cmd, args, options) {
                    if (this.inVirtualSelectionMode) return;
                    var keepOrder = options && options.keepOrder;
                    var $byLines = options == true || options && options.$byLines;
                    var session = this.session;
                    var selection = this.selection;
                    var rangeList = selection.rangeList;
                    var ranges = (keepOrder ? selection : rangeList).ranges;
                    var result;

                    if (!ranges.length) return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});

                    var reg = selection._eventRegistry;
                    selection._eventRegistry = {};

                    var tmpSel = new Selection(session);
                    this.inVirtualSelectionMode = true;
                    for (var i = ranges.length; i--;) {
                        if ($byLines) {
                            while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row) i--;
                        }
                        tmpSel.fromOrientedRange(ranges[i]);
                        tmpSel.index = i;
                        this.selection = session.selection = tmpSel;
                        var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                        if (!result && cmdResult !== undefined) result = cmdResult;
                        tmpSel.toOrientedRange(ranges[i]);
                    }
                    tmpSel.detach();

                    this.selection = session.selection = selection;
                    this.inVirtualSelectionMode = false;
                    selection._eventRegistry = reg;
                    selection.mergeOverlappingRanges();

                    var anim = this.renderer.$scrollAnimation;
                    this.onCursorChange();
                    this.onSelectionChange();
                    if (anim && anim.from == anim.to) this.renderer.animateScrolling(anim.from);

                    return result;
                };
                this.exitMultiSelectMode = function () {
                    if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
                    this.multiSelect.toSingleRange();
                };

                this.getSelectedText = function () {
                    var text = "";
                    if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                        var ranges = this.multiSelect.rangeList.ranges;
                        var buf = [];
                        for (var i = 0; i < ranges.length; i++) {
                            buf.push(this.session.getTextRange(ranges[i]));
                        }
                        var nl = this.session.getDocument().getNewLineCharacter();
                        text = buf.join(nl);
                        if (text.length == (buf.length - 1) * nl.length) text = "";
                    } else if (!this.selection.isEmpty()) {
                        text = this.session.getTextRange(this.getSelectionRange());
                    }
                    return text;
                };

                this.$checkMultiselectChange = function (e, anchor) {
                    if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                        var range = this.multiSelect.ranges[0];
                        if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor) return;
                        var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
                        if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column) this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                    }
                };
                this.findAll = function (needle, options, additive) {
                    options = options || {};
                    options.needle = needle || options.needle;
                    if (options.needle == undefined) {
                        var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
                        options.needle = this.session.getTextRange(range);
                    }
                    this.$search.set(options);

                    var ranges = this.$search.findAll(this.session);
                    if (!ranges.length) return 0;

                    this.$blockScrolling += 1;
                    var selection = this.multiSelect;

                    if (!additive) selection.toSingleRange(ranges[0]);

                    for (var i = ranges.length; i--;) selection.addRange(ranges[i], true);
                    if (range && selection.rangeList.rangeAtPoint(range.start)) selection.addRange(range, true);

                    this.$blockScrolling -= 1;

                    return ranges.length;
                };
                this.selectMoreLines = function (dir, skip) {
                    var range = this.selection.toOrientedRange();
                    var isBackwards = range.cursor == range.end;

                    var screenLead = this.session.documentToScreenPosition(range.cursor);
                    if (this.selection.$desiredColumn) screenLead.column = this.selection.$desiredColumn;

                    var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

                    if (!range.isEmpty()) {
                        var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                        var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
                    } else {
                        var anchor = lead;
                    }

                    if (isBackwards) {
                        var newRange = Range.fromPoints(lead, anchor);
                        newRange.cursor = newRange.start;
                    } else {
                        var newRange = Range.fromPoints(anchor, lead);
                        newRange.cursor = newRange.end;
                    }

                    newRange.desiredColumn = screenLead.column;
                    if (!this.selection.inMultiSelectMode) {
                        this.selection.addRange(range);
                    } else {
                        if (skip) var toRemove = range.cursor;
                    }

                    this.selection.addRange(newRange);
                    if (toRemove) this.selection.substractPoint(toRemove);
                };
                this.transposeSelections = function (dir) {
                    var session = this.session;
                    var sel = session.multiSelect;
                    var all = sel.ranges;

                    for (var i = all.length; i--;) {
                        var range = all[i];
                        if (range.isEmpty()) {
                            var tmp = session.getWordRange(range.start.row, range.start.column);
                            range.start.row = tmp.start.row;
                            range.start.column = tmp.start.column;
                            range.end.row = tmp.end.row;
                            range.end.column = tmp.end.column;
                        }
                    }
                    sel.mergeOverlappingRanges();

                    var words = [];
                    for (var i = all.length; i--;) {
                        var range = all[i];
                        words.unshift(session.getTextRange(range));
                    }

                    if (dir < 0) words.unshift(words.pop());else words.push(words.shift());

                    for (var i = all.length; i--;) {
                        var range = all[i];
                        var tmp = range.clone();
                        session.replace(range, words[i]);
                        range.start.row = tmp.start.row;
                        range.start.column = tmp.start.column;
                    }
                };
                this.selectMore = function (dir, skip, stopAtFirst) {
                    var session = this.session;
                    var sel = session.multiSelect;

                    var range = sel.toOrientedRange();
                    if (range.isEmpty()) {
                        range = session.getWordRange(range.start.row, range.start.column);
                        range.cursor = dir == -1 ? range.start : range.end;
                        this.multiSelect.addRange(range);
                        if (stopAtFirst) return;
                    }
                    var needle = session.getTextRange(range);

                    var newRange = find(session, needle, dir);
                    if (newRange) {
                        newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                        this.$blockScrolling += 1;
                        this.session.unfold(newRange);
                        this.multiSelect.addRange(newRange);
                        this.$blockScrolling -= 1;
                        this.renderer.scrollCursorIntoView(null, 0.5);
                    }
                    if (skip) this.multiSelect.substractPoint(range.cursor);
                };
                this.alignCursors = function () {
                    var session = this.session;
                    var sel = session.multiSelect;
                    var ranges = sel.ranges;
                    var row = -1;
                    var sameRowRanges = ranges.filter(function (r) {
                        if (r.cursor.row == row) return true;
                        row = r.cursor.row;
                    });

                    if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                        var range = this.selection.getRange();
                        var fr = range.start.row,
                            lr = range.end.row;
                        var guessRange = fr == lr;
                        if (guessRange) {
                            var max = this.session.getLength();
                            var line;
                            do {
                                line = this.session.getLine(lr);
                            } while (/[=:]/.test(line) && ++lr < max);
                            do {
                                line = this.session.getLine(fr);
                            } while (/[=:]/.test(line) && --fr > 0);

                            if (fr < 0) fr = 0;
                            if (lr >= max) lr = max - 1;
                        }
                        var lines = this.session.removeFullLines(fr, lr);
                        lines = this.$reAlignText(lines, guessRange);
                        this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
                        if (!guessRange) {
                            range.start.column = 0;
                            range.end.column = lines[lines.length - 1].length;
                        }
                        this.selection.setRange(range);
                    } else {
                        sameRowRanges.forEach(function (r) {
                            sel.substractPoint(r.cursor);
                        });

                        var maxCol = 0;
                        var minSpace = Infinity;
                        var spaceOffsets = ranges.map(function (r) {
                            var p = r.cursor;
                            var line = session.getLine(p.row);
                            var spaceOffset = line.substr(p.column).search(/\S/g);
                            if (spaceOffset == -1) spaceOffset = 0;

                            if (p.column > maxCol) maxCol = p.column;
                            if (spaceOffset < minSpace) minSpace = spaceOffset;
                            return spaceOffset;
                        });
                        ranges.forEach(function (r, i) {
                            var p = r.cursor;
                            var l = maxCol - p.column;
                            var d = spaceOffsets[i] - minSpace;
                            if (l > d) session.insert(p, lang.stringRepeat(" ", l - d));else session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                            r.start.column = r.end.column = maxCol;
                            r.start.row = r.end.row = p.row;
                            r.cursor = r.end;
                        });
                        sel.fromOrientedRange(ranges[0]);
                        this.renderer.updateCursor();
                        this.renderer.updateBackMarkers();
                    }
                };

                this.$reAlignText = function (lines, forceLeft) {
                    var isLeftAligned = true,
                        isRightAligned = true;
                    var startW, textW, endW;

                    return lines.map(function (line) {
                        var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                        if (!m) return [line];

                        if (startW == null) {
                            startW = m[1].length;
                            textW = m[2].length;
                            endW = m[3].length;
                            return m;
                        }

                        if (startW + textW + endW != m[1].length + m[2].length + m[3].length) isRightAligned = false;
                        if (startW != m[1].length) isLeftAligned = false;

                        if (startW > m[1].length) startW = m[1].length;
                        if (textW < m[2].length) textW = m[2].length;
                        if (endW > m[3].length) endW = m[3].length;

                        return m;
                    }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

                    function spaces(n) {
                        return lang.stringRepeat(" ", n);
                    }

                    function alignLeft(m) {
                        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                    function alignRight(m) {
                        return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                    function unAlign(m) {
                        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
                    }
                };
            }).call(Editor.prototype);

            function isSamePoint(p1, p2) {
                return p1.row == p2.row && p1.column == p2.column;
            }
            exports.onSessionChange = function (e) {
                var session = e.session;
                if (session && !session.multiSelect) {
                    session.$selectionMarkers = [];
                    session.selection.$initRangeList();
                    session.multiSelect = session.selection;
                }
                this.multiSelect = session && session.multiSelect;

                var oldSession = e.oldSession;
                if (oldSession) {
                    oldSession.multiSelect.off("addRange", this.$onAddRange);
                    oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
                    oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
                    oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
                    oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
                    oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
                }

                if (session) {
                    session.multiSelect.on("addRange", this.$onAddRange);
                    session.multiSelect.on("removeRange", this.$onRemoveRange);
                    session.multiSelect.on("multiSelect", this.$onMultiSelect);
                    session.multiSelect.on("singleSelect", this.$onSingleSelect);
                    session.multiSelect.lead.on("change", this.$checkMultiselectChange);
                    session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
                }

                if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
                    if (session.selection.inMultiSelectMode) this.$onMultiSelect();else this.$onSingleSelect();
                }
            };
            function MultiSelect(editor) {
                if (editor.$multiselectOnSessionChange) return;
                editor.$onAddRange = editor.$onAddRange.bind(editor);
                editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
                editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
                editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
                editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
                editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

                editor.$multiselectOnSessionChange(editor);
                editor.on("changeSession", editor.$multiselectOnSessionChange);

                editor.on("mousedown", onMouseDown);
                editor.commands.addCommands(commands.defaultCommands);

                addAltCursorListeners(editor);
            }

            function addAltCursorListeners(editor) {
                var el = editor.textInput.getElement();
                var altCursor = false;
                event.addListener(el, "keydown", function (e) {
                    var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
                    if (editor.$blockSelectEnabled && altDown) {
                        if (!altCursor) {
                            editor.renderer.setMouseCursor("crosshair");
                            altCursor = true;
                        }
                    } else if (altCursor) {
                        reset();
                    }
                });

                event.addListener(el, "keyup", reset);
                event.addListener(el, "blur", reset);
                function reset(e) {
                    if (altCursor) {
                        editor.renderer.setMouseCursor("");
                        altCursor = false;
                    }
                }
            }

            exports.MultiSelect = MultiSelect;

            require("./config").defineOptions(Editor.prototype, "editor", {
                enableMultiselect: {
                    set: function (val) {
                        MultiSelect(this);
                        if (val) {
                            this.on("changeSession", this.$multiselectOnSessionChange);
                            this.on("mousedown", onMouseDown);
                        } else {
                            this.off("changeSession", this.$multiselectOnSessionChange);
                            this.off("mousedown", onMouseDown);
                        }
                    },
                    value: true
                },
                enableBlockSelect: {
                    set: function (val) {
                        this.$blockSelectEnabled = val;
                    },
                    value: true
                }
            });
        });

        ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function (require, exports, module) {
            "use strict";

            var Range = require("../../range").Range;

            var FoldMode = exports.FoldMode = function () {};

            (function () {

                this.foldingStartMarker = null;
                this.foldingStopMarker = null;
                this.getFoldWidget = function (session, foldStyle, row) {
                    var line = session.getLine(row);
                    if (this.foldingStartMarker.test(line)) return "start";
                    if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) return "end";
                    return "";
                };

                this.getFoldWidgetRange = function (session, foldStyle, row) {
                    return null;
                };

                this.indentationBlock = function (session, row, column) {
                    var re = /\S/;
                    var line = session.getLine(row);
                    var startLevel = line.search(re);
                    if (startLevel == -1) return;

                    var startColumn = column || line.length;
                    var maxRow = session.getLength();
                    var startRow = row;
                    var endRow = row;

                    while (++row < maxRow) {
                        var level = session.getLine(row).search(re);

                        if (level == -1) continue;

                        if (level <= startLevel) break;

                        endRow = row;
                    }

                    if (endRow > startRow) {
                        var endColumn = session.getLine(endRow).length;
                        return new Range(startRow, startColumn, endRow, endColumn);
                    }
                };

                this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
                    var start = { row: row, column: column + 1 };
                    var end = session.$findClosingBracket(bracket, start, typeRe);
                    if (!end) return;

                    var fw = session.foldWidgets[end.row];
                    if (fw == null) fw = session.getFoldWidget(end.row);

                    if (fw == "start" && end.row > start.row) {
                        end.row--;
                        end.column = session.getLine(end.row).length;
                    }
                    return Range.fromPoints(start, end);
                };

                this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
                    var end = { row: row, column: column };
                    var start = session.$findOpeningBracket(bracket, end);

                    if (!start) return;

                    start.column++;
                    end.column--;

                    return Range.fromPoints(start, end);
                };
            }).call(FoldMode.prototype);
        });

        ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {
            "use strict";

            exports.isDark = false;
            exports.cssClass = "ace-tm";
            exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

            var dom = require("../lib/dom");
            dom.importCssString(exports.cssText, exports.cssClass);
        });

        ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function (require, exports, module) {
            "use strict";

            var oop = require("./lib/oop");
            var dom = require("./lib/dom");
            var Range = require("./range").Range;

            function LineWidgets(session) {
                this.session = session;
                this.session.widgetManager = this;
                this.session.getRowLength = this.getRowLength;
                this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
                this.updateOnChange = this.updateOnChange.bind(this);
                this.renderWidgets = this.renderWidgets.bind(this);
                this.measureWidgets = this.measureWidgets.bind(this);
                this.session._changedWidgets = [];
                this.$onChangeEditor = this.$onChangeEditor.bind(this);

                this.session.on("change", this.updateOnChange);
                this.session.on("changeFold", this.updateOnFold);
                this.session.on("changeEditor", this.$onChangeEditor);
            }

            (function () {
                this.getRowLength = function (row) {
                    var h;
                    if (this.lineWidgets) h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                    if (!this.$useWrapMode || !this.$wrapData[row]) {
                        return 1 + h;
                    } else {
                        return this.$wrapData[row].length + 1 + h;
                    }
                };

                this.$getWidgetScreenLength = function () {
                    var screenRows = 0;
                    this.lineWidgets.forEach(function (w) {
                        if (w && w.rowCount && !w.hidden) screenRows += w.rowCount;
                    });
                    return screenRows;
                };

                this.$onChangeEditor = function (e) {
                    this.attach(e.editor);
                };

                this.attach = function (editor) {
                    if (editor && editor.widgetManager && editor.widgetManager != this) editor.widgetManager.detach();

                    if (this.editor == editor) return;

                    this.detach();
                    this.editor = editor;

                    if (editor) {
                        editor.widgetManager = this;
                        editor.renderer.on("beforeRender", this.measureWidgets);
                        editor.renderer.on("afterRender", this.renderWidgets);
                    }
                };
                this.detach = function (e) {
                    var editor = this.editor;
                    if (!editor) return;

                    this.editor = null;
                    editor.widgetManager = null;

                    editor.renderer.off("beforeRender", this.measureWidgets);
                    editor.renderer.off("afterRender", this.renderWidgets);
                    var lineWidgets = this.session.lineWidgets;
                    lineWidgets && lineWidgets.forEach(function (w) {
                        if (w && w.el && w.el.parentNode) {
                            w._inDocument = false;
                            w.el.parentNode.removeChild(w.el);
                        }
                    });
                };

                this.updateOnFold = function (e, session) {
                    var lineWidgets = session.lineWidgets;
                    if (!lineWidgets || !e.action) return;
                    var fold = e.data;
                    var start = fold.start.row;
                    var end = fold.end.row;
                    var hide = e.action == "add";
                    for (var i = start + 1; i < end; i++) {
                        if (lineWidgets[i]) lineWidgets[i].hidden = hide;
                    }
                    if (lineWidgets[end]) {
                        if (hide) {
                            if (!lineWidgets[start]) lineWidgets[start] = lineWidgets[end];else lineWidgets[end].hidden = hide;
                        } else {
                            if (lineWidgets[start] == lineWidgets[end]) lineWidgets[start] = undefined;
                            lineWidgets[end].hidden = hide;
                        }
                    }
                };

                this.updateOnChange = function (delta) {
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;

                    var startRow = delta.start.row;
                    var len = delta.end.row - startRow;

                    if (len === 0) {} else if (delta.action == 'remove') {
                        var removed = lineWidgets.splice(startRow + 1, len);
                        removed.forEach(function (w) {
                            w && this.removeLineWidget(w);
                        }, this);
                        this.$updateRows();
                    } else {
                        var args = new Array(len);
                        args.unshift(startRow, 0);
                        lineWidgets.splice.apply(lineWidgets, args);
                        this.$updateRows();
                    }
                };

                this.$updateRows = function () {
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;
                    var noWidgets = true;
                    lineWidgets.forEach(function (w, i) {
                        if (w) {
                            noWidgets = false;
                            w.row = i;
                            while (w.$oldWidget) {
                                w.$oldWidget.row = i;
                                w = w.$oldWidget;
                            }
                        }
                    });
                    if (noWidgets) this.session.lineWidgets = null;
                };

                this.addLineWidget = function (w) {
                    if (!this.session.lineWidgets) this.session.lineWidgets = new Array(this.session.getLength());

                    var old = this.session.lineWidgets[w.row];
                    if (old) {
                        w.$oldWidget = old;
                        if (old.el && old.el.parentNode) {
                            old.el.parentNode.removeChild(old.el);
                            old._inDocument = false;
                        }
                    }

                    this.session.lineWidgets[w.row] = w;

                    w.session = this.session;

                    var renderer = this.editor.renderer;
                    if (w.html && !w.el) {
                        w.el = dom.createElement("div");
                        w.el.innerHTML = w.html;
                    }
                    if (w.el) {
                        dom.addCssClass(w.el, "ace_lineWidgetContainer");
                        w.el.style.position = "absolute";
                        w.el.style.zIndex = 5;
                        renderer.container.appendChild(w.el);
                        w._inDocument = true;
                    }

                    if (!w.coverGutter) {
                        w.el.style.zIndex = 3;
                    }
                    if (w.pixelHeight == null) {
                        w.pixelHeight = w.el.offsetHeight;
                    }
                    if (w.rowCount == null) {
                        w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
                    }

                    var fold = this.session.getFoldAt(w.row, 0);
                    w.$fold = fold;
                    if (fold) {
                        var lineWidgets = this.session.lineWidgets;
                        if (w.row == fold.end.row && !lineWidgets[fold.start.row]) lineWidgets[fold.start.row] = w;else w.hidden = true;
                    }

                    this.session._emit("changeFold", { data: { start: { row: w.row } } });

                    this.$updateRows();
                    this.renderWidgets(null, renderer);
                    this.onWidgetChanged(w);
                    return w;
                };

                this.removeLineWidget = function (w) {
                    w._inDocument = false;
                    w.session = null;
                    if (w.el && w.el.parentNode) w.el.parentNode.removeChild(w.el);
                    if (w.editor && w.editor.destroy) try {
                        w.editor.destroy();
                    } catch (e) {}
                    if (this.session.lineWidgets) {
                        var w1 = this.session.lineWidgets[w.row];
                        if (w1 == w) {
                            this.session.lineWidgets[w.row] = w.$oldWidget;
                            if (w.$oldWidget) this.onWidgetChanged(w.$oldWidget);
                        } else {
                            while (w1) {
                                if (w1.$oldWidget == w) {
                                    w1.$oldWidget = w.$oldWidget;
                                    break;
                                }
                                w1 = w1.$oldWidget;
                            }
                        }
                    }
                    this.session._emit("changeFold", { data: { start: { row: w.row } } });
                    this.$updateRows();
                };

                this.getWidgetsAtRow = function (row) {
                    var lineWidgets = this.session.lineWidgets;
                    var w = lineWidgets && lineWidgets[row];
                    var list = [];
                    while (w) {
                        list.push(w);
                        w = w.$oldWidget;
                    }
                    return list;
                };

                this.onWidgetChanged = function (w) {
                    this.session._changedWidgets.push(w);
                    this.editor && this.editor.renderer.updateFull();
                };

                this.measureWidgets = function (e, renderer) {
                    var changedWidgets = this.session._changedWidgets;
                    var config = renderer.layerConfig;

                    if (!changedWidgets || !changedWidgets.length) return;
                    var min = Infinity;
                    for (var i = 0; i < changedWidgets.length; i++) {
                        var w = changedWidgets[i];
                        if (!w || !w.el) continue;
                        if (w.session != this.session) continue;
                        if (!w._inDocument) {
                            if (this.session.lineWidgets[w.row] != w) continue;
                            w._inDocument = true;
                            renderer.container.appendChild(w.el);
                        }

                        w.h = w.el.offsetHeight;

                        if (!w.fixedWidth) {
                            w.w = w.el.offsetWidth;
                            w.screenWidth = Math.ceil(w.w / config.characterWidth);
                        }

                        var rowCount = w.h / config.lineHeight;
                        if (w.coverLine) {
                            rowCount -= this.session.getRowLineCount(w.row);
                            if (rowCount < 0) rowCount = 0;
                        }
                        if (w.rowCount != rowCount) {
                            w.rowCount = rowCount;
                            if (w.row < min) min = w.row;
                        }
                    }
                    if (min != Infinity) {
                        this.session._emit("changeFold", { data: { start: { row: min } } });
                        this.session.lineWidgetWidth = null;
                    }
                    this.session._changedWidgets = [];
                };

                this.renderWidgets = function (e, renderer) {
                    var config = renderer.layerConfig;
                    var lineWidgets = this.session.lineWidgets;
                    if (!lineWidgets) return;
                    var first = Math.min(this.firstRow, config.firstRow);
                    var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);

                    while (first > 0 && !lineWidgets[first]) first--;

                    this.firstRow = config.firstRow;
                    this.lastRow = config.lastRow;

                    renderer.$cursorLayer.config = config;
                    for (var i = first; i <= last; i++) {
                        var w = lineWidgets[i];
                        if (!w || !w.el) continue;
                        if (w.hidden) {
                            w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                            continue;
                        }
                        if (!w._inDocument) {
                            w._inDocument = true;
                            renderer.container.appendChild(w.el);
                        }
                        var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
                        if (!w.coverLine) top += config.lineHeight * this.session.getRowLineCount(w.row);
                        w.el.style.top = top - config.offset + "px";

                        var left = w.coverGutter ? 0 : renderer.gutterWidth;
                        if (!w.fixedWidth) left -= renderer.scrollLeft;
                        w.el.style.left = left + "px";

                        if (w.fullWidth && w.screenWidth) {
                            w.el.style.minWidth = config.width + 2 * config.padding + "px";
                        }

                        if (w.fixedWidth) {
                            w.el.style.right = renderer.scrollBar.getWidth() + "px";
                        } else {
                            w.el.style.right = "";
                        }
                    }
                };
            }).call(LineWidgets.prototype);

            exports.LineWidgets = LineWidgets;
        });

        ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function (require, exports, module) {
            "use strict";

            var LineWidgets = require("../line_widgets").LineWidgets;
            var dom = require("../lib/dom");
            var Range = require("../range").Range;

            function binarySearch(array, needle, comparator) {
                var first = 0;
                var last = array.length - 1;

                while (first <= last) {
                    var mid = first + last >> 1;
                    var c = comparator(needle, array[mid]);
                    if (c > 0) first = mid + 1;else if (c < 0) last = mid - 1;else return mid;
                }
                return -(first + 1);
            }

            function findAnnotations(session, row, dir) {
                var annotations = session.getAnnotations().sort(Range.comparePoints);
                if (!annotations.length) return;

                var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
                if (i < 0) i = -i - 1;

                if (i >= annotations.length) i = dir > 0 ? 0 : annotations.length - 1;else if (i === 0 && dir < 0) i = annotations.length - 1;

                var annotation = annotations[i];
                if (!annotation || !dir) return;

                if (annotation.row === row) {
                    do {
                        annotation = annotations[i += dir];
                    } while (annotation && annotation.row === row);
                    if (!annotation) return annotations.slice();
                }

                var matched = [];
                row = annotation.row;
                do {
                    matched[dir < 0 ? "unshift" : "push"](annotation);
                    annotation = annotations[i += dir];
                } while (annotation && annotation.row == row);
                return matched.length && matched;
            }

            exports.showErrorMarker = function (editor, dir) {
                var session = editor.session;
                if (!session.widgetManager) {
                    session.widgetManager = new LineWidgets(session);
                    session.widgetManager.attach(editor);
                }

                var pos = editor.getCursorPosition();
                var row = pos.row;
                var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
                    return w.type == "errorMarker";
                })[0];
                if (oldWidget) {
                    oldWidget.destroy();
                } else {
                    row -= dir;
                }
                var annotations = findAnnotations(session, row, dir);
                var gutterAnno;
                if (annotations) {
                    var annotation = annotations[0];
                    pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
                    pos.row = annotation.row;
                    gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
                } else if (oldWidget) {
                    return;
                } else {
                    gutterAnno = {
                        text: ["Looks good!"],
                        className: "ace_ok"
                    };
                }
                editor.session.unfold(pos.row);
                editor.selection.moveToPosition(pos);

                var w = {
                    row: pos.row,
                    fixedWidth: true,
                    coverGutter: true,
                    el: dom.createElement("div"),
                    type: "errorMarker"
                };
                var el = w.el.appendChild(dom.createElement("div"));
                var arrow = w.el.appendChild(dom.createElement("div"));
                arrow.className = "error_widget_arrow " + gutterAnno.className;

                var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
                arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";

                w.el.className = "error_widget_wrapper";
                el.className = "error_widget " + gutterAnno.className;
                el.innerHTML = gutterAnno.text.join("<br>");

                el.appendChild(dom.createElement("div"));

                var kb = function (_, hashId, keyString) {
                    if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                        w.destroy();
                        return { command: "null" };
                    }
                };

                w.destroy = function () {
                    if (editor.$mouseHandler.isMousePressed) return;
                    editor.keyBinding.removeKeyboardHandler(kb);
                    session.widgetManager.removeLineWidget(w);
                    editor.off("changeSelection", w.destroy);
                    editor.off("changeSession", w.destroy);
                    editor.off("mouseup", w.destroy);
                    editor.off("change", w.destroy);
                };

                editor.keyBinding.addKeyboardHandler(kb);
                editor.on("changeSelection", w.destroy);
                editor.on("changeSession", w.destroy);
                editor.on("mouseup", w.destroy);
                editor.on("change", w.destroy);

                editor.session.widgetManager.addLineWidget(w);

                w.el.onmousedown = editor.focus.bind(editor);

                editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
            };

            dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
        });

        ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function (require, exports, module) {
            "use strict";

            require("./lib/fixoldbrowsers");

            var dom = require("./lib/dom");
            var event = require("./lib/event");

            var Editor = require("./editor").Editor;
            var EditSession = require("./edit_session").EditSession;
            var UndoManager = require("./undomanager").UndoManager;
            var Renderer = require("./virtual_renderer").VirtualRenderer;
            require("./worker/worker_client");
            require("./keyboard/hash_handler");
            require("./placeholder");
            require("./multi_select");
            require("./mode/folding/fold_mode");
            require("./theme/textmate");
            require("./ext/error_marker");

            exports.config = require("./config");
            exports.require = require;

            if (typeof define === "function") exports.define = define;
            exports.edit = function (el) {
                if (typeof el == "string") {
                    var _id = el;
                    el = document.getElementById(_id);
                    if (!el) throw new Error("ace.edit can't find div #" + _id);
                }

                if (el && el.env && el.env.editor instanceof Editor) return el.env.editor;

                var value = "";
                if (el && /input|textarea/i.test(el.tagName)) {
                    var oldNode = el;
                    value = oldNode.value;
                    el = dom.createElement("pre");
                    oldNode.parentNode.replaceChild(el, oldNode);
                } else if (el) {
                    value = dom.getInnerText(el);
                    el.innerHTML = "";
                }

                var doc = exports.createEditSession(value);

                var editor = new Editor(new Renderer(el));
                editor.setSession(doc);

                var env = {
                    document: doc,
                    editor: editor,
                    onResize: editor.resize.bind(editor, null)
                };
                if (oldNode) env.textarea = oldNode;
                event.addListener(window, "resize", env.onResize);
                editor.on("destroy", function () {
                    event.removeListener(window, "resize", env.onResize);
                    env.editor.container.env = null; // prevent memory leak on old ie
                });
                editor.container.env = editor.env = env;
                return editor;
            };
            exports.createEditSession = function (text, mode) {
                var doc = new EditSession(text, mode);
                doc.setUndoManager(new UndoManager());
                return doc;
            };
            exports.EditSession = EditSession;
            exports.UndoManager = UndoManager;
            exports.version = "1.2.5";
        });
        (function () {
            ace.require(["ace/ace"], function (a) {
                if (a) {
                    a.config.init(true);
                    a.define = ace.define;
                }
                if (!window.ace) window.ace = a;
                for (var key in a) if (a.hasOwnProperty(key)) window.ace[key] = a[key];
            });
        })();
    })(this);

    return _retrieveGlobal();
});
$__System.registerDynamic("70", ["5b"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    ace.define("ace/theme/monokai", ["require", "exports", "module", "ace/lib/dom"], function (require, exports, module) {

      exports.isDark = true;
      exports.cssClass = "ace-monokai";
      exports.cssText = ".ace-monokai .ace_gutter {\
background: #2F3129;\
color: #8F908A\
}\
.ace-monokai .ace_print-margin {\
width: 1px;\
background: #555651\
}\
.ace-monokai {\
background-color: #272822;\
color: #F8F8F2\
}\
.ace-monokai .ace_cursor {\
color: #F8F8F0\
}\
.ace-monokai .ace_marker-layer .ace_selection {\
background: #49483E\
}\
.ace-monokai.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #272822;\
}\
.ace-monokai .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-monokai .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #49483E\
}\
.ace-monokai .ace_marker-layer .ace_active-line {\
background: #202020\
}\
.ace-monokai .ace_gutter-active-line {\
background-color: #272727\
}\
.ace-monokai .ace_marker-layer .ace_selected-word {\
border: 1px solid #49483E\
}\
.ace-monokai .ace_invisible {\
color: #52524d\
}\
.ace-monokai .ace_entity.ace_name.ace_tag,\
.ace-monokai .ace_keyword,\
.ace-monokai .ace_meta.ace_tag,\
.ace-monokai .ace_storage {\
color: #F92672\
}\
.ace-monokai .ace_punctuation,\
.ace-monokai .ace_punctuation.ace_tag {\
color: #fff\
}\
.ace-monokai .ace_constant.ace_character,\
.ace-monokai .ace_constant.ace_language,\
.ace-monokai .ace_constant.ace_numeric,\
.ace-monokai .ace_constant.ace_other {\
color: #AE81FF\
}\
.ace-monokai .ace_invalid {\
color: #F8F8F0;\
background-color: #F92672\
}\
.ace-monokai .ace_invalid.ace_deprecated {\
color: #F8F8F0;\
background-color: #AE81FF\
}\
.ace-monokai .ace_support.ace_constant,\
.ace-monokai .ace_support.ace_function {\
color: #66D9EF\
}\
.ace-monokai .ace_fold {\
background-color: #A6E22E;\
border-color: #F8F8F2\
}\
.ace-monokai .ace_storage.ace_type,\
.ace-monokai .ace_support.ace_class,\
.ace-monokai .ace_support.ace_type {\
font-style: italic;\
color: #66D9EF\
}\
.ace-monokai .ace_entity.ace_name.ace_function,\
.ace-monokai .ace_entity.ace_other,\
.ace-monokai .ace_entity.ace_other.ace_attribute-name,\
.ace-monokai .ace_variable {\
color: #A6E22E\
}\
.ace-monokai .ace_variable.ace_parameter {\
font-style: italic;\
color: #FD971F\
}\
.ace-monokai .ace_string {\
color: #E6DB74\
}\
.ace-monokai .ace_comment {\
color: #75715E\
}\
.ace-monokai .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y\
}";

      var dom = require("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("71", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("72", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {})(this);

  return _retrieveGlobal();
});
$__System.register('1',['4','73','74','3','75','76','77','78','7','d','11','15','39','41','46','51','58','5b','5a','5c','5d','5e','5f','60','61','63','62','66','67','59','68','69','6a','6d','79','6e','6f','70','71','72'],function(_export,_context){"use strict";var angular$1,firebase,ace,CryptoJS,camelCase,c3,noop,ace$1,tmpl,alert,tmpl$1,noop$1,navbar,tmpl$2,sign,components,list,setTmpl,pythonTmpl,angularjsTmpl,javascriptTmpl,javaTmpl,iconSet,langIcons,icons,_classCallCheck,_createClass,hex,random,pbkdf2,saltSize,keySize,iterations,prf,PasswordService,Service,crypto,defaults,routeServices,_defineProperty,gravatarBaseUrl,eventName,SpfCurrentUserService,datastore,invalidChar,services,spfShared,template,component,ACE_STATS_URL,ace$2,mcqTmpl,mcqEditTmpl,mcqStart,surveyTmpl,schEngagePreview,motiStratPreview,eduDissPreview,noop$5,teamActivityCreateTmpl,teamIRATTmpl,teamTRATTmpl,teamFormationTmpl,TIMESTAMP,mentorCreationTmpl,challenges,tmpl$3,component$1,classmentors,cohortTmpl,newCohortTmpl,cohortViewTmpl,cohortEditTmpl,cohortStatsPageTmpl,cohortRankingPageTmpl,noop$6,component$2,cohorts,editTmpl,eventTableParticipantsTmpl,eventTableRankTmpl,eventTableResultsTmpl,eventTaskFormTmpl,eventTmpl,listTmpl,newTmpl,pagerTmpl,passwordTmpl,linkTmpl,responseTmpl,editProfileTmpl,codeTmpl,mcqTmpl$1,voteQuestionTmpl,reviewQuestionTmpl,schEngageScaleTmpl,motiStratLearnTmpl,eduDisLearnTmpl,noop$7,TIMESTAMP$1,events,editTmpl$1,showTmpl,noop$8,profiles,template$1,component$3,feedback,qqHome,eventQ,oneQn,askQnTmpl,ansQnTmpl,questionQueue,template$2,AdminCtrl,component$4,admin,formTemplate,template$3,noop$9,ServiceCardCtrl,component$5,GenericServiceFormCtrl,serviceForm,serviceCard,components$1,module$1,noBackList,thisCurrentRoute,thisTaskId,routeChangeStartListener,routeChangeSuccessListener;/**
 * Directive transforming a textarea to a ace editor.
 *
 * @usage
 * <spf-editor-container flex>
 *     <label>Tests</label>
 *     <textarea name="someTextAreaName"
 *         ng-model="$ctrl.someContent"
 *         columns="1"
 *         ng-required="true"
 *         ng-minlength="3"
 *         ng-maxlength="4096"
 *         spf-editor="{{$ctrl.someLanguage}}"
 *     ></textarea>
 *     <div ng-messages="someFormName.someTextAreaName.$error">
 *         <div ng-message="required">This is required.</div>
 *         <div ng-message="minlength">This has to be more than 3 characters long.</div>
 *         <div ng-message="maxlength">this has to be less than 4096 characters long.</div>
 *     </div>
 * </spf-editor-container>
 *
 * @param  {object} $log Angular logging service
 * @return {[type]}      [description]
 */function spfEditorDirectiveFactory($log){var editorIds=1;var languageToMode={angularjs:'html',python:'python',javascript:'javascript',java:'java'};return{restrict:'A',require:'ngModel',link:function spfAceLink(scope,elm,attrs,ngModel){var editorId='spf-editor-'+editorIds++;var editor,session;var render=ngModel.$render||noop;var container=elm.parent();var label=container.find('label');var watchers=[];// Setup DOM
elm.after('<div class="spf-ace-editor" id="'+editorId+'"/>');editor=ace.edit(elm.next()[0]);session=editor.getSession();elm.css('display','none');// Link editor and model
ngModel.$formatters.push(function(value){if(value==null){return'';}switch(typeof value){case'object':case'array':throw new Error('ui-ace cannot use an object or an array as a model');default:return value;}});ngModel.$render=function(){render();session.setValue(ngModel.$viewValue);};session.on('change',function(){ngModel.$setViewValue(session.getValue(),'change');render();});editor.on('focus',function(){container.addClass('has-focus');});editor.on('blur',function(){ngModel.$setViewValue(session.getValue(),'blur');render();container.removeClass('has-focus');container.addClass('had-focus');});// Make label behave like a label
label.on('click',clickHandler);function clickHandler(){editor.focus();}// Observed attributes
watchers.push(attrs.$observe('spfEditor',function(value){var mode;if(!value){return;}mode=languageToMode[value];if(!mode){$log.error('No mode for '+value);return;}session.setMode('ace/mode/'+mode);}));watchers.push(attrs.$observe('spfReadonly',function(value){var isReadOnly=scope.$eval(value);editor.setReadOnly(isReadOnly);}));// Other options
editor.setTheme('ace/theme/twilight');editor.setFontSize(14);editor.renderer.setShowGutter(true);editor.renderer.setShowInvisibles(true);session.setUseWrapMode(true);session.setUseSoftTabs(true);// Watch for resize
watchers.push(scope.$watch(function(){return[elm[0].offsetWidth,elm[0].offsetHeight];},function(){editor.resize();editor.renderer.updateFull();},true));// Decorate container with input state
['pristine','valid','invalid'].map(function(state){var attrName='$'+state;var className='is-'+state;watchers.push(scope.$watch(function(){return ngModel[attrName];},function(){if(ngModel[attrName]){container.addClass(className);}else{container.removeClass(className);}}));});watchers.push(scope.$watch(function(){return ngModel.$viewValue;},function(){if(ngModel.$viewValue.length===0){container.addClass('is-empty');}else{container.removeClass('is-empty');}}));// clean up
elm.on('$destroy',function(){editor.session.$stopWorker();editor.destroy();watchers.map(function(deregistrationFn){deregistrationFn();});label.off('click',clickHandler);});}};}function SpfAlertCtrl($mdToast,notifications,toastOptions){var self=this;this.notifications=notifications;this.prev=function(){if(self.notifications&&self.notifications.length>0){self.notifications.splice(0,1);$mdToast.show(toastOptions);}};this.close=function(){if(self.notifications&&self.notifications.length>0){self.notifications.splice(0);$mdToast.hide();}};}/**
 * Service to show notification m.
 *
 * It takes as arguments the type of notification and the content
 * of the nofication.
 *
 * The type is used as title of the notification and is user to set
 * the class of the notication block: for type set `info`,
 * the block class will be set `alert` and `alert-info` (always lowercase).
 *
 * `spfAlert.success`, `spfAlert.info`, `spfAlert.warning`, `spfAlert.error`
 * and `spfAlert.danger` are shortcut for the spfAlert function.
 *
 * @param  {function} $q       Angular Promise factory.
 * @param  {object}   $mdToast ngMaterial mdToast service.
 * @return {function}
 */function spfAlertFactory($q,$mdToast){var notifications=[];var options={hideDelay:5000,controller:SpfAlertCtrl,controllerAs:'ctrl',parent:'.main-view',position:'top left right',template:tmpl,locals:{notifications:notifications}};options.locals.toastOptions=options;function newNotification(nType,message){return{notificationType:nType||'success',message:message};}function spfAlert(nType,message){notifications.splice(0,0,newNotification(nType,message));$mdToast.show(options);}spfAlert.success=spfAlert.bind(null,'success');spfAlert.info=spfAlert.bind(null,'info');spfAlert.warning=spfAlert.bind(null,'warning');spfAlert.danger=spfAlert.bind(null,'danger');spfAlert.error=spfAlert.bind(null,'error');return spfAlert;}/**
 * Fill the template cache to the navbar template and listen for route change
 * events to reset the navbar.
 *
 * @param  {object} $templateCache   Angular template cache service.
 * @param  {object} $rootScope       Angular rootScope service.
 * @param  {object} spfNavBarService Singpath-core navbar service.
 */function initNavBar($templateCache,$rootScope,spfNavBarService){$templateCache.put('shared/navbar-view.html',tmpl$1);$rootScope.$on('$routeChangeSuccess',function(e,currentRoute){var navBar=Object.assign({title:''},currentRoute&&currentRoute.locals&&currentRoute.locals.navBar||currentRoute.locals.navbar);spfNavBarService.update(navBar.title,navBar.parent,navBar.section);});}/**
 * NavBarService factory.
 *
 * Registery to set title name and menu items
 *
 * @return {function}
 */function spfNavBarServiceFactory(){return{title:undefined,parent:[],menuItems:[],update:function update(title,parents,menuItems){this.title=title;if(parents){this.parents=Array.isArray(parents)?parents:[parents];}else{this.parents=[];}this.menuItems=(menuItems||[]).map(function(item){item.onClick=item.onClick||noop$1;return item;});}};}/**
 * Controler for the header novigation bar.
 *
 * Set an auth property bound to spfAuth. Its user property can used
 * to display the state of the authentication and the user display name
 * when the user is logged in.
 *
 * The ctrl set a login and logout property to autenticate/unauthenticate
 * the current user.
 *
 * @param {function} $q               Angular promise factory service.
 * @param {function} $mdSidenav       ngMaterial side nav service.
 * @param {object}   spfAlert         singpath-core alert service.
 * @param {object}   spfAuth          singpath-core authentication service.
 * @param {object}   spfNavBarService singpath-core nav bar service.
 */function SpfSharedNavBarCtrl($q,$mdSidenav,spfAlert,spfAuth,spfNavBarService){this.auth=spfAuth;this.currentPage=spfNavBarService;this.login=function(){return spfAuth.login().catch(function(e){spfAlert.warning('You failed to authenticate with Google');return $q.reject(e);});};this.logout=function(){return spfAuth.logout();};this.openSideMenu=function(name){$mdSidenav(name).toggle();};}/**
 * Signin form controller.
 *
 * @param {object}   $scope        Angular schild scope of the form.
 * @param {array}    SPF_COUNTRIES List of country name and code.
 * @param {sunction} spfSchools    School list service.
 */function SpfSignFormCtrl($scope,SPF_COUNTRIES,spfSchools){var self=this;var year;spfSchools().then(function(schools){self.schools=Object.keys(schools).map(function(id){return schools[id];});// Make sure the items in the profile attribute are in the list
// of options; or ng-select will show empty select box
if($scope.currentUser.school){$scope.currentUser.school=schools[$scope.currentUser.school.id];}self.loaded=true;});this.loaded=false;this.publicIdIsReadOnly=Boolean($scope.currentUser.publicId);this.countries=SPF_COUNTRIES;this.schools=[];this.ageGroups=[];year=1990;while(year<=2011){this.ageGroups.push(year++);}// Make sure the items in the profile attribute are in the list
// of options; or ng-select will show empty select box
if($scope.currentUser.country){$scope.currentUser.country=this.countries.find(function(country){return country.code===$scope.currentUser.country.code;});}// Current year used to calculate age
$scope.currentYear=new Date().getFullYear();}/**
 * Signin form directive factory.
 *
 * @return {object}
 */function spfSignFormDirectiveFactory(){return{template:tmpl$2,restrict:'E',scope:{currentUser:'='},controller:SpfSignFormCtrl,controllerAs:'ctrl'};}/**
 * Form validator checking the the model value is an available public id.
 *
 * @param  {function} $q          Angular promise factory service.
 * @param  {object}   spfAuthData singpath-core current user data service.
 * @return {object}
 */function spfUniqPublicIdFactory($q,spfAuthData){return{restrict:'A',scope:false,require:'ngModel',link:function spfUniqPublicIdPostLink(s,e,a,model){model.$asyncValidators.spfUniqPublicId=function(modelValue,viewValue){if(!viewValue){return $q.when(true);}return spfAuthData.isPublicIdAvailable(viewValue).then(function(available){if(!available){return $q.reject(new Error(viewValue+' is already taken.'));}return true;});};}};}/**
 * Register the icon set and each language icon with ng-material' $mdIconProvider.
 *
 * @param  {object} $mdIconProvider $mdIcon provider.
 */function config($mdIconProvider){$mdIconProvider.defaultIconSet(iconSet.url,iconSet.vb);langIcons.forEach(function(i){return $mdIconProvider.icon(i.title,i.url,i.vb);});}/**
 * Populate template cache with each icon svg definition.
 *
 * @param  {object} $templateCache $templateCache service.
 */function run($templateCache){$templateCache.put(iconSet.url,iconSet.tmpl);langIcons.forEach(function(i){return $templateCache.put(i.url,i.tmpl);});}function urlForFactory(routes){var routeFns=Object.keys(routes).reduce(function(fns,name){var parts=routes[name].split('/');fns[name]=function(keys){keys=keys||{};return parts.map(function(part){return part[0]===':'?keys[part.slice(1)]:part;}).join('/');};return fns;},{});return function(name,params){var fn=routeFns[name]||routeFns.home;return fn(params);};}function urlForFilterFactory(urlFor){return function urlForFilter(name,params){var url=urlFor(name,params);return url;};}/**
 * Listen for routing error to alert the user of the error and
 * redirect to the default route if not is selected.
 *
 * No route will be selected if the user reload the page in an invalid state
 * for her/his last route. It that case the app should redirect the user
 * to the home route.
 *
 * @param  {object} $rootScope Angular root scope service.
 * @param  {object} $location  Angular location service.
 * @param  {object} routes     Route dictionary.
 * @param  {object} spfAlert   singpath-core alert service
 */function run$1($rootScope,$location,routes,spfAlert){$rootScope.$on('$routeChangeError',function(e,failedRoute,currentRoute,err){spfAlert.error(err.message||err.toString());if(!currentRoute){$location.path(routes.home);}});}/**
 * Returns an object with `user` (Firebase auth user data) property,
 * and login/logout methods.
 *
 * @param  {object}   $q               Angular loggin service.
 * @param  {object}   $route           Angular router service.
 * @param  {object}   $log             Angular logging service.
 * @param  {object}   $firebaseAuth    Angularfire autentication service.
 * @param  {object}   authFirebaseApp  Firebase firebase app holding the authentication data.
 * @param  {object}   authProvider     Firebase auth provider
 * @return {{user: object, login: function, logout: function, onAuth: function}}
 */function spfAuthFactory($q,$route,$log,$firebaseAuth,authFirebaseApp,authProvider){var auth=$firebaseAuth(authFirebaseApp.auth());var cbs=[];var loaded=false;var spfAuth={// The current user auth data (null is not authenticated).
user:undefined,/**
     * Waits for the current user status loads before resolving.
     *
     * @return {Promise<void>}
     */$loaded:function $loaded(){return $q(function(resolve){var cancel=void 0;if(spfAuth.user!==undefined){resolve(spfAuth);return;}cancel=spfAuth.onAuth(function(){resolve(spfAuth);cancel();});});},/**
     * Rejects is the user is logged off.
     *
     * It waits for the status to load before resolving/rejecting.
     *
     * @return {Promise<void,Error>}
     */requireLoggedIn:function requireLoggedIn(){return spfAuth.$loaded().then(function(){if(!spfAuth.user||!spfAuth.user.uid){return $q.reject(new Error('You are not logged in.'));}return spfAuth;});},/**
     * Get user info from current user provider data.
     *
     * @return {?{name: string, email: string}}
     */userInfo:function userInfo(){if(!spfAuth.user){return null;}if(!spfAuth.user.providerData){return{};}return spfAuth.user.providerData.reduce(function(merged,data){switch(data.providerId){case'google.com':merged.email=data.email;merged.name=data.displayName;break;case'custom':if(!merged.email){merged.email='custom@example.com';}if(!merged.name){merged.name='Custom User';}break;default:$log.error('Wrong provider: '+spfAuth.user.providerId);}return merged;},{});},/**
     * Start Oauth authentication dance against google oauth2 service.
     *
     * Updates spfAuth.user and return a promise resolving to the
     * current user auth data.
     *
     * @return {Promise<firebase.User, Error>}
     */login:function login(){return auth.$signInWithPopup(authProvider).then(function(userCredentials){spfAuth.user=userCredentials.user;return userCredentials.user;});},/**
     * Unauthenticate user and reset spfAuth.user.
     *
     * @return {Promise<void, Error>}
     */logout:function logout(){return auth.$signOut();},/**
     * Register a callback for the authentication event.
     *
     * @param  {function} fn  cb function for auth change events.
     * @param  {object}   ctx cb context.
     * @return {function} function to deregister handler
     */onAuth:function onAuth(fn,ctx){var handler={fn:fn,ctx:ctx};cbs.push(handler);if(loaded){handler.fn.call(handler.ctx,spfAuth.user);}return function(){var index=cbs.indexOf(handler);if(index>-1){cbs.splice(index,1);}};}};auth.$onAuthStateChanged(function(currentAuth){loaded=true;$log.debug('reloading');$route.reload();spfAuth.user=currentAuth||null;cbs.forEach(function(handler){try{handler.fn.call(handler.ctx,spfAuth.user);}catch(e){$log.error(e);}});});return spfAuth;}/**
 * Service to interact with '/auth/users' singpath firebase db entry
 *
 * @param  {function} $q              Angular promise factory service.
 * @param  {object}   $log            Angular logging service.
 * @param  {object}   $firebaseObject AngularFire synchronized objects service.
 * @param  {object}   authFirebaseApp Firebase app hosting authentication data.
 * @param  {object}   spfAuth         singpath-core authentication service.
 * @param  {object}   spfCrypto       singpath-core crypto helpers service.
 * @return {{user: function, register: function, publicId: function, isPublicIdAvailable: function}}
 */function spfAuthDataFactory($q,$log,$firebaseObject,authFirebaseApp,spfAuth,spfCrypto){var userDataPromise,spfAuthData;var db=authFirebaseApp.database();var UserFirebaseObject=$firebaseObject.$extend({$completed:function $completed(){return Boolean(this.publicId&&this.country&&(this.yearOfBirth||this.country.code!=='SG')&&(this.school||!this.yearOfBirth||this.yearOfBirth<1996||this.yearOfBirth>2004));}});UserFirebaseObject.create=function(ref){if(typeof ref.child!=='function'){throw new Error('A firebase Reference is required; received "'+ref+'".');}return new spfAuthData.UserFirebaseObject(ref);};spfAuth.onAuth(function(){userDataPromise=undefined;});spfAuthData={UserFirebaseObject:UserFirebaseObject,_user:function _user(){var ref=db.ref('auth/users/'+spfAuth.user.uid);var syncObj=UserFirebaseObject.create(ref);return syncObj.$loaded().then(function(){return syncObj;});},/**
     * Returns a promise resolving to an angularFire $firebaseObject
     * for the current user data.
     *
     * The promise will be rejected if the is not authenticated.
     *
     * @return {Promise<object, Error>}
     */user:function user(){if(userDataPromise){return userDataPromise;}userDataPromise=spfAuth.$loaded().then(function(){if(!spfAuth.user||!spfAuth.user.uid){return $q.reject(new Error('Your did not login or your session expired.'));}return spfAuthData._user();}).then(spfAuthData.register);return userDataPromise;},/**
     * Setup initial data for the current user.
     *
     * Should run if 'auth.user().$value is `null`.
     *
     * Returns a promise resolving to the user data when
     * they become available.
     *
     * @param  {object} userDataObj user data to register.
     * @return {Promise<object, Error>}
     */register:function register(userDataObj){var userInfo;if(userDataObj==null){return $q.reject(new Error('A user should be logged in to register'));}// $value will be undefined and not null when the userDataObj object
// is set.
if(userDataObj.$value!==null){return $q.resolve(userDataObj);}userInfo=spfAuth.userInfo();if(!userInfo||!userInfo.name||!userInfo.email){return $q.reject(new Error('Failed to retrieve user data from provider data: '+JSON.stringify(spfAuth.user.providerData)));}userDataObj.$value={id:spfAuth.user.uid,fullName:userInfo.name,displayName:userInfo.name,email:userInfo.email,gravatar:gravatarBaseUrl+spfCrypto.md5(userInfo.email),createdAt:{'.sv':'timestamp'}};return userDataObj.$save().then(function(){return userDataObj;});},/**
     * Set the user public id.
     *
     * @param  {object} userSync AngularFire object.
     * @return {Promise<void, Error>}
     */publicId:function publicId(userSync){var _data;if(!userSync||!userSync.publicId){return $q.reject(new Error('The user has not set a user public id.'));}if(!userSync.$id){return $q.reject(new Error('Expected an angularFire synchronized object.'));}var ref=db.ref('auth');var data=(_data={},_defineProperty(_data,'publicIds/'+userSync.publicId,userSync.$id),_defineProperty(_data,'usedPublicIds/'+userSync.publicId,true),_defineProperty(_data,'users/'+userSync.$id+'/publicId',userSync.publicId),_data);return ref.update(data).catch(function(err){$log.info(err);return $q.reject(new Error('Failed to save public id. It might have already being used by an other user.'));});},/**
     * Test if a public id is available.
     *
     * @param  {string}  publicId id to test
     * @return {Promise<boolean, Error>}
     */isPublicIdAvailable:function isPublicIdAvailable(publicId){var ref=db.ref('auth/usedPublicIds/'+publicId);return ref.once('value').then(function(snapshot){return!snapshot.val();});}};return spfAuthData;}/**
 * Create a function which when called return a promise resolving to the list of
 * Singapore schools.
 *
 * Load the list as soon as the the service is created. The service will return
 * the same promise over again as a way to cache the result.
 *
 * @param  {object}   $firebaseObject AngularFire synchronized objects service.
 * @param  {object}   firebaseApp     Firebase app hosting the app data.
 * @return {function}
 */function spfSchoolsFactory($firebaseObject,firebaseApp){var db=firebaseApp.database();var ref=db.ref('classMentors/schools');var syncObj=$firebaseObject(ref);var promise=syncObj.$loaded().then(function(){return syncObj;});/**
   * Resolve to the list of schools as an angularFire synchronized object.
   *
   * @return {Promise<object, Error>}
   */return function spfSchools(){return promise;};}function run$2($log,spfProfilesPath){if(!spfProfilesPath){throw new Error('spfProfilesPath constant is not set\n'+'(set it with e.g. '+'"myModule.constant(\`spfProfilesPath\`, \'classMentors/userProfiles\');"'+')');}$log.info('spfProfilesPath set to "'+spfProfilesPath+'".');}/**
 * singpath-core/services/firebase.js - helpers for firebase operation.
 *//**
 * Check the firebase app references are set.
 *
 * @param {object}                     $log            Angular logger service
 * @param {firebase.app.App}           firebaseApp     Main firebase app
 * @param {firebase.app.App}           authFirebaseApp Firebase app handling authentication.
 * @param {firebase.auth.AuthProvider} authProvider    Firebase app auth provider.
 */function run$3($log,firebaseApp,authFirebaseApp,authProvider){if(!firebaseApp||!authFirebaseApp){throw new Error('Firebase Apps (main and auth) are not set.');}if(!authProvider){throw new Error('Firebase auth provider is not set.');}$log.info('Auth Firebase app: '+authFirebaseApp.options.authDomain);$log.info('Main Firebase app: '+firebaseApp.options.authDomain);}/**
 * Remove invalid items from an object.
 *
 * Invalid items have a key with an invalid char:
 * '.', '#', '$', '/', '[' or ']'.
 *
 * @param  {any} obj value to cleanup.
 * @return {any}
 */function cleanObj(obj){if(obj===undefined){return null;}if(Array.isArray(obj)){return obj.map(function(x){return cleanObj(x);});}if(obj==null||!(obj instanceof Object)||typeof obj.getDate==='function'){return obj;}return Object.keys(obj).reduce(function(copy,key){for(var i=0;i<invalidChar.length;i++){if(key.indexOf(invalidChar[i])!==-1){return copy;}}copy[key]=cleanObj(obj[key]);return copy;},{});}/**
 * singpath-core/filters.js - spfShared filter factories.
 *//**
 * Create a filter checking a an object (including angularFire object) or an
 * arrayis empty.
 *
 * @return {function} [description]
 */function spfEmptyFilterFactory(){/**
   * Return true if the object is empty or falsy.
   *
   * @param  {any} obj value to test.
   * @return {boolean}
   */return function spfEmpty(obj){if(!obj){return true;}if(obj.hasOwnProperty('$value')){return obj.$value===null;}if(obj.length!==undefined){return obj.length===0;}return Object.keys(obj).length===0;};}/**
 * Create a filter checking for the length of an array or object.
 *
 * @return {function} [description]
 */function spfLengthFilterFactory(){/**
   * Return the number of elements (array element or object properties).
   *
   * Returns:
   * - 0 if the object is falsy;
   * - 0 if it's an angularfire object referencing null;
   * - the object element length if it's an array-like object;
   * - or the number of iterable properties otherwise.
   *
   * @param  {any}    obj Object to assess the length.
   * @return {number}
   */return function spfLength(obj){if(!obj){return 0;}if(obj.hasOwnProperty('$value')&&obj.$value===null){return 0;}if(obj.length!==undefined){return obj.length;}return Object.keys(obj).filter(function(k){return k&&k[0]!=='$';}).length;};}/**
 * Create filter extract the values of an object iterable properties.
 *
 * @return {function}
 */function spfToArrayFilterFactory(){/**
   * Return the object values.
   *
   * @param  {object} obj Object to convert.
   * @return {array}
   */return function spfToArrayFilter(obj){if(!(obj instanceof Object)){return obj;}return Object.keys(obj).reduce(function(arr,key){if(!key||key[0]==='$'){return arr;}var value=obj[key];if(!(obj instanceof Object)||value.$$hashkey){arr.push(value);return arr;}arr.push(Object.defineProperty(value,'$$hashKey',{__proto__:null,value:key}));return arr;},[]);};}/**
 * singpath-core/config.js
 *//**
 * Configure cfpLoadingBar options.
 *
 * spfShared.config(config.loadingBar);
 * spfShared.config(mdTheme);
 *
 * @param {object} cfpLoadingBarProvider loading bar service
 */function loadingBar(cfpLoadingBarProvider){cfpLoadingBarProvider.includeSpinner=false;}/**
 * Configure theme colours
 *
 * @param  {object} $mdThemingProvider ngMaterial theming provider.
 */function mdTheme($mdThemingProvider){$mdThemingProvider.theme('default').primaryPalette('indigo').accentPalette('amber').warnPalette('deep-orange');}function loaded(syncObjOrArray){return syncObjOrArray.$loaded().then(function(){return syncObjOrArray;});}/**
 * Singleton third party services list factory.
 *
 * @example
 * module.run(['clmServices', function() {
 *   clmServices.register('codeCombat');
 * }]);
 * module.component('someComponent', {
 *   template: '...',
 *   controller: [
 *     '$firebaseObject',
 *     'clmServices',
 *     'spfCurrentUser',
 *     function($firebaseObject. clmServices, spfCurrentUser) {
 *       this.data = $firebaseObject(clmServices.codeCombat.dataRef(spfCurrentUser.publicId));
 *   }]
 * });
 *
 * @param  {object}   $firebaseObject AngularFire sync object service.
 * @param  {object}   $log            Angular logging service.
 * @param  {function} $q              Angular Promise factory service.
 * @param  {function} $timeout        Angular timeout service.
 * @param  {object}   firebaseApp     Class Mentors main firebase App
 * @return {object}
 */function clmServicesFactory($firebaseObject,$log,$q,$timeout,firebaseApp){var availableBadgesPromise={};var db=firebaseApp.database();/**
   * Basic third party service handler
   */var GenericService=function(){/**
     * GenericService constructor.
     * @param  {string} name        Service name.
     * @param  {string} [id]        Service id
     * @param  {string} [settingId] Id of the setting enabling this service.
     */function GenericService(name,id,settingId){_classCallCheck(this,GenericService);/**
       * The service name.
       * @type {string}
       */this.name=name;/**
       * The Service id.
       * @type {string}
       */this.serviceId=id||camelCase(name);/**
       * The setting enabling this service.
       * @type {string}
       */this.settingId=settingId||camelCase('enable '+name);}/* deprecated methods */_createClass(GenericService,[{key:'badges',value:function badges(){$log.warn(new Error('deprecated'));return{};}},{key:'fetchProfile',value:function fetchProfile(){$log.warn(new Error('deprecated'));return $q.resolve({});}},{key:'fetchBadges',value:function fetchBadges(){$log.warn(new Error('deprecated'));return $q.resolve([]);}},{key:'updateProfile',value:function updateProfile(){$log.warn(new Error('deprecated'));return $q.resolve();}/**
     * Return a promise resolving to all avalaible badges at
     * that service.
     *
     * @todo replaced by `availableAchievement`.
     * @return {FirebaseObject} the list of badge for a service.
     */},{key:'availableBadges',value:function availableBadges(){if(availableBadgesPromise[this.serviceId]){return availableBadgesPromise[this.serviceId];}var ref=db.ref('classMentors/badges/'+this.serviceId);var badges=$firebaseObject(ref);availableBadgesPromise[this.serviceId]=loaded(badges);return availableBadgesPromise[this.serviceId];}/**
     * Return a firebase Reference to the user service data (for that service).
     *
     * @param  {string} publicId The user publicId
     * @return {firebase.database.Reference}
     */},{key:'dataRef',value:function dataRef(publicId){return db.ref('classMentors/userProfiles/'+publicId+'/services/'+this.serviceId);}/**
     * Return the user data for that service.
     *
     * It will return undefined if the details are for that service are
     * not set or if the user id is missing.
     *
     * @param {firebaseObj} profile Class Mentor profile of a user
     * @return {?{details: object, lastUpdate: number, lastUpdateRequest: number}}
     */},{key:'data',value:function data(profile){if(profile&&profile.services&&profile.services[this.serviceId]&&profile.services[this.serviceId].details&&profile.services[this.serviceId].details.id){return profile.services[this.serviceId];}return undefined;}/**
     * Return the user details for that service.
     *
     * It will return undefined if the details are for that service are
     * not set or if the user id is missing.
     *
     * @param {FirebaseObject} profile Class Mentor profile of a user.
     * @return {?{id: string, name: string, registeredBefore: number}}
     */},{key:'details',value:function details(profile){var data=this.data(profile);return data&&data.details;}/**
     * It should create the user details for that service and request an update.
     *
     * @param  {string}                     publicId User's publiId.
     * @param  {{id: string, name: string}} details  Holds the user id and user name for that service
     * @return {Promise<void,Error>}
     */},{key:'saveDetails',value:function saveDetails(publicId,details){var _this=this;if(!publicId){return $q.reject(new Error('No public id provided..'));}if(!details||!details.id){return $q.reject(new Error('The user details for '+this.serviceId+' should include an id.'));}var ref=db.ref('classMentors/userProfiles/'+publicId+'/services/'+this.serviceId+'/details');return ref.set(Object.assign({registeredBefore:{'.sv':'timestamp'}},cleanObj(details))).then(function(){return _this.requestUpdate(publicId).catch(function(err){return $log.error(err);});});}/**
     * Remove the service data.
     *
     * @param  {string}  publicId User's publiId.
     * @return {Promise<void,Error>}
     */},{key:'removeDetails',value:function removeDetails(publicId){if(!publicId){return $q.reject(new Error('No public id provided.'));}var ref=db.ref('classMentors/userProfiles/'+publicId+'/services/'+this.serviceId);return ref.remove();}/**
     * Request the profile for that service to be updated.
     *
     * @param  {string} publicId The user public id.
     * @return {Promise<void,Error>}
     */},{key:'requestUpdate',value:function requestUpdate(publicId){var _rootRef$update;if(!publicId){return $q.reject(new Error('No public id provided.'));}var rootRef=db.ref('/');var taskKey=db.ref('queue/tasks').push().key;var servicePath='classMentors/userProfiles/'+publicId+'/services/'+this.serviceId;return rootRef.update((_rootRef$update={},_defineProperty(_rootRef$update,'queue/tasks/'+taskKey,{id:publicId,service:this.serviceId}),_defineProperty(_rootRef$update,servicePath+'/lastUpdateRequest',{'.sv':'timestamp'}),_rootRef$update));}}]);return GenericService;}();/**
   * List of third party services providing user achievements.
   */var Services=function(){/**
     * Service list contructor.
     *
     * Iteration other the Services object should only return service id.
     */function Services(){_classCallCheck(this,Services);/**
       * List of enabled services.
       * @type {Array}
       */Object.defineProperty(this,'$enabledServices',{value:[],writable:true});/**
       * List of settings
       * @type {Object}
       */Object.defineProperty(this,'$settings',{value:{},writable:true});}/**
     * Register a new third party service.
     *
     * Adds the service as clmServices propertty (using the serviceId as the key).
     *
     * @param  {string} serviceName Service name.
     * @param  {string} [serviceId] Service id - default to the service name in camel case.
     * @param  {string} [settingId] Id of the setting enabling the service.
     * @return {GenericService}
     */_createClass(Services,[{key:'register',value:function register(serviceName,serviceId,settingId){var service=new GenericService(serviceName,serviceId,settingId);this[service.serviceId]=service;this.doEnableServices();return service;}/**
     * Handler for setting changes.
     *
     * Should update the list of enabled services.
     *
     * @param  {object} settings List of Class Mentors settings.
     * @private
     */},{key:'enableServices',value:function enableServices(settings){this.$settings=settings||{};this.doEnableServices();}/**
     * Update the list enabled services.
     *
     * @private
     */},{key:'doEnableServices',value:function doEnableServices(){var _this2=this;var ids=Object.keys(this);this.$enabledServices=ids.filter(function(serviceId){var settingId=_this2[serviceId].settingId;return _this2.$settings[settingId]&&_this2.$settings[settingId].value;});}/**
     * List available services.
     *
     * @return {object}
     */},{key:'available',value:function available(){var _this3=this;return this.$enabledServices.map(function(serviceId){return _this3[serviceId];});}/**
     * List available and setup services for a profile.
     *
     * @param  {object} profile AngularFire sync object representing a user object.
     * @return {object}
     */},{key:'registeredWith',value:function registeredWith(profile){return this.available().filter(function(service){var details=service.details(profile);return details!==undefined;});}/**
     * Refresh profile service details.
     *
     * Service refreshed too recently will be skipped.
     *
     * @param  {object} profile AngularFire sync object representing a user object.
     * @return {Promise<void,Error>}
     */},{key:'refresh',value:function refresh(profile){var requests=this.registeredWith(profile).map(function(service){return service.requestUpdate(profile.$id);});return $q.all(requests);}/**
     * Return a database reference to the user service data.
     *
     * @param  {string} publicId [description]
     * @return {firebase.database.Reference}
     */},{key:'ref',value:function ref(publicId){if(!publicId){throw new Error('Note public id provided.');}return db.ref('classMentors/userProfiles/'+publicId+'/services');}},{key:'userAchievementsRef',value:function userAchievementsRef(publicId){if(!publicId){throw new Error('Note public id provided.');}return db.ref('classMentors/userAchievements/'+publicId);}}]);return Services;}();var services=new Services();var settingsRef=db.ref('classMentors/settings');// watch for setting update enabling/disabling service.
settingsRef.on('value',function(snapshot){return services.enableServices(snapshot.val());},function(err){$log.error(err);services.enableServices();});return services;}/**
 * Service to interact with singpath firebase db
 *
 */function clmDataStoreFactory($window,$location,$q,$log,$http,$timeout,firebaseApp,$firebaseObject,$firebaseArray,spfSchools,routes,spfAuth,spfAuthData,spfCurrentUser,spfCrypto,clmServices,clmServicesUrl){var clmDataStore;var db=firebaseApp.database();var ProfileFirebaseObject=$firebaseObject.$extend({canView:function canView(obj){var kind=obj&&obj.$ref&&obj.$ref().parent.path.toString();// if (this.user && this.user.isAdmin) {
//   return true;
// }
if(obj.owner&&obj.owner.publicId&&this.$id===obj.owner.publicId){return true;}if(obj.assistants&&obj.assistants[this.$id]){// $log.info(obj.assistants );
return true;}if(kind==='/classMentors/events'&&obj.$id&&this.joinedEvents&&this.joinedEvents[obj.$id]){return true;}return false;}});ProfileFirebaseObject.create=function(publicId){var ref=db.ref('classMentors/userProfiles/'+publicId);return new ProfileFirebaseObject(ref);};var ParticipantsFirebaseArray=$firebaseArray.$extend({$schools:function $schools(){return this.$list.reduce(function(schools,participant){if(!participant.user||!participant.user.school||!participant.user.school.name){return schools;}schools[participant.user.school.name]=participant.user.school;return schools;},{});}});ParticipantsFirebaseArray.create=function(eventId){var ref=db.ref('classMentors/eventParticipants/'+eventId);return new ParticipantsFirebaseArray(ref);};clmDataStore={ProfileFirebaseObject:ProfileFirebaseObject,/**
     * Return a promise resolving to $firebaseObj pointing to
     * the current user profile for Classmemtors.
     *
     * If the user has a classmemtor profile and its user data are outdated.
     * they will get updated.
     *
     */currentUserProfile:function currentUserProfile(){var currentUserPromise=spfAuthData.user();var profilePromise=spfAuthData.user().then(function(currentUser){if(!currentUser.publicId){return undefined;}return clmDataStore.profile(currentUser.publicId);});return $q.all({currentUser:currentUserPromise,profile:profilePromise}).then(function(resp){var userData=resp.profile&&resp.profile.user;if(!userData){return resp.profile;}var userCountry=userData.country&&userData.country.code;var profileCountry=resp.currentUser.country&&resp.currentUser.country.code;if(userData.displayName===resp.currentUser.displayName&&userData.gravatar===resp.currentUser.gravatar&&userCountry===profileCountry&&userData.yearOfBirth===resp.currentUser.yearOfBirth){return resp.profile;}return clmDataStore.updateProfile(resp.currentUser);});},logging:{inputLog:function inputLog(actionObj){var ref=db.ref('classMentors/userActions');return ref.push(actionObj);}},profile:function profile(publicId){return $q.resolve(publicId).then(function(id){return loaded(clmDataStore.ProfileFirebaseObject.create(id));});},getProfileData:function getProfileData(publicId){var ref=db.ref('classMentors/userProfiles/'+publicId+'/user');return loaded($firebaseObject(ref));},updateProfile:function updateProfile(userData){var ref=db.ref('classMentors/userProfiles/'+userData.publicId+'/user');return ref.update({displayName:userData.displayName,gravatar:userData.gravatar,// cleanup optional values
country:cleanObj(userData.country),yearOfBirth:cleanObj(userData.yearOfBirth),school:cleanObj(userData.school)}).then(function(){return clmDataStore.profile(userData.publicId);});},getSchools:function getSchools(){return spfSchools();},initProfile:function initProfile(){return spfAuthData.user().then(function(currentUser){if(!currentUser||!currentUser.publicId){return $q.reject(new Error('The user has not set a user public id.'));}return clmDataStore.updateProfile(currentUser);});},cohorts:{errNoPublicId:new Error('You should have a public id to join a cohort'),create:function create(cohort){var rootRef=db.ref('classMentors/cohorts');var publicId=cohort.owner.publicId;var ref=rootRef.push(cohort);return ref.then(function(){return ref.once('value');}).then(function(snapshot){var val=snapshot.val();var profileRef=db.ref('classMentors/userProfiles/'+publicId+'/createdCohorts/'+snapshot.key);return profileRef.set({createdAt:val.createdAt,title:val.title,featured:val.featured||false});}).then(function(){return ref.key;});},updateCohort:function updateCohort(cohort){if(!cohort||!cohort.$id||!cohort.$save){return $q.reject(new Error('Cohort is not a firebase object'));}return cohort.$save().then(function(){var cohortId=cohort.$id;}).catch(function(err){$log.error(err);return err;});},get:function get(cohortId){var ref=db.ref('classMentors/cohorts/'+cohortId);return loaded($firebaseObject(ref));},listAllCohorts:function listAllCohorts(){var ref=db.ref('classMentors/cohorts');var query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));},listFeaturedCohorts:function listFeaturedCohorts(){var ref=db.ref('classMentors/cohorts');var query=ref.orderByChild('featured').equalTo(true).limitToLast(50);return loaded($firebaseArray(query));},listCreatedCohorts:function listCreatedCohorts(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/createdCohorts');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));}).catch(function(err){$log.error('Failed to list created cohorts: '+err);return[];});},addEvent:function addEvent(cohortId,eventId,eventNum){var ref=db.ref('classMentors/cohorts/'+cohortId+'/events/'+eventNum);return ref.set(eventId);},removeEvent:function removeEvent(cohortId,newEventArray){var ref=db.ref('classMentors/cohorts/'+cohortId+'/events');$log.error(new Error('TODO: fix race condition by removing event child instead of replacing the list.'));return ref.set(newEventArray);},addAnnouncement:function addAnnouncement(cohortId,madeBy,announcement,isArchived){var rootRef=db.ref('classMentors/cohortAnnouncements/'+cohortId);var ref=rootRef.push();var priority=announcement.priority;var promise;announcement.madeAt={'.sv':'timestamp'};announcement.madeBy=madeBy.publicId;promise=priority?ref.setWithPriority(announcement,priority):ref.set(announcement);return promise.then(function(){return ref;});},getAnnouncements:function getAnnouncements(cohortId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId);var query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));},featureAnnouncement:function featureAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/featured');return ref.set(true);},unfeatureAnnouncement:function unfeatureAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/featured');return ref.set(false);},showAnnouncement:function showAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/visible');return ref.set(true);},hideAnnouncement:function hideAnnouncement(cohortId,announcementId){var ref=db.ref('classMentors/cohortAnnouncements/'+cohortId+'/'+announcementId+'/visible');return ref.set(false);}},events:{addTaskWithAns:function addTaskWithAns(eventId,task,isOpen,answers){var rootRef=db.ref('classMentors/eventTasks/'+eventId);var ref=rootRef.push();var priority=task.priority;var promise;$log.info('Eventid is ? ',eventId);$log.info('task is : ',task);if(isOpen){task.openedAt={'.sv':'timestamp'};task.closedAt=null;}else{task.closedAt={'.sv':'timestamp'};task.openedAt=null;}promise=priority?ref.setWithPriority(task,priority):ref.set(task);return promise.then(function(){var taskId=ref.key;var answerRef=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);return answerRef.set(answers);});},getTaskAnswers:function getTaskAnswers(eventId,taskId){var ref=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));},updateTaskWithAns:function updateTaskWithAns(eventId,taskId,task,answers){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var ansRef=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);var priority=task.priority;return ref.setWithPriority(task,priority).then(function(){return ansRef.set(answers);});},addTaskAnswers:function addTaskAnswers(eventId,answers){var ref=db.ref('classMentors/eventAnswers/'+eventId);return ref.push(answers);},errNoPublicId:new Error('You should have a public id to join an event'),list:function list(){var ref=db.ref('classMentors/events');var query=ref.orderByChild('featured').equalTo(true).limitToLast(50);return loaded($firebaseArray(query));},listAll:function listAll(){var ref=db.ref('classMentors/events');var query=ref.orderByChild('createdAt');return loaded($firebaseObject(query));},listAllArr:function listAllArr(){var ref=db.ref('classMentors/events');var query=ref.orderByChild('createdAt');return loaded($firebaseArray(query));},listCreatedEvents:function listCreatedEvents(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/createdEvents');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));}).catch(function(err){$log.error('Failed to list created events: '+err);return[];});},listJoinedEvents:function listJoinedEvents(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/joinedEvents');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseArray(query));}).catch(function(err){$log.error('Failed to list joined events: '+err);return[];});},listJoinedEventsObj:function listJoinedEventsObj(){return spfAuthData.user().then(function(authData){var ref,query;if(!authData.publicId){return[];}ref=db.ref('classMentors/userProfiles/'+authData.publicId+'/joinedEvents');query=ref.orderByChild('createdAt').limitToLast(50);return loaded($firebaseObject(query));}).catch(function(err){$log.error('Failed to list joined events: '+err);return[];});},create:function create(event,password){var eventRef=db.ref('classMentors/events').push(event);var eventId=eventRef.key;var passwordRef=db.ref('classMentors/eventPasswords/'+eventId);var ownerId=event.owner.publicId;var profileRef=db.ref('classMentors/userProfiles/'+ownerId+'/createdEvents/'+eventId);return eventRef.then(function(){var hash=spfCrypto.password.newHash(password);var opts={hash:hash.value,options:hash.options};return passwordRef.set(opts);}).then(function(){return eventRef.once('value');}).then(function(snapshot){var val=snapshot.val();return profileRef.set({createdAt:val.createdAt,title:val.title,featured:val.featured||false});}).then(function(){return eventId;});},updateEvent:function updateEvent(event,password){var eventId=event&&event.$id;var ownerId=event&&event.owner&&event.owner.publicId;var passwordRef,profileRef;if(!eventId||!ownerId){return $q.reject(new Error('Event is not a firebase object'));}passwordRef=db.ref('classMentors/eventPasswords/'+eventId);profileRef=db.ref('classMentors/userProfiles/'+ownerId+'/createdEvents/'+eventId);return event.$save().then(function(){var hash,opts;if(!password){return null;}hash=spfCrypto.password.newHash(password);opts={hash:hash.value,options:hash.options};return passwordRef.set(opts);}).then(function(){return profileRef.update({title:event.title,featured:event.featured||false});}).catch(function(err){$log.error(err);return err;});},get:function get(eventId){var ref=db.ref('classMentors/events/'+eventId);return loaded($firebaseObject(ref));},getRanking:function getRanking(event,participants,rankedServices,sort){var defaultSort=function defaultSort(ranking){return ranking.sort(function(a,b){return a.$total>b.$total;});};var assistants=event.assistants||{};var asyncRanking=participants.filter(function(p){var isAssistant=assistants[p.$id]!==undefined;var isOwner=event.owner.publicId===p.$id;return!isAssistant&&!isOwner;}).map(function(p){var achievementsRef=clmServices.userAchievementsRef(p.$id);return achievementsRef.once('value').then(function(snapshot){var val=snapshot.val();var achievements=val&&val.services||{};var stats={$id:p.$id,$user:p.user,$total:0};rankedServices.forEach(function(service){var rawCount=achievements[service.id]&&achievements[service.id].totalAchievements;var count=parseInt(rawCount,10)||0;stats[service.id]=count;stats.$total+=count;});return stats;});});return $q.all(asyncRanking).then(sort||defaultSort);},getProgress:function getProgress(eventId){var ref=db.ref('classMentors/eventProgress/'+eventId);return loaded($firebaseObject(ref));},getTeam:function getTeam(eventId,taskId,teamId){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+teamId);return loaded($firebaseObject(ref)).then(function(result){console.log('result sissssss:',Object.keys(result));return Object.keys(result);});},getUserProgress:function getUserProgress(eventId,publicId){var ref=db.ref('classMentors/eventProgress/'+eventId+'/'+publicId);return loaded($firebaseObject(ref));},getSolutions:function getSolutions(eventId){var ref=db.ref('classMentors/eventSolutions/'+eventId);return loaded($firebaseObject(ref));},getEventTaskSolutions:function getEventTaskSolutions(eventId,taskId){var ref=db.ref('classMentors/eventSolutions/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));},getScores:function getScores(eventId){var ref=db.ref('classMentors/eventScores/'+eventId);return loaded($firebaseObject(ref));},getUserSolutions:function getUserSolutions(eventId,publicId){var ref=db.ref('classMentors/eventSolutions/'+eventId+'/'+publicId);return loaded($firebaseObject(ref));},deleteUserSolution:function deleteUserSolution(eventId,publicId,taskId){var ref=db.ref('classMentors/eventSolutions/'+eventId+'/'+publicId+'/'+taskId);return ref.remove();},getTasksAsObject:function getTasksAsObject(eventId){var ref=db.ref('classMentors/eventTasks/'+eventId);var query=ref.orderByPriority();return loaded($firebaseObject(query));},getTasks:function getTasks(eventId){var ref=db.ref('classMentors/eventTasks/'+eventId);var query=ref.orderByPriority();return loaded($firebaseArray(query));},getTask:function getTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));},addTask:function addTask(eventId,task,isOpen){var ref=db.ref('classMentors/eventTasks/'+eventId).push();var priority=task.priority;var promise;if(isOpen){task.openedAt={'.sv':'timestamp'};task.closedAt=null;}else{task.closedAt={'.sv':'timestamp'};task.openedAt=null;}$log.info('Adding task (id: "'+ref.key+'") to event id "'+eventId+'"');$log.info('Task: '+JSON.stringify(task));promise=priority?ref.setWithPriority(task,priority):ref.set(task);return promise.then(function(){return ref;});},setFeatured:function setFeatured(eventId,featured){var ref=db.ref('classMentors/events/'+eventId+'/featured');ref.set(featured);},getFeatured:function getFeatured(eventId){var ref=db.ref('classMentors/events/'+eventId+'/featured');var featured;ref.on('value',function(snapshot){featured=snapshot.val();});return featured;},updateTask:function updateTask(eventId,taskId,task){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var priority=task.priority;if(priority){return ref.setWithPriority(task,priority);}else{return ref.set(task);}},joinTeam:function joinTeam(eventId,taskId,teamId,participantId,user){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+teamId);return ref.transaction(function(team){if(team.currentSize+1<=team.maxSize&&team.currentSize>=0){team[participantId]=user;team[participantId].joinedAt={'.sv':'timestamp'};return team;}});},setCurrentSize:function setCurrentSize(eventId,taskId,teamId,participantId,user){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+teamId);var currentSize=0;return ref.transaction(function(team){if(team!=null){for(var member in team){if(member!='maxSize'&&member!='currentSize'&&member!='teamLeader'){currentSize++;}}if(currentSize<=team.maxSize){team.currentSize=currentSize;}else{team.currentSize=team.maxSize;}return team;}});},removeUser:function removeUser(eventId,taskId,currentTeamId,participantId,nextSelectedTeamId){var participantToRemove=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+currentTeamId+'/'+participantId);var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+nextSelectedTeamId);ref.transaction(function(team){if(team.currentSize+1<=team.maxSize&&team.currentSize>=0){participantToRemove.remove();}});},leaveTeam:function leaveTeam(eventId,taskId,currentTeamId,participantId){var participantToRemove=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId+'/'+currentTeamId+'/'+participantId);participantToRemove.remove();},getEventTeams:function getEventTeams(eventId){var ref=db.ref('classMentors/eventTeams/'+eventId);return loaded($firebaseArray(ref));},getEventTeamsObj:function getEventTeamsObj(eventId){var ref=db.ref('classMentors/eventTeams/'+eventId);return loaded($firebaseObject(ref));},getEventTaskTeams:function getEventTaskTeams(eventId,taskId){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));},getEventTaskTeamsArr:function getEventTaskTeamsArr(eventId,taskId){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId);return loaded($firebaseArray(ref));},openTask:function openTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var abort;return ref.transaction(function(task){if(!task.closedAt){return abort;}task.history=task.history||{};task.history[task.closedAt]='closed';task.openedAt={'.sv':'timestamp'};task.closedAt=null;return task;});},closeTask:function closeTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var abort;return ref.transaction(function(task){if(!task.openedAt){return abort;}task.history=task.history||{};task.history[task.openedAt]='opened';task.closedAt={'.sv':'timestamp'};task.openedAt=null;return task;});},showTask:function showTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId+'/hidden');return ref.set(false);},hideTask:function hideTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId+'/hidden');return ref.set(true);},archiveTask:function archiveTask(eventId,taskId){var ref=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId+'/archived');return ref.set(true);},ParticipantsFirebaseArray:ParticipantsFirebaseArray,participants:function participants(eventId){return loaded(clmDataStore.events.ParticipantsFirebaseArray.create(eventId));},join:function join(event,pw){var refs=void 0;if(!event||!event.$id){return $q.reject('Event was not provided');}var eventId=event.$id;return spfCurrentUser.$loaded().then(function(){var publicId=spfCurrentUser.publicId;var uid=spfCurrentUser.uid;if(!publicId){return $q.reject(clmDataStore.events.errNoPublicId);}refs={hashOptions:db.ref('classMentors/eventPasswords/'+eventId+'/options'),application:db.ref('classMentors/eventApplications/'+eventId+'/'+uid),participation:db.ref('classMentors/eventParticipants/'+eventId+'/'+publicId),joinedEvent:db.ref('classMentors/userProfiles/'+publicId+'/joinedEvents/'+eventId),services:db.ref('classMentors/userProfiles/'+publicId+'/services')};return refs;}).then(function(){return refs.hashOptions.once('value');}).then(function(snapshot){var options=snapshot.val();var hash=spfCrypto.password.fromSalt(pw,options.salt,options);return refs.application.set(hash);}).then(function(){return refs.services.once('value');}).then(function(snapshot){var services=snapshot.val()||{};var user={displayName:spfCurrentUser.profile.displayName,gravatar:spfCurrentUser.profile.gravatar,school:cleanObj(spfCurrentUser.profile.school)||null};var partialServices={};clmServices.available().forEach(function(service){var details=service.details({services:services});if(!details){return;}// we only copy the service id
partialServices[service.serviceId]={details:{id:details.id}};});return refs.participation.set({user:user,services:partialServices,joinedAt:{'.sv':'timestamp'}});}).then(function(){return refs.joinedEvent.set({createdAt:event.createdAt,featured:event.featured||false,owner:event.owner,title:event.title});});},leave:function leave(eventId){return spfAuthData.user().then(function(authData){return clmDataStore.events.removeParticpants(eventId,authData.publicId);});},removeParticpants:function removeParticpants(eventId,publicId){var profileRef=db.ref('classMentors/userProfiles/'+publicId+'/joinedEvents/'+eventId);var particpantRef=db.ref('classMentors/eventParticipants/'+eventId+'/'+publicId);return profileRef.remove().then(function(){return particpantRef.remove();}).catch(function(err){$log.error(err);return err;});},// to be true the task only need registration.
_hasRegistered:function _hasRegistered(task,clmProfile,spfProfile){var serviceId=task.serviceId;if(!task.serviceId||task.badge||task.singPathProblem){return false;}if(serviceId==='singPath'){return Boolean(spfProfile);}return clmProfile.services&&clmProfile.services[serviceId]&&clmProfile.services[serviceId].details&&clmProfile.services[serviceId].details.id;},_hasAchievement:function _hasAchievement(task,achievements){if(!task.badge||!task.badge.id){return false;}var serviceId=task.serviceId;return task.badge&&task.badge.id&&achievements.services&&achievements.services[serviceId]&&achievements.services[serviceId].achievements&&achievements.services[serviceId].achievements[task.badge.id];},_hasSolvedSingpathProblem:function _hasSolvedSingpathProblem(task,profile){if(!task.singPathProblem||!task.singPathProblem.path||!task.singPathProblem.path.id||!task.singPathProblem.level||!task.singPathProblem.level.id||!task.singPathProblem.problem||!task.singPathProblem.problem.id){return false;}var queueId='default';return clmDataStore.singPath.hasSolved(profile,task.singPathProblem.path.id,task.singPathProblem.level.id,task.singPathProblem.problem.id,queueId);},_isSolutionLinkValid:function _isSolutionLinkValid(task,solutions){return task.linkPattern&&solutions&&solutions[task.$id]&&solutions[task.$id].match&&solutions[task.$id].match(task.linkPattern);},_isResponseValid:function _isResponseValid(task,solutions){return task.textResponse&&solutions&&solutions[task.$id]||task.type=='reflectionQuestion'&&solutions&&solutions[task.$id]||task.type=='mentorAssignment'&&solutions&&solutions[task.$id];},_hasDoneSurvey:function _hasDoneSurvey(task,solutions){return task.survey&&solutions&&solutions[task.$id];},_hasDoneMcq:function _hasDoneMcq(task,solutions){return task.mcqQuestions&&solutions&&solutions[task.$id];},_hasFormTeam:function _hasFormTeam(task,solutions){return task.formationPattern&&solutions&&solutions[task.$id];},_getProgress:function _getProgress(tasks,data){return tasks.reduce(function(progress,task){// We never recheck archived task completeness
if(task.archived){if(data.progress&&data.progress[task.$id]){progress[task.$id]=data.progress[task.$id];}return progress;}// We skip unsolved closed tasks, but recheck solved ones in case of
// requirements changed.
if(task.closedAt&&!(data.progress&&data.progress[task.$id]&&data.progress[task.$id].completed)){return progress;}var solved=clmDataStore.events._isSolutionLinkValid(task,data.solutions)||clmDataStore.events._isResponseValid(task,data.solutions)||clmDataStore.events._hasRegistered(task,data.classMentors,data.singPath)||clmDataStore.events._hasAchievement(task,data.userAchievements)||clmDataStore.events._hasSolvedSingpathProblem(task,data.singPath)||clmDataStore.events._hasDoneSurvey(task,data.solutions)||clmDataStore.events._hasDoneMcq(task,data.solutions)||clmDataStore.events._hasFormTeam(task,data.solutions);if(solved){progress[task.$id]={completed:true};}else{progress[task.$id]={completed:false};}return progress;},{});},monitorEvent:function monitorEvent(event,tasks,participants,solutions,progress){var tid;var delay=300;//TODO: Extending delay due to continual error issue.
var unWatchSolution=solutions.$watch(debouncedUpdate);var unWatchParticipants=participants.$watch(debouncedUpdate);function update(){return participants.map(function(participant){return clmDataStore.events.updateProgress(event,tasks,solutions,participant.$id,progress[participant.$id]);});}function debouncedUpdate(){if(tid){$timeout.cancel(tid);}tid=$timeout(update,delay,false);}debouncedUpdate();return{update:debouncedUpdate,unwatch:function stopMonitorEvent(){unWatchParticipants();unWatchSolution();}};},updateProgress:function updateProgress(event,tasks,solutions,publicId,userProgress){if(!publicId){return $q.reject('User public id is missing missing.');}if(!solutions||!solutions.$id||solutions.$id!==event.$id){return $q.reject('User solutions are missing');}var cmProfilePromise=clmDataStore.profile(publicId);var userAchievementsRef=clmDataStore.services.userAchievementsRef(publicId);// 1. load profile, userAchievements and current progress
return $q.all({singPath:clmDataStore.singPath.profile(publicId),classMentors:cmProfilePromise,userAchievements:userAchievementsRef.once('value'),solutions:solutions[publicId]||{},progress:userProgress}).then(function(data){var participationRef=db.ref('classMentors/eventParticipants/'+event.$id+'/'+data.classMentors.$id);var user={displayName:data.classMentors.user.displayName,gravatar:data.classMentors.user.gravatar,school:data.classMentors.user.school||null};var services={};clmServices.available().forEach(function(service){var details=service.details(data.classMentors);if(!details){return;}services[service.serviceId]={details:{id:details.id}};});// 2. Update event data
return $q.all([// 3. check completness and update progress if needed.
$q.resolve(clmDataStore.events._getProgress(tasks,data)).then(function(progress){var ref=db.ref('classMentors/eventProgress/'+event.$id+'/'+data.classMentors.$id);var updated=Object.keys(progress).some(function(taskId){var wasCompleted=data.progress&&data.progress[taskId]&&data.progress[taskId].completed;var isCompleted=progress&&progress[taskId]&&progress[taskId].completed;return isCompleted!==wasCompleted;});if(updated){return ref.set(progress);}return null;}),// 4. update participants data
participationRef.update({user:user,services:services})]);}).catch(function(err){$log.error('Failed to update progress of '+publicId+': '+err.toString());});},/**
       * Only update the the current user profile and his/her event badge/problem solution.
       *
       * Only admin and event onwer can save the progress and ranking.
       *
       */updateCurrentUserProfile:function updateCurrentUserProfile(event,tasks,userSolutions,profile){if(!event||!event.$id||!userSolutions||!userSolutions.$id||!profile||!profile.$id){return $q.reject(new Error('Event, userSolutions or profile are not valid firebase object'));}function solvedTask(task,solutions){return Boolean(solutions[task.$id]);}var userAchievementsRef=clmDataStore.services.userAchievementsRef(profile.$id);return $q.all({userAchievements:userAchievementsRef.once('value'),singPath:clmDataStore.singPath.profile(profile.$id)}).then(function(data){var updatedTasks=tasks.filter(function(task){if(solvedTask(task,userSolutions)){return false;}return clmDataStore.events._hasRegistered(task,profile,data.singPath)||clmDataStore.events._hasSolvedSingpathProblem(task,data.singPath)||clmDataStore.events._hasAchievement(task,data.userAchievements);}).map(function(task){userSolutions[task.$id]=true;return task;});if(updatedTasks.length>0){userSolutions.$save();}return updatedTasks;}).catch(function(err){$log.error('Failed to update profile and soltuions of '+profile.$id+': '+err.toString());});},// newly added codes by ky
saveSurveyResponse:function saveSurveyResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyTask){var ref;if(!surveyResp){return $q.reject(new Error('No responses provided'));}if(!questionNumber){return $q.reject(new Error('Invalid survey question'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!eventId){return $q.reject(new Error('No event id provided'));}if(!userId){return $q.reject(new Error('No user id provided'));}ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyTask+'/'+userId+'/'+questionNumber);return ref.set(surveyResp);},saveSurveyResponseOnSubmit:function saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,motiResp){var ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyType+'/'+userId);return ref.set(motiResp);},saveSurveyEduDisResponse:function saveSurveyEduDisResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyTask,qnTitle){var ref;if(!surveyResp){return $q.reject(new Error('No responses provided'));}if(!questionNumber){return $q.reject(new Error('Invalid survey question'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!eventId){return $q.reject(new Error('No event id provided'));}if(!userId){return $q.reject(new Error('No user id provided'));}if(!surveyTask){return $q.reject(new Error('No survey task provided'));}if(!qnTitle){return $q.reject(new Error('No question title provided'));}$log.info('qntitle isss',qnTitle);ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyTask+'/'+userId+'/'+qnTitle+'/'+questionNumber);return ref.set(surveyResp);},saveSurveyEduDisMultiResponse:function saveSurveyEduDisMultiResponse(responses,questionNumber,taskId,eventId,userId,surveyTask,qnTitle){var ref;if(!responses){return $q.reject(new Error('No responses provided'));}if(!questionNumber){return $q.reject(new Error('Invalid survey question'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!eventId){return $q.reject(new Error('No event id provided'));}if(!userId){return $q.reject(new Error('No user id provided'));}if(!surveyTask){return $q.reject(new Error('No survey task provided'));}if(!qnTitle){return $q.reject(new Error('No question title provided'));}ref=db.ref('classMentors/surveyResponse/'+eventId+'/'+taskId+'/'+surveyTask+'/'+userId+'/'+qnTitle+'/'+questionNumber);return ref.set(responses);},submitSolution:function submitSolution(eventId,taskId,publicId,link){var ref;if(!eventId){return $q.reject(new Error('No event id provided'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!publicId){return $q.reject(new Error('No public id provided'));}ref=db.ref('classMentors/eventSolutions/'+eventId+'/'+publicId+'/'+taskId);return ref.set(link);},setProgress:function setProgress(eventId,taskId,publicId,progress){var ref=db.ref('classMentors/eventProgress/'+eventId+'/'+publicId+'/'+taskId);return ref.set(progress[publicId][taskId]);},saveScore:function saveScore(eventId,publicId,taskId,score){var ref;if(!eventId){return $q.reject(new Error('No event id provided'));}if(!taskId){return $q.reject(new Error('No task id provided'));}if(!publicId){return $q.reject(new Error('No public id provided'));}ref=db.ref('classMentors/eventScores/'+eventId+'/'+publicId+'/'+taskId);return ref.set(score);},addAssistant:function addAssistant(eventId,assistantId,assistant){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId);return ref.set(assistant);},getAssistants:function getAssistants(eventId){var ref=db.ref('classMentors/events/'+eventId+'/assistants');return loaded($firebaseArray(ref));},getAsstObj:function getAsstObj(eventId){var ref=db.ref('classMentors/events/'+eventId+'/assistants');return loaded($firebaseObject(ref));},enableAssistantEditing:function enableAssistantEditing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canEdit');return ref.set(true);},disableAssistantEditing:function disableAssistantEditing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canEdit');return ref.set(false);},enableAssistantReviewing:function enableAssistantReviewing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canReview');return ref.set(true);},disableAssistantReviewing:function disableAssistantReviewing(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId+'/canReview');return ref.set(false);},removeAssistant:function removeAssistant(eventId,assistantId){var ref=db.ref('classMentors/events/'+eventId+'/assistants/'+assistantId);return ref.remove();},getAssistingEvents:function getAssistingEvents(publicId){var ref=db.ref('classMentors/events');var query=ref.orderByChild('assistants/'+publicId).startAt(true);return loaded($firebaseArray(query));},getForumStatus:function getForumStatus(eventId){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/closedForum');return loaded($firebaseObject(ref));},questions:{/**
         * Return query to all event questions sorted by upvote.
         *
         * @param  {string}   eventId The event id to query question for.
         * @return {firebase.database.Reference}
         */allRef:function allRef(eventId){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/questions');var query=ref.orderByChild('createdAt');return loaded($firebaseArray(query));},/**
         * Create a question on behalf of the current user.
         *
         * @param  {string}   eventId The event id to submit the question for.
         * @param  {{title: string, body: string}} question Question details
         * @return {Promise<firebase.database.Reference,Error>}
         */create:function create(question,eventId){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/questions');return ref.push(question);},getQuestion:function getQuestion(eventId,questionId){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/questions/'+questionId);return loaded($firebaseObject(ref));},answers:{/**
           * Return query to all the answer of a question sorted by upvote.
           *
           * @param  {string}   eventId    The event id of the question.
           * @param  {string}   questionId The question id to query comments for.
           * @return {firebase.database.Reference}
           */allRef:function allRef(eventId,questionId){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/answers/'+questionId);var query=ref.orderByChild('createdAt');return loaded($firebaseArray(query));},/**
           * Create an answer on behave of the current user.
           *
           * @param  {string} eventId    The event id to submit the answer for.
           * @param  {string} questionId The question id to submit the answer for.
           * @param  {string} body       The answer body.
           * @return {Promise<firebase.database.Reference,Error>}
           */postAnswer:function postAnswer(eventId,questionId,answer){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/answers/'+questionId);return ref.push(answer);},/**
           * Mark an answer as the accepted answer to the question.
           *
           * @param  {string} eventId    The event id to mark the answer for.
           * @param  {string} questionId The question id to mark the answer for.
           * @param  {string} answerId   The answer id to mark as accepted.
           * @return {Promise<void,Error>}
           */accept:function accept(){},/**
           * Upvote a comment.
           *
           * @param  {string}   eventId    The event id of the question.
           * @param  {string}   questionId The question id of the answer.
           * @param  {string}   answerId   The answer id to upvote.
           * @return {Promise<void,Error>}
           */upVote:function upVote(){},/**
           * Add a comment to a question.
           *
           * @param  {string} eventId    The event id to add comment for.
           * @param  {string} questionId The question id to add comment for.
           * @param  {string} answerId   The answer id to add comment for.
           * @param  {string} body       The comment body.
           * @return {Promise<void,Error>}
           */comment:function comment(){}}},getTeams:function getTeams(eventId,taskId){var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId);return loaded($firebaseArray(ref));},getMCQAnswers:function getMCQAnswers(eventId,taskId){var ref=db.ref('classMentors/eventAnswers/'+eventId+'/'+taskId);return loaded($firebaseObject(ref));}},services:clmServices,settings:{/**
       * Return Classmentors settings as a firebase synchronized array.
       *
       * Note that the array might not be loaded yet.
       *
       * @return {array}
       */get:function get(){return $firebaseArray(db.ref('classMentors/settings'));},/**
       * Return Classmentors settings as a firebase synchronized array.
       *
       * Note that the array might not be loaded yet.
       *
       * @return {object}
       */getObj:function getObj(){return $firebaseObject(db.ref('classMentors/settings'));}},singPath:{/**
       * Return user's singpath profile
       *
       */profile:function profile(publicId){return $q.resolve(publicId).then(function(id){var ref=db.ref('singpath/userProfiles/'+id);return loaded($firebaseObject(ref));});},queuedSolutions:function queuedSolutions(publicId){return $q.resolve(publicId).then(function(id){var ref=db.ref('singpath/userProfiles/'+id+'/queuedSolutions');return loaded($firebaseObject(ref));});},hasSolved:function hasSolved(profile,pathId,levelId,problemId,queueId){return profile&&profile.queuedSolutions&&profile.queuedSolutions[pathId]&&profile.queuedSolutions[pathId][levelId]&&profile.queuedSolutions[pathId][levelId][problemId]&&profile.queuedSolutions[pathId][levelId][problemId][queueId]&&profile.queuedSolutions[pathId][levelId][problemId][queueId].solved;},countSolvedSolution:function countSolvedSolution(profile,queueId){var solutions=profile&&profile.queuedSolutions;if(!solutions){return 0;}queueId=queueId||'default';return Object.keys(solutions).map(function(pathId){return Object.keys(solutions[pathId]).map(function(levelId){return Object.keys(solutions[pathId][levelId]).filter(function(problemId){return solutions[pathId][levelId][problemId][queueId]&&solutions[pathId][levelId][problemId][queueId].solved===true;}).length;}).reduce(function(sum,count){return sum+count;},0);}).reduce(function(sum,count){return sum+count;},0);},countSolvedSolutionPerLanguage:function countSolvedSolutionPerLanguage(profile,queueId){var paths=profile.queuedSolutions||{};queueId=queueId||'default';return Object.keys(paths).reduce(function(result,pathKey){var levels=paths[pathKey]||{};Object.keys(levels).forEach(function(levelKey){var problems=levels[levelKey]||{};Object.keys(problems).forEach(function(problemKey){var language=problems[problemKey][queueId].language;if(problems[problemKey][queueId]&&problems[problemKey][queueId].solved){result[language]=(result[language]||0)+1;}});});return result;},{});},/**
       * Return a map of available paths at SingPath
       *
       */paths:function paths(){var ref=db.ref('singpath/paths');return ref.once('value').then(function(snapshot){var paths=snapshot.val();return Object.keys(paths).reduce(function(all,id){if(!id||id[0]==='$'){return all;}all[id]={id:id,title:paths[id].title,url:clmServicesUrl.singPath+'/#paths/'+id+'/levels'};return all;},{});});},/**
       * Return a map of available levels at SingPath for a specific path
       *
       */levels:function levels(pathId){var ref=db.ref('singpath/levels/'+pathId);return ref.once('value').then(function(snapshot){var levels=snapshot.val();return Object.keys(levels).reduce(function(all,id){if(!id||id[0]==='$'){return all;}all[id]={id:id,title:levels[id].title,url:clmServicesUrl.singPath+'/#paths/'+pathId+'/levels/'+id+'/problems'};return all;},{});});},/**
       * Return a map of available problems at SingPath for a specific level
       *
       */problems:function problems(pathId,levelId){var ref=db.ref('singpath/problems/'+pathId+'/'+levelId);return ref.once('value').then(function(snapshot){var problems=snapshot.val();return Object.keys(problems).reduce(function(all,id){if(!id||id[0]==='$'){return all;}all[id]={id:id,title:problems[id].title,url:clmServicesUrl.singPath+'/#paths/'+pathId+'/levels/'+levelId+'/problems/'+id+'/play'};return all;},{});});},/**
       * Return a promise resolving to all problems as as simple object
       * (Not a firebase object).
       *
       * @return {Promise}
       */allProblems:function allProblems(){var ref=db.ref('singpath/problems');return ref.once('value').then(function(snapshot){return snapshot.val();});},countProblems:function countProblems(paths){return Object.keys(paths||{}).reduce(function(result,pathKey){var levels=paths[pathKey]||{};Object.keys(levels).forEach(function(levelKey){var problems=levels[levelKey]||{};Object.keys(problems).forEach(function(problemKey){var language=problems[problemKey].language;result[language]=(result[language]||0)+1;});});return result;},{});}}};// TODO: rename.
clmDataStore.badges={all:function all(){return $q.all(Object.keys(clmDataStore.services).reduce(function(all,serviceId){all[serviceId]=clmDataStore.services[serviceId].availableBadges();return all;},{}));}};return clmDataStore;}/**
 * classmentors/filters - shared filter factories.
 */function cmTruncateFilterFactory(){return function cmTruncate(s,limit){if(!s||!s.length||!limit){return'';}if(s.length<=limit){return s;}return s.slice(0,limit)+'...';};}function countConditionallyFilterFactory(){return function countConditionally(objArr,inputs){var field=inputs[0];var bool=inputs[1];var count=0;for(var index in objArr){var obj=objArr[index];if(obj[field]&&obj.hasOwnProperty('createdAt')){if(bool){count++;}}if(!obj[field]&&obj.hasOwnProperty('createdAt')){if(!bool){count++;}}}return''+count;};}function cmTruncateFilterBooleanFactory(){return function cmTruncateBoolean(s,limit){if(!s||!s.length||!limit){return{content:'',truncated:false};}if(s.length<=limit){return{content:s,truncated:false};}return{content:s.slice(0,limit)+'...',truncated:true};};}function showSchoolFilterFactory(){return function showSchool(s){var obj=JSON.parse(s);return obj.school.name+'...';};}function showTeamMembersFilterFactory(){return function(team){var output=Object.keys(team);function filterUserID(id){if(id!="currentSize"&&id!="maxSize"&&id!="$id"&&id!="$priority"&&id!="$$hashKey"){return id;}}return output.filter(filterUserID);};}function countObjKeysFactory(){return function countObjKeys(obj){if(obj){return''+Object.keys(obj).length;}return 0;};}function displayMentorshipFactory(){return function displayMentorship(s){if(s){var mentObj=angular.fromJson(s);return mentObj.mentor.displayName+' mentoring '+mentObj.mentee.displayName;}else{return'';}};}// export function reverseArray (){
//   return function(items) {
//     return items.slice().reverse();
//   };
// };
/**
 * classmentors/directives.js - shared directive factories / components options.
 *//**
 * Validate that an input value contains a pattern.
 *
 * TODO: replace with ngPattern?
 */function cmContainsFactory(){return{restrict:'A',scope:false,require:'ngModel',link:function cmContainsPostLink(scope,e,attr,model){var pattern=scope.$eval(attr.cmContains);scope.$watch(attr.cmContains,function(value){pattern=value;});model.$validators.cmContains=function(modelValue,viewValue){var patt=new RegExp(pattern);if(modelValue.indexOf("http:")>-1&&viewValue.indexOf("http:")>-1){return true;}else{return patt.test(modelValue)&&patt.test(viewValue);}//return viewValue && viewValue.indexOf(pattern) !== -1;
};}};}//https://dl.dropboxusercontent.com/u/4972572/ace_of_coders_2016_stats.json';
/**
 * Route resolver helper.
 *
 * This is not a service; this is not generating a singleton. If used in a route
 * configuration "resolve" map, the function will be run on each resolution of
 * that route.
 *
 * @param  {Object}  $http       $http service.
 * @param  {string}  aceStatsUrl URL to fetch stats from
 * @return {Promise}
 */function getStats($http,aceStatsUrl){return $http.get(aceStatsUrl).then(function(response){return response.data;});}/**
 * Config route for ace of coders views.
 *
 * @param  {object} $routeProvider ngRoute $route service provider.
 * @param  {object} routes         classmentors route map.
 */function configRoute($routeProvider,routes){$routeProvider.when(routes.aceOfCoders,{template:'<ace stats="$resolve.stats"></ace>',resolve:{stats:getStats,//navBar: () => ({title: 'Ace of Coders'})
navBar:function navBar(){return{title:'2017 National Coding Championships'};}}}).otherwise(routes.home);}function editMcqController(initialData,spfNavBarService,challengeService,$filter,$mdDialog,urlFor,$location){//todo: sheryl comment to add corner cases checking; only allow edit when 1. there are no submission for the challenge 2. the challenge is closed (avoid race conditions)
var self=this;self.task=initialData.data.task;self.isMcqValid=true;self.isTextFilled=true;var questions=angular.fromJson(self.task.mcqQuestions);var savedAnswers=angular.fromJson(initialData.savedAnswers.$value);self.questions=builtMCQ(questions,savedAnswers);spfNavBarService.update(initialData.data.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:initialData.data.event.title,url:'#'+urlFor('oneEvent',{eventId:initialData.data.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:initialData.data.event.$id})}]);function builtMCQ(questions,savedAnswers){for(var i=0;i<questions.length;i++){questions[i].answers=savedAnswers[i];}return questions;}self.checkMCQValid=function(text){console.log("text",text);if(text.length==0||text==undefined){self.isTextFilled=false;}else{self.isTextFilled=true;}};self.isOptionValid=true;self.checkOptionValid=function(text){if(text.length==0||text==undefined){self.isOptionValid=false;}else{self.isOptionValid=true;}};// console.log("var questions are", questions);
// console.log("self q", self.questions);
// self.isMcqValid = checkMCQValid();
// Save mcq question to database.
self.save=function(questions){var setAnswers=[];for(var i=0;i<questions.length;i++){var answers=questions[i].answers;setAnswers.push(answers);delete questions[i].answers;}// Check does questions contain answers?
// console.log(questions);
// Check answer list
// console.log(setAnswers);
// Change questions into JSON text
var answersJsonText=angular.toJson(questions);// console.log(answersJsonText);
// Save function defined in challenges.js
// Parameters: event, taskid, task, taskType, isOpen
var event=initialData.data.event;var task=self.task;var taskId=task.$id;var taskType=initialData.data.taskType;var isOpen=initialData.data.isOpen;task.mcqQuestions=answersJsonText;task.answers=angular.toJson(setAnswers);// console.log(task);
challengeService.update(event,taskId,task,taskType,isOpen);};// Add question when add question button is clicked
self.addQuestion=function(){var question={text:"",answers:[],options:[{text:""}]};// Push new question object into questions list
self.questions.push(question);checkMCQValid();};function checkMCQValid(){for(var i=0;i<self.questions.length;i++){if(self.questions[i].answers.length==0){self.isMcqValid=false;return;}}self.isMcqValid=true;}self.removeQuestion=function(ev,itemIndex){var confirm=$mdDialog.confirm().title('Would you like to delete this question?').textContent('This question and its option(s) will be deleted. Do you wish to proceed?').ariaLabel('Question deletion').targetEvent(ev).ok('Delete').cancel('Do not delete');$mdDialog.show(confirm).then(function(){if(itemIndex>-1){var removed=self.questions.splice(itemIndex,1);console.log('Removed : ',removed);console.log(self.questions);checkMCQValid();}});};// Functionality for toggleOption between single answer and multi ans functionality
// Needs further review though..
// Is it better to set the answers as default multiple and the users will just set 1..n answers?
self.toggleOption=function(question,itemIndex){console.log('Index being deleted...',itemIndex);var idx=question.answers.indexOf(itemIndex);if(idx>-1){var removed=question.answers.splice(idx,1);console.log(removed);}else{question.answers.push(itemIndex);}console.log(question.answers);checkMCQValid();};// Add new option to question
self.addOption=function(question){// Get options
question.options.push({text:""});checkMCQValid();};// Delete options
self.removeOption=function(question,itemIndex){question.options.splice(itemIndex,1);var idxOfAns=question.answers.indexOf(itemIndex);if(idxOfAns>-1){var removedAns=question.answers.splice(idxOfAns,1);console.log('Removed an answer: ',removedAns);}for(var i=0;i<question.answers.length;i++){var ans=question.answers[i];if(ans>itemIndex){question.answers[i]=ans-1;}}console.log(question.options);checkMCQValid();};//back button controls here
self.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not saved your changes').textContent('All of your changes will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Discard my changes').cancel('Continue editing');$mdDialog.show(confirm).then(function(){$location.path(urlFor('editEvent',{eventId:initialData.data.event.$id}));});};}function startMcqController(initialData,challengeService,clmDataStore,$location,$mdDialog,urlFor,spfAlert,$scope,spfNavBarService){var self=this;var mcqInvalid=true;$scope.$on("$routeChangeStart",function(event,next,current){if(mcqInvalid){if(!confirm("You have not complete your multiple choice questions. Are you sure you want to continue? All data will be lost!")){event.preventDefault();}}});var data=initialData;var eventId=data.eventId;var taskId=data.taskId;var participant=data.currentUser;var userId=data.currentUser.publicId;var correctAnswers=angular.fromJson(data.correctAnswers.$value);// console.log('correctans:',correctAnswers);
self.task=data.task;var quesFromJson=angular.fromJson(self.task.mcqQuestions);self.questions=quesFromJson;self.multipleAns=initMultipleAns(correctAnswers);self.isMcqValid=false;// what is dah output?
//console.log(self.multipleAns);
//update navbar herrre. 5566
// console.log("all the data is ",data);
spfNavBarService.update(data.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:data.eventTitle,// modify initialdata
url:'#'+urlFor('oneEvent',{eventId:eventId})}]);function initMultipleAns(correctAnswers){var multipleAnsList=[];for(var i=0;i<correctAnswers.length;i++){if(correctAnswers[i].length>1){multipleAnsList.push(true);self.questions[i].answers=[];}else{multipleAnsList.push(false);}}return multipleAnsList;}self.toggle=function(list,item){console.log(list);var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}};function arraysEqual(arr1,arr2){if(arr1.length!==arr2.length)return 0;for(var i=arr1.length;i--;){if(arr1[i]!==arr2[i])return 0;}return 1;}function markQuestions(submittedAnswers){console.log('Correct Answers...',correctAnswers);console.log('Submitted Answers...',submittedAnswers);var score=0;for(var i=0;i<submittedAnswers.length;i++){score+=arraysEqual(submittedAnswers[i],correctAnswers[i]);}return score;}self.submit=function(){mcqInvalid=false;var submission={};var userAnswers=[];for(var i=0;i<self.questions.length;i++){var ans=self.questions[i].answers;if(typeof ans=='string'){ans=angular.fromJson('['+ans+']');}userAnswers.push(ans);}submission.userAnswers=userAnswers;var score=markQuestions(userAnswers);var answerString=angular.toJson(submission);clmDataStore.events.submitSolution(eventId,taskId,participant.publicId,answerString).then(clmDataStore.events.saveScore(eventId,participant.publicId,taskId,score),spfAlert.success('Your Mcq responses are saved.'),//set progress to true, and save the progress into firebase
initialData.progress[userId]={taskId:taskId},initialData.progress[userId][taskId]={completed:true},// clmDataStore.events.setProgress(eventId, taskId, userId, initialData.progress),
$location.path(urlFor('oneEvent',{eventId:eventId}))).catch(function(err){$log.error(err);spfAlert.error('Failed to save the mcq responses.');return err;});};self.cancel=function(){$mdDialog.hide();};self.discardChanges=function(ev){mcqInvalid=false;var confirm=$mdDialog.confirm().title('Would you like to discard your answers?').textContent('All of your answers will be discarded. Are you sure you want to continue?').ariaLabel('Discard answers').targetEvent(ev).ok('Cancel Answering').cancel('Continue Answering');$mdDialog.show(confirm).then(function(){$location.path(urlFor('oneEvent',{eventId:eventId}));});};}function newMcqController(initialData,challengeService,$filter,$mdDialog,urlFor,$location,spfNavBarService){var self=this;// Checks if all questions have at least one answer
// self.isMcqValid = true;
// console.log("new mcq data are", initialData);
self.task=initialData.task;self.event=initialData.event;self.isMcqValid=false;self.isTextFilled=false;spfNavBarService.update(self.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:self.event.title,url:'#'+urlFor('oneEvent',{eventId:self.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:self.event.$id})}]);self.checkMCQValid=function(text){console.log(text);if(text.length==0||text==undefined){self.isTextFilled=false;}else{self.isTextFilled=true;}};self.isOptionValid=false;self.checkOptionValid=function(text){if(text.length==0||text==undefined){self.isOptionValid=false;}else{self.isOptionValid=true;}};self.questions=[{text:"",answers:[],options:[{text:""}]}];// Save mcq question to database.
//todo: clean up the form before submitting. e.g. when toggled, vid entered, but toggled off
self.save=function(questions){var setAnswers=[];for(var i=0;i<questions.length;i++){var answers=questions[i].answers;setAnswers.push(answers);delete questions[i].answers;}// Check does questions contain answers?
// console.log(questions);
//
// // Check answer list
// console.log(setAnswers);
// Change questions into JSON text
var answersJsonText=angular.toJson(questions);// console.log(answersJsonText);
// Save function defined in challenges.js
// Parameters: event, taskid, task, taskType, isOpen
var event=initialData.event;var task=initialData.task;var taskId=initialData.taskId;var taskType=initialData.taskType;var isOpen=initialData.isOpen;task.mcqQuestions=answersJsonText;task.answers=angular.toJson(setAnswers);challengeService.save(event,taskId,task,taskType,isOpen);};// Add question when add question button is clicked
self.addQuestion=function(){var question={text:"",answers:[],options:[{text:""}]};// Push new question object into questions list
self.questions.push(question);checkMCQValid();};function checkMCQValid(){for(var i=0;i<self.questions.length;i++){if(self.questions[i].answers.length==0){self.isMcqValid=false;return;}}self.isMcqValid=true;}self.removeQuestion=function(ev,itemIndex){var confirm=$mdDialog.confirm().title('Would you like to delete this question?').textContent('This question and its option(s) will be deleted. Do you wish to proceed?').ariaLabel('Question deletion').targetEvent(ev).ok('Delete').cancel('Do not delete');$mdDialog.show(confirm).then(function(){if(itemIndex>-1){var removed=self.questions.splice(itemIndex,1);console.log('Removed : ',removed);console.log(self.questions);checkMCQValid();}});};self.toggleOption=function(question,itemIndex){console.log('Index being deleted...',itemIndex);var idx=question.answers.indexOf(itemIndex);if(idx>-1){var removed=question.answers.splice(idx,1);console.log(removed);}else{question.answers.push(itemIndex);}console.log(question.answers);checkMCQValid();};// Add new option to question
self.addOption=function(question){// Get options
question.options.push({text:""});checkMCQValid();};// Delete options
self.removeOption=function(question,itemIndex){question.options.splice(itemIndex,1);var idxOfAns=question.answers.indexOf(itemIndex);if(idxOfAns>-1){var removedAns=question.answers.splice(idxOfAns,1);console.log('Removed an answer: ',removedAns);}for(var i=0;i<question.answers.length;i++){var ans=question.answers[i];if(ans>itemIndex){question.answers[i]=ans-1;}}console.log(question.options);checkMCQValid();};self.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not save your challenge information').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Discard Challenge').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){$location.path(urlFor('oneEvent',{eventId:initialData.event.$id}));});};}function starMcqTmpl(){return mcqStart;}//this export function return the template when creating a new mcq challenge
function newMcqTmpl(){return mcqTmpl;}function editMcqTmpl(){return mcqEditTmpl;}function showPreviewInitialData($q,$location,$route,firebaseApp,$firebaseArray,spfAuthData,clmDataStore){var db=firebaseApp.database();var errNoEvent=new Error('Event not found');var eventId=$route.current.params.eventId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$5);var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var canviewPromise=$q.all({event:eventPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.event));});//returns a promise object from firebase
var surveyRef=db.ref('classMentors/surveyTemplate');var survey=$firebaseArray(surveyRef);return $q.all({currentUser:spfAuthData.user().catch(noop$5),profile:profilePromise,event:eventPromise,canView:canviewPromise,survey2:survey.$loaded().then(function(){return survey;}),tasks:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getTasks(eventId);}}),participants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.participants(eventId);}}),progress:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getProgress(eventId);}}),solutions:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getSolutions(eventId);}})});}function showPreviewController(spfNavBarService,$location,urlFor,initialData,$routeParams,clmDataStore,clmPagerOption,spfAlert,$scope,firebase,$route){var self=this;var eventId=$route.current.params.eventId;var getTask=JSON.parse($route.current.params.task);var eventTitle=$route.current.params.eventTitle;spfNavBarService.update(getTask.title,[{title:'Events',url:'#'+urlFor('events')},{title:eventTitle,url:'#'+urlFor('oneEvent',{eventId:eventId})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:eventId})}]);this.questions=initialData.survey2;this.ratingOptions=[{id:1},{id:2},{id:3},{id:4},{id:5},{id:6},{id:7}];if($routeParams.surveyType==='School engagement scale'){self.responseRating=[{option:'Never'},{option:'On Occasion'},{option:'Some of the Time'},{option:'Most of the Time'},{option:'All of the Time'}];self.schEngageResp={};}if($routeParams.surveyType=='Motivated strategies for learning'){self.questionsArr=[];for(var i=1;i<Object.keys(initialData.survey2[1]).length-1;i++){//console.log("testing: ", initialData.survey2[1]["Q" + i]);
self.questionsArr.push({'name':initialData.survey2[1]["Q"+i],'qnid':i});}self.motiResp={};}if($routeParams.surveyType==='Education vs Dissatisfaction with learning'){this.familyMembers=[{name:'Father'},{name:'Mother'},{name:'Sister(s)'},{name:'Brother(s)'},{name:'Relative(s)'},{name:'Grandparent(s)'}];this.selectedFamily=[];this.selectedRaceEthnicity=[];this.toggle=function(item,list){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}return list;};this.exists=function(item,list){return list.indexOf(item)>-1;};this.bdayMonth=[{month:'January'},{month:'February'},{month:'March'},{month:'April'},{month:'May'},{month:'June'},{month:'July'},{month:'August'},{month:'September'},{month:'October'},{month:'November'},{month:'December'}];this.ethnicity=[{firstRow:'White'},{firstRow:'African American'},{firstRow:'Hispanic/Latino'},{secondRow:'Asian'},{secondRow:'Native Hawaii/Pacific Islander'},{secondRow:'Other'}];this.eduDissResp={};this.questionJson={};// console.log("this initialdata is", initialData.survey2[0]);
//console.log("initial data before: ", initialData.survey2[0]);
for(var _i=1;_i<Object.keys(initialData.survey2[0]).length-1;_i++){this.eduDissResp[initialData.survey2[0][_i].title]={};}}self.back=function(){$location.path('/challenges/survey/'+eventTitle+'/'+eventId+'/'+JSON.stringify(getTask));};}function showSurveyTmpl(){return surveyTmpl;}function createTeamActivityInitialData($q,eventService,clmDataStore){var data=eventService.get();// console.log("team data is:", data);
return clmDataStore.events.participants(data.event.$id).then(function(result){return{data:data,participants:result};});}function createTeamActivityController($q,initialData,clmDataStore,$location,urlFor,eventService,$mdDialog,spfAlert,firebaseApp,$firebaseObject,$firebaseArray,$log,spfNavBarService){var self=this;// console.log("initialdata for teamform are", initialData);
// event variable consist of event id,timecreated,owner and event title
self.event=initialData.data.event;//task variable consist of description,title of task, showProgress, priority, archived(t/f)
self.task=initialData.data.task;self.taskType=initialData.data.taskType;self.participants=initialData.participants;self.teamsMaximumStudents=0;self.taskType=initialData.data.taskType;self.activityType=null;self.newExistingTeams=null;self.teamFormationMethod=null;self.teamFormationParameter=null;self.collabChallengeType=null;self.coopChallengeType=null;spfNavBarService.update(self.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:self.event.title,url:'#'+urlFor('oneEvent',{eventId:self.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:self.event.$id})}]);self.submit=function(){self.task.activityType=self.activityType;self.task.newExistingTeams=self.newExistingTeams;self.task.teamFormationMethod=self.teamFormationMethod;self.task.teamFormationParameter=self.teamFormationParameter;self.event.teams=formTeams(self.teamFormationMethod,self.teamFormationParameter,self.participants.length);if(self.activityType=='gameShow'){self.task.startIRAT=true;eventService.set({taskType:self.taskType,event:self.event,task:self.task,isOpen:initialData.data.isOpen});$location.path(urlFor('viewMcq'));}else if(self.activityType=='collabSubmission'){self.task.collabChallengeType=self.collabChallengeType;createColSubActivity(self.event,self.task,initialData.data.isOpen);}else if(self.activityType=='mentoring'){self.task.mentorChallengeType=self.mentorChallengeType;createMentoringActivity(self.event,self.task,initialData.data.isOpen);console.log('Create mentoring activity');}else if(self.task.activityType=='indexCards'){var db=firebaseApp.database();var eventTaskRef=db.ref('classMentors/eventTasks/'+self.event.$id);var textResponsePromise=addTask(eventTaskRef,addTextResponse(self.task),initialData.data.isOpen);// console.log(textResponsePromise);
textResponsePromise.then(function(ref){return addTask(eventTaskRef,buildTeamFormationTask(ref.key,self.task),false);}).then(function(teamFormationPromise){var eventTeamsRef=db.ref('classMentors/eventTeams/'+self.event.$id+'/'+teamFormationPromise.key);return $q.all({teamVotingTask:addTask(eventTaskRef,buildTeamVotingTask(teamFormationPromise.key,self.task),false),initTeams:self.event.teams.map(function(team){return eventTeamsRef.push(team);})});}).then(function(voteTaskPromise){return $q.all([addTask(eventTaskRef,buildReflectionQuestion(voteTaskPromise.teamVotingTask.key,self.task),false)]);}).then(function(){spfAlert.success('Challenge created.');$location.path(urlFor('editEvent',{eventId:self.event.$id}));});}else if(self.task.activityType=='cooperative'){self.task.coopChallengeType=self.coopChallengeType;createCoopSubActivity(self.event,self.task,initialData.data.isOpen);}};function createMentoringActivity(event,task,isOpen){// console.log('Task:', task);
var timestamp=Date.now();// Get firebase database object.
var db=firebaseApp.database();self.creatingTask=true;// Get firebase task reference.
var taskRef=db.ref('classMentors/eventTasks/'+event.$id);var mentoringForTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();var mentoringAssignmentTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();var mentorTaskSettableRef=db.ref('classMentors/eventTasks/'+event.$id+'/'+mentoringForTaskRef.key);var mentorAssignmentSettableRef=db.ref('classMentors/eventTasks/'+event.$id+'/'+mentoringAssignmentTaskRef.key);var mentorTask={title:task.title,description:task.description,openedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:task.mentorChallengeType+'Mentoring',mentorAssignmentRef:mentoringAssignmentTaskRef.key,mentorAssignmentMethod:self.mentorAssignmentMethod};// Define 'teamFormationTask'.
var mentorAssignmentTask={title:task.title,description:"Locate your mentor mentee pairing and learn together!",taskFrom:mentoringForTaskRef.key,openedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:"mentorAssignment",mentorAssignmentMethod:self.mentorAssignmentMethod};if(task.linkPattern){mentorTask.linkPattern=task.linkPattern;}else if(task.lang){mentorTask.lang=task.lang;mentorTask.textResponse=task.textResponse;}else{mentorTask.textResponse=task.textResponse;}console.log('Mentor Task: ',mentorTask);console.log('Mentor Assignment: ',mentorAssignmentTask);mentorTaskSettableRef.set(mentorTask).then(function(){console.log('Mentor task set!');mentorAssignmentSettableRef.set(mentorAssignmentTask).then(function(){console.log('Mentor Assignment set!');}).then(function(){spfAlert.success('Challenge created.');$location.path(urlFor('editEvent',{eventId:self.event.$id}));});});}function buildReflectionQuestion(taskFrom,task){return{taskFrom:taskFrom,title:task.title,description:"Tell us about your question",showProgress:task.showProgress,archived:false,question:angular.toJson({question:"Select the appropriate response below for your question",options:["Instructor answered it","Teaching Assistants answered it","Figured it out on my own or answered by peers","My question was not answered and I need help"]}),type:"reflectionQuestion"};}function addTask(ref,task,isOpen){if(isOpen){task.openedAt={'.sv':'timestamp'};task.closedAt=null;}else{task.closedAt={'.sv':'timestamp'};task.openedAt=null;}var promise=ref.push(task);$log.info('Task: '+angular.toJson(task)+' is stored at '+ref+', '+promise.key);return promise;}function buildTeamVotingTask(taskFrom,task){return{taskFrom:taskFrom,title:task.title,description:"As a team, select your favorite question. Click on the question to rank them.",formationPattern:true,closedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:"voteQuestions"};}function buildTeamFormationTask(taskFrom,task){return{taskFrom:taskFrom,title:task.title,description:"Click Below To Join Team",formationPattern:true,closedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:"formTeam",teamFormationMethod:task.teamFormationMethod};}function addTextResponse(task){task.textResponse='Placeholder';// task.priority = priority;
return task;}function createCoopSubActivity(event,task,isOpen){var timestamp=Date.now();// Get firebase database object.
var db=firebaseApp.database();self.creatingTask=true;// Get firebase task reference.
var taskRef=db.ref('classMentors/eventTasks/'+event.$id);var teamFormationTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();var eventTeamsRef=db.ref('classMentors/eventTeams/'+event.$id+'/'+teamFormationTaskRef.key);var settableRef=db.ref('classMentors/eventTasks/'+event.$id+'/'+teamFormationTaskRef.key);// Define 'teamFormationTask'.
var teamFormationTask={title:task.title,description:"Join a team to undertake the challenge together",taskFrom:teamFormationTaskRef.key,formationPattern:true,openedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:"formTeam",teamFormationMethod:task.teamFormationMethod,coopSubmission:true};var coopTask={teamFormationRef:teamFormationTaskRef.key,title:task.title,description:task.description,closedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:task.coopChallengeType,teamFormationMethod:task.teamFormationMethod,coopSubmission:true};if(task.linkPattern){coopTask.linkPattern=task.linkPattern;}else if(task.lang){coopTask.lang=task.lang;coopTask.textResponse=task.textResponse;}else{coopTask.textResponse=task.textResponse;}settableRef.set(teamFormationTask).then(function(){}).catch(function(error){console.log('FAILED AT SETTING TEAM FORMATION TASK');});taskRef.push(coopTask).then(function(){// Create 'teams' in 'eventTeams'.
for(var i=0;i<event.teams.length;i++){var team=event.teams[i];eventTeamsRef.push(team);}spfAlert.success('Challenge created');$location.path(urlFor('editEvent',{eventId:event.$id}));}).catch(function(error){console.log('FAILED AT SETTING COOPERATIVE TASK');});}function createColSubActivity(event,task,isOpen){var timestamp=Date.now();// Get firebase database object.
var db=firebaseApp.database();self.creatingTask=true;// Get firebase task reference.
var taskRef=db.ref('classMentors/eventTasks/'+event.$id);var teamFormationTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();var eventTeamsRef=db.ref('classMentors/eventTeams/'+event.$id+'/'+teamFormationTaskRef.key);var settableRef=db.ref('classMentors/eventTasks/'+event.$id+'/'+teamFormationTaskRef.key);// Define 'teamFormationTask'.
var teamFormationTask={title:task.title,description:"Join a team to undertake the challenge together",taskFrom:teamFormationTaskRef.key,formationPattern:true,openedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:"formTeam",teamFormationMethod:task.teamFormationMethod};var collabTask={teamFormationRef:teamFormationTaskRef.key,title:task.title,description:task.description,closedAt:{'.sv':'timestamp'},showProgress:task.showProgress,archived:false,type:task.collabChallengeType,teamFormationMethod:task.teamFormationMethod};if(task.linkPattern){collabTask.linkPattern=task.linkPattern;}else if(task.lang){collabTask.lang=task.lang;collabTask.textResponse=task.textResponse;}else{collabTask.textResponse=task.textResponse;}settableRef.set(teamFormationTask).then(function(){}).catch(function(error){console.log('FAILED AT SETTING TEAM FORMATION TASK');});taskRef.push(collabTask).then(function(){// Create 'teams' in 'eventTeams'.
for(var i=0;i<event.teams.length;i++){var team=event.teams[i];eventTeamsRef.push(team);}spfAlert.success('Challenge created');$location.path(urlFor('editEvent',{eventId:event.$id}));}).catch(function(error){console.log('FAILED AT SETTING COLLAB TASK');});}function formTeams(method,methodParameter,participants){var teams=[];var teamStructure=[];// participants = participants + 1;// hmm, shouldn't need to add 1 here.
if(method=='noOfTeams'){//initialze teamStructure with team size of 0 each
teamStructure=Array.apply(null,Array(methodParameter)).map(Number.prototype.valueOf,0);console.log('teamStructure :',teamStructure);//add 1 to each team until there are no more participants left
for(var i=0;i<participants;i++){teamStructure[i%methodParameter]+=1;}}else{//else by teamSize
while(participants>methodParameter){teamStructure.push(methodParameter);participants-=methodParameter;}// split up remaining participants
for(var _i=0;_i<participants;_i++){teamStructure[_i%teamStructure.length]+=1;}}//Create 'teams'
for(var _i2=0;_i2<teamStructure.length;_i2++){// teams[i] = populateTeam(teamStructure[i]);
teams.push({maxSize:teamStructure[_i2],currentSize:0});}// console.log('Teams is: ', teams);
return teams;}function populateTeam(members){var team={};// console.log(members);
for(var i=0;i<members;i++){team[i]="";}// console.log(angular.toJson(team));
return team;}// if number of teams, "Each team will have a maximum enrollment of # students"; #= roundup (totalParticipants / # of teams)
// if max number of student, "You will have # teams"; #= round up (totalParticipants / # stud per team)
self.calculateTeamMaximumStudent=function(noTeamsOrStudents){// var noTeamsOrStudents = self.teamFormationInput;
var totalParticipants=self.participants.length;// console.log("number is ", noTeamsOrStudents);
// console.log("cal", Math.ceil(totalParticipants / noTeamsOrStudents));
self.teamsMaximumStudents=Math.ceil(totalParticipants/noTeamsOrStudents)?Math.ceil(totalParticipants/noTeamsOrStudents):0;};self.calculationResult=function(){return self.teamsMaximumStudents;};//this function double checks with user if he wishes to go back and discard all changes thus far
this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not save your challenge information').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Discard Challenge').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:self.event.$id}));});};}function startTRATInitialData($q,spfAuthData,eventService,clmDataStore,firebaseApp,$firebaseObject,$firebaseArray,$route){var data=eventService.get();var db=firebaseApp.database();// console.log("my data is:", data);
var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;// var teamLogPromise = null;
var tratId=taskId;var userTeamId=null;var userPublicId=data.participant.$id;// console.log("userpublicid iss:", data.participant);
var teamFormationRefKey=data.task.teamFormationRef;var eventTeamRef=db.ref('classMentors/eventTeams/'+eventId+'/'+teamFormationRefKey);return $q.all({task:data.task,event:clmDataStore.events.get(eventId),currentUser:spfAuthData.user(),correctAnswers:clmDataStore.events.getTaskAnswers(data.eventId,data.task.taskFrom).then(function(data){return data.$value;}),progress:clmDataStore.events.getProgress(data.eventId).then(function(data){return data;}),teamRefId:teamFormationRefKey,questions:angular.fromJson(data.task.mcqQuestions),tratId:tratId,teamAndteamId:$firebaseArray(eventTeamRef).$loaded().then(function(teams){// console.log("teams in resolve:", spfAuthData.user());
// Sanity check that teams are retrieved
for(var i=0;i<teams.length;i++){var team=teams[i];if(team[userPublicId]){return team.$id;}}}).then(function(teamId){var teamRef=db.ref('classMentors/eventTeams/'+eventId+'/'+teamFormationRefKey+'/'+teamId);return{team:$firebaseArray(teamRef).$loaded(function(team){var outputTeam=[];for(var i=0;i<team.length;i++){var idAtIdx=team[i].$id;if(idAtIdx!='currentSize'&&idAtIdx!='maxSize'){outputTeam.push(team[i]);}}return outputTeam;}).then(function(result){return result;}),teamId:teamId};}),eventId:eventId,teamFormId:teamFormationRefKey});}function startTRATController($q,initialData,clmDataStore,$location,urlFor,firebaseApp,$firebaseObject,$firebaseArray,spfAlert,$scope,spfNavBarService){// Sanity check
var mcqInvalid=true;$scope.$on("$routeChangeStart",function(event,next,current){if(mcqInvalid){if(!confirm("You have not complete your multiple choice questions. Are you sure you want to continue? All data will be lost!")){event.preventDefault();}}});var self=this;var db=firebaseApp.database();self.index=0;// Inititalize Question and Question's option(s)
self.questions=initialData.questions;self.question=self.questions[self.index];self.options=self.question.options;var userPublicId=initialData.currentUser.publicId;self.eventId=initialData.eventId;var teamAndteamId=initialData.teamAndteamId;// console.log(initialData.teamAndteamId);
self.teamId=teamAndteamId.teamId;self.team=null;teamAndteamId.team.then(function(result){self.team=result;});spfNavBarService.update(initialData.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:initialData.event.title,// modify initialdata
url:'#'+urlFor('oneEvent',{eventId:initialData.eventId})}]);self.tratId=initialData.tratId;self.teamFormId=initialData.teamFormId;var userAnswers=[];self.multiAns=[];self.correctAnswers=angular.fromJson(initialData.correctAnswers);var teamLogRef=db.ref('classMentors/eventTeamsLog/'+self.teamFormId+'/'+self.teamId);self.multipleAns=function(){var multipleAnsArray=[];for(var i=0;i<self.correctAnswers.length;i++){var ans=self.correctAnswers[i];if(ans.length>1){multipleAnsArray.push(true);}else{multipleAnsArray.push(false);}}// console.log('Sanity check: ', multipleAnsArray);
return multipleAnsArray;}();// console.log(self.multipleAns);
var teamAnsRef=db.ref('classMentors/eventSolutions/'+self.eventId+'/'+self.teamId+'/'+self.tratId);self.noOfTries=3;self.totalScore=0;//Init team log
self.teamLog=null;//print out question number and number of attempts first
function refreshLog(){$firebaseArray(teamLogRef.orderByKey()).$loaded(function(data){self.teamLog=data;});}refreshLog();// test this later
var updateLog=function updateLog(msg){teamLogRef.push().set(msg).then(function(){// console.log('Msg has been pushed');
refreshLog();});};updateLog(buildMessage("Question "+(self.index+1),'Remaining attempts: '+self.noOfTries,'black'));self.submitTrat=function(){$location.path(urlFor('oneEvent'));};function writeScoreAndProgress(team,score,solution){// console.log(team);
var teamMembers=[];for(var key in team){var id=team[key].$id;if(id!='teamLeader'){teamMembers.push(id);}}// console.log('Members ', teamMembers);
var promiseArray=[];for(var key in teamMembers){var publicId=team[key].$id;// console.log('PublicID being processed now ',publicId);
var eventSolRef=db.ref('classMentors/eventSolutions/'+self.eventId+'/'+publicId+'/'+self.tratId);var eventSolRefPromise=eventSolRef.set({'answer':angular.toJson(solution),'completed':TIMESTAMP});var eventScoreRef=db.ref('classMentors/eventScores/'+self.eventId+'/'+publicId+'/'+self.tratId);var eventScoreRefPromise=eventScoreRef.set(score);promiseArray.push(eventSolRefPromise);promiseArray.push(eventScoreRefPromise);}return promiseArray;// Write progress for all members as completed.
}function buildMessage(status,message,style){return{status:status,text:message,style:style,timestamp:TIMESTAMP};}var attempts=[];self.nextQuestion=function(){// For Single answer MCQ
if(self.selected!=null){var tempArray=[];tempArray.push(parseInt(self.selected));var result=markQuestions(tempArray,self.index);if(result==0){self.noOfTries-=1;updateLog(buildMessage("Question "+(self.index+1)+": "+"Incorrect",'Remaining attempts: '+self.noOfTries,'#A9241C'));// Store reccord
attempts.push(tempArray);// console.log('Current attempts: ', attempts);
if(self.noOfTries==0){updateLog(buildMessage("Question "+(self.index+1)+": "+"Incorrect",'No attempts remaining','#A9241C'));self.totalScore+=0;if(self.index==self.questions.length-1){userAnswers.push(attempts);attempts=[];$q.all(writeScoreAndProgress(self.team,self.totalScore,userAnswers)).then(function(){spfAlert.success('TRAT Submitted');$location.path(urlFor('oneEvent',{eventId:self.eventId}));});}else{self.noOfTries=3;userAnswers.push(attempts);attempts=[];self.question=loadQuestion(self.index+=1,self.questions);updateLog(buildMessage("Question "+(self.index+1),'Remaining attempts: '+self.noOfTries,'black'));self.options=loadOptions(self.question);}}clmDataStore.logging.inputLog({publicId:userPublicId,timestamp:TIMESTAMP,action:"wrongTeamSubmission",taskId:self.tratId,eventId:self.eventId,members:self.team.map(function(member){return member.$id;})});}else{// Add score if correct
self.totalScore+=addScore(self.noOfTries,1);updateLog(buildMessage("Question "+(self.index+1)+": "+"Correct!",'Remaining attempts: '+self.noOfTries,'#259b24'));attempts.push(tempArray);if(self.index==self.questions.length-1){mcqInvalid=false;userAnswers.push(attempts);attempts=[];$q.all(writeScoreAndProgress(self.team,self.totalScore,userAnswers)).then(function(){spfAlert.success('TRAT Submitted');$location.path(urlFor('oneEvent',{eventId:self.eventId}));});}else{mcqInvalid=true;self.noOfTries=3;userAnswers.push(attempts);attempts=[];self.question=loadQuestion(self.index+=1,self.questions);updateLog(buildMessage("Question "+(self.index+1),'Remaining attempts: '+self.noOfTries,'black'));self.options=loadOptions(self.question);}clmDataStore.logging.inputLog({publicId:userPublicId,timestamp:TIMESTAMP,action:"correctTeamSubmission",taskId:self.tratId,eventId:self.eventId,members:self.team.map(function(member){return member.$id;})});}// console.log(self.totalScore);
// teamAns(tempArray);
self.selected=null;}else{// For multi answer MCQ
var result=markQuestions(self.multiAns,self.index);if(result==0){self.noOfTries-=1;// Store reccord
attempts.push(self.multiAns);updateLog(buildMessage("Question "+(self.index+1)+": "+"Incorrect",'Remaining attempts: '+self.noOfTries,'#A9241C'));if(self.noOfTries==0){self.totalScore+=0;if(self.index==self.questions.length-1){mcqInvalid=false;userAnswers.push(attempts);attempts=[];writeScoreAndProgress(self.team,self.totalScore,userAnswers);spfAlert.success('TRAT Submitted');$location.path(urlFor('oneEvent',{eventId:self.eventId}));}else{mcqInvalid=true;self.noOfTries=3;userAnswers.push(attempts);attempts=[];self.question=loadQuestion(self.index+=1,self.questions);updateLog(buildMessage("Question "+(self.index+1),'Remaining attempts: '+self.noOfTries,'black'));self.options=loadOptions(self.question);}}// clear options.
for(var key in self.options){delete self.options[key].checked;}self.multiAns=[];clmDataStore.logging.inputLog({publicId:userPublicId,timestamp:TIMESTAMP,action:"wrongTeamSubmission",taskId:self.tratId,eventId:self.eventId,members:self.team.map(function(member){return member.$id;})});}else{// Add score
// console.log('Single ans mcq is correct!');
// console.log('index is : ',self.index);
attempts.push(self.multiAns);self.totalScore+=addScore(self.noOfTries,1);updateLog(buildMessage("Question "+(self.index+1)+": "+"Correct!",'Remaining attempts: '+self.noOfTries,'#259b24'));if(self.index==self.questions.length-1){mcqInvalid=false;userAnswers.push(attempts);attempts=[];writeScoreAndProgress(self.team,self.totalScore,userAnswers);spfAlert.success('TRAT Submitted');$location.path(urlFor('oneEvent',{eventId:self.eventId}));}else{mcqInvalid=true;// console.log('Questions : ', self.questions);
// console.log('Load next question!');
self.noOfTries=3;userAnswers.push(attempts);attempts=[];self.question=loadQuestion(self.index+=1,self.questions);updateLog(buildMessage("Question "+(self.index+1),'Remaining attempts: '+self.noOfTries,'black'));self.options=loadOptions(self.question);}clmDataStore.logging.inputLog({publicId:userPublicId,timestamp:TIMESTAMP,action:"correctTeamSubmission",taskId:self.tratId,eventId:self.eventId,members:self.team.map(function(member){return member.$id;})});}// console.log(self.totalScore);
self.multiAns=[];}};function loadQuestion(index,questions){if(index<questions.length){return questions[index];}else{return false;}}function loadOptions(question){if(question){return question.options;}else{return false;}}function addScore(attempts,score){var s=score*(attempts/3);console.log(s);return Math.round(s*100)/100;}function arraysEqual(arr1,arr2){if(arr1.length!==arr2.length)return 0;if(arr1.length>1&&arr2.length>1&&arr1.length==arr2.length){for(var i=arr1.length;i--;){if(arr2.indexOf(arr1[i])<0)return 0;}}else{for(var i=arr1.length;i--;){if(arr1[i]!==arr2[i])return 0;}}return 1;}self.toggle=function(list,item){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}var selected=[];for(var i=0;i<list.length;i++){var text=self.options[list[i]].text;selected.push(text);}};function markQuestions(submittedAnswers,index){// console.log('Correct Answers...', self.correctAnswers);
// console.log('Submitted Answers...', submittedAnswers);
var score=0;// for (var i = 0; i < self.correctAnswers.length; i++) {
score+=arraysEqual(submittedAnswers,self.correctAnswers[index]);// console.log(score);
// }
return score;}}function createMentoringInitialData(){console.log("createMentoringInitial data came here");}function createMentoringController(){console.log("mentoring controller reaches here");}// TODO: Put out of use.
function tratQuestionFactory($q,spfAuthData,eventService,clmDataStore){var self=this;self.data=eventService.get();// console.log("my data is:", self.data);
// var question = $q.all ({
//     questions: angular.fromJson(data.task.mcqQuestions)
// }).then (function (result){
//     console.log("testing questions:", result);
//     return result;
//
// });
// return $q.all({
//     getQuestion: function(id){
//         var question = angular.fromJson(self.data.task.mcqQuestions);
//         if(id < question.length){
//             return question[id];
//         }else{
//             return false;
//         }
//     } 
// });
// Weird bugs often happen here. Could be bcoz of promise objects not resolved.
return{getQuestion:function getQuestion(id){var question=angular.fromJson(self.data.task.mcqQuestions);if(id<question.length){return question[id];}else{return false;}}};}//TODO: Add config for routing to various challenges
function configRoute$1($routeProvider,routes){$routeProvider.when(routes.indexCard,{template:'',controller:'',controllerAs:'ctrl',resolve:{initialData:''}}).when(routes.viewMcq,{template:newMcqTmpl,controller:newMcqController,controllerAs:'ctrl',resolve:{initialData:createMCQInitialData}}).when(routes.editMcq,{template:editMcqTmpl,controller:editMcqController,controllerAs:'ctrl',resolve:{initialData:editMCQInitialData}}).when(routes.viewSurvey,{template:showSurveyTmpl,controller:surveyFormEvent,controllerAs:'ctrl',resolve:{initialData:getTaskSurveyValues}}).when(routes.editSurvey,{template:showSurveyTmpl,controller:editsurveyFormEvent,controllerAs:'ctrl',resolve:{initialData:getTaskSurveyEditValues}}).when(routes.startMcq,{template:starMcqTmpl,controller:startMcqController,controllerAs:'ctrl',resolve:{initialData:startMCQInitialData}}).when(routes.createTeamActivity,{template:teamActivityCreateTmpl,controller:createTeamActivityController,controllerAs:'ctrl',resolve:{initialData:createTeamActivityInitialData}}).when(routes.viewMentorCreation,{template:mentorCreationTmpl,controller:createMentoringController,controllerAs:'ctrl',resolve:{initialData:createMentoringInitialData}}).when(routes.viewIRAT,{template:teamIRATTmpl,controller:undefined,controllerAs:'ctrl',resolve:{initialData:createTeamActivityInitialData}}).when(routes.viewTRAT,{// Start TRAT.
template:teamTRATTmpl,controller:startTRATController,controllerAs:'ctrl',resolve:{initialData:startTRATInitialData}}).when(routes.viewSchEngagePreview,{template:schEngagePreview,controller:showPreviewController,controllerAs:'ctrl',resolve:{initialData:showPreviewInitialData}}).when(routes.viewMotiStratPreview,{template:motiStratPreview,controller:showPreviewController,controllerAs:'ctrl',resolve:{initialData:showPreviewInitialData}}).when(routes.viewEduDissPreview,{template:eduDissPreview,controller:showPreviewController,controllerAs:'ctrl',resolve:{initialData:showPreviewInitialData}});}function editMCQInitialData($q,eventService,clmDataStore){var data=eventService.get();// console.log(data);
return clmDataStore.events.getTaskAnswers(data.event.$id,data.task.$id).then(function(result){return{data:data,savedAnswers:result};},function(error){console.log(error);});}// Initial data for starting an MCQ
//todo: tidy up the codes; should be using promises to access some objects as well as validation
function startMCQInitialData($q,spfAuthData,eventService,clmDataStore,$route,firebaseApp,$firebaseObject){//promise object
// var currentUser = spfAuthData.user().catch(noop);
var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;//retrieve mcq questions
var db=firebaseApp.database();return $q.all({currentUser:spfAuthData.user(),answers:clmDataStore.events.getTaskAnswers(eventId,taskId),getProgress:clmDataStore.events.getProgress(eventId),task:clmDataStore.events.getTask(eventId,taskId),event:clmDataStore.events.get(eventId)}).then(function(result){// console.log("result isss:", result);
return{eventTitle:result.event.title,eventId:eventId,taskId:taskId,task:result.task,correctAnswers:result.answers,currentUser:result.currentUser,progress:result.getProgress};});// return clmDataStore.events.getTaskAnswers(data.eventId, data.taskId).then(
//       function(result){
//         return {
//           data: data,
//           correctAnswers: result,
//             currentUser: currentUser
//         }
//       }, function(error){
//         console.log(error);
//       }
//   );
}// Initial data for creating MCQ
function createMCQInitialData($q,eventService){var data=eventService.get();return data;}function scrollBottom(){return{scope:{schrollBottom:"="},link:function link(scope,element){scope.$watchCollection('schrollBottom',function(newValue){if(newValue){$(element).scrollTop($(element)[0].scrollHeight);}});}};}//TODO: Generic save function
function challengeServiceFactory($q,$route,spfAuthData,clmDataStore,$log,spfAlert,$location,urlFor,firebaseApp,$firebaseArray,$firebaseObject){return{save:function save(event,taskId,task,taskType,isOpen){// Get firebase database object.
var db=firebaseApp.database();var copy=cleanObj(task);var answers=copy.answers;// console.log('COPY IS ... ', copy);
//
// console.log('COPY IS!! ', copy);
self.creatingTask=true;if(taskType==='multipleChoice'){delete copy.singPathProblem;delete copy.badge;delete copy.answers;var ref=clmDataStore.events.addTaskWithAns(event.$id,copy,isOpen,answers);ref.then(function(){spfAlert.success('Challenge created.');$location.path(urlFor('editEvent',{eventId:event.$id}));}).catch(function(err){$log.error(err);spfAlert.error('Failed to created new challenge.');}).finally(function(){self.creatingTask=false;});}else if(taskType==='teamActivity'){delete copy.singPathProblem;delete copy.badge;delete copy.answers;if(copy.link==""){delete copy.link;}// console.log(copy);
/*TODO:
                 1. Modify 'addTaskWithAns' to return firebase reference too? hmm.
                 2. Refactor once (1) is agreed upon.
                 */// Get firebase task reference.
var taskRef=db.ref('classMentors/eventTasks/'+event.$id);// Get root reference; Returns thenable reference
var ref=taskRef.push();var taskAnsRef=db.ref('classMentors/eventAnswers/'+event.$id+'/'+ref.key);var teamFormationTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();var tratTaskRef=db.ref('classMentors/eventTasks/'+event.$id).push();// console.log('Team Formation key: ', taskAnsRef.key)
var eventTeamsRef=db.ref('classMentors/eventTeams/'+event.$id+'/'+teamFormationTaskRef.key);console.log("eventteamsRef iss:",eventTeamsRef);// Check If key
// console.log(teamFormationTaskRef.key);
var priority=copy.priority;// Set openedAt, closedAt timestamp.
if(isOpen){copy.openedAt={'.sv':'timestamp'};copy.closedAt=null;}else{copy.closedAt={'.sv':'timestamp'};copy.openedAt=null;}// Save IRAT.
var promise=priority?ref.setWithPriority(copy,priority):ref.set(copy);promise.then(function(){// Save answers.
console.log('Task answers set.');// console.log(taskAnsRef);
return taskAnsRef.set(answers);}).then(function(){// Define 'teamFormationTask'.
var teamFormationTask={taskFrom:ref.key,title:copy.title,description:"Click Below To Join Team",formationPattern:true,closedAt:{'.sv':'timestamp'},showProgress:copy.showProgress,archived:false,type:"formTeam",teamFormationMethod:copy.teamFormationMethod};// Create 'teams' in 'eventTeams'.
for(var i=0;i<event.teams.length;i++){var team=event.teams[i];// console.log('Team here is: ', team);
console.log('Team is: ',team);eventTeamsRef.push(team).then(function(thenableRef){// console.log('Team reccorded at: ', thenableRef.key);
// var teamLog = {
//     init: {'.sv': 'timestamp'}
// }
var eventTeamsLogRef=db.ref('classMentors/eventTeamsLog/'+teamFormationTaskRef.key+'/'+thenableRef.key);// eventTeamsLogRef.set(teamLog);
});}console.log('Team answers set.');return priority?teamFormationTaskRef.setWithPriority(teamFormationTask,priority):teamFormationTaskRef.set(teamFormationTask);}).then(function(){console.log('TeamFormationTask set.');var tratTask={taskFrom:ref.key,teamFormationRef:teamFormationTaskRef.key,title:copy.title,description:"Click Below to Start TRAT",startTRAT:true,closedAt:{'.sv':'timestamp'},showProgress:copy.showProgress,archived:false,type:"TRAT",teamFormationMethod:copy.teamFormationMethod,mcqQuestions:copy.mcqQuestions};return priority?tratTaskRef.setWithPriority(tratTask,priority):tratTaskRef.set(tratTask);}).then(function(){console.log('TRAT set.');console.log('Events Created');spfAlert.success('Challenge saved');$location.path(urlFor('editEvent',{eventId:event.$id}));});}},update:function update(event,taskId,task,taskType,isOpen){var copy=cleanObj(task);var answers=copy.answers;if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else if(taskType==='multipleChoice'){delete copy.singPathProblem;delete copy.badge;delete copy.answers;}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;var ref=clmDataStore.events.updateTaskWithAns(event.$id,taskId,copy,answers);ref.then(function(){if(isOpen&&task.openedAt||!isOpen&&task.closedAt){return;}else if(isOpen){return clmDataStore.events.openTask(event.$id,taskId);}return clmDataStore.events.closeTask(event.$id,taskId);}).then(function(){spfAlert.success('Challenge saved.');$location.path(urlFor('editEvent',{eventId:event.$id}));}).catch(function(){spfAlert.error('Failed to save the challenge.');}).finally(function(){self.savingTask=false;});;}};}// export const component = {
//
// }
function surveyFormEvent($scope,clmSurvey,clmDataStore,$log,spfAlert,$location,urlFor,$mdDialog,spfNavBarService,$route){this.surveys=[{id:1,name:'Education vs Dissatisfaction with learning'},{id:2,name:'Motivated strategies for learning'},{id:3,name:'School engagement scale'}];//TODO: retrieve selected value, add task into firebase
// var sharedData = clmSurvey.get();
// var getTask = sharedData.task;
var eventTitle=$route.current.params.eventTitle;var self=this;var eventId=$route.current.params.eventId;var getTask=JSON.parse($route.current.params.task);// console.log(sharedData);
spfNavBarService.update(getTask.title,[{title:'Events',url:'#'+urlFor('events')},{title:eventTitle,url:'#'+urlFor('oneEvent',{eventId:eventId})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:eventId})}]);// console.log("my survey temp is ", self.surveyType);
self.hasSurveyTitle=false;//check if survey template has been selected.
this.checkSurveyValid=function(){if(self.surveyType==0||self.surveyType==undefined){self.hasSurveyTitle=false;}else{self.hasSurveyTitle=true;}};// console.log("the survey t/f is", self.hasSurveyTitle);
self.showPreview=function(surveyType){self.loadPreview=true;if(surveyType.name=='School engagement scale'){$location.path('/challenges/survey1/'+eventTitle+'/'+eventId+'/'+$route.current.params.task+'/'+surveyType.name);}if(surveyType.name=='Motivated strategies for learning'){$location.path('/challenges/survey2/'+eventTitle+'/'+eventId+'/'+$route.current.params.task+'/'+surveyType.name);}if(surveyType.name=='Education vs Dissatisfaction with learning'){$location.path('/challenges/survey3/'+eventTitle+'/'+eventId+'/'+$route.current.params.task+'/'+surveyType.name);}};this.saveSurveyTask=function(surveyType){var copy=cleanObj(getTask);self.creatingTask=true;// console.log("survey type is " + surveyType);
copy.survey=surveyType;clmDataStore.events.addTask(eventId,copy,true).then(function(){spfAlert.success('Challenge created.');$location.path(urlFor('editEvent',{eventId:eventId}));}).catch(function(err){$log.error(err);spfAlert.error('Failed to create new challenge.');}).finally(function(){self.creatingTask=false;});};this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('Would you like to discard your changes?').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Cancel Editing').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:eventId}));});};}function getTaskSurveyEditValues($q,$route,spfAuthData,clmDataStore){var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;var editedTask=JSON.parse($route.current.params.task);// var chosenTask = clmDataStore.events.getTask(eventId, taskId);
return $q.all({task:clmDataStore.events.getTask(eventId,taskId),event:clmDataStore.events.get(eventId),editedTask:editedTask});}function editsurveyFormEvent(initialData,$scope,clmSurvey,clmDataStore,$log,spfAlert,$location,urlFor,spfNavBarService,eventService,$mdDialog){//todo: sheryl comment to add corner cases checking; only allow edit when 1. there are no submission for the challenge 2. the challenge is closed (avoid race conditions)
this.surveys=[{id:1,name:'Education vs Dissatisfaction with learning'},{id:2,name:'Motivated strategies for learning'},{id:3,name:'School engagement scale'}];var editedTask=initialData.editedTask;//TODO: retrieve selected value, add task into firebase
var sharedData=clmSurvey.get();var getTask=sharedData.task;var self=this;self.currentSelected=initialData.task.survey;//NOTE: no need to check for valid cause you cannot deselect your previous option.
self.hasSurveyTitle=false;//check if survey template has been selected.
this.checkSurveyValid=function(){// self.currentSelected = self.surveyType.name;
if(self.surveyType==0||self.surveyType==undefined){self.hasSurveyTitle=false;}else{self.hasSurveyTitle=true;}};spfNavBarService.update(initialData.task.title,[{title:'Events',url:'#'+urlFor('events')},{title:initialData.event.title,url:'#'+urlFor('oneEvent',{eventId:initialData.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:initialData.event.$id})}]);this.saveSurveyTask=function(surveyType){var copy=cleanObj(initialData.task);//assign all edited values to the copy to be put into firebase
self.creatingTask=true;copy.survey=surveyType;console.log("copy for edit survey is: ",copy);console.log("my editedTask is: ",editedTask);copy.archived=editedTask.archived;copy.description=editedTask.description;copy.showProgress=editedTask.showProgress;copy.title=editedTask.title;// var data = {
//     taskType: copy.survey,
//     isOpen: sharedData.isOpen,
//     event: sharedData.event,
//     task: getTask
// };
//
// eventService.set(data);
// $location.path(location);
self.savingTask=true;clmDataStore.events.updateTask(initialData.event.$id,initialData.task.$id,copy).then(function(){// if (
//     (sharedData.isOpen && sharedData.task.openedAt) ||
//     (!sharedData.isOpen && sharedData.task.closedAt)
// ) {
//     return;
// } else if (sharedData.isOpen) {
//     return clmDataStore.events.openTask(sharedData.eventId, sharedData.task.$id);
// }
//
// return clmDataStore.events.closeTask(sharedData.eventId, sharedData.task.$id);
}).then(function(){$location.path(urlFor('editEvent',{eventId:initialData.event.$id}));spfAlert.success('Survey has been edited.');}).catch(function(){spfAlert.error('Failed to edit the survey.');}).then(function(){self.savingTask=false;});};this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('Would you like to discard your changes?').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Cancel Editing').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:sharedData.event.$id}));});};}function getTaskSurveyValues(clmSurvey,$q,$route,spfAuthData,clmDataStore){var eventId=$route.current.params.eventId;var data=baseEditCtrlInitialData(eventId,$q,$route,spfAuthData,clmDataStore,clmSurvey);data.badges=clmDataStore.badges.all();data.singPath=$q.all({paths:clmDataStore.singPath.paths(),levels:[],problems:[]});return $q.all(data);}function baseEditCtrlInitialData(eventId,$q,$route,spfAuthData,clmDataStore,clmSurvey){var task=$route.current.params.task;// var sharedData = clmSurvey.get();
var errNoEvent=new Error('Event not found');var errNotAuthaurized=new Error('You cannot edit this event');var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var data={currentUser:spfAuthData.user(),event:eventPromise};data.canEdit=$q.all({currentUser:spfAuthData.user(),event:eventPromise}).then(function(result){if(!result.currentUser.publicId||!result.event.owner||!result.event.owner.publicId||result.event.owner.publicId!==result.currentUser.publicId){return $q.reject(errNotAuthaurized);}return result;});return data;}function sideNavController(){this.navAceOfCoders={};this.navCohorts={};this.navEvents={};this.navProfile={};this.navFeedback={};this.navQQ={};this.navClick=function(navStyle){if(navStyle=='navAceOfCoders'){this.navAceOfCoders={'background-color':'#CDCDCD'};this.navCohorts={};this.navEvents={};this.navProfile={};this.navFeedback={};this.navQQ={};}else if(navStyle=='navCohorts'){this.navAceOfCoders={};this.navCohorts={'background-color':'#CDCDCD'};this.navEvents={};this.navProfile={};this.navFeedback={};this.navQQ={};}else if(navStyle=='navEvents'){this.navEvents={'background-color':'#CDCDCD'};this.navCohorts={};this.navAceOfCoders={};this.navProfile={};this.navFeedback={};this.navQQ={};}else if(navStyle=='navProfile'){this.navProfile={'background-color':'#CDCDCD'};this.navEvents={};this.navCohorts={};this.navAceOfCoders={};this.navFeedback={};this.navQQ={};}else if(navStyle=='navFeedback'){this.navFeedback={'background-color':'#CDCDCD'};this.navProfile={};this.navEvents={};this.navCohorts={};this.navAceOfCoders={};this.navQQ={};}else if(navStyle=='navQQ'){this.navQQ={'background-color':'#CDCDCD'};this.navFeedback={};this.navProfile={};this.navEvents={};this.navCohorts={};this.navAceOfCoders={};}};}function configRoute$2($routeProvider,routes){$routeProvider.when(routes.cohorts,{template:cohortTmpl,controller:ClmListCohorts,controllerAs:'ctrl',resolve:{initialData:classMentorsCohortResolver}}).when(routes.newCohort,{template:newCohortTmpl,controller:NewCohortCtrl,controllerAs:'ctrl',resolve:{initialData:newCohortCtrlInitialData}}).when(routes.viewCohort,{template:cohortViewTmpl,controller:ViewCohortCtrl,controllerAs:'ctrl',resolve:{initialData:viewCohortCtrlInitialData}}).when(routes.editCohort,{template:cohortEditTmpl,controller:EditCohortCtrl,controllerAs:'ctrl',resolve:{initialData:editCohortCtrlInitialData}});}function ClmListCohorts(initialData,spfNavBarService,urlFor,spfAuthData){var title='Cohorts';var parentPages=[];var menuItems=[];this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.allCohorts=initialData.allCohorts;this.featuredCohorts=initialData.featuredCohorts;this.createdCohorts=initialData.createdCohorts;this.joinedEvents=initialData.joinedEvents;this.auth=initialData.auth;// *** Populate joined cohorts out-of-DB
this.joinedCohorts=[];for(var i=0;i<this.allCohorts.length;i++){var cohort=this.allCohorts[i];var cohortEvents=cohort.events;for(var j=0;j<this.joinedEvents.length;j++){var eventId=this.joinedEvents[j].$id;if(cohortEvents&&eventId&&cohortEvents.indexOf(eventId)>-1){this.joinedCohorts.push(cohort);break;}}}// ***
if(this.profile&&this.profile.user&&this.profile.user.isPremium){menuItems.push({title:'New Cohort',url:'#'+urlFor('newCohort'),icon:'add'});}spfNavBarService.update('Cohorts',undefined,menuItems);}function classMentorsCohortResolver($q,spfAuth,spfAuthData,clmDataStore){return $q.all({featuredCohorts:clmDataStore.cohorts.listFeaturedCohorts(),auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(){return;}),profile:clmDataStore.currentUserProfile(),createdCohorts:clmDataStore.cohorts.listCreatedCohorts(),joinedEvents:clmDataStore.events.listJoinedEvents(),allCohorts:clmDataStore.cohorts.listAllCohorts()});}/**
 * NewCohortCtrl
 *
 */function NewCohortCtrl($q,$location,initialData,urlFor,spfAuthData,spfAlert,spfNavBarService,clmDataStore){var self=this;this.auth=initialData.auth;this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.events=initialData.events;this.createdEvents=initialData.createdEvents;this.joinedEvents=initialData.joinedEvents;this.selectedEvents=[];this.selectedEventsNames=[];this.featured=false;this.includeCreated=false;this.includeJoined=false;this.creatingEvent=false;this.profileNeedsUpdate=!this.currentUser.$completed();spfNavBarService.update('New Cohorts',{title:'Cohorts',url:'#'+urlFor('cohorts')},[]);this.toggle=function(item,item2,list,list2){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);list2.push(item2);}};this.exists=function(item,list){return list.indexOf(item)>-1;};function cleanProfile(){self.currentUser.country=cleanObj(self.currentUser.country);self.currentUser.school=cleanObj(self.currentUser.school);}function updateProfile(profile){spfAlert.success('Profile setup.');self.profile=profile;self.profileNeedsUpdate=!self.currentUser.$completed();}this.save=function(currentUser,newCohort,events,featured){var next;self.creatingCohort=true;if(!self.profile){cleanProfile();next=spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved.');return clmDataStore.initProfile();}).then(updateProfile);}else if(self.profileNeedsUpdate){cleanProfile();next=self.currentUser.$save().then(function(){return clmDataStore.currentUserProfile();}).then(updateProfile);}else{next=$q.when();}next.then(function(){var data=Object.assign({owner:{publicId:currentUser.publicId,displayName:currentUser.displayName,gravatar:currentUser.gravatar},createdAt:{'.sv':'timestamp'},events:events,featured:featured},newCohort);return clmDataStore.cohorts.create(data);}).then(function(){spfAlert.success('New cohort created.');$location.path(urlFor('cohorts'));}).catch(function(e){spfAlert.error(e.toString());}).finally(function(){self.creatingCohort=false;});};this.reset=function(cohortForm){this.newCohort={data:{}};if(cohortForm&&cohortForm.$setPristine){cohortForm.$setPristine();}};this.reset();}function newCohortCtrlInitialData($q,spfAuth,spfAuthData,clmDataStore){var profilePromise;var loggedIn=spfAuth.requireLoggedIn().catch(function(){return $q.reject(new Error('The user should be logged in to create an event.'));});profilePromise=loggedIn.then(function(){return clmDataStore.currentUserProfile();}).then(function(profile){if(profile&&profile.$value===null){return clmDataStore.initProfile();}return profile;}).then(function(profile){if(!profile||!profile.user||!profile.user.isPremium){return $q.reject(new Error('Only premium users can create events.'));}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user(),profile:profilePromise,events:clmDataStore.events.list(),createdEvents:clmDataStore.events.listCreatedEvents(),joinedEvents:clmDataStore.events.listJoinedEvents()});}/**
 * Used to resolve `initialData` of `ViewEventCtrl`.
 *
 */function viewCohortCtrlInitialData($q,$route,spfAuth,spfAuthData,clmDataStore){var errNoCohort=new Error('Cohort not found');var cohortId=$route.current.params.cohortId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$6);var cohortPromise=clmDataStore.cohorts.get(cohortId).then(function(cohort){if(cohort.$value===null){return $q.reject(errNoCohort);}return cohort;});var canviewPromise=$q.all({cohort:cohortPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.cohort));});return $q.all({currentUser:spfAuthData.user().catch(noop$6),profile:profilePromise,cohort:cohortPromise,canView:canviewPromise,announcements:clmDataStore.cohorts.getAnnouncements(cohortId),events:clmDataStore.events.listAll(),joinedEvents:clmDataStore.events.listJoinedEventsObj(),createdEvents:clmDataStore.events.listCreatedEvents()});}function ViewCohortCtrl($log,$scope,initialData,$document,$mdDialog,$route,$firebaseObject,spfAlert,urlFor,firebaseApp,spfAuthData,spfNavBarService,clmDataStore,$firebaseArray){var self=this;var db=firebaseApp.database();var monitorHandler;this.currentUser=initialData.currentUser;this.cohort=initialData.cohort;this.participants=initialData.participants;this.profile=initialData.profile;this.announcements=initialData.announcements;this.events=initialData.events;this.isOwner=false;this.joinedEvents=initialData.joinedEvents;this.createdEvents=initialData.createdEvents;this.selectedEvent=null;this.eventChallenges=null;this.selectedAction=null;// this.taskType = null;
//
// //deciding what tasktype this is
// this.updateTaskType = function(){
//     if (this.eventChallenges.serviceId) {
//         this.taskType = 'Service/Badge/Problem';
//
//     } else if (this.eventChallenges.linkPattern) {
//         this.taskType = 'Link Pattern';
//
//     } else if (this.eventChallenges.lang) {
//         this.taskType = 'Code';
//
//     } else if (this.eventChallenges.toEdit) {
//         this.taskType = 'Profile Edit';
//
//     } else if (this.eventChallenges.textResponse) {
//         this.taskType = 'Text Response';
//
//     } else if (this.eventChallenges.mcqQuestions) {
//         this.taskType = 'Multiple Choice';
//
//     } else if (this.eventChallenges.survey) {
//         this.taskType = 'Survey';
//
//     } else if (this.eventChallenges.teamFormationMethod) {
//         this.taskType = 'Team Activities';
//     }
// }
if(self.cohort&&self.cohort.owner&&self.cohort.owner.publicId&&self.currentUser&&self.cohort.owner.publicId===self.currentUser.publicId){this.isOwner=true;}updateNavbar();function updateNavbar(){spfNavBarService.update(self.cohort.title,{title:'Cohorts',url:'#'+urlFor('cohorts')},getOptions());}function getOptions(){var options=[];if(!self.currentUser||!self.currentUser.publicId){return options;}// Add edit button
if(self.cohort.owner.publicId===self.currentUser.publicId){options.push({title:'Edit This Cohort',url:'#'+urlFor('editCohort',{cohortId:self.cohort.$id}),icon:'create'});}return options;}this.loadEventChallenges=function(){var ref=db.ref('classMentors/eventTasks/'+self.selectedEvent);var obj=$firebaseObject(ref);obj.$loaded().then(function(){self.eventChallenges=obj;}).catch(function(err){$log.error(err);});};this.duplicateChallenges=function(){self.selectedChallenge.archived=false;delete self.selectedChallenge.$$mdSelectId;// console.log("selected events are ",self.selectedEvents);
// console.log("selected challenge is ", self.selectedChallenge);
var eventIndex=0;insertChallenge();function insertChallenge(){if(eventIndex<self.selectedEvents.length){var eventId=self.selectedEvents[eventIndex];clmDataStore.events.addTask(eventId,self.selectedChallenge,true).then(function(){console.log(self.selectedChallenge.title+" inserted into "+eventId+".");eventIndex++;}).then(function(){insertChallenge();}).catch(function(err){$log.error(err);return err;});}else{spfAlert.success(self.selectedChallenge.title+" inserted into selected events.");self.selectedEvent=null;self.selectedChallenge=null;self.selectedEvents=null;}}};this.viewFullAnnouncement=function(content,title){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:'<md-dialog aria-label="Announcement dialog" class="announcement-dialog">'+'  <md-dialog-content class="sticky-container">'+'<md-subheader class="md-sticky-no-effect">{{ctrl.title}}</md-subheader>'+'    <div style="white-space: pre-wrap;">{{ctrl.content}}</div>'+'  </md-dialog-content>'+'  <md-dialog-actions>'+'    <md-button ng-click="ctrl.closeDialog()" class="md-primary">'+'      Close'+'    </md-button>'+'  </md-dialog-actions>'+'</md-dialog>',controller:viewAnnouncementController,controllerAs:'ctrl'});function viewAnnouncementController(){this.content=content;this.title=title;this.closeDialog=function(){$mdDialog.hide();};}};this.userQuery='';this.foundUsers=null;this.startManageAsst=function(){self.selectedAction='cohortAsst';};this.findUsers=function(){var ref=db.ref('classMentors/userProfiles').orderByChild('user/displayName').startAt(self.userQuery).endAt(self.userQuery);var data=$firebaseArray(ref);data.$loaded().then(function(result){self.foundUsers=result;console.log(self.foundUsers);});};this.assignCohortAssistant=function(user){var asst={name:user.user.displayName,canEdit:true,canReview:true};var assistantId=user.$id;for(var event in self.cohort.events){var eventId=self.cohort.events[event];clmDataStore.events.addAssistant(eventId,assistantId,asst);};spfAlert.success('Added assistant.');this.foundUsers=null;};//
// function promptPassword() {
//     if (
//         self.event.schoolEvent && (
//             !self.profile ||
//             !self.profile.user ||
//             !self.profile.user.school
//         )
//     ) {
//         spfAlert.warning(
//             'Only Students from Singapore can join this event. ' +
//             'Maybe you profile needs to be updated.');
//         return;
//     }
//     $mdDialog.show({
//         parent: $document.body,
//         template: passwordTmpl,
//         controller: DialogController,
//         controllerAs: 'ctrl'
//     });
//
//     function DialogController() {
//         this.pw = '';
//
//         this.join = function(pw) {
//             clmDataStore.events.join(self.event, pw).then(function() {
//                 spfAlert.success('You joined this event');
//                 $mdDialog.hide();
//                 $route.reload();
//             }).catch(function(err) {
//                 spfAlert.error(`Failed to add you: ${err}`);
//             });
//         };
//
//         this.closeDialog = function() {
//             $mdDialog.hide();
//         };
//     }
// }
//
// function cleanProfile(currentUser) {
//     currentUser.country = cleanObj(currentUser.country);
//     currentUser.school = cleanObj(currentUser.school);
// }
//
// this.register = function(currentUser) {
//     cleanProfile(currentUser);
//     spfAuthData.publicId(currentUser).then(function() {
//         spfAlert.success('Public id and display name saved');
//         return clmDataStore.initProfile();
//     }).then(function() {
//         $route.reload();
//     }).catch(function(err) {
//         spfAlert.error('Failed to save public id');
//         return err;
//     });
// };
//
// this.removeParticipant = function(e, event, participant) {
//     var confirm = $mdDialog.confirm()
//         .parent($document.body)
//         .title(`Would you like to remove ${participant.user.displayName}?`)
//         .content('The participant progress will be kept but he/she will not show as participant')
//         .ariaLabel('Remove participant')
//         .ok('Remove')
//         .cancel('Cancel')
//         .targetEvent(e);
//
//     $mdDialog.show(confirm).then(function() {
//         clmDataStore.events.removeParticpants(event.$id, participant.$id);
//     });
// };
}/**
 * Used to resolve `initialData` for `EditCtrl`
 *
 */function editCohortCtrlInitialData($q,$route,spfAuthData,clmDataStore){var data=baseEditCtrlInitialData$1($q,$route,spfAuthData,clmDataStore);return $q.all(data);}function EditCohortCtrl(initialData,spfNavBarService,urlFor,spfAlert,clmDataStore){var self=this;// console.log("initial data ", initialData);
this.currentUser=initialData.currentUser;this.eventsArr=initialData.eventsArr;this.events=initialData.events;this.cohort=initialData.cohort;this.announcements=initialData.announcements;this.savingCohort=false;this.creatingNewAnnouncement=false;this.newAnnouncement={};this.showingEvents=true;this.showingAnnouncements=true;this.addingEvent=false;// For searching events
this.mappedEvents=mapAllEvents();this.selectedEvent=null;this.searchEvent=null;this.querySearch=querySearch;function querySearch(query){return query?self.mappedEvents.filter(createFilterFor(query)):self.mappedEvents;}function mapAllEvents(){return self.eventsArr.map(function(event){return{id:event.$id,value:event.title.toLowerCase(),title:event.title};});}function createFilterFor(query){var lowercaseQuery=angular.lowercase(query);return function filterFn(event){// to filter results based on query and ensure that user cannot select events already in the cohort
return event.value.indexOf(lowercaseQuery)>=0&&self.cohort.events.indexOf(event.id)<0;};}spfNavBarService.update('Edit',[{title:'Cohorts',url:'#'+urlFor('cohorts')},{title:this.cohort.title,url:'#'+urlFor('viewCohort',{cohortId:this.cohort.$id})}],[{title:'View this Cohort',url:'#'+urlFor('viewCohort',{cohortId:this.cohort.$id}),icon:'arrow-back'}]);// spfNavBarService.update(
//     {
//         title: 'View this Cohort',
//         url: `#${urlFor('viewCohort', {cohortId: this.cohort.$id})}`,
//         icon: 'arrow-back'
//     }
// );
console.log(this.cohort.events);this.removeCohortEvent=function(eventId,eventIndex){var newEventArray=self.cohort.events;newEventArray.splice(eventIndex,1);clmDataStore.cohorts.removeEvent(self.cohort.$id,newEventArray).then(function(){spfAlert.success('Removed event.');self.cohortEventLength=self.cohort.events.length*50;self.eventStyle={height:self.cohortEventLength+'px'};}).catch(function(err){spfAlert.error('Failed to remove event.');});};this.saveAddedEvent=function(){clmDataStore.cohorts.addEvent(self.cohort.$id,self.selectedEvent.id,self.cohort.events.length).then(function(){self.addingEvent=false;spfAlert.success(self.selectedEvent.title+' has been added to the cohort.');self.cohortEventLength=self.cohort.events.length*50;self.eventStyle={height:self.cohortEventLength+'px'};self.selectedEvent=null;}).catch(function(err){spfAlert.error('Failed to add '+self.selectedEvent.title+' to the cohort.');self.selectedEvent=null;});};this.addEvent=function(){self.addingEvent=true;};this.closeAddingEvent=function(){self.cohortEventLength=self.cohort.events.length*50;self.eventStyle={height:self.cohortEventLength+'px'};self.addingEvent=false;};this.toggleEvents=function(){if(self.showingEvents){self.cohortEventLength=0;self.eventStyle={height:self.cohortEventLength+'px'};self.showingEvents=false;}else{self.cohortEventLength=self.cohort.events.length*50;self.eventStyle={height:self.cohortEventLength+'px'};self.showingEvents=true;}self.addingEvent=false;// if(self.showingEvents) {
//     self.showingEvents = false;
// } else {
//     self.showingEvents = true;
// }
};this.toggleAnnouncements=function(){if(self.showingAnnouncements){self.annnouncementArrLength=0;self.announcementStyle={height:self.annnouncementArrLength+'px'};self.showingAnnouncements=false;}else{self.annnouncementArrLength=self.announcements.length*50;self.announcementStyle={height:self.annnouncementArrLength+'px'};self.showingAnnouncements=true;}self.creatingNewAnnouncement=false;// if(self.showingAnnouncements) {
//     self.showingAnnouncements = false;
// } else {
//     self.showingAnnouncements = true;
// }
};this.createNewAnnouncement=function(){self.creatingNewAnnouncement=true;self.newAnnouncement.featured=false;self.newAnnouncement.visible=true;};this.closeNewAnnouncement=function(){self.creatingNewAnnouncement=false;};this.save=function(currentUser,cohort,editCohortForm){self.savingCohort=true;cohort.owner.publicId=currentUser.publicId;cohort.owner.displayName=currentUser.displayName;cohort.owner.gravatar=currentUser.gravatar;return clmDataStore.cohorts.updateCohort(cohort).then(function(){spfAlert.success('Cohort saved.');editCohortForm.$setPristine(true);}).catch(function(){spfAlert.error('Failed to save cohort.');}).finally(function(){self.savingCohort=false;});};this.saveAnnouncement=function(cohortId){clmDataStore.cohorts.addAnnouncement(cohortId,this.currentUser,this.newAnnouncement,false).then(function(){self.creatingNewAnnouncement=false;spfAlert.success('Announcement created.');self.annnouncementArrLength=self.announcements.length*50;self.announcementStyle={height:self.annnouncementArrLength+'px'};}).catch(function(){spfAlert.error('Failed to create announcement.');}).finally(function(){self.newAnnouncement={};});};this.featureAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.featureAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement featured.');}).catch(function(){spfAlert.error('Failed to feature announcement.');});};this.unfeatureAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.unfeatureAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement un-featured.');}).catch(function(){spfAlert.error('Failed to un-feature announcement.');});};this.showAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.showAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement is now visible.');}).catch(function(){spfAlert.error('Failed to make announcement visible.');});};this.hideAnnouncement=function(cohortId,announcementId){clmDataStore.cohorts.hideAnnouncement(cohortId,announcementId).then(function(){spfAlert.success('Announcement is now hidden.');}).catch(function(){spfAlert.error('Failed to hide announcement');});};}function baseEditCtrlInitialData$1($q,$route,spfAuthData,clmDataStore){var errNoCohort=new Error('Cohort not found');var errNotAuthorized=new Error('You cannot edit this cohort');var cohortId=$route.current.params.cohortId;var cohortPromise=clmDataStore.cohorts.get(cohortId).then(function(cohort){if(cohort.$value===null){return $q.reject(errNoCohort);}return cohort;});var data={currentUser:spfAuthData.user(),announcements:clmDataStore.cohorts.getAnnouncements(cohortId),eventsArr:clmDataStore.events.listAllArr(),events:clmDataStore.events.listAll(),cohort:cohortPromise};data.canEdit=$q.all({currentUser:spfAuthData.user(),announcements:clmDataStore.cohorts.getAnnouncements(cohortId),cohort:cohortPromise}).then(function(result){if(!result.currentUser.publicId||!result.cohort.owner||!result.cohort.owner.publicId||result.cohort.owner.publicId!==result.currentUser.publicId){return $q.reject(errNotAuthorized);}return result;});return data;}function clmCohortsStatsPageFactory(){return{template:cohortStatsPageTmpl,restrict:'E',bindToController:true,scope:{cohort:'=',profile:'=',events:'='},controller:ClmCohortStatsPageCtrl,controllerAs:'ctrl'};}function ClmCohortStatsPageCtrl($scope,$q,$log,$mdDialog,$document,$firebaseArray,urlFor,spfAlert,firebaseApp,clmServicesUrl,clmDataStore,$firebaseObject){var self=this;var db=firebaseApp.database();this.selectedStatistic=null;this.participantAchievements={};this.badgesCount={codeCombat:{},freeCodeCamp:{},codeSchool:{},pivotalExpert:{}};this.loadRequest=false;this.loadingAchievements=false;this.numParticipants=0;this.numLoaded=0;this.generateReportCard=function(){self.badgesCount={codeCombat:{},freeCodeCamp:{},codeSchool:{},pivotalExpert:{}};self.loadRequest=true;self.loadingAchievements=true;var iter=0;loadParticipants();self.numParticipants=0;self.numLoaded=0;function loadParticipants(){var eventId=self.cohort.events[iter];if(iter<self.cohort.events.length){var eventParticipants=$firebaseArray(db.ref('classMentors/eventParticipants/'+eventId));eventParticipants.$loaded().then(function(){// console.log(eventParticipants);
for(var participantI in eventParticipants){var participant=eventParticipants[participantI];if(!self.participantAchievements[participant.$id]&&participant.$id!=undefined){fetchParticipantInfo(participant.$id);self.numParticipants++;}}iter++;loadParticipants();});}else{checkLoadFinish();}}function fetchParticipantInfo(participantId){var participantAchievement=$firebaseObject(db.ref('classMentors/userAchievements/'+participantId));participantAchievement.$loaded().then(function(){if(participantAchievement.services){self.participantAchievements[participantId]=participantAchievement.services;}self.numLoaded++;});}function checkLoadFinish(){if(self.numParticipants==self.numLoaded){console.log('All data loaded');transformData();}else{console.log('checking',self.numParticipants,self.numLoaded);setTimeout(checkLoadFinish,1000);}}//after fetching all the stuff, now isolate by pivotalExpert, freeCodeCamp, codeSchool, and codeCombat. Each node has an acheivements object and a totalAchievements value.
function transformData(){// console.log('TRANSFORM DATA CALLED');
var partsWithAchievements=Object.keys(self.participantAchievements);for(var user in partsWithAchievements){var userAchievements=self.participantAchievements[partsWithAchievements[user]];if(userAchievements.codeCombat&&userAchievements.codeCombat.achievements){var codeCombatAchievements=Object.keys(userAchievements.codeCombat.achievements);for(var a in codeCombatAchievements){var key=userAchievements.codeCombat.achievements[codeCombatAchievements[a]].name;if(self.badgesCount.codeCombat[key]){self.badgesCount.codeCombat[key]=self.badgesCount.codeCombat[key]+1;}else{self.badgesCount.codeCombat[key]=1;}}}if(userAchievements.pivotalExpert&&userAchievements.pivotalExpert.achievements){var pivotalExpertAchievements=Object.keys(userAchievements.pivotalExpert.achievements);for(var _a in pivotalExpertAchievements){var _key=userAchievements.pivotalExpert.achievements[pivotalExpertAchievements[_a]].name;if(self.badgesCount.pivotalExpert[_key]){self.badgesCount.pivotalExpert[_key]=self.badgesCount.pivotalExpert[_key]+1;}else{self.badgesCount.pivotalExpert[_key]=1;}}}if(userAchievements.freeCodeCamp&&userAchievements.freeCodeCamp.achievements){var freeCodeCampAchievements=Object.keys(userAchievements.freeCodeCamp.achievements);for(var _a2 in freeCodeCampAchievements){var _key2=userAchievements.freeCodeCamp.achievements[freeCodeCampAchievements[_a2]].name;if(self.badgesCount.freeCodeCamp[_key2]){self.badgesCount.freeCodeCamp[_key2]=self.badgesCount.freeCodeCamp[_key2]+1;}else{self.badgesCount.freeCodeCamp[_key2]=1;}}}if(userAchievements.codeSchool&&userAchievements.codeSchool.achievements){var codeSchoolAchievements=Object.keys(userAchievements.codeSchool.achievements);for(var _a3 in codeSchoolAchievements){var _key3=userAchievements.codeSchool.achievements[codeSchoolAchievements[_a3]].name;if(self.badgesCount.codeSchool[_key3]){self.badgesCount.codeSchool[_key3]=self.badgesCount.codeSchool[_key3]+1;}else{self.badgesCount.codeSchool[_key3]=1;}}}}self.badgesCount.codeCombatA=Object.keys(self.badgesCount.codeCombat).map(function(k){return{'name':k,'count':self.badgesCount.codeCombat[k]};});self.badgesCount.pivotalExpertA=Object.keys(self.badgesCount.pivotalExpert).map(function(k){return{'name':k,'count':self.badgesCount.pivotalExpert[k]};});self.badgesCount.codeSchoolA=Object.keys(self.badgesCount.codeSchool).map(function(k){return{'name':k,'count':self.badgesCount.codeSchool[k]};});self.badgesCount.freeCodeCampA=Object.keys(self.badgesCount.freeCodeCamp).map(function(k){return{'name':k,'count':self.badgesCount.freeCodeCamp[k]};});self.badgesCount.codeCombatA.sort(function(a,b){return b.count-a.count;});self.badgesCount.pivotalExpertA.sort(function(a,b){return b.count-a.count;});self.badgesCount.codeSchoolA.sort(function(a,b){return b.count-a.count;});self.badgesCount.freeCodeCampA.sort(function(a,b){return b.count-a.count;});self.loadingAchievements=false;setTimeout(function(){$scope.$apply();},1);self.loadRequest=false;}};this.renderDashboard=function(){if(self.selectedStatistic){if(self.selectedStatistic=='Submission time series'){// How formatted data should look like
var dataObj={};var dataArr=[];//Axis data object
var axisParam={};//Initialise dataObj
for(var e=0;e<self.cohort.events.length;e++){dataObj[self.events[self.cohort.events[e]].title+"_x"]=[];dataObj[self.events[self.cohort.events[e]].title]=[];axisParam[self.events[self.cohort.events[e]].title]=self.events[self.cohort.events[e]].title+"_x";}var actionsRef=db.ref('classMentors/userActions');var actionObj=$firebaseArray(actionsRef);actionObj.$loaded().then(function(){self.submissionLogs=actionObj;}).then(function(){for(var actionIndex=0;actionIndex<self.submissionLogs.length;actionIndex++){var logHolder=self.submissionLogs[actionIndex];if(self.cohort.events.indexOf(logHolder.eventId)>=0){dataObj[self.events[logHolder.eventId].title+"_x"].push(logHolder.timestamp);dataObj[self.events[logHolder.eventId].title].push(new Date(logHolder.timestamp).getHours()*60+new Date(logHolder.timestamp).getMinutes());}}}).then(function(){for(var obj in dataObj){var newArr=[obj];dataArr.push(newArr.concat(dataObj[obj]));}// console.log()
var chart=c3.generate({bindto:"#chart",data:{xs:axisParam,columns:dataArr,type:'scatter'},axis:{x:{label:'timestamp',tick:{format:function format(x){var a=new Date(x);var months=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];var year=a.getFullYear();var month=months[a.getMonth()];var date=a.getDate();var hour=a.getHours();var min=a.getMinutes();var sec=a.getSeconds();var time=date+' '+month+' '+year;return time;},fit:false}},y:{label:'Time of Action',tick:{format:function format(x){return Math.floor(x/60)+':'+x%60;},fit:false}}},point:{r:5},padding:{left:50,right:50}});}).catch(function(err){$log.error(err);});}}};}function clmCohortRankPageFactory(){return{template:cohortRankingPageTmpl,restrict:'E',bindToController:true,scope:{cohort:'=',profile:'='},controller:ClmCohortRankPageCtrl,controllerAs:'ctrl'};}function ClmCohortRankPageCtrl($q,$scope,$log,firebaseApp,$firebaseObject,$firebaseArray,clmDataStore,clmPagerOption){var self=this;var db=firebaseApp.database();var unwatchers=[];this.cohortEventData=[];this.cohortTotalParticipants=[];// console.log(self.cohort);
// *************************** Re-write code here ***************************
var iter=0;loadInitialData();function loadInitialData(){var oneEventData={};var eventId=self.cohort.events[iter];if(iter<self.cohort.events.length){var eventObj=$firebaseObject(db.ref('classMentors/events/'+eventId));eventObj.$loaded().then(function(){return oneEventData.title=eventObj.title;},function(err){oneEventData.participants=[];$log.error(err);}).then(function(){oneEventData.id=eventId;oneEventData.participants=[];oneEventData.qualifiedParticipants=[];self.cohortEventData.push(oneEventData);fetchParticipantInfo(eventId);iter++;loadInitialData();});}}function fetchParticipantInfo(eventId){var participantsArray=$firebaseArray(db.ref('classMentors/eventParticipants/'+eventId));participantsArray.$loaded().then(function(){return self.cohortEventData.find(function(e){return e.id==eventId;}).participants=participantsArray;}).then(function(){self.cohortTotalParticipants=self.cohortTotalParticipants.concat(participantsArray);var _loop=function _loop(participantIndex){// console.log("User " + participantsArray[participantIndex].$id + " from event " + eventId);
rankCodeCombat=true;// default to only Code Combat. 
rankFreeCodeCamp=false;if(self.cohort.rankedServices&&self.cohort.rankedServices.codeCombat){if(self.cohort.rankedServices.codeCombat==true){rankCodeCombat=true;}else{rankCodeCombat=false;}}if(self.cohort.rankedServices&&self.cohort.rankedServices.freeCodeCamp&&self.cohort.rankedServices.freeCodeCamp==true){rankFreeCodeCamp=true;}$firebaseObject(db.ref('classMentors/userProfiles/'+participantsArray[participantIndex].$id+'/services')).$loaded().then(function(result){//Both services supported
if(rankFreeCodeCamp&&result.freeCodeCamp&&result.freeCodeCamp.totalAchievements>=1&&rankCodeCombat&&result.codeCombat&&result.codeCombat.totalAchievements>=1){self.cohortEventData.find(function(e){return e.id==eventId;}).qualifiedParticipants.push({displayName:participantsArray[participantIndex].user.displayName,userId:participantsArray[participantIndex].$id,score:parseInt(result.freeCodeCamp.totalAchievements)+parseInt(result.codeCombat.totalAchievements)});}//Just freeCodeCamp
if(rankFreeCodeCamp&&result.freeCodeCamp&&result.freeCodeCamp.totalAchievements>=1&&(!rankCodeCombat||!result.codeCombat||result.codeCombat.totalAchievements<1)){self.cohortEventData.find(function(e){return e.id==eventId;}).qualifiedParticipants.push({displayName:participantsArray[participantIndex].user.displayName,userId:participantsArray[participantIndex].$id,score:result.freeCodeCamp.totalAchievements});}//Just Code Combat
if((!rankFreeCodeCamp||!result.freeCodeCamp||result.freeCodeCamp.totalAchievements<1)&&rankCodeCombat&&result.codeCombat&&result.codeCombat.totalAchievements>=1){self.cohortEventData.find(function(e){return e.id==eventId;}).qualifiedParticipants.push({displayName:participantsArray[participantIndex].user.displayName,userId:participantsArray[participantIndex].$id,score:result.codeCombat.totalAchievements});}self.cohortEventData.find(function(e){return e.id==eventId;}).qualifiedParticipants.sort(function(a,b){return b.score-a.score;});});};for(var participantIndex=0;participantIndex<participantsArray.length;participantIndex++){var rankCodeCombat;var rankFreeCodeCamp;_loop(participantIndex);}});}// *************************** END ***************************
// getAllEventData();
// this.cohortTotalParticipants = 0;
// this.showFilteredRanking = false;
//
// function getAllEventData() {
//     var iter = 0;
//     loopDBEvents();
//     function loopDBEvents() {
//         var oneEventData = {};
//         var eventId = self.cohort.events[iter];
//
//         if(iter < self.cohort.events.length) {
//             var participantsRef = db.ref(`classMentors/eventParticipants/${eventId}`);
//             var participantsQuery = participantsRef;
//             var participantsArray = $firebaseArray(participantsQuery);
//
//             participantsArray.$loaded().then(
//                 () => (oneEventData.participants = participantsArray),
//                 err => {
//                     oneEventData.participants = [];
//                     $log.error(err);
//                 }
//             ).then(function () {
//                 var eventRef = db.ref(`classMentors/events/${eventId}`);
//                 var eventObj = $firebaseObject(eventRef);
//
//                 eventObj.$loaded().then(function() {
//                     var result = eventObj;
//                     oneEventData.title = result.title;
//                     self.cohortTotalParticipants += oneEventData.participants.length;
//                     oneEventData.id = result.$id;
//                     oneEventData.userRanks = [];
//                     var userIndex = 0;
//                     loadUserAchievements();
//                     function loadUserAchievements() {
//                         if(userIndex < oneEventData.participants.length) {
//                             var participantRankingRef = db.ref(`classMentors/userProfiles/${oneEventData.participants[userIndex].$id}`);
//                             var participantRankingObj = $firebaseObject(participantRankingRef);
//                             participantRankingObj.$loaded().then(function () {
//                                 var rankingResult = participantRankingObj;
//                                 if(rankingResult.services && rankingResult.services.freeCodeCamp) {
//                                     oneEventData.userRanks.push({"user": rankingResult.user, "total": parseInt(rankingResult.services.freeCodeCamp.totalAchievements)});
//                                 } else {
//                                     oneEventData.userRanks.push({"user": rankingResult.user, "total": 0});
//                                 }
//                                 userIndex++;
//                                 loadUserAchievements();
//                             });
//                         } else {
//                             self.cohortEventData.push(oneEventData);
//                             iter++;
//                             loopDBEvents();
//                         }
//                     }
//                 });
//             });
//         }
//     }
// }
//
// this.fourEntryThreshold = 2;
// this.twoEntryThreshold = 12;
//
// this.filterRanking = function() {
//     if(self.showFilteredRanking) {
//         for(let eventId in self.cohortEventData) {
//             let event = self.cohortEventData[eventId];
//             let totalEventScore = 0;
//             for(let user in event.userRanks) {
//                 let rankObj = event.userRanks[user];
//                 if(rankObj.total) {
//                     totalEventScore += rankObj.total;
//                 }
//             }
//             self.cohortEventData[eventId].totalScore = totalEventScore;
//         }
//         self.cohortEventData.sort(function(a,b) {
//             return b.totalScore - a.totalScore;
//         });
//         for(let placing = 0; placing < self.fourEntryThreshold; placing++) {
//             let event = self.cohortEventData[placing];
//             if(event) {
//                 event.userRanks.sort(function (a,b) {
//                     return b.total - a.total;
//                 });
//                 if(event.userRanks[0]) {
//                     self.cohortEventData[placing].first = {"name": event.userRanks[0].user.displayName, "total": event.userRanks[0].total};
//                 }
//                 if(event.userRanks[1]) {
//                     self.cohortEventData[placing].second = {"name": event.userRanks[1].user.displayName, "total": event.userRanks[1].total};
//                 }
//                 if(event.userRanks[2]) {
//                     self.cohortEventData[placing].third = {"name": event.userRanks[2].user.displayName, "total": event.userRanks[2].total};
//                 }
//                 if(event.userRanks[3]) {
//                     self.cohortEventData[placing].fourth = {"name": event.userRanks[3].user.displayName, "total": event.userRanks[3].total};
//                 }
//             }
//         }
//         for(let placing = self.fourEntryThreshold; placing < self.twoEntryThreshold; placing ++) {
//             let event = self.cohortEventData[placing];
//             if(event) {
//                 event.userRanks.sort(function (a,b) {
//                     return b.total - a.total;
//                 });
//                 if(event.userRanks[0]) {
//                     self.cohortEventData[placing].first = {"name": event.userRanks[0].user.displayName, "total": event.userRanks[0].total};
//                 }
//                 if(event.userRanks[1]) {
//                     self.cohortEventData[placing].second = {"name": event.userRanks[1].user.displayName, "total": event.userRanks[1].total};
//                 }
//             }
//         }
//     } else {
//         self.cohortEventData.sort(function(a,b) {
//             return b.participants.length - a.participants.length;
//         });
//     }
// }
}function configRoute$3($routeProvider,routes){$routeProvider.when(routes.events,{template:listTmpl,controller:ClmListEvent,controllerAs:'ctrl',resolve:{initialData:classMentorsEventResolver}}).when(routes.newEvent,{template:newTmpl,controller:NewEventCtrl,controllerAs:'ctrl',resolve:{initialData:newEventCtrlInitialData}}).when(routes.oneEvent,{template:eventTmpl,controller:ViewEventCtrl,controllerAs:'ctrl',resolve:{initialData:viewEventCtrlInitialData}}).when(routes.editEvent,{template:editTmpl,controller:EditEventCtrl,controllerAs:'ctrl',resolve:{initialData:editEventCtrllInitialData}}).when(routes.addEventTask,{template:eventTaskFormTmpl,controller:AddEventTaskCtrl,controllerAs:'ctrl',resolve:{initialData:addEventTaskCtrlInitialData}}).when(routes.editEventTask,{template:eventTaskFormTmpl,controller:EditEventTaskCtrl,controllerAs:'ctrl',resolve:{initialData:editEventTaskCtrlInitialData}}).when('/events/:eventId/:taskId/survey1/:surveyTask',{template:schEngageScaleTmpl,controller:SurveyFormFillCtrl,controllerAs:'ctrl',resolve:{initialData:addSurveyEventTaskCtrlInitialData}}).when('/events/:eventId/:taskId/survey2/:surveyTask',{template:motiStratLearnTmpl,controller:SurveyFormFillCtrl,controllerAs:'ctrl',resolve:{initialData:addSurveyEventTaskCtrlInitialData}}).when('/events/:eventId/:taskId/survey3/:surveyTask',{template:eduDisLearnTmpl,controller:SurveyFormFillCtrl,controllerAs:'ctrl',resolve:{initialData:addSurveyEventTaskCtrlInitialData}});}//Create eventServiceFactory
//TODO: Edit
function eventServiceFactory($q,$route,spfAuthData,clmDataStore,$log,spfAlert){var self=this;var savedData={};var eventService={set:function set(data){savedData=data;},get:function get(){return savedData;},save:function save(event,_,task,taskType,isOpen){var copy=cleanObj(task);if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;clmDataStore.events.addTask(event.$id,copy,isOpen);// .then(function() {
// spfAlert.success('Challenge created');
// $location.path(urlFor('editEvent', {eventId: self.event.$id}));
// }).catch(function(err) {
//     $log.error(err);
//     spfAlert.error('Failed to created new challenge');
// }).finally(function() {
//     self.creatingTask = false;
// });
}};return eventService;}/**
 * Used to resolve `initialData` of `ClmListEvent`.
 *
 */function classMentorsEventResolver($q,spfAuth,spfAuthData,clmDataStore){return $q.all({events:clmDataStore.events.list(),auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(error){return error;}),profile:clmDataStore.currentUserProfile(),createdEvents:clmDataStore.events.listCreatedEvents(),joinedEvents:clmDataStore.events.listJoinedEvents()});}/**
 * ClmListEvent
 *
 */function ClmListEvent(initialData,spfNavBarService,urlFor){var opts=[];this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.events=initialData.events;this.createdEvents=initialData.createdEvents;this.joinedEvents=initialData.joinedEvents;this.auth=initialData.auth;if(this.profile&&this.profile.user&&this.profile.user.isPremium){opts.push({title:'New event',url:'#'+urlFor('newEvent'),icon:'add'});}spfNavBarService.update('Events',undefined,opts);}/**
 * Used to resolve `initialData` of `NewEventCtrl`.
 *
 */function newEventCtrlInitialData($q,spfAuth,spfAuthData,clmDataStore){var profilePromise;var loggedIn=spfAuth.requireLoggedIn().catch(function(){return $q.reject(new Error('The user should be logged in to create an event.'));});profilePromise=loggedIn.then(function(){return clmDataStore.currentUserProfile();}).then(function(profile){if(profile&&profile.$value===null){return clmDataStore.initProfile();}return profile;}).then(function(profile){if(!profile||!profile.user||!profile.user.isPremium){return $q.reject(new Error('Only premium users can create events.'));}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user(),profile:profilePromise});}/**
 * NewEventCtrl
 *
 */function NewEventCtrl($q,$location,initialData,urlFor,spfAuthData,spfAlert,spfNavBarService,clmDataStore){var self=this;this.auth=initialData.auth;this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.creatingEvent=false;this.profileNeedsUpdate=!this.currentUser.$completed();spfNavBarService.update('New Events',{title:'Events',url:'#'+urlFor('events')},[]);function cleanProfile(){self.currentUser.country=cleanObj(self.currentUser.country);self.currentUser.school=cleanObj(self.currentUser.school);}function updateProfile(profile){spfAlert.success('Profile setup.');self.profile=profile;self.profileNeedsUpdate=!self.currentUser.$completed();}//allow users to feature their event
this.featureEvent=true;this.toggle=function(){if(this.featureEvent){this.featureEvent=false;}else{this.featureEvent=true;}};this.save=function(currentUser,newEvent,password,featuredEvent){var next;self.creatingEvent=true;if(!self.profile){cleanProfile();next=spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved.');return clmDataStore.initProfile();}).then(updateProfile);}else if(self.profileNeedsUpdate){cleanProfile();next=self.currentUser.$save().then(function(){return clmDataStore.currentUserProfile();}).then(updateProfile);}else{next=$q.when();}next.then(function(){var data=Object.assign({owner:{id:currentUser.$id,publicId:currentUser.publicId,displayName:currentUser.displayName,gravatar:currentUser.gravatar},featured:featuredEvent,createdAt:{'.sv':'timestamp'}},newEvent);return clmDataStore.events.create(data,password);}).then(function(){spfAlert.success('New event created.');$location.path(urlFor('events'));}).catch(function(e){spfAlert.error(e.toString());}).finally(function(){self.creatingEvent=false;});};this.reset=function(eventForm){this.newEvent={data:{},password:''};if(eventForm&&eventForm.$setPristine){eventForm.$setPristine();}};this.reset();}/**
 * Used to resolve `initialData` of `ViewEventCtrl`.
 *
 */function viewEventCtrlInitialData($q,$route,spfAuth,spfAuthData,clmDataStore){var errNoEvent=new Error('Event not found-1');var eventId=$route.current.params.eventId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$7);var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var canviewPromise=$q.all({event:eventPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.event));});return $q.all({currentUser:spfAuthData.user().catch(noop$7),profile:profilePromise,event:eventPromise,canView:canviewPromise,tasks:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getTasks(eventId);}}),participants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.participants(eventId);}}),progress:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getProgress(eventId);}}),solutions:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getSolutions(eventId);}}),scores:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getScores(eventId);}}),assistants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getAssistants(eventId);}}),assistantObj:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getAsstObj(eventId);}})});}/**
 * ViewEventCtrl
 *
 */function ViewEventCtrl($scope,initialData,$document,$mdDialog,$route,spfAlert,urlFor,spfAuthData,spfNavBarService,clmDataStore,$sce){var self=this;var monitorHandler;this.event=initialData.event;this.currentUser=initialData.currentUser;this.participants=initialData.participants;this.profile=initialData.profile;this.tasks=initialData.tasks;this.loadingSolutions=true;this.progress=initialData.progress;this.solutions=initialData.solutions;this.scores=initialData.scores;this.canView=initialData.canView;this.viewArchived=false;this.selected=null;this.isOwner=false;this.assistants=initialData.assistants;this.assistantObj=initialData.assistantObj;this.asstArr=[];this.isReviewSuperUser=false;for(var _asst in self.assistants){if(self.assistants[_asst].$id){self.asstArr.push(self.assistants[_asst].$id);}}// console.log('Tasks: ', self.tasks);
// console.log('Solutions: ', self.solutions);
if(self.participants){this.hasSubmissions=self.participants.find(function(p){return p.$id==self.profile.$id;});}this.filteredTasks=self.tasks;this.taskQuery='';this.filterTaskSearch=function(){if(self.taskQuery.length>=1){self.filteredTasks=self.tasks.filter(function(task){return task.title.toLowerCase().indexOf(self.taskQuery.toLowerCase())>=0;});}else{self.filteredTasks=self.tasks;}};// this.solutions = clmDataStore.events.getSolutions(self.event.$id).then(function (solutions) {
//     console.log(solutions);
//     return solutions;
// }).then(function () {
//     monitorHandler = clmDataStore.events.monitorEvent(
//         self.event, self.tasks, self.participants, self.solutions, self.progress
//     );
// });
if(self.event&&self.event.owner&&self.event.owner.publicId&&self.currentUser&&self.event.owner.publicId===self.currentUser.publicId){monitorHandler=clmDataStore.events.monitorEvent(this.event,this.tasks,this.participants,this.solutions,this.progress);this.isOwner=true;}else{monitorHandler={update:noop$7,unwatch:noop$7};}if(self.event&&self.currentUser&&self.asstArr.indexOf(self.currentUser.publicId)>=0){monitorHandler=clmDataStore.events.monitorEvent(this.event,this.tasks,this.participants,this.solutions,this.progress);var asst=self.assistantObj[self.currentUser.publicId];if(asst.canReview){this.isReviewAssistant=true;}if(asst.canEdit){this.isEditAssistant=true;}}if(self.isReviewAssistant||self.isOwner){self.isReviewSuperUser=true;}$scope.$on('$destroy',function(){/* eslint no-unused-expressions: 0 */monitorHandler.unwatch();self.event&&self.event.$destroy&&self.event.$destroy();self.participants&&self.participants.$destroy&&self.participants.$destroy();self.profile&&self.profile.$destroy&&self.profile.$destroy();self.progress&&self.progress.$destroy&&self.progress.$destroy();self.solutions&&self.solutions.$destroy&&self.solutions.$destroy();});updateNavbar();function updateNavbar(){spfNavBarService.update(self.event.title,{title:'Events',url:'#'+urlFor('events')},getOptions());}function getOptions(){var options=[];if(!self.currentUser||!self.currentUser.publicId){return options;}// add join/leave button
if(self.participants&&self.participants.$indexFor(self.currentUser.publicId)>-1){options.push({title:'Leave Event',onClick:function onClick(){clmDataStore.events.leave(self.event.$id).then(function(){$route.reload();});},icon:'clear'});}else{options.push({title:'Join',onClick:promptPassword,icon:'add'});}// Add edit and update button
//self.event.owner.publicId === self.currentUser.publicId
if(self.isOwner||self.isEditAssistant){options.push({title:'Edit This Event',url:'#'+urlFor('editEvent',{eventId:self.event.$id}),icon:'create'});options.push({title:'Add New Challenge',url:'#'+urlFor('addEventTask',{eventId:self.event.$id}),icon:'add-circle-outline'});options.push({title:'Update',onClick:function onClick(){monitorHandler.update();},icon:'loop'});}return options;}function promptPassword(){if(self.event.schoolEvent&&(!self.profile||!self.profile.user||!self.profile.user.school)){spfAlert.warning('Only Students from Singapore can join this event. '+'Maybe your profile needs to be updated.');return;}$mdDialog.show({parent:$document.body,template:passwordTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.pw='';this.join=function(pw){clmDataStore.events.join(self.event,pw).then(function(){spfAlert.success('You joined this event.');$mdDialog.hide();$route.reload();}).catch(function(err){spfAlert.error('Failed to join event. Please ensure that your password is valid and try again.');console.log('Failed to add you: '+err);// spfAlert.error(`Failed to add you: ${err}`);
});};this.closeDialog=function(){$mdDialog.hide();};}}function cleanProfile(currentUser){currentUser.country=cleanObj(currentUser.country);currentUser.school=cleanObj(currentUser.school);}this.register=function(currentUser){cleanProfile(currentUser);spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved.');return clmDataStore.initProfile();}).then(function(){$route.reload();}).catch(function(err){spfAlert.error('Failed to save public id.');return err;});};this.removeParticipant=function(e,event,participant){var confirm=$mdDialog.confirm().parent($document.body).title('Would you like to remove '+participant.user.displayName+'?').content('The participant progress will be kept but he/she will not show as participant').ariaLabel('Remove participant').ok('Remove').cancel('Cancel').targetEvent(e);$mdDialog.show(confirm).then(function(){clmDataStore.events.removeParticpants(event.$id,participant.$id);});};this.loadSolutions=function(){self.loadingSolutions=true;console.log("loading solutions....");// self.solutions = clmDataStore.events.getSolutions(self.event.$id).then(function (solutions) {
//     console.log(solutions);
//     return solutions;
// }).then(self.loadingSolutions = false).then(
//     monitorHandler = clmDataStore.events.monitorEvent(
//         this.event, this.tasks, this.participants, this.solutions, this.progress
// ));
if(self.selected.teamFormationRef){this.loadingTeams=true;clmDataStore.events.getTeams(self.event.$id,self.selected.teamFormationRef).then(function(teams){self.teams=teams;// console.log(self.teams);
for(var index in self.teams){self.teams[index].number=parseInt(index)+1;if(self.teams[index].score){self.teams[index].score=self.scores[self.teams[index].teamLeader][self.selected.$id];}}}).finally(self.loadingTeams=false);}if(self.selected.type=='voteQuestions'){this.loadingTeams=true;clmDataStore.events.getTeams(self.event.$id,self.selected.taskFrom).then(function(teams){self.teams=teams;// console.log(self.teams);
for(var index in self.teams){self.teams[index].number=parseInt(index)+1;}}).then(function(){for(var teamIndex in self.teams){var team=self.teams[teamIndex];var members=Object.keys(team).filter(function(k){if(team[k]&&team[k].displayName){return k;}});if(members[0]){var qnInfo=angular.fromJson(self.solutions[members[0]][self.selected.$id]);self.teams[teamIndex].questions=qnInfo.map(function(obj){return{question:obj.answer,score:0,askedBy:obj.member};});// console.log(self.teams[teamIndex].questions);
for(var memberIndex in members){var member=members[memberIndex];var indvVotes=angular.fromJson(self.solutions[member][self.selected.$id]);for(var qnVoteIndex in indvVotes){var qnVote=indvVotes[qnVoteIndex];// console.log(qnVote);
self.teams[teamIndex].questions.find(function(x){return x.question==qnVote.answer;}).score+=qnVote.rank;};}self.teams[teamIndex].qnState=0;self.teams[teamIndex].questions.sort(function(a,b){return a.score-b.score;});}}}).finally(self.loadingTeams=false);}if(self.selected.mcqQuestions){self.selected.numQns=angular.fromJson(self.selected.mcqQuestions).length;}self.loadingSolutions=false;};this.submissionRouter=function(eventId,taskId,task,participant,userSolution){if(task.linkPattern){viewLink(eventId,taskId,task,participant,userSolution);}else if(task.lang){viewCodeResponse(eventId,taskId,task,participant,userSolution);}else if(task.textResponse){viewTextResponse(eventId,taskId,task,participant,userSolution);}else if(task.mcqQuestions){viewMultipleChoiceResponse(eventId,taskId,task,participant,userSolution);}else{console.log(task);}};function viewLink(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:linkTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.review=true;this.participant=participant;if(userSolution&&userSolution[taskId]){this.solution=$sce.trustAsResourceUrl(userSolution[taskId]);}this.save=function(link){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,link).then(function(){$mdDialog.hide();spfAlert.success('Link is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save the link.');return err;});};this.cancel=function(){$mdDialog.hide();};}}function viewMultipleChoiceResponse(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:mcqTmpl$1,controller:DialogController,controllerAs:'ctrl'});function DialogController(){var self=this;this.task=task;this.viewOnly=true;this.questions=angular.fromJson(task.mcqQuestions);this.isChecked=function(answers,index){if(answers){return answers.indexOf(index)>-1;}else{return false;}};this.show=function(answers){if(answers){return answers.length>1;}else{return false;}};// If userSolution is not null and userSolution given
// taskId is not null
if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}if(task.type=='TRAT'){clmDataStore.events.getMCQAnswers(eventId,task.taskFrom).then(function(answers){var userAnswers=angular.fromJson(answers.$value);for(var i=0;i<self.questions.length;i++){self.questions[i].answers=userAnswers[i];}});}else{var userAnswers=angular.fromJson(this.solution).userAnswers;for(var i=0;i<this.questions.length;i++){this.questions[i].answers=userAnswers[i];}}this.cancel=function(){$mdDialog.hide();};}}function getMCQModelAnswers(){}function viewTextResponse(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:responseTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.viewOnly=true;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(response){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});};this.cancel=function(){$mdDialog.hide();};}}function viewCodeResponse(eventId,taskId,task,participant,userSolution){console.log("2");$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,onComplete:loadEditor,controller:CodeController,controllerAs:'ctrl'});self.loadingEditor=true;var parent=self;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);editor.setOptions({readOnly:true,highlightActiveLine:false,highlightGutterLine:false});parent.loadingEditor=false;}function CodeController(){console.log("11");this.task=task;this.viewOnly=true;this.checkEditor=function(){return parent.loadingEditor;};if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(){var editor=ace.edit(document.querySelector('#editor'));var response=editor.getValue();// console.log("Function submitted for answer " + response);
clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});};this.cancel=function(){$mdDialog.hide();};}}}/**
 * Minimal resolver for `EditCtrl` and `AddEventTaskCtrl`.
 *
 * Load the event data and the current user data.
 *
 * The promise will resolved to an error if the the current user
 * is not the owner of the event.
 *
 */function baseEditCtrlInitialData$2($q,$route,spfAuthData,clmDataStore){var errNoEvent=new Error('Event not found-2');var errNotAuthaurized=new Error('You cannot edit this event');var eventId=$route.current.params.eventId;var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var data={currentUser:spfAuthData.user(),event:eventPromise,participants:clmDataStore.events.participants(eventId)};data.canEdit=$q.all({currentUser:spfAuthData.user(),event:eventPromise,assistants:clmDataStore.events.getAsstObj(eventId)}).then(function(result){if(!result.currentUser.publicId||!result.event.owner||!result.event.owner.publicId||result.event.owner.publicId!==result.currentUser.publicId){if(result.assistants[result.currentUser.publicId]){if(!result.assistants[result.currentUser.publicId].canEdit){return $q.reject(errNotAuthaurized);}}else{return $q.reject(errNotAuthaurized);}}return result;});return data;}/**
 * Used to resolve `initialData` for `EditCtrl`
 *
 */function editEventCtrllInitialData($q,$route,spfAuthData,clmDataStore){var data=baseEditCtrlInitialData$2($q,$route,spfAuthData,clmDataStore);data.tasks=data.event.then(function(event){return clmDataStore.events.getTasks(event.$id);});data.assistants=data.event.then(function(event){return clmDataStore.events.getAssistants(event.$id);});return $q.all(data);}/**
 * EditEventCtrl
 *
 */function EditEventCtrl(initialData,spfNavBarService,urlFor,spfAlert,clmDataStore,firebaseApp,$firebaseArray){var self=this;this.currentUser=initialData.currentUser;this.participants=initialData.participants;this.event=initialData.event;this.tasks=initialData.tasks;this.showingAssistants=false;this.showingTasks=true;this.nonArchivedTask=[];for(var i=0;i<this.tasks.length;i++){if(!this.tasks[i].archived){this.nonArchivedTask.push(this.tasks[i]);}}function updateNonArchivedTask(){var archived=[];for(var i=0;i<this.tasks.length;i++){if(!this.tasks[i].archived){archived.push(this.tasks[i]);}}this.nonArchivedTask=archived;};// console.log("this event id isss:", this.event.$id);
this.assistants=initialData.assistants;this.newPassword='';this.isOwner=false;this.savingEvent=false;//allow users to feature their events
//retrieve the current featured status
this.featureEvent=clmDataStore.events.getFeatured(this.event.$id);//set the selection by user
this.toggle=function(){if(this.featureEvent){this.featureEvent=false;}else{this.featureEvent=true;}clmDataStore.events.setFeatured(this.event.$id,this.featureEvent);if(this.featureEvent){spfAlert.success("You have featured your event.");}else{spfAlert.success("You have unfeatured your event.");}};if(self.event&&self.event.owner&&self.event.owner.publicId&&self.currentUser&&self.event.owner.publicId===self.currentUser.publicId){this.isOwner=true;}this.addingNewAssistant=false;this.newAssistant={canEdit:false,canReview:true};// Search form variables
this.users=mapAllUsers();this.selectedUser=null;this.searchUser=null;this.querySearch=querySearch;self.assistantArr=[];for(var asst in self.assistants){if(self.assistants[asst].$id){self.assistantArr.push(self.assistants[asst].$id);}}function querySearch(query){return query?self.users.filter(createFilterFor(query)):self.users;}function mapAllUsers(){return self.participants.map(function(user){return{id:user.$id,value:user.user.displayName.toLowerCase(),displayName:user.user.displayName};});}function createFilterFor(query){query=query||'';var lowercaseQuery=query.toLowerCase();return function filterFn(user){//Filter results in auto complete. Ensure that users who are already assistants may not be selected again
return user.value.indexOf(lowercaseQuery)>=0&&self.assistantArr.indexOf(user.id)<0;};}spfNavBarService.update('Edit',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})}],[{title:'View This Event',url:'#'+urlFor('oneEvent',{eventId:this.event.$id}),icon:'arrow-back'},{title:'Add New Challenge',url:'#'+urlFor('addEventTask',{eventId:this.event.$id}),icon:'add-circle-outline'}]);self.eventAssistantBttnText="View Event Assistants";this.toggleAssistants=function(){if(self.showingAssistants){self.assistantArrLength=0;self.divStyle={height:self.assistantArrLength+'px'};self.showingAssistants=false;self.eventAssistantBttnText="View Event Assistants";}else{if(self.isOwner){self.assistantArrLength=self.assistants.length*100;self.divStyle={height:self.assistantArrLength+'px'};self.showingAssistants=true;self.eventAssistantBttnText="Hide Event Assistants";}else{spfAlert.error('Only the event owner may manage assistants.');}}self.addingNewAssistant=false;};self.eventChallengeBttnText="Hide Challenges";this.toggleTaskEditView=function(){if(self.showingTasks){self.taskLength=0;self.taskStyle={height:self.taskLength+'px'};self.showingTasks=false;self.eventChallengeBttnText="View Challenges";}else{self.taskLength=this.nonArchivedTask.length*100;self.taskStyle={height:self.taskLength+'px'};self.showingTasks=true;self.eventChallengeBttnText="Hide Challenges";}};this.addAssistant=function(){self.addingNewAssistant=true;};this.enableReview=function(eventId,assistantId,assistantName){clmDataStore.events.enableAssistantReviewing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can now review event challenge submissions.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.disableReview=function(eventId,assistantId,assistantName){clmDataStore.events.disableAssistantReviewing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can no longer review event challenge submissions.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.enableEdit=function(eventId,assistantId,assistantName){clmDataStore.events.enableAssistantEditing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can now edit the event.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.disableEdit=function(eventId,assistantId,assistantName){clmDataStore.events.disableAssistantEditing(eventId,assistantId).then(function(){spfAlert.success(assistantName+' can no longer edit the event.');}).catch(function(){spfAlert.error('Failed to change assistant rights.');});};this.removeAssistant=function(eventId,assistantId,assistantName){clmDataStore.events.removeAssistant(eventId,assistantId).then(function(){spfAlert.success(assistantName+' removed as event assistant.');if(self.assistantArr.indexOf(assistantId)>=0){self.assistantArr.splice(assistantId,1);}self.assistantArrLength=self.assistants.length*100;self.divStyle={height:self.assistantArrLength+'px'};}).catch(function(){spfAlert.error('Failed to remove assistant.');});};this.saveNewAssistant=function(eventId){self.newAssistant.name=self.selectedUser.displayName;clmDataStore.events.addAssistant(eventId,self.selectedUser.id,self.newAssistant).then(function(){spfAlert.success(self.newAssistant.name+' added as event assistant.');self.assistantArrLength=self.assistants.length*100;self.divStyle={height:self.assistantArrLength+'px'};}).catch(function(){spfAlert.error('Failed to add assistant.');});self.addingNewAssistant=false;self.selectedUser=null;};this.closeNewAssistant=function(){self.addingNewAssistant=false;};this.save=function(currentUser,event,newPassword,editEventForm){self.savingEvent=true;event.owner.publicId=currentUser.publicId;event.owner.displayName=currentUser.displayName;event.owner.gravatar=currentUser.gravatar;return clmDataStore.events.updateEvent(event,newPassword).then(function(){spfAlert.success('Event saved.');self.newPassword='';editEventForm.$setPristine(true);}).catch(function(err){spfAlert.error('Failed to save event.');}).finally(function(){self.savingEvent=false;});};this.openTask=function(eventId,task){var taskId=task.$id;// console.log('The task id is : ',taskId);
clmDataStore.events.openTask(eventId,taskId).then(function(){assignTeamLeaders(eventId,task);spfAlert.success('Challenge opened.');}).catch(function(){spfAlert.error('Failed to open challenge.');});};this.closeTask=function(eventId,task){// What event is here.
// console.log(task);
var taskId=task.$id;clmDataStore.events.closeTask(eventId,taskId).then(function(){spfAlert.success('Challenge closed.');}).catch(function(){spfAlert.error('Failed to close challenge.');});};function assignTeamLeaders(eventId,task){if(task.teamFormationRef&&!task.coopSubmission){var db=firebaseApp.database();// console.log(task.teamFormationRef);
// console.log(eventId);
var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+task.teamFormationRef);ref.once("value").then(function(snapshot){snapshot.forEach(function(childSnapshot){// Assign team leader if it does not exists
var team=childSnapshot.val();// console.log(team);
if(!('teamLeader'in team)){var acc=[];//accumulator for team members.
console.log("assigned team is: ",team);for(var key in team){if(key!='currentSize'&&key!='maxSize'){acc.push(key);}}// If there are memebers in the team.
if(acc.length>0){// Randomly pick a value out of acc.
// console.log(acc);
var item=acc[Math.floor(Math.random()*acc.length)];// console.log(item);
// assign here.
var teamRef=ref.child(childSnapshot.key);// console.log(teamRef); // Sanity check here
teamRef.child('teamLeader').set(item);}}});});}}this.showTask=function(eventId,taskId){clmDataStore.events.showTask(eventId,taskId).then(function(){spfAlert.success('Challenge visible.');}).catch(function(){spfAlert.error('Failed to make challenge visible.');});};this.hideTask=function(eventId,taskId){clmDataStore.events.hideTask(eventId,taskId).then(function(){spfAlert.success('Challenge hidden.');}).catch(function(){spfAlert.error('Failed to make challenge hidden.');});};this.archiveTask=function(eventId,taskId){clmDataStore.events.archiveTask(eventId,taskId).then(function(){spfAlert.success('Challenge archived.');}).catch(function(){spfAlert.error('Failed to archive challenge.');}).finally(function(){updateNonArchivedTask();self.taskLength=this.nonArchivedTask.length*100;self.taskStyle={height:self.taskLength+'px'};});};}/**
 * AddEventTaskCtrl initial data
 *
 */function addEventTaskCtrlInitialData($q,$route,spfAuthData,clmDataStore){var data=baseEditCtrlInitialData$2($q,$route,spfAuthData,clmDataStore);data.badges=clmDataStore.badges.all();data.singPath=$q.all({paths:clmDataStore.singPath.paths(),levels:[],problems:[]});return $q.all(data);}/**
 * AddEventTaskCtrl
 *
 */function AddEventTaskCtrl(initialData,$location,$log,spfAlert,urlFor,spfNavBarService,clmDataStore,$mdDialog,$scope,eventService,clmSurvey){var self=this;this.event=initialData.event;this.badges=initialData.badges;this.isOpen=true;this.singPath=initialData.singPath;this.savingTask=false;this.task={archived:false,showProgress:true};this.enableBeta=true;var location;this.selectedMetaData=[];spfNavBarService.update('New Challenge',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);this.toggle=function(item,list){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}};this.exists=function(item,list){return list.indexOf(item)>-1;};this.loadLevels=function(selected){return clmDataStore.singPath.levels(selected.path.id).then(function(levels){self.singPath.levels=levels;});};this.loadProblems=function(selected){return clmDataStore.singPath.problems(selected.path.id,selected.level.id).then(function(problems){self.singPath.problems=problems;});};this.challengeRouteProvider=function(tasktype,task,isOpen){if(tasktype=='service'){console.log('service is clicked');return'Save';}else if(tasktype=='singPath'){console.log('singpath is clicked');return'Save';}else if(tasktype=='linkPattern'){console.log('linkPattern is clicked');return'Save';}else if(tasktype=='textResponse'){console.log('textResponse is clicked');return'Save';}else if(tasktype=='multipleChoice'){console.log('multipleChoice is clicked');location='/challenges/mcq';return'Continue';}else if(tasktype=='code'){console.log('code is clicked');return'Save';}else if(tasktype=='teamActivity'){console.log('teamActivity is clicked');location='/challenges/team-activity/create';return'Continue';}else if(tasktype=='journalling'){console.log('journalling is clicked');return'Continue';}else if(tasktype=='survey'){// console.log("clicked clmdataa: ", initialData.event);
clmSurvey.set(initialData.event.$id,initialData.event,task,tasktype,isOpen);// var obj = clmSurvey.get();
location='/challenges/survey/'+initialData.event.title+'/'+initialData.event.$id+'/'+JSON.stringify(task);return'Continue';}else if(tasktype==='profileEdit'){return'Save';}else if(tasktype==='mentoringActivity'){console.log("mentoring activity is clicked");location='/challenges/mentoring-activity/create';return'Continue';}else{return'Save';// by default should show 'save'
}};//this function double checks with user if he wishes to go back and discard all changes thus far
this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not save your challenge information').textContent('All of the information input will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Discard Challenge').cancel('Continue Editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:self.event.$id}));});};this.saveTask=function(event,taskId,task,taskType,isOpen){console.log(taskType);if(taskType==='profileEdit'){task.toEdit=self.selectedMetaData;task.textResponse="Placeholder";}var copy=cleanObj(task);console.log(copy);if(taskType==='code'){delete copy.linkPattern;delete copy.badge;}//check if user keys in http inside Link Pattern
var checkLinkPattern=copy.linkPattern;if(checkLinkPattern!=null){if(checkLinkPattern.indexOf("http:")>-1){checkLinkPattern=checkLinkPattern.replace("http:","https:");}copy.linkPattern=checkLinkPattern;}var data={taskType:taskType,isOpen:isOpen,event:event,task:task};if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;delete copy.textResponse;delete copy.lang;// console.log("it went here when create");
//check if user keys in http inside Link Pattern
var checkLinkPattern=copy.linkPattern;if(checkLinkPattern!=null){if(checkLinkPattern.indexOf("http:")>-1){checkLinkPattern=checkLinkPattern.replace("http:","https:");}copy.linkPattern=checkLinkPattern;}}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;if(taskType==='multipleChoice'||taskType==='journalling'||taskType==='survey'||taskType==='teamActivity'||taskType==='mentoringActivity'){delete task.textResponse;delete task.linkPattern;delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;delete copy.textResponse;delete copy.lang;var data={taskType:taskType,isOpen:isOpen,event:event,task:task};spfNavBarService.update('Challenge Details',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);eventService.set(data);$location.path(location);}else{clmDataStore.events.addTask(event.$id,copy,isOpen).then(function(){spfAlert.success('Challenge created.');$location.path(urlFor('editEvent',{eventId:self.event.$id}));}).catch(function(err){$log.error(err);spfAlert.error('Failed to created new challenge.');}).finally(function(){self.creatingTask=false;});}};}function clmSurveyTaskFactory(){var sharedData={};//console.log("it comes in here");
function set(eventId,event,task,tasktype,isOpen){sharedData.eventId=eventId;sharedData.event=event;sharedData.task=task;sharedData.taskType=tasktype;sharedData.isOpen=isOpen;//sharedData.currentUser = spfAuthData.user();
}function get(){return sharedData;}return{set:set,get:get};}/**
 * Used to resolve `initialData` of `EditEventTaskCtrl`.
 *
 */function editEventTaskCtrlInitialData($q,$route,spfAuthData,clmDataStore){var errNoEvent=new Error('Event not found-3');var errNoTask=new Error('Event not found-4');var errNotAuthaurized=new Error('You cannot edit this event');var eventId=$route.current.params.eventId;var taskId=$route.current.params.taskId;var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var taskPromise=eventPromise.then(function(){return clmDataStore.events.getTask(eventId,taskId).then(function(task){if(!task||task.$value===null){return $q.reject(errNoTask);}return task;});});return $q.all({currentUser:spfAuthData.user(),event:eventPromise,badges:clmDataStore.badges.all(),taskId:taskId,task:taskPromise,assistants:clmDataStore.events.getAsstObj(eventId)}).then(function(data){if(!data.currentUser.publicId||!data.event.owner||!data.event.owner.publicId||data.event.owner.publicId!==data.currentUser.publicId&&data.currentUser.publicId){if(data.assistants[data.currentUser.publicId]){if(!data.assistants[data.currentUser.publicId].canEdit){return $q.reject(errNotAuthaurized);}}else{return $q.reject(errNotAuthaurized);}}return data;});}/**
 * EditEventTaskCtrl
 *
 *//**Todo: enable edit to multiple choice, index card, etc. **/function EditEventTaskCtrl(initialData,spfAlert,urlFor,spfNavBarService,clmDataStore,eventService,$mdDialog,$location,clmSurvey){var self=this;self.edit=true;// console.log("the initialdata looks like this:", initialData);
this.event=initialData.event;this.badges=initialData.badges;this.taskId=initialData.taskId;this.task=initialData.task;this.taskTitle=initialData.task.title;// console.log(this.taskTitle);
this.isOpen=Boolean(this.task.openedAt);this.savingTask=false;this.enableBeta=true;var location;this.taskType=null;/**todo: append tasktype here **/if(this.task.serviceId){this.taskType='service';}else if(this.task.linkPattern){this.taskType='linkPattern';}else if(this.task.lang){this.taskType='code';}else if(this.task.toEdit){this.taskType='profileEdit';this.selectedMetaData=this.task.toEdit;// console.log(this.task.toEdit);
}else if(this.task.textResponse){this.taskType='textResponse';}else if(this.task.mcqQuestions){this.taskType='multipleChoice';}else if(this.task.survey){this.taskType='survey';}this.toggle=function(item,list){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}};this.exists=function(item,list){return list.indexOf(item)>-1;};// else if (this.task.profileEdit) {
//     return 'Save';
// }
// md-select badge list and the the ng-model are compared
// by reference.
if(this.task.badge&&this.task.badge.id&&this.badges[this.task.serviceId]&&this.badges[this.task.serviceId][this.task.badge.id]){this.task.badge=this.badges[this.task.serviceId][this.task.badge.id];}spfNavBarService.update(this.taskTitle,[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);this.challengeRouteProvider=function(){//console.log("task type passed in is",tasktype);
//console.log("this task type passed in is", this.taskType);
if(this.taskType=='service'){console.log('service is clicked');return'Save';}else if(this.taskType=='singPath'){console.log('singpath is clicked');return'Save';}else if(this.taskType=='linkPattern'){console.log('linkPattern is clicked');return'Save';}else if(this.taskType=='textResponse'){console.log('textResponse is clicked');return'Save';}else if(this.taskType=='multipleChoice'){console.log('multipleChoice is clicked');// console.log("this event url", urlFor('oneEvent', {eventId: this.event.$id}));
location="/challenges/mcq/edit";return'Continue';}else if(this.taskType=='code'){console.log('code is clicked');return'Save';}else if(this.taskType=='journalling'){console.log('journalling is clicked');return'Continue';}else if(this.taskType=='teamActivity'){console.log('teamActivity is clicked');location='/challenges/team-activity/edit';return'Continue';}else if(this.taskType==='profileEdit'){return'Save';}else if(this.taskType=='survey'){clmSurvey.set(this.event.$id,this.event,this.task,this.taskType,this.isOpen);var obj=clmSurvey.get();console.log("survey in edit is clicked");return'Continue';}else{return'Save';}};//this function double checks with user if he wishes to go back and discard all changes thus far
this.discardChanges=function(ev){var confirm=$mdDialog.confirm().title('You have not saved your changes').textContent('All of your changes will be discarded. Are you sure you want to continue?').ariaLabel('Discard changes').targetEvent(ev).ok('Discard my changes').cancel('Continue editing');$mdDialog.show(confirm).then(function(){// decided to discard data, bring user to previous page
$location.path(urlFor('editEvent',{eventId:self.event.$id}));});};this.saveTask=function(event,taskId,task,taskType,isOpen){var copy=cleanObj(task);console.log("this edit task is: ",task);var editedTask={archived:task.archived,description:task.description,priority:task.priority,showProgress:task.showProgress,title:task.title};var data={taskType:taskType,isOpen:isOpen,event:event,task:task};if(taskType==='linkPattern'){delete copy.badge;delete copy.serviceId;delete copy.singPathProblem;// console.log("it went here in edit");
//check if user keys in http inside Link Pattern
var checkLinkPattern=copy.linkPattern;if(checkLinkPattern!=null){if(checkLinkPattern.indexOf("http:")>-1){checkLinkPattern=checkLinkPattern.replace("http:","https:");}copy.linkPattern=checkLinkPattern;}}else if(copy.serviceId==='singPath'){delete copy.badge;if(copy.singPathProblem){copy.singPathProblem.path=cleanObj(task.singPathProblem.path);copy.singPathProblem.level=cleanObj(task.singPathProblem.level);copy.singPathProblem.problem=cleanObj(task.singPathProblem.problem);}}else{delete copy.singPathProblem;copy.badge=cleanObj(task.badge);}if(!copy.link){// delete empty link. Can't be empty string
delete copy.link;}self.creatingTask=true;if(taskType==='multipleChoice'||taskType==='journalling'||taskType==='survey'){var data={taskType:taskType,isOpen:isOpen,event:event,task:task};spfNavBarService.update({title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})},{title:'Challenges',url:'#'+urlFor('editEvent',{eventId:this.event.$id})}]);eventService.set(data);if(taskType==='survey'){location='/challenges/editSurvey/'+event.$id+'/'+taskId+'/'+JSON.stringify(editedTask);// editSurvey: '/challenges/survey/edit/:eventId/:taskId'
}console.log("location path is: ",location);$location.path(location);}else{self.savingTask=true;clmDataStore.events.updateTask(event.$id,taskId,copy).then(function(){if(isOpen&&task.openedAt||!isOpen&&task.closedAt){return;}else if(isOpen){return clmDataStore.events.openTask(event.$id,taskId);}return clmDataStore.events.closeTask(event.$id,taskId);}).then(function(){spfAlert.success('Challenge edited.');$location.path(urlFor('editEvent',{eventId:self.event.$id}));}).catch(function(){spfAlert.error('Failed to edit the challenge.');}).then(function(){self.savingTask=false;});}};}/**
 * Show event tasks and participants progress in a paged table.
 *
 */function clmEventTableFactory(){return{template:eventTableParticipantsTmpl,restrict:'E',bindToController:true,scope:{event:'=',profile:'=',participants:'=',tasks:'=',progress:'=',solutions:'='},controller:ClmEventTableCtrl,controllerAs:'ctrl'};}function ClmEventTableCtrl($scope,$q,$log,$mdDialog,$document,urlFor,spfAlert,clmServicesUrl,clmDataStore,clmPagerOption,eventService,$location,routes,$route,spfAuthData,authFirebaseApp,firebaseApp,$firebaseArray,$firebaseObject,$routeParams){var authDb=authFirebaseApp.database();var self=this;var unwatchers=[];this.currentUserParticipant=undefined;this.participantsView=[];this.visibleTasks=[];this.taskCompletion={};this.eventTeams=[];this.orderOptions={key:undefined,reversed:false};this.saveDisabled=false;// Load 'team leaders' of each member.
// self.teamLeaders = null;
// self.team = null;
var teamByTask=null;var eventId=$routeParams.eventId;// var teamByUsers = {};
var allEventTeams=clmDataStore.events.getEventTeams(eventId).then(function(result){//get all the tasks wif teams belonging to a single event
teamByTask=result;return result;});var taskByEvent=null;var allEvents=clmDataStore.events.getTasksAsObject(eventId).then(function(result){taskByEvent=result;return result;});var solutionByTask=null;var allEventSolutions=clmDataStore.events.getSolutions(eventId).then(function(result){solutionByTask=result;return result;});var allTeamsByEvent=null;var eventTeamObj=clmDataStore.events.getEventTeamsObj(eventId).then(function(result){allTeamsByEvent=result;return result;});self.team={};self.applied=false;//display team leader
self.checkUser=function(taskId,currentUserId){// console.log("taskId is:", taskId)
if(teamByTask!=null){for(var i=0;i<teamByTask.length;i++){if(teamByTask[i].$id!=undefined&&teamByTask[i].$id==taskId){for(name in teamByTask[i]){if(name!='$id'&&name!='$priority'){if(teamByTask[i][name][currentUserId]!=null){self.team[taskId]=teamByTask[i][name];// console.log("team leader is:", self.team[taskId].teamLeader);
}}}}}}if(Object.keys(self.team).length!=0){return true;}else{return false;}// return Object.keys(self.team).length != 0;
};// self.isTeamLeader = function (eventId, teamFormationId, currentUserId) {
// var db = firebaseApp.database();
// var teamRef = db.ref(`classMentors/eventTeams/${eventId}`);
// teamRef.once("value")
//     .then(function(snapshot){
//         snapshot.forEach(function(childSnapShot){
//             var team = childSnapShot.val();
//             if(team[currentUserId.$id] != null){
//                 self.team = team;
//                 self.teamLeader = team.teamLeader;
//                 // Break execution.
//                 return true;
//             }
//         })
//     });
// };
//Find superReviewUser rights
// console.log(self.profile);
this.isReviewSuperUser=false;if(self.event.owner.publicId==self.profile.$id){self.isReviewSuperUser=true;}if(self.event.assistants){if(self.event.assistants[self.profile.$id]){if(self.event.assistants[self.profile.$id].canReview){self.isReviewSuperUser=true;}}}this.pagerOptions=clmPagerOption();unwatchers.push(self.pagerOptions.$destroy.bind(self.pagerOptions));/**
     * Get current user participant row
     */function currentUserParticipant(){if(!self.participants||!self.participants.$getRecord||!self.profile||!self.profile.$id){self.currentUserParticipant=undefined;}self.currentUserParticipant=self.participants.$getRecord(self.profile.$id);}/**
     * Set list of visible tasks and the % completion.
     *
     */function visibleTasks(){if(!self.tasks||!self.tasks.filter){self.visibleTasks=[];return;}self.visibleTasks=self.tasks.filter(function(t){return!t.hidden&&!t.archived;});taskCompletion();}/**
     * Calculate all visible tasks completion rate.
     *
     */function taskCompletion(){self.taskCompletion=self.visibleTasks.reduce(function(all,task){all[task.$id]=_taskCompletion(task.$id);return all;},{});}/**
     * Return the completion rate of a task.
     *
     */function _taskCompletion(taskId){var participantCount,participantsIds;if(!self.participants||!self.progress){return 0;}participantCount=self.participants.length;participantsIds=self.participants.reduce(function(all,participant){if(participant.$id){all[participant.$id]=true;}return all;},{});if(participantCount<1){return 0;}return Object.keys(self.progress).filter(function(publicId){return participantsIds[publicId]&&// Make sure user is still participating
// (user progress is kept when they leave)
self.progress[publicId]&&self.progress[publicId][taskId]&&self.progress[publicId][taskId].completed;}).length/participantCount*100;}function _completionComparer(options){var taskId=options.key;return function(a,b){var aP=self.progress&&self.progress[a.$id]&&self.progress[a.$id][taskId]&&self.progress[a.$id][taskId].completed;var bP=self.progress&&self.progress[b.$id]&&self.progress[b.$id][taskId]&&self.progress[b.$id][taskId].completed;if(aP===bP){return 0;}else if(aP){return 1;}return-1;};}function _solutionComparer(options){var taskId=options.key;var task=self.tasks.$getRecord(taskId);if(!task||!task.textResponse&&!task.linkPattern&&task.type!='formTeam'&&task.type!='mentorAssignment'){return noop$7;}return function(a,b){var aS=self.solutions&&self.solutions[a.$id]&&self.solutions[a.$id][taskId]||'';var bS=self.solutions&&self.solutions[b.$id]&&self.solutions[b.$id][taskId]||'';return aS.localeCompare(bS);};}function _compareName(a,b){var aN=a.user&&a.user.displayName||'';var bN=b.user&&b.user.displayName||'';return aN.localeCompare(bN);}function sortedParticipants(participants,options){var rows=participants.filter(function(p){return p.$id!==self.profile.$id;});var comparer;if(options.key){comparer=chainComparer([_completionComparer(options),_solutionComparer(options),_compareName]);}else{comparer=_compareName;}rows.sort(reverseComparer(options.reversed,comparer));return rows;}// Update the pager rowCount
// (the pager should trigger a range update which will call participantsView)
function updateParticipantRowCount(){currentUserParticipant();if(self.currentUserParticipant){self.pagerOptions.setRowCount(self.participants.length-1);}else{self.pagerOptions.setRowCount(self.participants.length);}}/**
     * Set the slice of participant to show.
     *
     */function participantsView(){var rows=sortedParticipants(self.participants,self.orderOptions);self.participantsView=rows.slice(self.pagerOptions.range.start,self.pagerOptions.range.end);}/**
     * Switch ordering key or ordering direction.
     *
     * If the ordering key is changing, the ordering direction should be
     * ascendent.
     *
     * If the order key is not changing, the direction should be switched.
     *
     */this.orderBy=function(taskId){self.orderOptions.reversed=!self.orderOptions.reversed&&self.orderOptions.key===taskId;self.orderOptions.key=taskId;participantsView();};function defaultLinker(task,serviceProfile){if(!serviceProfile||!serviceProfile.details||!serviceProfile.details.id||!task||!task.badge||!task.badge.url){return'#'+urlFor('editProfile');}return task.badge.url;}var linkers={codeSchool:defaultLinker,codeCombat:defaultLinker,singPath:function singPath(task){if(!task||task.serviceId!=='singPath'){return'';}if(!task.singPathProblem||!task.singPathProblem.path||!task.singPathProblem.path.id||!task.singPathProblem.level||!task.singPathProblem.level.id||!task.singPathProblem.problem||!task.singPathProblem.problem.id){return clmServicesUrl.singPath;}return(clmServicesUrl.singPath+'/#'+'/paths/'+task.singPathProblem.path.id+'/levels/'+task.singPathProblem.level.id+'/problems/'+task.singPathProblem.problem.id+'/play').replace(/\/+/,'/');}};this.startLink=function(task,profile){var serviceProfile;if(!task||!task.serviceId||!linkers[task.serviceId]){return'';}serviceProfile=profile&&profile.services&&profile.services[task.serviceId];return linkers[task.serviceId](task,serviceProfile);};var trackedServices={codeSchool:true,codeCombat:true};this.logClick=function(taskId,url){console.log("logging click...");var logObj={action:'moreDetails',taskId:taskId,eventId:self.event.$id,helpLink:url,publicId:self.currentUserParticipant.$id};clmDataStore.logging.inputLog(logObj);};this.startMCQ=function(eventId,taskId,task,participant,userSolution){// console.log("participant isss:", participant);
$location.path('/events/'+eventId+'/challenges/'+taskId+'/mcq/start');};this.startTRAT=function(eventId,taskId,task,participant){var data={eventId:eventId,taskId:taskId,task:task,participant:participant};// Store data in eventService
eventService.set(data);$location.path('/events/'+eventId+'/challenges/'+taskId+'/TRAT/start');};this.mustRegister=function(task,profile){return Boolean(task&&task.serviceId&&trackedServices[task.serviceId]&&(!profile||!profile.services||!profile.services[task.serviceId]||!profile.services[task.serviceId].details||!profile.services[task.serviceId].details.id));};this.editProfileInfo=function(eventId,taskId,task,participant){// console.log(task);
$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:editProfileTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){var self=this;this.task=task;this.yearOpts=['born before 1990'];this.userData={};for(var y=1991;y<=2011;y++){self.yearOpts.push(y);}clmDataStore.getProfileData(participant.$id).then(function(promise){return promise;}).then(function(data){self.participantInfo=data;// console.log(self.participantInfo);
if(self.participantInfo.yearOfBirth){self.userData.yearOfBirth=self.participantInfo.yearOfBirth;}if(self.participantInfo.school){self.userData.school=self.participantInfo.school;}}).catch(function(err){$log.error(err);return err;});clmDataStore.getSchools().then(function(promise){return promise;}).then(function(data){self.schools=data;}).catch(function(err){$log.error(err);return err;});this.camelText=function(input){return input.replace(/(?:^\w|[A-Z]|\b\w)/g,function(letter,index){return index==0?letter.toLowerCase():letter.toUpperCase();}).replace(/\s+/g,'');};this.save=function(){self.userData.displayName=self.participantInfo.displayName;self.userData.gravatar=self.participantInfo.gravatar;if(!self.userData.yearOfBirth){self.userData.yearOfBirth=self.participantInfo.yearOfBirth;}else{spfAuthData.user().then(function(data){var ref=authDb.ref('auth/users/'+data.$id+'/yearOfBirth');return ref.set(self.userData.yearOfBirth);}).catch(noop$7);}if(!self.userData.school){self.userData.school=self.participantInfo.school;}else{spfAuthData.user().then(function(data){var ref=authDb.ref('auth/users/'+data.$id+'/school');ref.set(cleanObj(self.userData.school));});}// if(!self.userData.country) {
//     self.userData.country = self.participantInfo.country;
// }
self.userData.publicId=participant.$id;clmDataStore.events.submitSolution(eventId,taskId,participant.$id,JSON.stringify(self.userData)).then(function(){}).catch(function(err){$log.error(err);spfAlert.error('Failed to register submission.');return err;});clmDataStore.updateProfile(self.userData).then(function(){$mdDialog.hide();spfAlert.success('Profile updated.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to update your profile.');return err;});// if(self.userData.school) {
//     spfFirebase.set(['auth/users'], actionObj);
// }
};this.cancel=function(){$mdDialog.hide();};}};this.promptForLink=function(eventId,taskId,task,participant,userSolution){task.team=self.team[task.teamFormationRef];$mdDialog.show({parent:$document.body,template:linkTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(link){if(link.indexOf("http:")>-1){link=link.replace("http:","https:");}if(task.team){console.log('SUBMIT FOR THE TEAM!');Object.keys(task.team).forEach(function(key){if(task.team[key].displayName){// console.log('Submitting for: ' + key);
clmDataStore.events.submitSolution(eventId,taskId,key,link);}});$mdDialog.hide();spfAlert.success('Link is saved.');clmDataStore.logging.inputLog({action:"submitTeamLinkResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,members:Object.keys(task.team).filter(function(key){if(task.team[key].displayName){return key;}}),timestamp:TIMESTAMP$1});}else{clmDataStore.events.submitSolution(eventId,taskId,participant.$id,link).then(function(){$mdDialog.hide();spfAlert.success('Link is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save the link.');return err;});clmDataStore.logging.inputLog({action:"submitLinkResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});if(task.type&&task.type=='linkPatternMentoring'){if(self.solutions[self.currentUserParticipant.$id]&&self.solutions[self.currentUserParticipant.$id][task.mentorAssignmentRef]){}else{assignMentorPairing(taskId,task.mentorAssignmentRef,self.profile.$id,task.mentorAssignmentMethod);}}}};this.cancel=function(){$mdDialog.hide();};}};this.promptForReviewQuestion=function(eventId,taskId,task,participant,userSolution){var db=firebaseApp.database();$mdDialog.show({parent:$document.body,template:reviewQuestionTmpl,controller:DialogController,controllerAs:'ctrl',resolve:{initialData:reviewQuestionIntitalData}});function reviewQuestionIntitalData(){//Get user's question
var eventReviewTaskRef=db.ref('classMentors/eventTasks/'+eventId+'/'+taskId);var userQuestion=$firebaseObject(eventReviewTaskRef).$loaded(function(promise){var votingTaskRef=db.ref('classMentors/eventTasks/'+eventId+'/'+promise.taskFrom);return $firebaseObject(votingTaskRef);}).then(function(promise){var formTeamTaskRef=db.ref('classMentors/eventTasks/'+eventId+'/'+promise.taskFrom);return $firebaseObject(formTeamTaskRef);}).then(function(promise){var questionTaskRef=db.ref('classMentors/eventSolutions/'+eventId+'/'+participant.$id+'/'+promise.taskFrom);return $firebaseObject(questionTaskRef);});return $q.all({userQuestion:userQuestion});}function DialogController(initialData,$mdDialog){var self=this;self.answer=null;self.userQuestion=initialData.userQuestion.$value;//'No question found';
self.options=[{text:"Instructor answered it"},{text:"Teaching Assistants answered it"},{text:"Figured it out on my own or answered by peers"},{text:"My question was not answered and I need help"}];self.submit=function(){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,angular.toJson(self.options[self.answer])).then(function(){clmDataStore.logging.inputLog({action:'setAskedQuestionStatus',eventId:eventId,taskId:taskId,publicId:participant.$id,timestamp:Date.now()});spfAlert.success('Response is saved.');$mdDialog.hide();});};self.cancel=function(){$mdDialog.hide();};}DialogController.$inject=['initialData','$mdDialog'];};this.promptForVoteQuestion=function(eventId,taskId,task,participant,userSolution){var db=firebaseApp.database();$mdDialog.show({parent:$document.body,template:voteQuestionTmpl,controller:DialogController,controllerAs:'ctrl',preserveScope:true,resolve:{initialData:voteQuestionIntitalData}});function DialogController(initialData,$scope){var self=this;$log.info('Code reaches here');console.log(initialData);self.title=task.title;self.desc=task.description;// self.allMembers = initialData.teamMembers;
self.rankedQuestions=[];self.filterSelected=true;self.searchText='';self.select=function(item){var exist=false;for(var i=0;i<self.rankedQuestions.length;i++){if(self.rankedQuestions[i].member==item.member){exist=true;break;}}if(!exist){self.rankedQuestions.push(item);}};function searchRankedQuestions(item){return;}//Watch rankedQuestions array
$scope.$watch(function(){return self.rankedQuestions;},function(newValue,oldValue){if(newValue.length!=oldValue.length){self.rankedQuestions=self.rankedQuestions.map(rankAnswer);}},true);var resolveMapTeamMemberAnswers=function resolveMapTeamMemberAnswers(record){return{member:record.displayName,answer:record.answer.$value};};if(initialData.userRankedQuestions.$value!=null){self.rankedQuestions=angular.fromJson(initialData.userRankedQuestions.$value);}self.allMemberAnswers=initialData.teamMemberAnswers.map(resolveMapTeamMemberAnswers);self.validateChip=function(chip){var question=self.rankedQuestions.filter(function(question){return angular.lowercase(question.member).indexOf(angular.lowercase(chip.member))!=-1;});if(question.length>0){return null;}else{return undefined;}};function rankAnswer(answer,index,array){answer.rank=index+1;return answer;}var cachedQuery;self.queryMembers=function(query){cachedQuery=cachedQuery||query;if(cachedQuery!=query){cachedQuery=query;}return cachedQuery?self.allMemberAnswers.filter(createFilterFor(cachedQuery)):[];};function createFilterFor(query){query=query||'';var lowercaseQuery=angular.lowercase(query);return function filterFn(contact){var bool=contact.member.toLowerCase().indexOf(lowercaseQuery)!=-1;return bool;};}self.submit=function(){$q.all([clmDataStore.events.submitSolution(eventId,taskId,participant.$id,angular.toJson(self.rankedQuestions))]).then(function(action){$mdDialog.hide();}).then(function(){clmDataStore.logging.inputLog({action:'voteTeamQuestions',eventId:eventId,taskId:taskId,publicId:participant.$id,timestamp:Date.now()});});};self.cancel=function(){$mdDialog.hide();};}DialogController.$inject=['initialData','$scope'];function voteQuestionIntitalData(){var self=this;var eventTeamsRef=db.ref('classMentors/eventTeams/'+eventId+'/'+task.taskFrom);var userRankedQuestions=db.ref('classMentors/eventSolutions/'+eventId+'/'+participant.$id+'/'+taskId);var team=$firebaseArray(eventTeamsRef).$loaded(function(teams){return teams.filter(function(nextTeam){return nextTeam[participant.$id]!=null;});});var getMembers=function getMembers(team){return Object.keys(team[0]).filter(function(key){return key!='currentSize'&&key!='maxSize'&&key!='$id'&&key!='$priority';});};var eventTasksRef=db.ref('classMentors/eventTasks/'+eventId+'/'+task.taskFrom);var teamMemberAnswers=team.then(function(team){var fbObj=$firebaseObject(eventTasksRef).$loaded(function(task){var eventSolutionRef=db.ref('classMentors/eventSolutions/'+eventId);var getAnswerFromMember=function getAnswerFromMember(member){var answerRef=eventSolutionRef.child(member+'/'+task.taskFrom);return{answer:$firebaseObject(answerRef),member:member,displayName:team[0][member].displayName};};return getMembers(team).map(getAnswerFromMember);});return fbObj;});var teamMembers=team.then(function(team){return getMembers(team);});return $q.all({team:team,teamMembers:teamMembers,teamMemberAnswers:teamMemberAnswers,userRankedQuestions:$firebaseObject(userRankedQuestions)});}};this.promptForTeamFormation=function(eventId,taskId,task,participant,userSolution){var db=firebaseApp.database();$mdDialog.show({parent:$document.body,template:teamFormationTmpl,controller:DialogController,controllerAs:'ctrl',resolve:{initialData:teamFormationInitialData}});function teamFormationInitialData(){//   var teamEventPromise = spfFirebase.loadedArray(['classMentors/eventTeams/',eventId,taskId]);
var ref=db.ref('classMentors/eventTeams/'+eventId+'/'+taskId);var teamEventPromise=$firebaseArray(ref);return $q.all({teams:clmDataStore.events.getEventTaskTeams(eventId,taskId).then(function(result){return result;})});};function DialogController(initialData){var self=this;// var participantId = participant.$id;
self.taskId=taskId;self.teams={};// Learning point here. undefined means not yet assigned a value. Whereas null is a special object.
// self.selectedTeam = initialData.selectedTeam;
self.selectedTeam=undefined;self.userInCurrentTeam=undefined;// self.teams = {};
self.initialDataStore=initialData.teams;//assign self.teams to initialdata to be displayed
self.teams=self.initialDataStore;//assign the current team that the user is in, to a variable
for(var item in self.initialDataStore){if(item.charAt(0)!='$'&&item!='forEach'){//check if participant is inside one of the teams initially
if(JSON.stringify(self.teams[item]).indexOf(participant.$id)>-1){self.userInCurrentTeam=item;}}}setTimeout(function(){$scope.$apply();},1);//ensure that radio button is checked if user clicks on one of the teams
self.selectedTeam=self.userInCurrentTeam;self.leave=function(teamId){if(typeof teamId!='undefined'){//remove user
clmDataStore.events.leaveTeam(eventId,taskId,teamId,participant.$id);//update current size
clmDataStore.events.setCurrentSize(eventId,taskId,teamId,participant.$id,participant.user).then(function(){clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId);});self.selectedTeam=undefined;self.userInCurrentTeam=undefined;}};self.previousTeam=undefined;self.teamChange=function(nextSelectedTeamId){// var previousTeam = self.selectedTeam;
var userIndex=0;//check if user is the first time joining team
if(typeof self.userInCurrentTeam=='undefined'){var joinedTeam=clmDataStore.events.joinTeam(eventId,taskId,nextSelectedTeamId,participant.$id,participant.user);var setSize=clmDataStore.events.setCurrentSize(eventId,taskId,nextSelectedTeamId,participant.$id,participant.user);self.selectedTeam=nextSelectedTeamId;self.userInCurrentTeam=nextSelectedTeamId;var taskTeam=clmDataStore.events.getEventTaskTeamsArr(eventId,taskId).then(function(team){for(var i=0;i<team.length;i++){if(team[i][participant.$id]){userIndex=i;}}clmDataStore.logging.inputLog({action:"formTeam",eventId:eventId,publicId:participant.$id,timestamp:Date.now(),taskId:taskId}).then(function(){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,"Team "+(userIndex+1));}).then(function(){clmDataStore.events.getEventTaskTeams(eventId,taskId).then(function(result){//perform error checking and assign self.team for display
clmDataStore.events.setCurrentSize(eventId,taskId,self.userInCurrentTeam,participant.$id,participant.user);clmDataStore.events.setCurrentSize(eventId,taskId,nextSelectedTeamId,participant.$id,participant.user);var insideTeam=false;var userInTeam=undefined;var memberNum=0;var userEqualCurrentSize=true;var numOfOccurrence=0;for(var team in result){if(team.charAt(0)!='$'&&team!='forEach'){//if user can be found inside this team
if(JSON.stringify(result[team]).indexOf(participant.$id)>-1){numOfOccurrence++;for(var member in result[team]){if(member==participant.$id){insideTeam=true;userInTeam=team;}if(member!='currentSize'&&member!='maxSize'){//count the number of members within each team
memberNum++;}}//check for error...if the currentSize is less than the number of members, means it's wrong
if(memberNum!=result[team].currentSize){userEqualCurrentSize=false;}memberNum=0;}clmDataStore.events.setCurrentSize(eventId,taskId,team,participant.$id,participant.user);}}//if check finds out that user is not inside any team, remove the user solution
if(!insideTeam){self.selectedTeam=undefined;self.userInCurrentTeam=undefined;clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId).then(function(){spfAlert.error('Oops! Seems like there is a conflict while joining team. Please wait awhile and try again!');});}else if(!userEqualCurrentSize||typeof userInTeam!='undefined'&&userInTeam!=nextSelectedTeamId&&numOfOccurrence==1){//check if user's team is equal to the current size. If not, remove the user and ask him to try again
//or he is inside a team which he did not select, remove this user
console.log("user undefined, error 1");for(var team in result){if(team.charAt(0)!='$'&&team!='forEach'){//if user can be found inside this team
if(JSON.stringify(result[team]).indexOf(participant.$id)>-1){for(var member in result[team]){if(member==participant.$id){clmDataStore.events.leaveTeam(eventId,taskId,team,member);clmDataStore.events.setCurrentSize(eventId,taskId,team,member,participant.user);clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId);}}}}}self.selectedTeam=undefined;self.userInCurrentTeam=undefined;// clmDataStore.events.leaveTeam(eventId, taskId, nextSelectedTeamId, participant.$id);
// //refresh currentSize
// clmDataStore.events.setCurrentSize(eventId, taskId, self.previousTeam, participant.$id, participant.user);
// clmDataStore.events.setCurrentSize(eventId, taskId, nextSelectedTeamId, participant.$id, participant.user);
//
// clmDataStore.events.deleteUserSolution(eventId, participant.$id, taskId);
// self.selectedTeam = undefined;
// self.userInCurrentTeam = undefined;
spfAlert.error('Oops! Seems like you have a conflict with others while joining team. Please try again!');}else if(numOfOccurrence>1){//check if user DOES NOT exist in more than 1 team at any point of time. If so, remove the user and ask the user to try again
//delete every trace of the user in the team
console.log("user undefined, error 2");for(var team in result){if(team.charAt(0)!='$'&&team!='forEach'){//if user can be found inside this team
if(JSON.stringify(result[team]).indexOf(participant.$id)>-1){for(var member in result[team]){if(member==participant.$id){clmDataStore.events.leaveTeam(eventId,taskId,team,member);clmDataStore.events.setCurrentSize(eventId,taskId,team,member,participant.user);clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId);}}}}}self.selectedTeam=undefined;self.userInCurrentTeam=undefined;spfAlert.error('Oops! Seems like you appear in 2 teams while joining team. Please try again!');}//refresh once more
// clmDataStore.events.setCurrentSize(eventId, taskId, self.userInCurrentTeam, participant.$id, participant.user);
// clmDataStore.events.setCurrentSize(eventId, taskId, nextSelectedTeamId, participant.$id, participant.user);
self.teams=result;});});});}else if(typeof self.userInCurrentTeam!='undefined'){//store his currentTeam first
self.previousTeam=self.userInCurrentTeam;//if user has previously joined a team
//remove user
clmDataStore.events.removeUser(eventId,taskId,self.userInCurrentTeam,participant.$id,nextSelectedTeamId);//update current size
clmDataStore.events.setCurrentSize(eventId,taskId,self.userInCurrentTeam,participant.$id,participant.user);//join another team
clmDataStore.events.joinTeam(eventId,taskId,nextSelectedTeamId,participant.$id,participant.user);clmDataStore.events.setCurrentSize(eventId,taskId,nextSelectedTeamId,participant.$id,participant.user);self.selectedTeam=nextSelectedTeamId;self.userInCurrentTeam=nextSelectedTeamId;var taskTeam=clmDataStore.events.getEventTaskTeamsArr(eventId,taskId).then(function(team){for(var i=0;i<team.length;i++){if(team[i][participant.$id]){userIndex=i;}}clmDataStore.logging.inputLog({action:"formTeam",eventId:eventId,publicId:participant.$id,timestamp:Date.now(),taskId:taskId}).then(function(){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,"Team "+(userIndex+1));}).then(function(){clmDataStore.events.getEventTaskTeams(eventId,taskId).then(function(result){//perform error checking and assign self.team for display
clmDataStore.events.setCurrentSize(eventId,taskId,self.userInCurrentTeam,participant.$id,participant.user);clmDataStore.events.setCurrentSize(eventId,taskId,nextSelectedTeamId,participant.$id,participant.user);var insideTeam=false;var userInTeam=undefined;var memberNum=0;var userEqualCurrentSize=true;var numOfOccurrence=0;for(var team in result){if(team.charAt(0)!='$'&&team!='forEach'){//if user can be found inside this team
if(JSON.stringify(result[team]).indexOf(participant.$id)>-1){numOfOccurrence++;for(var member in result[team]){if(member==participant.$id){insideTeam=true;userInTeam=team;}if(member!='currentSize'&&member!='maxSize'){//count the number of members within each team
memberNum++;}}//check for error...if the currentSize is less than the number of members, means it's wrong
if(memberNum!=result[team].currentSize){userEqualCurrentSize=false;}memberNum=0;}clmDataStore.events.setCurrentSize(eventId,taskId,team,participant.$id,participant.user);}}//if check finds out that user is not inside any team, remove the user solution
if(!insideTeam){self.selectedTeam=undefined;self.userInCurrentTeam=undefined;clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId).then(function(){spfAlert.error('Oops! Seems like there is a conflict while joining team. Please wait awhile and try again!');});}else if(!userEqualCurrentSize||typeof userInTeam!='undefined'&&userInTeam!=nextSelectedTeamId&&numOfOccurrence==1){//check if user's team is equal to the current size. If not, remove the user and ask him to try again
//or he is inside a team which he did not select, remove this user
console.log("user defined, error 1");for(var team in result){if(team.charAt(0)!='$'&&team!='forEach'){//if user can be found inside this team
if(JSON.stringify(result[team]).indexOf(participant.$id)>-1){for(var member in result[team]){if(member==participant.$id){clmDataStore.events.leaveTeam(eventId,taskId,team,member);clmDataStore.events.setCurrentSize(eventId,taskId,team,member,participant.user);clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId);}}}}}self.selectedTeam=undefined;self.userInCurrentTeam=undefined;// clmDataStore.events.leaveTeam(eventId, taskId, self.previousTeam, participant.$id);
// clmDataStore.events.leaveTeam(eventId, taskId, nextSelectedTeamId, participant.$id);
// //refresh currentSize
// clmDataStore.events.setCurrentSize(eventId, taskId, self.previousTeam, participant.$id, participant.user);
// clmDataStore.events.setCurrentSize(eventId, taskId, nextSelectedTeamId, participant.$id, participant.user);
//
// clmDataStore.events.deleteUserSolution(eventId, participant.$id, taskId);
// self.selectedTeam = undefined;
// self.userInCurrentTeam = undefined;
spfAlert.error('Oops! Seems like you have a conflict with others while joining team. Please try again!');}else if(numOfOccurrence>1){console.log("user defined, error 2");//check if user DOES NOT exist in more than 1 team at any point of time. If so, remove the user and ask the user to try again
//delete every trace of the user in the team
for(var team in result){if(team.charAt(0)!='$'&&team!='forEach'){//if user can be found inside this team
if(JSON.stringify(result[team]).indexOf(participant.$id)>-1){for(var member in result[team]){if(member==participant.$id){clmDataStore.events.leaveTeam(eventId,taskId,team,member);clmDataStore.events.setCurrentSize(eventId,taskId,team,member,participant.user);clmDataStore.events.deleteUserSolution(eventId,participant.$id,taskId);}}}}}self.selectedTeam=undefined;self.userInCurrentTeam=undefined;spfAlert.error('Oops! Seems like you appear in 2 teams while joining team. Please try again!');}//refresh once more
// clmDataStore.events.setCurrentSize(eventId, taskId, self.userInCurrentTeam, participant.$id, participant.user);
// clmDataStore.events.setCurrentSize(eventId, taskId, nextSelectedTeamId, participant.$id, participant.user);
self.teams=result;});});});}// var userInsideTeam = false;
// //finally, refresh the current team size again to ensure no inconsistency within the data
// var taskTeam = clmDataStore.events.getEventTaskTeamsArr(eventId, taskId).then(function (team) {
//     for (var i = 0; i < team.length; i++) {
//         if (team[i][participant.$id]) {
//             userInsideTeam = true;
//             break;
//         }
//     }
//
// })
// clmDataStore.events.setCurrentSize(eventId, taskId, self.userInCurrentTeam, participant.$id, participant.user);
// clmDataStore.events.setCurrentSize(eventId, taskId, nextSelectedTeamId, participant.$id, participant.user);
};// self.onChange = function (index) {
//     // If user has not joined any team before
//     if (previousSelectedTeam == undefined) {
//         if (index2 != undefined) {
//             switchTeam(index2, index);
//         } else {
//             joinTeam(index);
//         }
//         previousSelectedTeam = index;
//     } else if (index != previousSelectedTeam) { //Check if selected index has changed, else do nothing.
//         // Leave previous team.
//         // Join new team.
//
//         // switchTeam(previousSelectedTeam, index);
//         // previousSelectedTeam = index;
//     } else {
//         joinTeam(index);
//     }
// };
// function switchTeam(oldIndex, newIndex) {
//     var team = self.teams[oldIndex];
//     var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}/${team.$id}/${participant.$id}`);
//     var currentSize;
//     ref.remove().then(function () {
//         //do nothing
//         var refCurrentSize = db.ref(`classMentors/eventTeams/${eventId}/${taskId}/${team.$id}/currentSize`);
//         refCurrentSize.on("value", function (snapshot) {
//             currentSize = snapshot.val();
//             currentSize--;
//         });
//         //update currentsize in firebase, then assign to self.teams
//         refCurrentSize.set(currentSize).then(function () {
//             //retrieve the newly updated team promise and assign to this.teams
//             var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}`);
//             var teamEventPromise = $firebaseArray(ref);
//             teamEventPromise.$loaded().then(function (result) {
//                 self.teams = result;
//             })
//         }).then(function () {
//             var team = self.teams[newIndex];
//             var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}/${team.$id}/${participant.$id}`);
//             // var currentSize = 0;
//             var currentSize;
//
//             clmDataStore.events.joinTeam(eventId, taskId, team.$id, participant.$id, participant.user).then(function () {
//                 var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}`);
//                 var teamEventPromise = $firebaseArray(ref);
//                 teamEventPromise.$loaded().then(function (result) {
//                     self.teams = result;
//                 });
//                 clmDataStore.logging.inputLog(
//                     {
//                         action: "formTeam",
//                         eventId: eventId,
//                         publicId: participant.$id,
//                         timestamp: Date.now(),
//                         taskId: taskId
//                     }
//                 );
//             }).then(function () {
//                 //update progress asynchronously
//                 clmDataStore.events.submitSolution(eventId, taskId, participant.$id, "Team " + (newIndex + 1));
//
//             });
//         })
//     });
// }
// function leaveTeam(index) {
//     var team = self.teams[index];
//     var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}/${team.$id}/${participant.$id}`);
//     var currentSize;
//     //  spfFirebase.remove(['classMentors/eventTeams/',eventId,taskId,team.$id,participant.$id])
//     //retrieve currentsize, then decrement
//     ref.remove().then(function () {
//         //do nothing
//         var refCurrentSize = db.ref(`classMentors/eventTeams/${eventId}/${taskId}/${team.$id}/currentSize`);
//         refCurrentSize.on("value", function (snapshot) {
//             currentSize = snapshot.val();
//             currentSize--;
//         });
//         //update currentsize in firebase, then assign to self.teams
//         refCurrentSize.set(currentSize).then(function () {
//             //retrieve the newly updated team promise and assign to this.teams
//             var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}`);
//             var teamEventPromise = $firebaseArray(ref);
//             teamEventPromise.$loaded().then(function (result) {
//                 self.teams = result;
//             })
//         });
//     });
//
//
// }
// function joinTeam(index) {
//
//     var team = self.teams[index];
//     var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}/${team.$id}/${participant.$id}`);
//     var currentSize;
//     clmDataStore.events.joinTeam(eventId, taskId, team.$id, participant.$id, participant.user).then(function () {
//         var ref = db.ref(`classMentors/eventTeams/${eventId}/${taskId}`);
//         var teamEventPromise = $firebaseArray(ref);
//         teamEventPromise.$loaded().then(function (result) {
//             self.teams = result;
//         });
//         clmDataStore.logging.inputLog(
//             {
//                 action: "formTeam",
//                 eventId: eventId,
//                 publicId: participant.$id,
//                 timestamp: Date.now(),
//                 taskId: taskId
//             }
//         );
//     }).then(function () {
//         //update progress asynchronously
//         clmDataStore.events.submitSolution(eventId, taskId, participant.$id, "Team " + (index + 1));
//     });
//
// }
this.save=function(){//do nothing, but keep for ng-submit consistency
};this.cancel=function(){$mdDialog.hide();};}DialogController.$inject=['initialData'];};self.coopTeam={};self.coopStyle={};self.selectedProgress={};self.teamId={};self.showTeamComplete=function(participantId,taskId,eventId,task){self.selectedProgress[taskId]={};self.coopStyle={display:'inline-block',color:'red'};self.taskId=taskId;//get this task
var selectedTask=taskByEvent[taskId];//get the task where team formation is from
var teamTaskFrom=selectedTask.teamFormationRef;//get all the teams that belong to this event
var teamFromEvent=allTeamsByEvent[teamTaskFrom];//create arrays to store users who has completed task and total number of users in a team
var completedUsers=0;var usersInTeam=0;self.teamId[teamTaskFrom]={};//set initial data into array
var coopTeamDetails=[];var usersInside=[];coopTeamDetails.push(completedUsers);coopTeamDetails.push(usersInTeam);coopTeamDetails.push(usersInside);var status=[];for(var teamId in teamFromEvent){for(var user in teamFromEvent[teamId]){if(user!='maxSize'&&user!='currentSize'&&user!='status'){usersInTeam++;//if user has submitted an answer, increment by 1
if(typeof solutionByTask[user][taskId]=='undefined'){//do nothing
}else{completedUsers++;}self.teamId[teamTaskFrom][user]=teamId;}}status.push(usersInTeam);status.push(completedUsers);teamFromEvent[teamId]['status']=status;//reset user information
usersInTeam=0;completedUsers=0;status=[];}self.coopTeam[teamTaskFrom]=teamFromEvent;// for (var team in self.coopTeam[teamTaskFrom]) {
//     if (JSON.stringify(self.coopTeam[teamTaskFrom][team]).indexOf(participantId) > -1) {
//         self.selectedProgress[taskId][participantId] = self.coopTeam[teamTaskFrom][team].status;
//     }
// }
return true;};this.promptForSurvey=function(eventId,taskId,task,participant,userSolution){if(task.survey==="School engagement scale"){$location.path('/events/'+eventId+'/'+taskId+'/survey1/'+task.survey);}if(task.survey==="Motivated strategies for learning"){//console.log("motivated strategies came in here");
//route to the below specified url
$location.path('/events/'+eventId+'/'+taskId+'/survey2/'+task.survey);}if(task.survey==="Education vs Dissatisfaction with learning"){$location.path('/events/'+eventId+'/'+taskId+'/survey3/'+task.survey);}};this.promptForTextResponse=function(eventId,taskId,task,participant,userSolution){task.team=self.team[task.teamFormationRef];if(!task.team&&task.activityType&&task.activityType=='indexCards'){console.log('indexcard condition met');}$mdDialog.show({parent:$document.body,template:responseTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(response){// console.log("this response is: ", response);
//this line adds solution to firebase
if(task.team){console.log('SUBMIT FOR THE TEAM!');Object.keys(task.team).forEach(function(key){if(task.team[key].displayName){// console.log('Submitting for: ' + key);
clmDataStore.events.submitSolution(eventId,taskId,key,response);}});$mdDialog.hide();spfAlert.success('Response is saved.');clmDataStore.logging.inputLog({action:"submitTeamTextResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,members:Object.keys(task.team).filter(function(key){if(task.team[key].displayName){return key;}}),timestamp:TIMESTAMP$1});}else{clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});if(task.activityType&&task.activityType=='indexCards'){clmDataStore.logging.inputLog({action:"askIndividualQuestion",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});}else{clmDataStore.logging.inputLog({action:"submitTextResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});}if(task.type&&task.type=='textResponseMentoring'){if(self.solutions[self.currentUserParticipant.$id]&&self.solutions[self.currentUserParticipant.$id][task.mentorAssignmentRef]){}else{assignMentorPairing(taskId,task.mentorAssignmentRef,self.profile.$id,task.mentorAssignmentMethod);}}}};this.cancel=function(){$mdDialog.hide();};}};this.promptForCodeResponse=function(eventId,taskId,task,participant,userSolution){task.team=self.team[task.teamFormationRef];$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,controller:CodeController,controllerAs:'ctrl',onComplete:loadEditor});this.loadingEditor=true;var parent=this;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);parent.loadingEditor=false;}function CodeController(){console.log("22");this.task=task;this.checkEditor=function(){return parent.loadingEditor;};if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(){var editor=ace.edit($document[0].querySelector('#editor'));var response=editor.getValue();if(task.team){console.log('SUBMIT FOR THE TEAM!');Object.keys(task.team).forEach(function(key){if(task.team[key].displayName){// console.log('Submitting for: ' + key);
clmDataStore.events.submitSolution(eventId,taskId,key,response);}});$mdDialog.hide();spfAlert.success('Response is saved.');clmDataStore.logging.inputLog({action:"submitTeamCode",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,members:Object.keys(task.team).filter(function(key){if(task.team[key].displayName){return key;}}),timestamp:TIMESTAMP$1});}else{clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});clmDataStore.logging.inputLog({action:"submitCodeResponse",publicId:self.profile.$id,eventId:self.event.$id,taskId:taskId,timestamp:TIMESTAMP$1});if(task.type&&task.type=='codeMentoring'){if(self.solutions[self.currentUserParticipant.$id]&&self.solutions[self.currentUserParticipant.$id][task.mentorAssignmentRef]){}else{assignMentorPairing(taskId,task.mentorAssignmentRef,self.profile.$id,task.mentorAssignmentMethod);}}}};this.cancel=function(){$mdDialog.hide();};}};function assignMentorPairing(currentTaskId,writeToId,publicId,assignmentMethod){var participants=self.participantsView.map(function(p){return{publicId:p.$id,displayName:p.user.displayName,completed:self.progress[p.$id]&&(self.progress[p.$id][currentTaskId].completed||self.progress[p.$id][writeToId].completed)};});var incompleteParticipants=participants.filter(function(p){return!p.completed;});var mentee={};if(assignmentMethod=='random'){// select mentee
var mentee=incompleteParticipants[Math.floor(Math.random()*incompleteParticipants.length)];console.log(mentee);}else if(assignmentMethod=='prevCompletion'){var orderedIncompleteParticipants=incompleteParticipants.map(function(p){return{publicId:p.publicId,displayName:p.displayName,completed:p.completed,challengesCompleted:self.solutions[p.publicId]?Object.keys(self.solutions[p.publicId]).length:0};});orderedIncompleteParticipants.sort(function(a,b){return a.challengesCompleted-b.challengesCompleted;});// console.log(orderedIncompleteParticipants);
var mentee=orderedIncompleteParticipants[0];}else if(assignmentMethod=='roulette'){var valIncompleteParticipants;var divisor;var weightedIncompleteParticipants;var normalisedObj;var runningCount;var assignedMentee;(function(){var findRangeKey=function findRangeKey(normalisedObj,rand){var prev=-1;var i;for(i in normalisedObj){var n=parseInt(i);if(prev!=-1&&rand<n)return prev;else prev=n;}};valIncompleteParticipants=incompleteParticipants.map(function(p){return{publicId:p.publicId,displayName:p.displayName,completed:p.completed,challengesCompleted:self.solutions[p.publicId]?Object.keys(self.solutions[p.publicId]).length:0};});var totalCompleteChals=valIncompleteParticipants.reduce(function(a,b){return a.challengesCompleted+b.challengesCompleted;});divisor=weightedIncompleteParticipants.length-1;weightedIncompleteParticipants=valIncompleteParticipants.map(function(p){return{publicId:p.publicId,displayName:p.displayName,completed:p.completed,challengesCompleted:p.challengesCompleted,fitness:(totalCompleteChals-p.challengesCompleted)/divisor/totalCompleteChals};});normalisedObj={};runningCount=0;for(var entryIndex in weightedIncompleteParticipants){var entry=weightedIncompleteParticipants[entryIndex];runningCount+=entry.fitness;normalisedObj[runningCount]=entry;}assignedMentee=weightedIncompleteParticipants[findRangeKey(normalisedObj,Math.random())];})();}// Write pairing as solution to assignment challenge for both mentor and mentee
var mentObj={mentor:{publicId:publicId,displayName:participants.find(function(p){return p.publicId==publicId;})?participants.find(function(p){return p.publicId==publicId;}).displayName:self.profile.user.displayName},mentee:{publicId:mentee.publicId,displayName:mentee.displayName}};if(self.solutions[mentObj.mentee.publicId]&&self.solutions[mentObj.mentee.publicId][writeToId]){assignMentorPairing(currentTaskId,writeToId,publicId,assignmentMethod);}else{clmDataStore.events.submitSolution(self.event.$id,writeToId,publicId,angular.toJson(mentObj));clmDataStore.events.submitSolution(self.event.$id,writeToId,mentee.publicId,angular.toJson(mentObj));clmDataStore.logging.inputLog({action:"formMentorship",publicId:mentObj.mentor.publicId,eventId:self.event.$id,taskId:currentTaskId,mentorAssignmentId:writeToId,mentee:mentObj.mentee.publicId,timestamp:TIMESTAMP$1});}}this.reassignMentorPairing=function(toCheckId,writeToId,currentPair,assignmentMethod){var toDelete=angular.fromJson(currentPair);// Blow up current pairing
clmDataStore.events.deleteUserSolution(self.event.$id,toDelete.mentor.publicId,writeToId);clmDataStore.events.deleteUserSolution(self.event.$id,toDelete.mentee.publicId,writeToId);// Reassign the two depending if they have completed the challenge already
if(self.progress[toDelete.mentor.publicId][toCheckId].completed){console.log('Reassign mentor to other mentee');assignMentorPairing(toCheckId,writeToId,toDelete.mentor.publicId,'random');}if(self.progress[toDelete.mentee.publicId][toCheckId].completed){console.log('Reassign mentee to mentor');assignMentorPairing(toCheckId,writeToId,toDelete.mentee.publicId,'random');}};this.viewCodeResponse=function(task,solution){console.log("3");$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,controller:CodeController,controllerAs:'ctrl',onComplete:loadEditor});this.loadingEditor=true;var parent=this;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);parent.loadingEditor=false;}function CodeController(){console.log("33");this.task=task;this.saveDisabled=true;this.checkEditor=function(){return parent.loadingEditor;};this.solution=solution;this.cancel=function(){$mdDialog.hide();};}};this.update=function(){};this.removeParticipant=function(e,event,participant){var confirm=$mdDialog.confirm().parent($document.body).title('Would you like to remove '+participant.user.displayName+'?').content('The participant progress will be kept but he/she will not show as participant').ariaLabel('Remove participant').ok('Remove').cancel('Cancel').targetEvent(e);$mdDialog.show(confirm).then(function(){clmDataStore.events.removeParticpants(event.$id,participant.$id);});};// load up resources and start firebase watcher
this.loading=true;$q.all({userProgress:clmDataStore.events.getUserProgress(this.event.$id,this.profile.$id).then(function(progress){self.currentUserProgress=progress;unwatchers.push(progress.$destroy.bind(progress));return progress;}),userSolution:clmDataStore.events.getUserSolutions(this.event.$id,this.profile.$id).then(function(solutions){self.currentUserSolutions=solutions;// console.log('What is this ',solutions);
unwatchers.push(solutions.$destroy.bind(solutions));return solutions;}),singpathQueuedSolution:clmDataStore.singPath.queuedSolutions(this.profile.$id).then(function(paths){unwatchers.push(paths.$destroy.bind(paths));return paths;}),userTeams:function userTeams(){var db=firebaseApp.database();var eventTeamsReference=db.ref('classMentors/eventTeams/'+this.event.$id);}}).then(function(results){visibleTasks();// Set the participant view (via the pager range update event)
unwatchers.push(self.pagerOptions.onChange(participantsView));updateParticipantRowCount();// Monitor updates on task progress and participants list.
unwatchers.push(self.tasks.$watch(visibleTasks));unwatchers.push(self.progress.$watch(taskCompletion));unwatchers.push(self.participants.$watch(taskCompletion));unwatchers.push(self.participants.$watch(updateParticipantRowCount));//unwatchers.push(); for teams
return results;}).finally(function(){self.loading=false;}).then(function(results){var update=function update(){// Removed due to June 2016 profile updating process change.
// return clmDataStore.events.updateCurrentUserProfile(
// self.event,
// self.tasks,
// results.userSolution,
// self.profile
// );
};// Watch for singpath problem getting updated
unwatchers.push(results.singpathQueuedSolution.$watch(update));return update();}).catch(function(err){$log.error(err);});// clean up.
$scope.$on('$destroy',function(){unwatchers.forEach(function(f){if(f){try{f();}catch(err){$log.error(err);}}});});}function addSurveyEventTaskCtrlInitialData($q,$route,firebaseApp,$firebaseArray,spfAuthData,clmDataStore){var db=firebaseApp.database();var errNoEvent=new Error('Event not found');var eventId=$route.current.params.eventId;var profilePromise=clmDataStore.currentUserProfile().catch(noop$7);var eventPromise=clmDataStore.events.get(eventId).then(function(event){if(event.$value===null){return $q.reject(errNoEvent);}return event;});var canviewPromise=$q.all({event:eventPromise,profile:profilePromise}).then(function(data){return $q.when(data.profile&&data.profile.canView(data.event));});//returns a promise object from firebase
var surveyRef=db.ref('classMentors/surveyTemplate');var survey=$firebaseArray(surveyRef);return $q.all({currentUser:spfAuthData.user().catch(noop$7),profile:profilePromise,event:eventPromise,canView:canviewPromise,survey2:survey.$loaded().then(function(){return survey;}),tasks:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getTasks(eventId);}}),participants:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.participants(eventId);}}),progress:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getProgress(eventId);}}),solutions:canviewPromise.then(function(canView){if(canView){return clmDataStore.events.getSolutions(eventId);}})});}//TODO: include controller for the survey
function SurveyFormFillCtrl(spfNavBarService,$location,urlFor,initialData,$routeParams,clmDataStore,clmPagerOption,spfAlert,$scope,firebase){this.pagerOpts=clmPagerOption();var self=this;this.questions=initialData.survey2;this.ratingOptions=[{id:1},{id:2},{id:3},{id:4},{id:5},{id:6},{id:7}];if($routeParams.surveyTask==='School engagement scale'){self.responseRating=[{option:'Never'},{option:'On Occasion'},{option:'Some of the Time'},{option:'Most of the Time'},{option:'All of the Time'}];self.schEngageResp={};}if($routeParams.surveyTask==='Motivated strategies for learning'){self.questionsArr=[];for(var i=1;i<Object.keys(initialData.survey2[1]).length-1;i++){//console.log("testing: ", initialData.survey2[1]["Q" + i]);
self.questionsArr.push({'name':initialData.survey2[1]["Q"+i],'qnid':i});}self.motiResp={};}if($routeParams.surveyTask==='Education vs Dissatisfaction with learning'){this.familyMembers=[{name:'Father'},{name:'Mother'},{name:'Sister(s)'},{name:'Brother(s)'},{name:'Relative(s)'},{name:'Grandparent(s)'}];this.selectedFamily=[];this.selectedRaceEthnicity=[];this.toggle=function(item,list){var idx=list.indexOf(item);if(idx>-1){list.splice(idx,1);}else{list.push(item);}return list;};this.exists=function(item,list){return list.indexOf(item)>-1;};this.bdayMonth=[{month:'January'},{month:'February'},{month:'March'},{month:'April'},{month:'May'},{month:'June'},{month:'July'},{month:'August'},{month:'September'},{month:'October'},{month:'November'},{month:'December'}];this.ethnicity=[{firstRow:'White'},{firstRow:'African American'},{firstRow:'Hispanic/Latino'},{secondRow:'Asian'},{secondRow:'Native Hawaii/Pacific Islander'},{secondRow:'Other'}];//this.selectEthnicity = [];
this.eduDissResp={};this.questionJson={};// console.log("this initialdata is", initialData.survey2[0]);
//console.log("initial data before: ", initialData.survey2[0]);
for(var _i=1;_i<Object.keys(initialData.survey2[0]).length-1;_i++){this.eduDissResp[initialData.survey2[0][_i].title]={};}}//$routechangestart will be executed before users route to another page
var schEngageInvalid=true;var motiStratInvalid=true;var eduDissInvalid=true;$scope.$on("$routeChangeStart",function(event,next,current){if(schEngageInvalid&&motiStratInvalid&&eduDissInvalid){if(!confirm("You have not finish this survey. Are you sure you want to continue? All data will be lost")){event.preventDefault();}}});this.event=initialData.event;spfNavBarService.update('Survey',[{title:'Events',url:'#'+urlFor('events')},{title:this.event.title,url:'#'+urlFor('oneEvent',{eventId:this.event.$id})}]);this.saveSurveyResponse=function(response,item,task){var surveyResp=response;var questionNumber=item.currentTarget.getAttribute("data-id");var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;//console.log("all the VALUES HERE: " + surveyResp + ", " + questionNumber + "," + taskId + ", " + eventId + ", " + userId + ", " + surveyType)
clmDataStore.events.saveSurveyResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyType);};this.saveEduDisMultiResponse=function(selectedArr,item,task,qnTitle){var questionNumber=item.currentTarget.getAttribute("data-id");var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;if(questionNumber==2){var familyArr=[];//transfer selected family members values into array
for(var i=0;i<selectedArr.length;i++){familyArr.push(selectedArr[i].name);}clmDataStore.events.saveSurveyEduDisMultiResponse(familyArr,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}if(questionNumber==5){var ethnicityRace=[];//transfer selected race and ethnicity values into array
for(var i=0;i<selectedArr.length;i++){if(selectedArr[i].firstRow!=undefined){ethnicityRace.push(selectedArr[i].firstRow);}if(selectedArr[i].secondRow!=undefined){ethnicityRace.push(selectedArr[i].secondRow);}}clmDataStore.events.saveSurveyEduDisMultiResponse(ethnicityRace,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}};this.saveEduDisResponse=function(response,age,item,task,siblingNum,selectedMonth,country,language,qnTitle,bestResp){var surveyResp=response;var questionNumber=item.currentTarget.getAttribute("data-id");var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var ageResp=age;var sibResp=siblingNum;var monthResp=selectedMonth;var qnTitle=qnTitle;var bornCountry=country;var spokenLanguage=language;var bestResp=bestResp;if(surveyResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(surveyResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(ageResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(ageResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(sibResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(sibResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(monthResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(monthResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(bornCountry!=undefined){clmDataStore.events.saveSurveyEduDisResponse(bornCountry,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(spokenLanguage!=undefined){clmDataStore.events.saveSurveyEduDisResponse(spokenLanguage,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}else if(bestResp!=undefined){clmDataStore.events.saveSurveyEduDisResponse(bestResp,questionNumber,taskId,eventId,userId,surveyType,qnTitle);}};this.submitSchEngageResponse=function(schEngageResp){//to set warning
schEngageInvalid=false;motiStratInvalid=true;eduDissInvalid=true;var allResponses=true;for(var i=1;i<schEngageResp.length;i++){if(schEngageResp[i][i+1]===0){allResponses=false;break;}}if(!allResponses){spfAlert.warning('Failed to save the responses. Please answer all questions.');}else{var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var completed=true;initialData.progress[userId]={taskId:taskId};initialData.progress[userId][taskId]={completed:completed};clmDataStore.logging.inputLog({action:"submitSchEngageResponse",publicId:userId,eventId:eventId,taskId:taskId,timestamp:firebase.database.ServerValue.TIMESTAMP});spfAlert.success('Survey responses have been submitted.');clmDataStore.events.saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,schEngageResp);clmDataStore.events.submitSolution(eventId,taskId,userId,"Completed");// clmDataStore.events.setProgress(eventId, taskId, userId, initialData.progress);
$location.path(urlFor('oneEvent',{eventId:self.event.$id}));}};this.submitMotiStratResponse=function(motiResp){//to set warning
motiStratInvalid=false;eduDissInvalid=true;schEngageInvalid=true;var allResponses=true;// console.log("trying ", motiResp);
for(var i=1;i<motiResp.length;i++){if(motiResp[i][i+1]===0){allResponses=false;break;}}if(!allResponses){spfAlert.warning('Failed to save the responses.');}else{var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var completed=true;initialData.progress[userId]={taskId:taskId};initialData.progress[userId][taskId]={completed:completed};clmDataStore.logging.inputLog({action:"submitMotiStratResponse",publicId:userId,eventId:eventId,taskId:taskId,timestamp:firebase.database.ServerValue.TIMESTAMP});spfAlert.success('Survey responses have been submitted.');clmDataStore.events.saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,motiResp);clmDataStore.events.submitSolution(eventId,taskId,userId,"Completed");$location.path(urlFor('oneEvent',{eventId:self.event.$id}));}};this.submitEduDissResponse=function(eduDissResp,selectedFamily,selectedRaceEthnicity){//to set warning
eduDissInvalid=true;motiStratInvalid=false;schEngageInvalid=false;//add checkbox values into json
var allResponses=true;for(var title in eduDissResp){if(title=="Tell us about YOURSELF:"){eduDissResp[title][2]=selectedFamily;eduDissResp[title][5]=selectedRaceEthnicity;}else if(title=="What do you like BEST in this class?"){//ignore
}else{for(var qn in eduDissResp[title]){if(eduDissResp[title][qn]==undefined){allResponses=false;break;}}}if(!allResponses){break;}}if(!allResponses){spfAlert.warning('Failed to save the responses.');}else{//retrieving all required variables to be added into firebase
var taskId=$routeParams.taskId;var eventId=initialData.event.$id;var userId=initialData.currentUser.publicId;var surveyType=$routeParams.surveyTask;var completed=true;initialData.progress[userId]={taskId:taskId};initialData.progress[userId][taskId]={completed:completed};clmDataStore.logging.inputLog({action:"submitEduDissResponse",publicId:userId,eventId:eventId,taskId:taskId,timestamp:firebase.database.ServerValue.TIMESTAMP});spfAlert.success('Survey responses have been submitted.');//add into firebase
clmDataStore.events.saveSurveyResponseOnSubmit(taskId,eventId,userId,surveyType,eduDissResp);clmDataStore.events.submitSolution(eventId,taskId,userId,"Completed");$location.path(urlFor('oneEvent',{eventId:self.event.$id}));}};this.backToChallenge=function(){$location.path(urlFor('oneEvent',{eventId:self.event.$id}));};}function clmEventRankTableFactory(){return{template:eventTableRankTmpl,restrict:'E',bindToController:true,scope:{event:'=',profile:'=',assistants:'='},controller:ClmEventRankTableCtrl,controllerAs:'ctrl'};}/**
 * Ranking table controller.
 *
 * @todo move code dependent on bound attributes to $onInit method
 */function ClmEventRankTableCtrl($log,$q,$filter,firebaseApp,$firebaseObject,$firebaseArray,clmDataStore){var self=this;var db=firebaseApp.database();var updateLog=function updateLog(actionObj){actionObj.publicId=self.profile.$id;actionObj.timestamp=TIMESTAMP$1;clmDataStore.logging.inputLog(actionObj);};this.rankingView=[];setRankedServices(this);setParticipants(this);function setRankedServices(ctrl){if(!ctrl.event.rankedServices){ctrl.rankedServices=[{id:'freeCodeCamp',name:'Free Code Camp'},{id:'codeCombat',name:'Code Combat'}];return;}ctrl.rankedServices=[];for(var property in ctrl.event.rankedServices){if(ctrl.event.rankedServices.hasOwnProperty(property)){// do stuff
ctrl.rankedServices.push({id:property,name:property});}}};function setParticipants(ctrl){var ref=db.ref('classMentors/eventParticipants/'+ctrl.event.$id);var query=ref.limitToLast(1000);var data=$firebaseArray(query);data.$loaded().then(function(){ctrl.participants=data;setRankingView(ctrl);}).catch(function(reason){console.log('Failed '+reason);});};function setRankingView(ctrl){ctrl.rankingView=[];clmDataStore.events.getRanking(ctrl.event,ctrl.participants,ctrl.rankedServices,sortRanking).then(function(ranking){ctrl.rankingView=ranking;}).catch(function(err){return console.log('Failed: '+err);});};function sortRanking(ranking){var order=self.orderOpts.map(function(opt){var dir=opt.reversed?'-':'+';return''+dir+opt.key;});return $filter('orderBy')(ranking,order);}/**
     * Request update for all participants achievement.
     *
     * @todo redraw ranking when a profile is updated
     */this.updateAllParticipantUserProfiles=function(){// console.log("Requesting all users in ranking to be updated.");
updateLog({action:"updateAllParticipantUserProfiles","eventId":self.event.$id});self.participants.forEach(function(p){return clmDataStore.services.refresh(p);});};this.loading=false;this.currentUserRanking=undefined;this.orderOpts=[{key:'$total',reversed:true},{key:'$user.displayName',reversed:false}];this.orderBy=function(key){if(self.orderOpts[0]&&self.orderOpts[0].key===key){self.orderOpts[0].reversed=!self.orderOpts[0].reversed;}else{self.orderOpts.unshift({key:key,reversed:true});self.orderOpts=self.orderOpts.slice(0,2);}self.rankingView=sortRanking(self.rankingView);updateLog({action:"eventRankingOrderby","eventId":self.event.$id,"key":key,"reversed":self.orderOpts[0].reversed});};}// Show event participants and submissions in a paged table
function clmEventResultsTableFactory(){return{template:eventTableResultsTmpl,restrict:'E',bindToController:true,scope:{event:'=',profile:'=',participants:'=',tasks:'=',progress:'=',solutions:'=',selected:'=',scores:'=',teams:'='},controller:ClmEventResultsTableCtrl,controllerAs:'ctrl'};}function ClmEventResultsTableCtrl($scope,$q,$log,$mdDialog,$document,urlFor,spfAlert,clmServicesUrl,clmDataStore,clmPagerOption,$sce,firebaseApp,$firebaseObject){var self=this;var unwatchers=[];this.currentUserParticipant=undefined;this.participantsView=[];this.visibleTasks=[];this.taskCompletion={};this.orderOptions={key:undefined,reversed:false};this.pagerOptions=clmPagerOption();unwatchers.push(self.pagerOptions.$destroy.bind(self.pagerOptions));/**
     * Get current user participant row
     */function currentUserParticipant(){if(!self.participants||!self.participants.$getRecord||!self.profile||!self.profile.$id){self.currentUserParticipant=undefined;}self.currentUserParticipant=self.participants.$getRecord(self.profile.$id);}/**
     * Set list of visible tasks and the % completion.
     *
     */function visibleTasks(){if(!self.tasks||!self.tasks.filter){self.visibleTasks=[];return;}self.visibleTasks=self.tasks.filter(function(t){return!t.hidden&&!t.archived;});taskCompletion();}/**
     * Calculate all visible tasks completion rate.
     *
     */function taskCompletion(){self.taskCompletion=self.visibleTasks.reduce(function(all,task){all[task.$id]=_taskCompletion(task.$id);return all;},{});}/**
     * Return the completion rate of a task.
     *
     */function _taskCompletion(taskId){var participantCount,participantsIds;if(!self.participants||!self.progress){return 0;}participantCount=self.participants.length;participantsIds=self.participants.reduce(function(all,participant){if(participant.$id){all[participant.$id]=true;}return all;},{});if(participantCount<1){return 0;}return Object.keys(self.progress).filter(function(publicId){return participantsIds[publicId]&&// Make sure user is still participating
// (user progress is kept when they leave)
self.progress[publicId]&&self.progress[publicId][taskId]&&self.progress[publicId][taskId].completed;}).length/participantCount*100;}function _completionComparer(options){var taskId=options.key;return function(a,b){var aP=self.progress&&self.progress[a.$id]&&self.progress[a.$id][taskId]&&self.progress[a.$id][taskId].completed;var bP=self.progress&&self.progress[b.$id]&&self.progress[b.$id][taskId]&&self.progress[b.$id][taskId].completed;if(aP===bP){return 0;}else if(aP){return 1;}return-1;};}function _solutionComparer(options){var taskId=options.key;var task=self.tasks.$getRecord(taskId);if(!task||!task.textResponse&&!task.linkPattern){return noop$7;}return function(a,b){var aS=self.solutions&&self.solutions[a.$id]&&self.solutions[a.$id][taskId]||'';var bS=self.solutions&&self.solutions[b.$id]&&self.solutions[b.$id][taskId]||'';return aS.localeCompare(bS);};}function _compareName(a,b){var aN=a.user&&a.user.displayName||'';var bN=b.user&&b.user.displayName||'';return aN.localeCompare(bN);}function sortedParticipants(participants,options){var rows=participants.filter(function(p){return p.$id!==self.profile.$id;});var comparer;if(options.key){comparer=chainComparer([_completionComparer(options),_solutionComparer(options),_compareName]);}else{comparer=_compareName;}rows.sort(reverseComparer(options.reversed,comparer));return rows;}// Update the pager rowCount
// (the pager should trigger a range update which will call participantsView)
function updateParticipantRowCount(){currentUserParticipant();if(self.currentUserParticipant){self.pagerOptions.setRowCount(self.participants.length-1);}else{self.pagerOptions.setRowCount(self.participants.length);}}/**
     * Set the slice of participant to show.
     *
     */function participantsView(){var rows=sortedParticipants(self.participants,self.orderOptions);self.participantsView=rows.slice(self.pagerOptions.range.start,self.pagerOptions.range.end);self.participantsView.unshift(self.currentUserParticipant);}/**
     * Switch ordering key or ordering direction.
     *
     * If the ordering key is changing, the ordering direction should be
     * ascendent.
     *
     * If the order key is not changing, the direction should be switched.
     *
     */this.orderBy=function(taskId){self.orderOptions.reversed=!self.orderOptions.reversed&&self.orderOptions.key===taskId;self.orderOptions.key=taskId;participantsView();};function defaultLinker(task,serviceProfile){if(!serviceProfile||!serviceProfile.details||!serviceProfile.details.id||!task||!task.badge||!task.badge.url){return'#'+urlFor('editProfile');}return task.badge.url;}var linkers={codeSchool:defaultLinker,codeCombat:defaultLinker,singPath:function singPath(task){if(!task||task.serviceId!=='singPath'){return'';}if(!task.singPathProblem||!task.singPathProblem.path||!task.singPathProblem.path.id||!task.singPathProblem.level||!task.singPathProblem.level.id||!task.singPathProblem.problem||!task.singPathProblem.problem.id){return clmServicesUrl.singPath;}return(clmServicesUrl.singPath+'/#'+'/paths/'+task.singPathProblem.path.id+'/levels/'+task.singPathProblem.level.id+'/problems/'+task.singPathProblem.problem.id+'/play').replace(/\/+/,'/');}};this.startLink=function(task,profile){var serviceProfile;if(!task||!task.serviceId||!linkers[task.serviceId]){return'';}serviceProfile=profile&&profile.services&&profile.services[task.serviceId];return linkers[task.serviceId](task,serviceProfile);};var trackedServices={codeSchool:true,codeCombat:true};this.mustRegister=function(task,profile){return Boolean(task&&task.serviceId&&trackedServices[task.serviceId]&&(!profile||!profile.services||!profile.services[task.serviceId]||!profile.services[task.serviceId].details||!profile.services[task.serviceId].details.id));};this.viewLink=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:linkTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.review=true;this.participant=participant;if(userSolution&&userSolution[taskId]){this.solution=$sce.trustAsResourceUrl(userSolution[taskId]);}this.save=function(link){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,link).then(function(){$mdDialog.hide();spfAlert.success('Link is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save the link.');return err;});};this.cancel=function(){$mdDialog.hide();};}};this.viewMultipleChoiceResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:mcqTmpl$1,controller:DialogController,controllerAs:'ctrl'});function DialogController(){var self=this;this.task=task;this.viewOnly=true;this.questions=angular.fromJson(task.mcqQuestions);this.isChecked=function(answers,index){if(answers){return answers.indexOf(index)>-1;}else{return false;}};this.show=function(answers){if(answers){return answers.length>1;}else{return false;}};// If userSolution is not null and userSolution given
// taskId is not null
if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}if(task.type=='TRAT'){clmDataStore.events.getMCQAnswers(eventId,task.taskFrom).then(function(answers){var userAnswers=angular.fromJson(answers.$value);for(var i=0;i<self.questions.length;i++){self.questions[i].answers=userAnswers[i];}});}else{var userAnswers=angular.fromJson(this.solution).userAnswers;for(var i=0;i<this.questions.length;i++){this.questions[i].answers=userAnswers[i];}}this.cancel=function(){$mdDialog.hide();};}};this.viewTextResponse=function(eventId,taskId,task,participant,userSolution){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:responseTmpl,controller:DialogController,controllerAs:'ctrl'});function DialogController(){this.task=task;this.viewOnly=true;if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(response){clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});};this.cancel=function(){$mdDialog.hide();};}};this.viewCodeResponse=function(eventId,taskId,task,participant,userSolution){console.log("1");$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:codeTmpl,onComplete:loadEditor,controller:CodeController,controllerAs:'ctrl'});this.loadingEditor=true;var parent=this;function loadEditor(){var editor=ace.edit($document[0].querySelector('#editor'));editor.setTheme("ace/theme/monokai");editor.getSession().setMode("ace/mode/"+task.lang.toLowerCase());editor.getSession().setUseWrapMode(true);editor.setOptions({readOnly:true,highlightActiveLine:false,highlightGutterLine:false});parent.loadingEditor=false;}function CodeController(){console.log("44");this.task=task;this.viewOnly=true;this.checkEditor=function(){return parent.loadingEditor;console.log(parent.loadingEditor);};if(userSolution&&userSolution[taskId]){this.solution=userSolution[taskId];}this.save=function(){var editor=ace.edit(document.querySelector('#editor'));var response=editor.getValue();// console.log("Function submitted for answer " + response);
clmDataStore.events.submitSolution(eventId,taskId,participant.$id,response).then(function(){$mdDialog.hide();spfAlert.success('Response is saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save your response.');return err;});};this.cancel=function(){$mdDialog.hide();};}};this.saveAllocatedPoints=function(eventId,taskId,task,participant,score){clmDataStore.events.saveScore(eventId,participant.$id,taskId,score).then(function(){spfAlert.success('Score has been saved.');}).catch(function(err){$log.error(err);spfAlert.error('Failed to save score.');return err;});};this.update=function(){};/*
     this.update = function(event, tasks, userSolutions, profile) {
     return clmDataStore.events.updateCurrentUserProfile(
     event, tasks, userSolutions, profile
     ).then(function() {
     spfAlert.success('Profile updated');
     }).catch(function(err) {
     $log.error(err);
     spfAlert.error('Failed to update profile');
     });
     };*/this.removeParticipant=function(e,event,participant){var confirm=$mdDialog.confirm().parent($document.body).title('Would you like to remove '+participant.user.displayName+'?').content('The participant progress will be kept but he/she will not show as participant').ariaLabel('Remove participant').ok('Remove').cancel('Cancel').targetEvent(e);$mdDialog.show(confirm).then(function(){clmDataStore.events.removeParticpants(event.$id,participant.$id);});};// load up resources and start firebase watcher
this.loading=true;$q.all({userProgress:clmDataStore.events.getUserProgress(this.event.$id,this.profile.$id).then(function(progress){self.currentUserProgress=progress;unwatchers.push(progress.$destroy.bind(progress));return progress;}),userSolution:clmDataStore.events.getUserSolutions(this.event.$id,this.profile.$id).then(function(solutions){self.currentUserSolutions=solutions;unwatchers.push(solutions.$destroy.bind(solutions));return solutions;}),singpathQueuedSolution:clmDataStore.singPath.queuedSolutions(this.profile.$id).then(function(paths){unwatchers.push(paths.$destroy.bind(paths));return paths;})}).then(function(results){visibleTasks();// Set the participant view (via the pager range update event)
unwatchers.push(self.pagerOptions.onChange(participantsView));updateParticipantRowCount();// Monitor updates on task progress and participants list.
unwatchers.push(self.tasks.$watch(visibleTasks));unwatchers.push(self.progress.$watch(taskCompletion));unwatchers.push(self.participants.$watch(taskCompletion));unwatchers.push(self.participants.$watch(updateParticipantRowCount));return results;}).finally(function(){self.loading=false;}).then(function(results){var update=function update(){// Removed due to June 2016 profile updating process change.
/*
             return clmDataStore.events.updateCurrentUserProfile(
             self.event,
             self.tasks,
             results.userSolution,
             self.profile
             );
             */};// Watch for singpath problem getting updated
unwatchers.push(results.singpathQueuedSolution.$watch(update));return update();}).catch(function(err){$log.error(err);});// clean up.
$scope.$on('$destroy',function(){unwatchers.forEach(function(f){if(f){try{f();}catch(err){$log.error(err);}}});});}function clmPagerFactory(){return{template:pagerTmpl,restrict:'E',bindToController:true,scope:{options:'='},controller:ClmPagerCtrl,controllerAs:'ctrl'};}// Keep row per page selection acrossviews.
function clmRowPerPageFactory($log){var cb=[];var opts={value:50,options:[5,10,25,50,75,100],set:function set(value){opts.value=parseInt(value,10);if(opts.value<1){opts.value=1;}opts.triggerChange();},/**
         * Register a function to call synchronously whn roePerPage is set.
         *
         * If the function needs to modify the rowPerPage it shouldn't use the
         * setter or do it asynchronously.
         *
         * @param  {function} fn
         * @return {function}
         */onChange:function onChange(fn){cb.push(fn);return function(){cb=cb.filter(function(f){return f!==fn;});};},triggerChange:function triggerChange(){cb.forEach(function(fn){try{fn(opts.value);}catch(err){$log.error(err);}});}};return opts;}function clmPagerOptionFactory($log,clmRowPerPage){return function clmPagerOption(){var rangeCBs=[];var unwatch;var opts={rowCount:0,range:{start:0,end:0},/**
             * Set rowCount and reset range.
             *
             * Trigger a change "event".
             *
             * @param {number} count
             */setRowCount:function setRowCount(count){opts.rowCount=count;opts.setRange(opts.range.start);},/**
             * Set range from its starting index and `clmRowPerPage.value`.
             *
             * The range start index will be set to the start of a page, with the
             * first page starting at zero and the second page starting at
             * `clmRowPerPage.value`, etc...
             *
             * @param {number} start
             */setRange:function setRange(start){var end;start=start||0;if(start<0){start=0;}start-=start%clmRowPerPage.value;if(start>opts.rowCount){start=opts.rowCount;}end=start+clmRowPerPage.value;if(end>opts.rowCount){end=opts.rowCount;}opts.range.start=start;opts.range.end=end;opts.triggerChange();},/**
             * Register a function to be called each time the the pager data
             * are set.
             *
             * Setting the rowCount, the range or setting `clmRowPerPage.value`
             * will trigger a call synchronously.
             *
             * The calls must not update rowCount or the range using the setters
             * (or if it does it use them asynchronously).
             *
             * @param  {Function} cb Function to register.
             * @return {Function}    Deregister the function.
             */onChange:function onChange(cb){rangeCBs.push(cb);return function(){rangeCBs=rangeCBs.filter(function(fn){return fn!==cb;});};},triggerChange:function triggerChange(){rangeCBs.forEach(callCB);},$destroy:function $destroy(){unwatch();}};unwatch=clmRowPerPage.onChange(function(){opts.setRange(opts.range.start);});function callCB(cb){try{cb(opts);}catch(err){$log.error(err);}}return opts;};}function ClmPagerCtrl(clmRowPerPage){this.rowPerPage=clmRowPerPage;this.nextPage=function(options){options.setRange(options.range.end);};this.prevPage=function(options){options.setRange(options.range.start-1);};this.firstPage=function(options){options.setRange(0);};this.lastPage=function(options){options.setRange(options.rowCount);};}function reverseComparer(reverse,fn){if(!reverse){return fn;}return function(a,b){var result=fn(a,b);return result*-1;};}function chainComparer(comparerList){return function(a,b){var i,result;for(i=0;i<comparerList.length;i++){result=comparerList[i](a,b);if(result){return result;}}return 0;};}function configServices(clmServices){clmServices.register('Code Combat');clmServices.register('Code School');clmServices.register('Free Code Camp');clmServices.register('Pivotal Expert');}function configRoute$4($routeProvider,routes){$routeProvider.when(routes.editProfile,{template:editTmpl$1,controller:ClmProfileCtrl,controllerAs:'ctrl',resolve:{initialData:clmEditProfileInitialDataResolver}}).when(routes.profile,{template:showTmpl,controller:ClmProfileCtrl,controllerAs:'ctrl',resolve:{initialData:clmShowProfileInitialDataResolver}});}/**
 * Used to resolve `initialData` of `ClmProfileCtrl` the logged in user profile.
 *
 */function clmEditProfileInitialDataResolver($q,spfAuth,spfAuthData,clmDataStore){var profilePromise;var loggedIn=spfAuth.requireLoggedIn().catch(function(){return $q.reject(new Error('You need to be logged to edit her/his profile.'));});profilePromise=loggedIn.then(function(){return clmDataStore.currentUserProfile();}).then(function(profile){if(profile&&profile.$value===null){return clmDataStore.initProfile();}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user(),profile:profilePromise,currentUserProfile:profilePromise,settings:clmDataStore.settings.getObj()});}/**
 * Used to resolve `initialData` of `ClmProfileCtrl` for a public profile.
 *
 */function clmShowProfileInitialDataResolver($q,$route,spfAuth,spfAuthData,clmDataStore){var publicId=$route.current.params.publicId;var profilePromise;var errNoPublicId=new Error('Unexpected error: the public id is missing');var errNoProfile=new Error('Could not found the profile for '+publicId);if(!publicId){return $q.reject(errNoPublicId);}profilePromise=clmDataStore.profile(publicId).then(function(profile){if(profile.$value===null){return $q.reject(errNoProfile);}return profile;});return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(noop$8),currentUserProfile:clmDataStore.currentUserProfile(),profile:profilePromise,settings:clmDataStore.settings.getObj()});}/**
 * ClmProfileCtrl
 *
 */function ClmProfileCtrl($log,$q,$timeout,$route,spfAuthData,spfNavBarService,initialData,clmDataStore,spfAlert,clmRefreshTimout){var _this=this;var refreshLabel='Refresh Achievements';var waitingLabel='Waiting...';var self=this;var refreshButton={title:refreshLabel,onClick:function onClick(){return _this.refreshAllService();},icon:'loop',disabled:false};var menu=[refreshButton];this.auth=initialData.auth;this.currentUser=initialData.currentUser;this.currentUserProfile=initialData.currentUserProfile;this.profile=initialData.profile;this.settings=initialData.settings;this.canRefresh=true;this.refreshTimeout=undefined;if(this.profile&&this.profile.$id&&this.currentUser&&this.currentUser.publicId===this.profile.$id){menu.push({title:'Edit',onClick:function onClick(){return _this.profileNeedsUpdate=true;},icon:'create'});}spfNavBarService.update('Profile',undefined,menu);this.settingPublicId=false;// this.profileNeedsUpdate = this.currentUser && !this.currentUser.$completed();
this.profileNeedsUpdate=false;function cleanProfile(currentUser){currentUser.country=cleanObj(currentUser.country);currentUser.school=cleanObj(currentUser.school);}this.goBack=function(){self.profileNeedsUpdate=false;};this.setPublicId=function(currentUser){var saved;this.settingPublicId=true;cleanProfile(currentUser);if(!self.profile){saved=spfAuthData.publicId(currentUser).then(function(){spfAlert.success('Public id and display name saved');return clmDataStore.initProfile();});}else{saved=currentUser.$save().then(function(){return clmDataStore.updateProfile(currentUser);});}return saved.then(function(){spfAlert.success('Profile setup.');return $route.reload();}).catch(function(err){spfAlert.error('Failed to ');return $q.reject(err);}).finally(function(){self.settingPublicId=false;});};this.refreshAllService=function(){_this.disableRefresh();clmDataStore.services.refresh(_this.profile).catch(function(err){_this.canRefresh=true;$log.error(err);spfAlert.error('Failed to refresh achievements.');});};this.disableRefresh=function(){refreshButton.title=waitingLabel;refreshButton.disabled=true;_this.canRefresh=false;_this.refreshTimeout=$timeout(clmRefreshTimout);_this.refreshTimeout.then(function(){return _this.enableRefresh();});};this.enableRefresh=function(){refreshButton.title=refreshLabel;refreshButton.disabled=false;if(_this.refreshTimeout){$timeout.cancel(_this.refreshTimeout);_this.refreshTimeout=undefined;}};this.$onDestroy=function(){if(_this.refreshTimeout){$timeout.cancel(_this.refreshTimeout);_this.refreshTimeout=undefined;}};}/**
 * Update navBar with a title and no action.
 * @param {spfNavBarService} spfNavBarService
 * Load data required for executing controller functions
 * @param {initialData} initialData
 * Route routing directive
 * @param {urlFor} urlFor
 * Database reference
 * @param {firebaseApp} firebaseApp
 * Alert for success and errors
 * @param {spfAlert} spfAlert
 * Firebase reference for objects. Returns promise.
 * @param {$firebaseObject} $firebaseObject
 */function feedbackController(initialData,spfNavBarService,urlFor,firebaseApp,spfAlert,$firebaseObject){var self=this;var db=firebaseApp.database();this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.feedbackType=null;this.feedback={};this.anonymity=false;this.allFeedback={};spfNavBarService.update('Feedback');this.toggleFeedbackType=function(feedbackType){self.feedbackType=feedbackType;self.feedback={};if(self.feedbackType=='view'&&(self.currentUser.$id=='HTIc4MVi5CWC4I9rsbM6x0AarN52'||self.currentUser.$id=='google:113933988995739437762')){var path=db.ref('classMentors/userFeedback');var fb=$firebaseObject(path);fb.$loaded().then(function(){self.allFeedback=fb;});}};this.saveFeedback=function(){self.feedback.type=self.feedbackType;var stamp=new Date(Date.now());var months=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];self.feedback.timestamp=stamp.getDate()+"-"+months[stamp.getMonth()]+"-"+stamp.getFullYear()+" ("+stamp.getHours()+":"+stamp.getMinutes()+":"+stamp.getSeconds()+")";if(!self.anonymity){self.feedback.loggedBy={};self.feedback.loggedBy.displayName=self.profile.user.displayName;self.feedback.loggedBy.id=self.profile.$id;}else{self.feedback.loggedBy="anonymous";}var ref=db.ref('classMentors/userFeedback');ref.push(self.feedback).then(function(){self.feedbackType=null;self.feedback={};}).then(spfAlert.success("Feedback successfully registered. Thank you!")).catch(function(error){spfAlert.error("error");});};}/**
 * Config route for ace of coders views.
 *
 * @param  {object} $routeProvider ngRoute $route service provider.
 * @param  {object} routes         classmentors route map.
 */function configRoute$5($routeProvider,routes){$routeProvider.when(routes.feedback,{template:template$1,controller:feedbackController,controllerAs:'ctrl',resolve:{initialData:clmFeedbackResolver}}).otherwise(routes.home);}function clmFeedbackResolver($q,spfAuth,spfAuthData,clmDataStore){return $q.all({featuredCohorts:clmDataStore.cohorts.listFeaturedCohorts(),auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(error){return error;}),profile:clmDataStore.currentUserProfile(),createdCohorts:clmDataStore.cohorts.listCreatedCohorts(),joinedEvents:clmDataStore.events.listJoinedEvents(),allCohorts:clmDataStore.cohorts.listAllCohorts()});}/**
 * Update navBar with a title and no action.
 * @param {spfNavBarService} spfNavBarService
 * Load data required for executing controller functions
 * @param {initialData} initialData
 * Route routing directive
 * @param {urlFor} urlFor
 * Database reference
 * @param {firebaseApp} firebaseApp
 * Alert for success and errors
 * @param {spfAlert} spfAlert
 * Firebase reference for objects. Returns promises
 * @param {$firebaseObject} $firebaseObject
 */function qqController(initialData,spfNavBarService,urlFor,firebaseApp,spfAlert,$firebaseObject,clmDataStore,$q){var self=this;var db=firebaseApp.database();this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.createdEvents=initialData.createdEvents;this.joinedEvents=initialData.joinedEvents;this.asstEvents=[];clmDataStore.events.getAssistingEvents(self.currentUser.publicId).then(function(events){// console.log(events);
self.asstEvents=events;}).then(function(){for(var index in self.asstEvents){var eventId=self.asstEvents[index].$id;if(eventId){resolveEventQuestions('asst',eventId);}}}).catch(function(error){spfAlert.error(error);});for(var index in self.joinedEvents){var eventId=self.joinedEvents[index].$id;if(eventId){resolveEventQuestions('joined',eventId);}}for(var _index in self.createdEvents){var _eventId=self.createdEvents[_index].$id;if(_eventId){resolveEventQuestions('created',_eventId);}}function resolveEventQuestions(type,eventId){clmDataStore.events.questions.allRef(eventId).then(function(questions){if(type=='joined'){self.joinedEvents.find(function(e){return e.$id==eventId;}).questions=questions;}if(type=='created'){self.createdEvents.find(function(e){return e.$id==eventId;}).questions=questions;}if(type=='asst'){self.asstEvents.find(function(e){return e.$id==eventId;}).questions=questions;}});clmDataStore.events.getForumStatus(eventId).then(function(status){// console.log(status.$value);
if(type=='joined'){self.joinedEvents.find(function(e){return e.$id==eventId;}).closedForum=status.$value;}if(type=='created'){self.createdEvents.find(function(e){return e.$id==eventId;}).closedForum=status.$value;}if(type=='asst'){self.asstEvents.find(function(e){return e.$id==eventId;}).closedForum=status.$value;}});}spfNavBarService.update('Questions');}function eventQController(initialData,spfNavBarService,urlFor,firebaseApp,spfAlert,$firebaseObject,$mdDialog,$document,clmDataStore){var self=this;var db=firebaseApp.database();this.currentUser=initialData.currentUser;this.profile=initialData.profile;this.event=initialData.event;this.questions=initialData.questions;this.myQnLimit=3;this.voteQnLimit=3;this.expandMyQns=function(){if(self.myQnLimit+3>self.questions.filter(function(qn){return qn.owner.publicId==self.currentUser.publicId;}).length){self.myQnLimit=self.questions.filter(function(qn){return qn.owner.publicId==self.currentUser.publicId;}).length;}else{self.myQnLimit+=3;}};this.collapseMyQns=function(){if(self.myQnLimit-3<0){self.myQnLimit=0;}else{self.myQnLimit-=3;}};this.expandVoteQns=function(){if(self.voteQnLimit+3>self.questions.length){self.voteQnLimit=self.questions.length;}else{self.voteQnLimit+=3;}};this.collapseVoteQns=function(){if(self.voteQnLimit-3<0){self.voteQnLimit=0;}else{self.voteQnLimit-=3;}};clmDataStore.events.getForumStatus(self.event.$id).then(function(status){self.event.closedForum=status.$value;});this.toggleForumStatus=function(){if(self.event.closedForum){console.log('forum is now closed');spfAlert.success('Forum is now closed.');db.ref('classMentors/events/'+self.event.$id+'/closedForum').set(true);db.ref('classMentors/eventQuestions/'+self.event.$id+'/closedForum').set(true);}else{console.log('forum is now open');spfAlert.success('Forum is now open.');db.ref('classMentors/events/'+self.event.$id+'/closedForum').remove();db.ref('classMentors/eventQuestions/'+self.event.$id+'/closedForum').remove();}};spfNavBarService.update(self.event.title,{title:'Questions',url:'#'+urlFor('questionQueue')},getOptions());//update options on navigation bar on top
function getOptions(){var options=[];if(!self.currentUser||!self.currentUser.publicId){return options;}options.push({title:'View Other Questions',url:'#'+urlFor('questionQueue'),icon:'arrow-back'});return options;}this.toggleVote=function(question,questionId){var ref=db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+questionId+'/upVotes/'+self.currentUser.publicId);if(question.owner.publicId==self.currentUser.publicId){spfAlert.error("You cannot vote on your own question.");}else{if(question.upVotes&&question.upVotes[self.currentUser.publicId]){ref.remove();}else{return ref.set(Date.now());}}};this.toggleQnFlag=function(question){if(question.flagged){db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+question.$id+'/flagged').remove();}else{if(question.answeredBy){spfAlert.error('You cannot flag a question that has already been resolved.');}else{db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+question.$id+'/flagged').set(true);}}};this.askNewQuestion=function(event,currentUser){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:askQnTmpl,controller:askQnController,controllerAs:'ctrl'});function askQnController(){var self=this;this.event=event;this.user={publicId:currentUser.publicId,displayName:currentUser.displayName,gravatar:currentUser.gravatar};this.question={};this.postQn=function(){self.question.owner=self.user;self.question.createdAt=Date.now();clmDataStore.events.questions.create(self.question,self.event.$id).then(spfAlert.success('You have successfully posted a new question.')).then($mdDialog.hide()).catch(function(){spfAlert.error('You failed to post your question.');});clmDataStore.logging.inputLog({action:"askQuestion",publicId:currentUser.publicId,eventId:event.$id,timestamp:self.question.createdAt});};this.closeDialog=function(){$mdDialog.hide();};}};}function oneQnController(initialData,spfNavBarService,urlFor,firebaseApp,spfAlert,$firebaseObject,$document,clmDataStore,$mdDialog){var self=this;var db=firebaseApp.database();this.event=initialData.event;this.currentUser=initialData.currentUser;this.question=initialData.question;this.answers=initialData.answers;// console.log(self.event);
spfNavBarService.update('View Question',[{title:'Questions',url:'#'+urlFor('questionQueue')},{title:self.event.title,url:'#'+urlFor('eventQueue',{eventId:this.event.$id})}],[{title:'Back',url:'#'+urlFor('eventQueue',{eventId:this.event.$id}),icon:'arrow-back'}]);this.toggleQnVote=function(question,questionId){var ref=db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+questionId+'/upVotes/'+self.currentUser.publicId);if(question.owner.publicId==self.currentUser.publicId){spfAlert.error("You cannot vote on your own question.");}else{if(question.upVotes&&question.upVotes[self.currentUser.publicId]){ref.remove();}else{return ref.set(Date.now());}}};this.toggleAnsVote=function(questionId,answer){var ref=db.ref('classMentors/eventQuestions/'+self.event.$id+'/answers/'+questionId+'/'+answer.$id+'/upVotes/'+self.currentUser.publicId);if(answer.owner.publicId==self.currentUser.publicId){spfAlert.error("You cannot vote on your own answer.");}else{if(answer.upVotes&&answer.upVotes[self.currentUser.publicId]){ref.remove();}else{return ref.set(Date.now());}}};this.toggleQnFlag=function(){if(self.question.flagged){db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+self.question.$id+'/flagged').remove();}else{if(self.question.answeredBy){spfAlert.error('You cannot flag a question that has already been resolved.');}else{db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+self.question.$id+'/flagged').set(true);}}};this.toggleAskerChoice=function(answerId,accepted,answer){var ref1=db.ref('classMentors/eventQuestions/'+self.event.$id+'/answers/'+self.question.$id+'/'+answerId+'/acceptedAt');var ref2=db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+self.question.$id+'/answeredBy');if(accepted){ref1.remove();ref2.remove();spfAlert.success('You have re-opened this question.');}else{if(self.question.answeredBy){var oldAns=self.question.answeredBy;console.log(oldAns);var ref3=db.ref('classMentors/eventQuestions/'+self.event.$id+'/answers/'+self.question.$id+'/'+oldAns+'/acceptedAt');ref3.remove();}ref1.set(Date.now());ref2.set(answer.$id);db.ref('classMentors/eventQuestions/'+self.event.$id+'/questions/'+self.question.$id+'/flagged').remove();spfAlert.success('You have marked this question as resolved.');var action='';if(answer.owner.publicId==self.event.owner.publicId){action='questionResolvedByEducator';}else if(self.event.assistants[answer.owner.publicId]){action='questionResolvedByAssistant';}else if(answer.owner.publicId==self.question.owner.publicId){action='questionResolvedBySelf';}else{action='questionResolvedByPeers';}clmDataStore.logging.inputLog({publicId:self.currentUser.publicId,action:action,timestamp:Date.now(),questionId:self.question.$id,answerId:answerId});}};this.answerQuestion=function(eventId,questionId,currentUser){$mdDialog.show({clickOutsideToClose:true,parent:$document.body,template:ansQnTmpl,controller:ansQnController,controllerAs:'ctrl'});function ansQnController(){var self=this;this.answer={};this.answerQn=function(){self.answer.createdAt=Date.now();self.answer.owner={publicId:currentUser.publicId,gravatar:currentUser.gravatar,displayName:currentUser.displayName};clmDataStore.events.questions.answers.postAnswer(eventId,questionId,self.answer).then(function(answer){var ref=db.ref('classMentors/eventQuestions/'+eventId+'/questions/'+questionId+'/respondedBy/'+answer.key);ref.set(self.answer.createdAt);}).then(spfAlert.success("Successfully posted your response.")).then($mdDialog.hide()).catch(function(){spfAlert.error("Failed to post your response.");});clmDataStore.logging.inputLog({action:"respondToQuestion",questionId:questionId,publicId:currentUser.publicId,eventId:eventId,timestamp:self.answer.createdAt});};this.closeDialog=function(){$mdDialog.hide();};}};}// export const component = {
//     qqHome,
//     // controller: qqController,
//     eventQ
// };
/**
 * Config route for ace of coders views.
 *
 * @param  {object} $routeProvider ngRoute $route service provider.
 * @param  {object} routes         classmentors route map.
 */function configRoute$6($routeProvider,routes){$routeProvider.when(routes.questionQueue,{template:qqHome,controller:qqController,controllerAs:'ctrl',resolve:{initialData:clmQQResolver}}).when(routes.eventQueue,{template:eventQ,controller:eventQController,controllerAs:'ctrl',resolve:{initialData:eventQResolver}}).when(routes.oneQuestion,{template:oneQn,controller:oneQnController,controllerAs:'ctrl',resolve:{initialData:oneQnResolver}}).otherwise(routes.home);}function clmQQResolver($q,spfAuth,spfAuthData,clmDataStore){return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(error){return error;}),profile:clmDataStore.currentUserProfile(),joinedEvents:clmDataStore.events.listJoinedEvents(),createdEvents:clmDataStore.events.listCreatedEvents()});}function eventQResolver($q,spfAuth,spfAuthData,clmDataStore,$route){var eventId=$route.current.params.eventId;return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(error){return error;}),profile:clmDataStore.currentUserProfile(),event:clmDataStore.events.get(eventId),questions:clmDataStore.events.questions.allRef(eventId)});}function oneQnResolver($q,spfAuth,spfAuthData,clmDataStore,$route){var eventId=$route.current.params.eventId;var questionId=$route.current.params.questionId;return $q.all({auth:spfAuth.$loaded(),currentUser:spfAuthData.user().catch(function(error){return error;}),event:clmDataStore.events.get(eventId),question:clmDataStore.events.questions.getQuestion(eventId,questionId),answers:clmDataStore.events.questions.answers.allRef(eventId,questionId)});}/**
 * Route admin requests to the admin component.
 *
 * @param  {object} $routeProvider ngRoute $route service provider.
 * @param  {object} routes         Routes map.
 */function configRoute$7($routeProvider,routes){$routeProvider.when(routes.admin,{template:'<clm-admin></clm-admin>'});}function routeProtection($rootScope,$location){$rootScope.$on('$routeChangeStart',routeChangeStartListener);//  function(event, next, current){
$rootScope.$on('$routeChangeSuccess',routeChangeSuccessListener);}/**
 * Bootstrap classmentors Angular app and overwrite default settings.
 *
 * @param {{firebaseApp: string, singpathUrl: string, backendUrl: string}} options Application
 */function bootstrap(options){options=options||{};var deps=options.extra?[module$1.name,options.extra.name]:[module$1.name];var bootstrapModule=angular$1.module('classmentors.bootstrap',deps);if(options.firebaseApp){bootstrapModule.constant('firebaseApp',options.firebaseApp);bootstrapModule.constant('authFirebaseApp',options.firebaseApp);}else{// use singpath firebase by default
var firebaseApp=firebase.initializeApp({apiKey:'AIzaSyBH01uLzdMqH0hkbDqvcgpzTDpo6yYtPDA',authDomain:'singpath.firebaseapp.com',databaseURL:'https://singpath.firebaseio.com'});bootstrapModule.constant('firebaseApp',firebaseApp);bootstrapModule.constant('authFirebaseApp',firebaseApp);}if(options.provider){bootstrapModule.constant('authProvider',options.provider);}else{var provider=new firebase.auth.GoogleAuthProvider();provider.addScope('https://www.googleapis.com/auth/userinfo.email');provider.addScope('https://www.googleapis.com/auth/userinfo.profile');bootstrapModule.constant('authProvider',provider);}bootstrapModule.run(['clmServicesUrl',function(clmServicesUrl){if(options.singpathURL){clmServicesUrl.singPath=options.singpathURL.replace(/\/$/,'');}if(options.backendURL){clmServicesUrl.backend=options.backendURL.replace(/\/$/,'');}}]);angular$1.element(document).ready(function(){angular$1.bootstrap(document,[bootstrapModule.name],{strictDi:true});});}return{setters:[function(_2){angular$1=_2.default;},function(_3){firebase=_3.default;},function(_4){},function(_5){},function(_6){},function(_7){},function(_8){},function(_9){},function(_10){},function(_d){},function(_11){},function(_12){},function(_13){},function(_14){},function(_15){},function(_16){},function(_17){},function(_b){ace=_b.default;},function(_a4){},function(_c){},function(_d2){},function(_e){},function(_f){},function(_18){},function(_19){},function(_20){CryptoJS=_20.default;},function(_21){},function(_22){},function(_23){},function(_24){},function(_25){camelCase=_25.default;},function(_26){},function(_a5){},function(_d3){c3=_d3.default;},function(_27){},function(_e2){},function(_f2){},function(_28){},function(_29){},function(_30){}],execute:function(){noop=function noop(){return undefined;};spfEditorDirectiveFactory.$inject=['$log'];ace$1=Object.freeze({spfEditorDirectiveFactory:spfEditorDirectiveFactory});tmpl="<!-- ng-class=\"ctrl.notifications[0].notificationType\" -->\n<md-toast class=\"md-whiteframe-z2\" ng-class=\"ctrl.notifications[0].notificationType\" layout-padding layout-margin>\n    <span flex>{{ctrl.notifications[0].message}}</span>\n    <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.prev()\" ng-disabled=\"ctrl.notifications.length < 2\">\n        Prev\n    </md-button>\n    <md-button class=\"md-raised md-accent\" ng-click=\"ctrl.close()\">\n        Close\n    </md-button>\n</md-toast>\n";SpfAlertCtrl.$inject=['$mdToast','notifications','toastOptions'];spfAlertFactory.$inject=['$q','$mdToast'];alert=Object.freeze({spfAlertFactory:spfAlertFactory});tmpl$1="<div class=\"md-toolbar-tools\" ng-controller=\"SpfSharedNavBarCtrl as navBar\">\n    <md-button ng-click=\"navBar.openSideMenu('left')\" hide-gt-md class=\"open-menu\" aria-label=\"open side menu\">\n        <md-icon md-svg-icon=\"reorder\" alt=\"open side menu\"></md-icon>\n    </md-button>\n\n    <div hide-sm layout=\"row\" ng-repeat=\"parent in navBar.currentPage.parents\" class=\"nav-parent\">\n        <h2 ng-if=\"parent.title\">\n            <a ng-href=\"{{parent.url || ''}}\">\n                {{parent.title}}\n            </a>\n        </h2>\n\n        <md-icon class=\"separator\"\n            md-svg-icon=\"keyboard-arrow-right\"\n            ng-if=\"navBar.currentPage.parent &amp;&amp; navBar.currentPage.title\"\n        ></md-icon>\n    </div>\n\n    <h3 ng-bind=\"navBar.currentPage.title\"></h3>\n\n    <span flex></span>\n\n    <md-button class=\"menu-item responsive-button md-raised md-primary\" ng-repeat=\"btn in navBar.currentPage.menuItems track by (btn.url || btn.onClick)\" ng-href=\"{{btn.url}}\" aria-label=\"{{btn.title}}\" ng-click=\"btn.onClick()\" ng-disabled=\"btn.disabled\">\n        <md-icon md-svg-icon=\"{{btn.icon}}\" ng-if=\"btn.icon\"></md-icon>\n        <span ng-bind=\"btn.title\" hide show-gt-sm></span>\n    </md-button>\n\n    <span ng-switch=\"navBar.auth.user.uid\">\n        <span ng-switch-when=\"undefined\">\n            <md-button ng-click=\"navBar.login()\" class=\"responsive-button md-raised md-accent\">\n                <md-icon md-svg-icon=\"launch\"></md-icon>\n                <span hide-sm>login</span>\n            </md-button>\n        </span>\n        <span ng-switch-default>\n            <md-button ng-click=\"navBar.logout()\" class=\"responsive-button md-raised md-primary\">\n                <md-icon md-svg-icon=\"exit-to-app\"></md-icon>\n                <span hide-sm>logout</span>\n            </md-button>\n        </span>\n    </span>\n</div>\n";noop$1=function noop(){return undefined;};initNavBar.$inject=['$templateCache','$rootScope','spfNavBarService'];spfNavBarServiceFactory.$inject=[];SpfSharedNavBarCtrl.$inject=['$q','$mdSidenav','spfAlert','spfAuth','spfNavBarService'];navbar=Object.freeze({initNavBar:initNavBar,spfNavBarServiceFactory:spfNavBarServiceFactory,SpfSharedNavBarCtrl:SpfSharedNavBarCtrl});tmpl$2="<ng-form name=\"signForm\">\n\t<div layout layout-sm=\"column\">\n        <md-input-container flex ng-if=\"!ctrl.publicIdIsReadOnly\">\n            <label for=\"sign-public-id\">Your Public Id</label>\n            <input ng-minlength=\"3\" md-maxlength=\"20\" ng-pattern=\"/^[-a-z0-9]+$/\" required id=\"sign-public-id\" name=\"userPublicId\" ng-model=\"currentUser.publicId\" spf-uniq-public-id>\n            <div ng-messages=\"signForm.userPublicId.$error\">\n                <div ng-message=\"required\">This is required.</div>\n                <div ng-message=\"minlength\">The public id has to be more than 2 characters long.</div>\n                <div ng-message=\"md-maxlength\">The public id has to be less than 20 characters long.</div>\n                <div ng-message=\"pattern\">The public id should only include lowercase letters, numbers and \"-\".</div>\n                <div ng-message=\"spfUniqPublicId\">This public ID is already taken.</div>\n            </div>\n        </md-input-container>\n        <md-input-container flex ng-if=\"ctrl.publicIdIsReadOnly\">\n            <label for=\"sign-public-id\">Your Public Id</label>\n            <input ng-model=\"currentUser.publicId\" disabled=\"disabled\" />\n        </md-input-container>\n        <md-input-container flex>\n            <label for=\"sign-display-name\">Your screen name</label>\n            <input ng-minlength=\"3\" md-maxlength=\"64\" required id=\"sign-display-name\" name=\"userDisplayName\" ng-model=\"currentUser.displayName\">\n            <div ng-messages=\"signForm.userDisplayName.$error\">\n                <div ng-message=\"required\">This is required.</div>\n                <div ng-message=\"minlength\">The screen name has to be more than 2 characters long.</div>\n                <div ng-message=\"md-maxlength\">The screen name has to be less than 64 characters long.</div>\n            </div>\n        </md-input-container>\n    </div>\n\n    <div layout layout-sm=\"column\" ng-if=\"ctrl.publicIdIsReadOnly\">\n        <md-input-container flex layout=\"column\">\n            <md-select flex name=\"userCountry\" ng-model=\"currentUser.country\" required placeholder=\"Where are you from?\">\n                <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.countries track by opt.code\">{{opt.name}}</md-option>\n            </md-select>\n            <div ng-messages=\"signForm.userCountry.$error\">\n                <div ng-message=\"required\">This is required.</div>\n            </div>\n        </md-input-container>\n\n        <md-input-container flex layout=\"column\" ng-if=\"currentUser.country.code == 'SG'\">\n            <md-select flex name=\"userYearOfBirth\" ng-model=\"currentUser.yearOfBirth\" required placeholder=\"When were you born?\">\n                <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.ageGroups\">\n                    <span ng-if=\"opt == 1990\">born before</span>\n                    {{opt}}\n                </md-option>\n            </md-select>\n            <div ng-messages=\"signForm.userYearOfBirth.$error\">\n                <div ng-message=\"required\">This is required.</div>\n            </div>\n        </md-input-container>\n    \t\n        <p ng-if=\"!ctrl.loaded\" flex>Loading schools...</p>\n\n\t\t<md-input-container flex layout=\"column\" ng-if=\"ctrl.loaded &amp;&amp; currentYear - currentUser.yearOfBirth <= 20 &amp;&amp; currentYear - currentUser.yearOfBirth  >= 10\">\n            <md-select flex name=\"userSchool\" ng-model=\"currentUser.school\" required placeholder=\"Select a School\">\n                <md-optgroup label=\"Other\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Other' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n                <md-optgroup label=\"Junior College\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Junior College' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n                <md-optgroup label=\"Secondary\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Secondary' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n                <md-optgroup label=\"Polytechnic\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.schools | filter: {type: 'Polytechnic' }\">{{opt.name}}</md-option>\n                </md-optgroup>\n            </md-select>\n            <div ng-messages=\"signForm.userSchool.$error\">\n                <div ng-message=\"required\">This is required.</div>\n            </div>\n        </md-input-container>\n    </div>\n</ng-form>";SpfSignFormCtrl.$inject=['$scope','SPF_COUNTRIES','spfSchools'];spfSignFormDirectiveFactory.$inject=[];spfUniqPublicIdFactory.$inject=['$q','spfAuthData'];sign=Object.freeze({spfSignFormDirectiveFactory:spfSignFormDirectiveFactory,spfUniqPublicIdFactory:spfUniqPublicIdFactory});components={ace:ace$1,alert:alert,navbar:navbar,sign:sign};list=[{name:'Afghanistan',code:'AF'},{name:'Åland Islands',code:'AX'},{name:'Albania',code:'AL'},{name:'Algeria',code:'DZ'},{name:'American Samoa',code:'AS'},{name:'AndorrA',code:'AD'},{name:'Angola',code:'AO'},{name:'Anguilla',code:'AI'},{name:'Antarctica',code:'AQ'},{name:'Antigua and Barbuda',code:'AG'},{name:'Argentina',code:'AR'},{name:'Armenia',code:'AM'},{name:'Aruba',code:'AW'},{name:'Australia',code:'AU'},{name:'Austria',code:'AT'},{name:'Azerbaijan',code:'AZ'},{name:'Bahamas',code:'BS'},{name:'Bahrain',code:'BH'},{name:'Bangladesh',code:'BD'},{name:'Barbados',code:'BB'},{name:'Belarus',code:'BY'},{name:'Belgium',code:'BE'},{name:'Belize',code:'BZ'},{name:'Benin',code:'BJ'},{name:'Bermuda',code:'BM'},{name:'Bhutan',code:'BT'},{name:'Bolivia',code:'BO'},{name:'Bosnia and Herzegovina',code:'BA'},{name:'Botswana',code:'BW'},{name:'Bouvet Island',code:'BV'},{name:'Brazil',code:'BR'},{name:'British Indian Ocean Territory',code:'IO'},{name:'Brunei Darussalam',code:'BN'},{name:'Bulgaria',code:'BG'},{name:'Burkina Faso',code:'BF'},{name:'Burundi',code:'BI'},{name:'Cambodia',code:'KH'},{name:'Cameroon',code:'CM'},{name:'Canada',code:'CA'},{name:'Cape Verde',code:'CV'},{name:'Cayman Islands',code:'KY'},{name:'Central African Republic',code:'CF'},{name:'Chad',code:'TD'},{name:'Chile',code:'CL'},{name:'China',code:'CN'},{name:'Christmas Island',code:'CX'},{name:'Cocos (Keeling) Islands',code:'CC'},{name:'Colombia',code:'CO'},{name:'Comoros',code:'KM'},{name:'Congo',code:'CG'},{name:'Congo, The Democratic Republic of the',code:'CD'},{name:'Cook Islands',code:'CK'},{name:'Costa Rica',code:'CR'},{name:'Cote D\'Ivoire',code:'CI'},{name:'Croatia',code:'HR'},{name:'Cuba',code:'CU'},{name:'Cyprus',code:'CY'},{name:'Czech Republic',code:'CZ'},{name:'Denmark',code:'DK'},{name:'Djibouti',code:'DJ'},{name:'Dominica',code:'DM'},{name:'Dominican Republic',code:'DO'},{name:'Ecuador',code:'EC'},{name:'Egypt',code:'EG'},{name:'El Salvador',code:'SV'},{name:'Equatorial Guinea',code:'GQ'},{name:'Eritrea',code:'ER'},{name:'Estonia',code:'EE'},{name:'Ethiopia',code:'ET'},{name:'Falkland Islands (Malvinas)',code:'FK'},{name:'Faroe Islands',code:'FO'},{name:'Fiji',code:'FJ'},{name:'Finland',code:'FI'},{name:'France',code:'FR'},{name:'French Guiana',code:'GF'},{name:'French Polynesia',code:'PF'},{name:'French Southern Territories',code:'TF'},{name:'Gabon',code:'GA'},{name:'Gambia',code:'GM'},{name:'Georgia',code:'GE'},{name:'Germany',code:'DE'},{name:'Ghana',code:'GH'},{name:'Gibraltar',code:'GI'},{name:'Greece',code:'GR'},{name:'Greenland',code:'GL'},{name:'Grenada',code:'GD'},{name:'Guadeloupe',code:'GP'},{name:'Guam',code:'GU'},{name:'Guatemala',code:'GT'},{name:'Guernsey',code:'GG'},{name:'Guinea',code:'GN'},{name:'Guinea-Bissau',code:'GW'},{name:'Guyana',code:'GY'},{name:'Haiti',code:'HT'},{name:'Heard Island and Mcdonald Islands',code:'HM'},{name:'Holy See (Vatican City State)',code:'VA'},{name:'Honduras',code:'HN'},{name:'Hong Kong',code:'HK'},{name:'Hungary',code:'HU'},{name:'Iceland',code:'IS'},{name:'India',code:'IN'},{name:'Indonesia',code:'ID'},{name:'Iran, Islamic Republic Of',code:'IR'},{name:'Iraq',code:'IQ'},{name:'Ireland',code:'IE'},{name:'Isle of Man',code:'IM'},{name:'Israel',code:'IL'},{name:'Italy',code:'IT'},{name:'Jamaica',code:'JM'},{name:'Japan',code:'JP'},{name:'Jersey',code:'JE'},{name:'Jordan',code:'JO'},{name:'Kazakhstan',code:'KZ'},{name:'Kenya',code:'KE'},{name:'Kiribati',code:'KI'},{name:'Korea, Democratic People\'S Republic of',code:'KP'},{name:'Korea, Republic of',code:'KR'},{name:'Kuwait',code:'KW'},{name:'Kyrgyzstan',code:'KG'},{name:'Lao People\'S Democratic Republic',code:'LA'},{name:'Latvia',code:'LV'},{name:'Lebanon',code:'LB'},{name:'Lesotho',code:'LS'},{name:'Liberia',code:'LR'},{name:'Libyan Arab Jamahiriya',code:'LY'},{name:'Liechtenstein',code:'LI'},{name:'Lithuania',code:'LT'},{name:'Luxembourg',code:'LU'},{name:'Macao',code:'MO'},{name:'Macedonia, The Former Yugoslav Republic of',code:'MK'},{name:'Madagascar',code:'MG'},{name:'Malawi',code:'MW'},{name:'Malaysia',code:'MY'},{name:'Maldives',code:'MV'},{name:'Mali',code:'ML'},{name:'Malta',code:'MT'},{name:'Marshall Islands',code:'MH'},{name:'Martinique',code:'MQ'},{name:'Mauritania',code:'MR'},{name:'Mauritius',code:'MU'},{name:'Mayotte',code:'YT'},{name:'Mexico',code:'MX'},{name:'Micronesia, Federated States of',code:'FM'},{name:'Moldova, Republic of',code:'MD'},{name:'Monaco',code:'MC'},{name:'Mongolia',code:'MN'},{name:'Montserrat',code:'MS'},{name:'Morocco',code:'MA'},{name:'Mozambique',code:'MZ'},{name:'Myanmar',code:'MM'},{name:'Namibia',code:'NA'},{name:'Nauru',code:'NR'},{name:'Nepal',code:'NP'},{name:'Netherlands',code:'NL'},{name:'Netherlands Antilles',code:'AN'},{name:'New Caledonia',code:'NC'},{name:'New Zealand',code:'NZ'},{name:'Nicaragua',code:'NI'},{name:'Niger',code:'NE'},{name:'Nigeria',code:'NG'},{name:'Niue',code:'NU'},{name:'Norfolk Island',code:'NF'},{name:'Northern Mariana Islands',code:'MP'},{name:'Norway',code:'NO'},{name:'Oman',code:'OM'},{name:'Pakistan',code:'PK'},{name:'Palau',code:'PW'},{name:'Palestinian Territory, Occupied',code:'PS'},{name:'Panama',code:'PA'},{name:'Papua New Guinea',code:'PG'},{name:'Paraguay',code:'PY'},{name:'Peru',code:'PE'},{name:'Philippines',code:'PH'},{name:'Pitcairn',code:'PN'},{name:'Poland',code:'PL'},{name:'Portugal',code:'PT'},{name:'Puerto Rico',code:'PR'},{name:'Qatar',code:'QA'},{name:'Reunion',code:'RE'},{name:'Romania',code:'RO'},{name:'Russian Federation',code:'RU'},{name:'RWANDA',code:'RW'},{name:'Saint Helena',code:'SH'},{name:'Saint Kitts and Nevis',code:'KN'},{name:'Saint Lucia',code:'LC'},{name:'Saint Pierre and Miquelon',code:'PM'},{name:'Saint Vincent and the Grenadines',code:'VC'},{name:'Samoa',code:'WS'},{name:'San Marino',code:'SM'},{name:'Sao Tome and Principe',code:'ST'},{name:'Saudi Arabia',code:'SA'},{name:'Senegal',code:'SN'},{name:'Serbia and Montenegro',code:'CS'},{name:'Seychelles',code:'SC'},{name:'Sierra Leone',code:'SL'},{name:'Singapore',code:'SG'},{name:'Slovakia',code:'SK'},{name:'Slovenia',code:'SI'},{name:'Solomon Islands',code:'SB'},{name:'Somalia',code:'SO'},{name:'South Africa',code:'ZA'},{name:'South Georgia and the South Sandwich Islands',code:'GS'},{name:'Spain',code:'ES'},{name:'Sri Lanka',code:'LK'},{name:'Sudan',code:'SD'},{name:'Suriname',code:'SR'},{name:'Svalbard and Jan Mayen',code:'SJ'},{name:'Swaziland',code:'SZ'},{name:'Sweden',code:'SE'},{name:'Switzerland',code:'CH'},{name:'Syrian Arab Republic',code:'SY'},{name:'Taiwan, Province of China',code:'TW'},{name:'Tajikistan',code:'TJ'},{name:'Tanzania, United Republic of',code:'TZ'},{name:'Thailand',code:'TH'},{name:'Timor-Leste',code:'TL'},{name:'Togo',code:'TG'},{name:'Tokelau',code:'TK'},{name:'Tonga',code:'TO'},{name:'Trinidad and Tobago',code:'TT'},{name:'Tunisia',code:'TN'},{name:'Turkey',code:'TR'},{name:'Turkmenistan',code:'TM'},{name:'Turks and Caicos Islands',code:'TC'},{name:'Tuvalu',code:'TV'},{name:'Uganda',code:'UG'},{name:'Ukraine',code:'UA'},{name:'United Arab Emirates',code:'AE'},{name:'United Kingdom',code:'GB'},{name:'United States',code:'US'},{name:'United States Minor Outlying Islands',code:'UM'},{name:'Uruguay',code:'UY'},{name:'Uzbekistan',code:'UZ'},{name:'Vanuatu',code:'VU'},{name:'Venezuela',code:'VE'},{name:'Viet Nam',code:'VN'},{name:'Virgin Islands, British',code:'VG'},{name:'Virgin Islands, U.S.',code:'VI'},{name:'Wallis and Futuna',code:'WF'},{name:'Western Sahara',code:'EH'},{name:'Yemen',code:'YE'},{name:'Zambia',code:'ZM'},{name:'Zimbabwe',code:'ZW'}];setTmpl="<svg display=\"none\" width=\"0\" height=\"0\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs>\n        <g id=\"bookmark-outline\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M725.333 128h-426.667c-47.147 0-84.907 38.187-84.907 85.333l-0.427 682.667 298.667-128 298.667 128v-682.667c0-47.147-38.187-85.333-85.333-85.333zM725.333 768l-213.333-92.8-213.333 92.8v-554.667h426.667v554.667z\"></path>\n        </g>\n        <g id=\"delete\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M256 810.667c0 47.147 38.187 85.333 85.333 85.333h341.333c47.147 0 85.333-38.187 85.333-85.333v-512h-512v512zM810.667 170.667h-149.333l-42.667-42.667h-213.333l-42.667 42.667h-149.333v85.333h597.333v-85.333z\"></path>\n        </g>\n        <g id=\"exit-to-app\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M430.293 664.96l60.373 60.373 213.333-213.333-213.333-213.333-60.373 60.373 110.293 110.293h-412.587v85.333h412.587l-110.293 110.293zM810.667 128h-597.333c-47.147 0-85.333 38.187-85.333 85.333v170.667h85.333v-170.667h597.333v597.333h-597.333v-170.667h-85.333v170.667c0 47.147 38.187 85.333 85.333 85.333h597.333c47.147 0 85.333-38.187 85.333-85.333v-597.333c0-47.147-38.187-85.333-85.333-85.333z\"></path>\n        </g>\n        <g id=\"highlight-remove\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M622.293 341.333l-110.293 110.293-110.293-110.293-60.373 60.373 110.293 110.293-110.293 110.293 60.373 60.373 110.293-110.293 110.293 110.293 60.373-60.373-110.293-110.293 110.293-110.293-60.373-60.373zM512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.16 0-341.333-153.173-341.333-341.333s153.173-341.333 341.333-341.333 341.333 153.173 341.333 341.333-153.173 341.333-341.333 341.333z\"></path>\n        </g>\n        <g id=\"home\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M426.667 853.333v-256h170.667v256h213.333v-341.333h128l-426.667-384-426.667 384h128v341.333z\"></path>\n        </g>\n        <g id=\"info-outline\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M469.333 725.333h85.333v-256h-85.333v256zM512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.16 0-341.333-153.173-341.333-341.333s153.173-341.333 341.333-341.333 341.333 153.173 341.333 341.333-153.173 341.333-341.333 341.333zM469.333 384h85.333v-85.333h-85.333v85.333z\"></path>\n        </g>\n        <g id=\"launch\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M810.667 810.667h-597.333v-597.333h298.667v-85.333h-298.667c-47.147 0-85.333 38.187-85.333 85.333v597.333c0 47.147 38.187 85.333 85.333 85.333h597.333c47.147 0 85.333-38.187 85.333-85.333v-298.667h-85.333v298.667zM597.333 128v85.333h152.96l-419.413 419.413 60.373 60.373 419.413-419.413v152.96h85.333v-298.667h-298.667z\"></path>\n        </g>\n        <g id=\"reorder\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M128 640h768v-85.333h-768v85.333zM128 810.667h768v-85.333h-768v85.333zM128 469.333h768v-85.333h-768v85.333zM128 213.333v85.333h768v-85.333h-768z\"></path>\n        </g>\n        <g id=\"settings\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M829.013 553.6c1.707-13.653 2.987-27.52 2.987-41.6s-1.28-27.947-2.987-41.6l90.24-70.613c8.107-6.4 10.453-17.92 5.12-27.307l-85.333-147.84c-5.333-9.173-16.427-13.013-26.027-9.173l-106.24 42.88c-21.973-16.853-46.080-31.147-72.107-42.027l-16-113.067c-1.92-10.027-10.667-17.92-21.333-17.92h-170.667c-10.667 0-19.413 7.893-21.12 17.92l-16 113.067c-26.027 10.88-50.133 24.96-72.107 42.027l-106.24-42.88c-9.6-3.627-20.693 0-26.027 9.173l-85.333 147.84c-5.333 9.173-2.987 20.693 5.12 27.307l90.027 70.613c-1.707 13.653-2.987 27.52-2.987 41.6s1.28 27.947 2.987 41.6l-90.027 70.613c-8.107 6.4-10.453 17.92-5.12 27.307l85.333 147.84c5.333 9.173 16.427 13.013 26.027 9.173l106.24-42.88c21.973 16.853 46.080 31.147 72.107 42.027l16 113.067c1.707 10.027 10.453 17.92 21.12 17.92h170.667c10.667 0 19.413-7.893 21.12-17.92l16-113.067c26.027-10.88 50.133-24.96 72.107-42.027l106.24 42.88c9.6 3.627 20.693 0 26.027-9.173l85.333-147.84c5.333-9.173 2.987-20.693-5.12-27.307l-90.027-70.613zM512 661.333c-82.56 0-149.333-66.773-149.333-149.333s66.773-149.333 149.333-149.333 149.333 66.773 149.333 149.333-66.773 149.333-149.333 149.333z\"></path>\n        </g>\n        <g id=\"not-interested\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.587 0-341.333-152.747-341.333-341.333 0-78.933 27.093-151.253 71.893-209.067l478.507 478.507c-57.813 44.8-130.133 71.893-209.067 71.893zM781.44 721.067l-478.507-478.507c57.813-44.8 130.133-71.893 209.067-71.893 188.587 0 341.333 152.747 341.333 341.333 0 78.933-27.093 151.253-71.893 209.067z\"></path>\n        </g>\n        <g id=\"play-arrow\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M341.333 213.333v597.333l469.333-298.667z\"></path>\n        </g>\n        <g id=\"add-circle-outline\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M554.667 298.667h-85.333v170.667h-170.667v85.333h170.667v170.667h85.333v-170.667h170.667v-85.333h-170.667v-170.667zM512 85.333c-235.733 0-426.667 190.933-426.667 426.667s190.933 426.667 426.667 426.667 426.667-190.933 426.667-426.667-190.933-426.667-426.667-426.667zM512 853.333c-188.16 0-341.333-153.173-341.333-341.333s153.173-341.333 341.333-341.333 341.333 153.173 341.333 341.333-153.173 341.333-341.333 341.333z\"></path>\n        </g>\n        <g id=\"create\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M128 736v160h160l472.107-472.107-160-160-472.107 472.107zM883.413 300.587c16.64-16.64 16.64-43.733 0-60.373l-99.627-99.627c-16.64-16.64-43.733-16.64-60.373 0l-78.080 78.080 160 160 78.080-78.080z\"></path>\n        </g>\n        <g id=\"keyboard-arrow-right\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M366.293 702.293l195.627-195.627-195.627-195.627 60.373-60.373 256 256-256 256z\"></path>\n        </g>\n        <g id=\"keyboard-arrow-left\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M657.707 696.96l-195.627-195.627 195.627-195.627-60.373-60.373-256 256 256 256z\"></path>\n        </g>\n        <g id=\"person\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 512c94.293 0 170.667-76.587 170.667-170.667 0-94.293-76.373-170.667-170.667-170.667s-170.667 76.373-170.667 170.667c0 94.080 76.373 170.667 170.667 170.667zM512 597.333c-113.707 0-341.333 56.96-341.333 170.667v85.333h682.667v-85.333c0-113.707-227.627-170.667-341.333-170.667z\"></path>\n        </g>\n        <g id=\"loop\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 170.667v-128l-170.667 170.667 170.667 170.667v-128c141.44 0 256 114.56 256 256 0 43.307-10.88 83.84-29.653 119.68l62.293 62.293c33.067-52.907 52.693-114.987 52.693-181.973 0-188.587-152.747-341.333-341.333-341.333zM512 768c-141.44 0-256-114.56-256-256 0-43.307 10.88-83.84 29.653-119.68l-62.293-62.293c-33.067 52.907-52.693 114.987-52.693 181.973 0 188.587 152.747 341.333 341.333 341.333v128l170.667-170.667-170.667-170.667v128z\"></path>\n        </g>\n        <g id=\"done\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M384 689.92l-177.92-177.92-60.373 60.373 238.293 238.293 512-512-60.373-60.373z\"></path>\n        </g>\n        <g id=\"chevron-left\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M657.707 316.373l-60.373-60.373-256 256 256 256 60.373-60.373-195.627-195.627z\"></path>\n        </g>\n        <g id=\"chevron-right\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M323.525 752.112l253.021-253.021-253.021-253.021 77.455-77.455 330.475 330.475-330.475 330.475z\"></path>\n        </g>\n        <g id=\"check\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M384 690l452-452 60 60-512 512-238-238 60-60z\"></path>\n        </g>\n        <g id=\"clear\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M810 274l-238 238 238 238-60 60-238-238-238 238-60-60 238-238-238-238 60-60 238 238 238-238z\"></path>\n        </g>\n        <g id=\"add\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M899.725 566.645h-333.077v333.077h-109.292v-333.077h-333.077v-109.292h333.077v-333.077h109.292v333.077h333.077v109.292z\"></path>\n        </g>\n        <g id=\"more-horiz\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M256 426.667c-47.147 0-85.333 38.187-85.333 85.333s38.187 85.333 85.333 85.333 85.333-38.187 85.333-85.333-38.187-85.333-85.333-85.333zM768 426.667c-47.147 0-85.333 38.187-85.333 85.333s38.187 85.333 85.333 85.333 85.333-38.187 85.333-85.333-38.187-85.333-85.333-85.333zM512 426.667c-47.147 0-85.333 38.187-85.333 85.333s38.187 85.333 85.333 85.333 85.333-38.187 85.333-85.333-38.187-85.333-85.333-85.333z\"></path>\n        </g>\n        <g id=\"arrow-back\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M853.333 469.333h-519.253l238.293-238.293-60.373-60.373-341.333 341.333 341.333 341.333 60.373-60.373-238.293-238.293h519.253v-85.333z\"></path>\n        </g>\n        <g id=\"arrow-forward\" viewBox=\"0 0 1024 1024\">\n            <path class=\"path1\" d=\"M512 170.667l-60.373 60.373 238.293 238.293h-519.253v85.333h519.253l-238.293 238.293 60.373 60.373 341.333-341.333z\"></path>\n        </g>\n    </defs>\n</svg>\n";pythonTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n    <linearGradient id=\"a\" gradientUnits=\"userSpaceOnUse\" x1=\"70.252\" y1=\"1237.476\" x2=\"170.659\" y2=\"1151.089\" gradientTransform=\"matrix(.563 0 0 -.568 -29.215 707.817)\">\n        <stop offset=\"0\" stop-color=\"#5A9FD4\"/>\n        <stop offset=\"1\" stop-color=\"#306998\"/>\n    </linearGradient>\n    <path fill=\"url(#a)\" d=\"M63.391 1.988c-4.222.02-8.252.379-11.8 1.007-10.45 1.846-12.346 5.71-12.346 12.837v9.411h24.693v3.137h-33.961c-7.176 0-13.46 4.313-15.426 12.521-2.268 9.405-2.368 15.275 0 25.096 1.755 7.311 5.947 12.519 13.124 12.519h8.491v-11.282c0-8.151 7.051-15.34 15.426-15.34h24.665c6.866 0 12.346-5.654 12.346-12.548v-23.513c0-6.693-5.646-11.72-12.346-12.837-4.244-.706-8.645-1.027-12.866-1.008zm-13.354 7.569c2.55 0 4.634 2.117 4.634 4.721 0 2.593-2.083 4.69-4.634 4.69-2.56 0-4.633-2.097-4.633-4.69-.001-2.604 2.073-4.721 4.633-4.721z\"/>\n    <linearGradient id=\"b\" gradientUnits=\"userSpaceOnUse\" x1=\"209.474\" y1=\"1098.811\" x2=\"173.62\" y2=\"1149.537\" gradientTransform=\"matrix(.563 0 0 -.568 -29.215 707.817)\">\n        <stop offset=\"0\" stop-color=\"#FFD43B\"/>\n        <stop offset=\"1\" stop-color=\"#FFE873\"/>\n    </linearGradient>\n    <path fill=\"url(#b)\" d=\"M91.682 28.38v10.966c0 8.5-7.208 15.655-15.426 15.655h-24.665c-6.756 0-12.346 5.783-12.346 12.549v23.515c0 6.691 5.818 10.628 12.346 12.547 7.816 2.297 15.312 2.713 24.665 0 6.216-1.801 12.346-5.423 12.346-12.547v-9.412h-24.664v-3.138h37.012c7.176 0 9.852-5.005 12.348-12.519 2.578-7.735 2.467-15.174 0-25.096-1.774-7.145-5.161-12.521-12.348-12.521h-9.268zm-13.873 59.547c2.561 0 4.634 2.097 4.634 4.692 0 2.602-2.074 4.719-4.634 4.719-2.55 0-4.633-2.117-4.633-4.719 0-2.595 2.083-4.692 4.633-4.692z\"/>\n    <radialGradient id=\"c\" cx=\"1825.678\" cy=\"444.45\" r=\"26.743\" gradientTransform=\"matrix(0 -.24 -1.055 0 532.979 557.576)\" gradientUnits=\"userSpaceOnUse\">\n        <stop offset=\"0\" stop-color=\"#B8B8B8\" stop-opacity=\".498\"/>\n        <stop offset=\"1\" stop-color=\"#7F7F7F\" stop-opacity=\"0\"/>\n    </radialGradient>\n    <path opacity=\".444\" fill=\"url(#c)\" enable-background=\"new\" d=\"M97.309 119.597c0 3.543-14.816 6.416-33.091 6.416-18.276 0-33.092-2.873-33.092-6.416 0-3.544 14.815-6.417 33.092-6.417 18.275 0 33.091 2.872 33.091 6.417z\"/>\n</svg>";angularjsTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n  <path fill=\"#B3B3B3\" d=\"M63.81 1.026l-59.257 20.854 9.363 77.637 49.957 27.457 50.214-27.828 9.36-77.635z\"/>\n  <path fill=\"#A6120D\" d=\"M117.536 25.998l-53.864-18.369v112.785l45.141-24.983z\"/>\n  <path fill=\"#DD1B16\" d=\"M11.201 26.329l8.026 69.434 44.444 24.651v-112.787z\"/>\n  <path fill=\"#F2F2F2\" d=\"M78.499 67.67l-14.827 6.934h-15.628l-7.347 18.374-13.663.254 36.638-81.508 14.827 55.946zm-1.434-3.491l-13.295-26.321-10.906 25.868h10.807l13.394.453z\"/>\n  <path fill=\"#B3B3B3\" d=\"M63.671 11.724l.098 26.134 12.375 25.888h-12.446l-.027 10.841 17.209.017 8.042 18.63 13.074.242z\"/>\n</svg>";javascriptTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n\t<path fill=\"#F0DB4F\" d=\"M1.408 1.408h125.184v125.185h-125.184z\"/>\n\t<path fill=\"#323330\" d=\"M116.347 96.736c-.917-5.711-4.641-10.508-15.672-14.981-3.832-1.761-8.104-3.022-9.377-5.926-.452-1.69-.512-2.642-.226-3.665.821-3.32 4.784-4.355 7.925-3.403 2.023.678 3.938 2.237 5.093 4.724 5.402-3.498 5.391-3.475 9.163-5.879-1.381-2.141-2.118-3.129-3.022-4.045-3.249-3.629-7.676-5.498-14.756-5.355l-3.688.477c-3.534.893-6.902 2.748-8.877 5.235-5.926 6.724-4.236 18.492 2.975 23.335 7.104 5.332 17.54 6.545 18.873 11.531 1.297 6.104-4.486 8.08-10.234 7.378-4.236-.881-6.592-3.034-9.139-6.949-4.688 2.713-4.688 2.713-9.508 5.485 1.143 2.499 2.344 3.63 4.26 5.795 9.068 9.198 31.76 8.746 35.83-5.176.165-.478 1.261-3.666.38-8.581zm-46.885-37.793h-11.709l-.048 30.272c0 6.438.333 12.34-.714 14.149-1.713 3.558-6.152 3.117-8.175 2.427-2.059-1.012-3.106-2.451-4.319-4.485-.333-.584-.583-1.036-.667-1.071l-9.52 5.83c1.583 3.249 3.915 6.069 6.902 7.901 4.462 2.678 10.459 3.499 16.731 2.059 4.082-1.189 7.604-3.652 9.448-7.401 2.666-4.915 2.094-10.864 2.07-17.444.06-10.735.001-21.468.001-32.237z\"/>\n</svg>";javaTmpl="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 128 128\">\n  <path fill=\"#0074BD\" d=\"M47.617 98.12s-4.767 2.774 3.397 3.71c9.892 1.13 14.947.968 25.845-1.092 0 0 2.871 1.795 6.873 3.351-24.439 10.47-55.308-.607-36.115-5.969zM44.629 84.455s-5.348 3.959 2.823 4.805c10.567 1.091 18.91 1.18 33.354-1.6 0 0 1.993 2.025 5.132 3.131-29.542 8.64-62.446.68-41.309-6.336z\"/>\n  <path fill=\"#EA2D2E\" d=\"M69.802 61.271c6.025 6.935-1.58 13.17-1.58 13.17s15.289-7.891 8.269-17.777c-6.559-9.215-11.587-13.792 15.635-29.58 0 .001-42.731 10.67-22.324 34.187z\"/>\n  <path fill=\"#0074BD\" d=\"M102.123 108.229s3.529 2.91-3.888 5.159c-14.102 4.272-58.706 5.56-71.094.171-4.451-1.938 3.899-4.625 6.526-5.192 2.739-.593 4.303-.485 4.303-.485-4.953-3.487-32.013 6.85-13.743 9.815 49.821 8.076 90.817-3.637 77.896-9.468zM49.912 70.294s-22.686 5.389-8.033 7.348c6.188.828 18.518.638 30.011-.326 9.39-.789 18.813-2.474 18.813-2.474s-3.308 1.419-5.704 3.053c-23.042 6.061-67.544 3.238-54.731-2.958 10.832-5.239 19.644-4.643 19.644-4.643zM90.609 93.041c23.421-12.167 12.591-23.86 5.032-22.285-1.848.385-2.677.72-2.677.72s.688-1.079 2-1.543c14.953-5.255 26.451 15.503-4.823 23.725 0-.002.359-.327.468-.617z\"/>\n  <path fill=\"#EA2D2E\" d=\"M76.491 1.587s12.968 12.976-12.303 32.923c-20.266 16.006-4.621 25.13-.007 35.559-11.831-10.673-20.509-20.07-14.688-28.815 8.548-12.834 32.229-19.059 26.998-39.667z\"/>\n  <path fill=\"#0074BD\" d=\"M52.214 126.021c22.476 1.437 57-.8 57.817-11.436 0 0-1.571 4.032-18.577 7.231-19.186 3.612-42.854 3.191-56.887.874 0 .001 2.875 2.381 17.647 3.331z\"/>\n</svg>";iconSet={url:'icons/svgdefs.svg',tmpl:setTmpl,vb:1024};langIcons=[{title:'language:python',url:'icons/icons-python.svg',tmpl:pythonTmpl,vb:128},{title:'language:angularjs',url:'icons/icons-angularjs.svg',tmpl:angularjsTmpl,vb:128},{title:'language:javascript',url:'icons/icons-javascript.svg',tmpl:javascriptTmpl,vb:128},{title:'language:java',url:'icons/icons-java.svg',tmpl:javaTmpl,vb:128}];config.$inject=['$mdIconProvider'];run.$inject=['$templateCache'];icons=Object.freeze({config:config,run:run});_classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}};_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();hex=CryptoJS.enc.Hex;random=CryptoJS.lib.WordArray.random;pbkdf2=CryptoJS.PBKDF2;saltSize=16;keySize=8;iterations=1012;prf='SHA256';PasswordService=function(){function PasswordService(settings){_classCallCheck(this,PasswordService);this.settings=settings;}/**
   * Return a hash for the password and options allowing
   * to rebuild the same against the same password.
   *
   * The options will include the hashing algorithm name, the
   * salt an other parameters.
   *
   * @param  {string} password password to hash
   * @return {{value: string, options: {salt: string, iterations: number, keySize: number, hasher: string}}}
   */_createClass(PasswordService,[{key:'newHash',value:function newHash(password){var salt=random(this.settings.saltSize);var hash=pbkdf2(password,salt,{keySize:this.settings.keySize,iterations:this.settings.iterations,hasher:CryptoJS.algo[prf]});return{value:hex.stringify(hash),options:{salt:hex.stringify(salt),iterations:this.settings.iterations,keySize:this.settings.keySize,hasher:'PBKDF2',prf:prf}};}/**
  * Return a hash built from the password, the hash and the
  * hashing options.
  *
  * The salt should be hex encoded.
  *
   * @param  {string} password password to hash.
   * @param  {string} hexSalt  hash salt.
   * @param  {object} options  hash options
   * @return {string}
   */},{key:'fromSalt',value:function fromSalt(password,hexSalt,options){var salt=hex.parse(hexSalt);var hash=pbkdf2(password,salt,{keySize:options.keySize||this.settings.keySize,iterations:options.iterations||this.settings.iterations,hasher:CryptoJS.algo[options.prf||prf]});return hex.stringify(hash);}}]);return PasswordService;}();Service=function(){function Service(spfCryptoSaltSize,spfCryptoHashKeySize,spfCryptoIteration){_classCallCheck(this,Service);this.password=new PasswordService({saltSize:spfCryptoSaltSize,iterations:spfCryptoIteration,keySize:spfCryptoHashKeySize});}/**
   * Return a CryptoJS MD5 Hash.
   *
   * Usage:
   *
   *  const spfCrypto = new Service();
   *  const hash = spfCrypto.md5();
   *  const hex = hash.toString();
   *
   * @param  {string} message message to hash.
   * @return {object}
   */_createClass(Service,[{key:'md5',value:function md5(message){return new CryptoJS.MD5(message);}},{key:'randomString',value:function randomString(size){var str=random(size);return hex.stringify(str);}}]);return Service;}();Service.$inject=['spfCryptoSaltSize','spfCryptoHashKeySize','spfCryptoIteration'];crypto=Object.freeze({saltSize:saltSize,keySize:keySize,iterations:iterations,prf:prf,Service:Service});defaults={home:'/'};urlForFactory.$inject=['routes'];urlForFilterFactory.$inject=['urlFor'];run$1.$inject=['$rootScope','$location','routes','spfAlert'];routeServices=Object.freeze({defaults:defaults,urlForFactory:urlForFactory,urlForFilterFactory:urlForFilterFactory,run:run$1});_defineProperty=function(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;};gravatarBaseUrl='//www.gravatar.com/avatar/';eventName='spfCurrentUser.authChanged';SpfCurrentUserService=function(){function SpfCurrentUserService($q,$timeout,$log,$rootScope,spfCrypto,firebaseApp,authFirebaseApp,spfAuth,spfProfilesPath){var _this=this;_classCallCheck(this,SpfCurrentUserService);this.$q=$q;this.$timeout=$timeout;this.$log=$log;this.$rootScope=$rootScope;this.$db=firebaseApp.database();this.$authDb=authFirebaseApp.database();this.$spfAuth=spfAuth;this.$spfCrypto=spfCrypto;this.$spfProfilesPath=spfProfilesPath;this.$watchers={};this.firebaseUser=undefined;this.uid=undefined;this.user=undefined;this.publicId=undefined;this.profile=undefined;this.isAdmin=false;this.isPremium=false;this.$watchers.firebaseUser=spfAuth.onAuth(function(firebaseUser){return _this.authChangedHandler(firebaseUser);});}/**
   * Return a promise resolving once the profile/auth data currently loading
   * finishes.
   *
   * Reject if the it times out (2000ms timeout delay by default).
   *
   * @param  {number} delay timeout delay
   * @return {Promise<void, Error>}
   */_createClass(SpfCurrentUserService,[{key:'$loaded',value:function $loaded(delay){var _this2=this;var defaultTimeout=2000;delay=isNaN(delay)?defaultTimeout:delay;return this.$q(function(resolve,reject){var loaded=function loaded(){return _this2.user!==undefined&&_this2.profile!==undefined;};if(loaded()){resolve();return;}var timer=void 0;var stop=_this2.$rootScope.$on(eventName,function(){if(!loaded()){return;}stop();resolve();_this2.$timeout.cancel(timer);});timer=_this2.$timeout(function(){stop();reject(new Error('timeout'));},delay);});}/**
   * Stop watching user's data and profile and reset them.
   *
   * It should notify (event and digest trigger) the changed state.
   *
   * @param {any} value to set the value to null (loaded) instead indefined.
   */},{key:'resetUser',value:function resetUser(value){this.publicId=value!==undefined?null:undefined;this.user=value!==undefined?null:undefined;this.doResetProfile(value);if(this.$watchers.user){this.$watchers.user();this.$watchers.user=undefined;}this.$rootScope.$emit(eventName,{user:true,profile:true});this.$rootScope.$applyAsync();}/**
   * Stop watching user's profile and reset it.
   *
   * It should notify (event and digest trigger) the changed state.
   *
   * @param {any} value to set the value to null (loaded) instead indefined.
   */},{key:'resetProfile',value:function resetProfile(value){this.doResetProfile(value);this.$rootScope.$emit(eventName,{profile:true});this.$rootScope.$applyAsync();}},{key:'doResetProfile',value:function doResetProfile(value){this.profile=value!==undefined?null:undefined;this.isAdmin=false;this.isPremium=false;if(this.$watchers.profile){this.$watchers.profile();this.$watchers.profile=undefined;}}},{key:'userRef',value:function userRef(uid){if(!uid){throw new Error('The user uid provided.');}return this.$authDb.ref('auth/users/'+uid);}},{key:'profileRef',value:function profileRef(publicId){if(!publicId){throw new Error('The user publicId provided.');}return this.$db.ref(this.$spfProfilesPath+'/'+publicId);}},{key:'profileDetailsRef',value:function profileDetailsRef(publicId){return this.profileRef(publicId).child('user');}/**
   * Set or update the saved user data at "auth/users/$userId".
   *
   * @return {Promise<void, Error>}
   */},{key:'patchUser',value:function patchUser(){var _this3=this;var ref=this.userRef(this.firebaseUser.uid);return ref.once('value').then(function(){return ref.transaction(function(value){return _this3.updateUser(value);});});}},{key:'updateUser',value:function updateUser(user){var info=this.info();if(!info){return undefined;}if(!user){return{id:this.firebaseUser.uid,fullName:info.name,displayName:info.name,email:info.email,gravatar:this.gravatar(info.email),createdAt:{'.sv':'timestamp'}};}var updated=false;if(info.name!==user.fullName){user.fullName=info.name;updated=true;}if(info.email!==user.email){user.email=info.email;user.gravatar=this.gravatar(info.email);updated=true;}return updated?user:undefined;}/**
   * Set or update the Profile data at "path/to/profile/$publicId/user".
   *
   * The path to app profile location is set via the "spfProfilesPath" angular
   * module constant.
   *
   * @return {Promise<void, Error>}
   */},{key:'patchProfile',value:function patchProfile(){var _this4=this;var ref=this.profileDetailsRef(this.user.publicId);return ref.once('value').then(function(){return ref.transaction(function(value){return _this4.updateProfile(value);});});}},{key:'updateProfile',value:function updateProfile(profile){if(!this.user||!this.user.displayName||!this.user.gravatar){return undefined;}var newProfile={displayName:this.user.displayName,gravatar:this.user.gravatar,yearOfBirth:this.user.yearOfBirth||null,school:this.user.school||null,country:this.user.country||null};if(!profile){return newProfile;}var updatedProfile=Object.assign({},profile,newProfile);var updated=Object.keys(updatedProfile).some(function(key){var value=updatedProfile[key];var old=profile[key]||null;var isObject=value instanceof Object;if(!isObject){return value!==old;}if(Boolean(value)!==Boolean(old)){return true;}var propsChanged=Object.keys(value).some(function(p){return value[p]!==old[p];});if(propsChanged){return true;}var propsDeleted=Object.keys(old).some(function(p){return!value[p];});return propsDeleted;});return updated?Object.assign(profile,updatedProfile):undefined;}/**
   * Handle changes to the current user auth status.
   *
   * It should update the firebaseUser and uid properties and notify (event and
   * digest trigger) the changed state.
   *
   * The changes should cascade to the auth and profile data, and the related
   * properties related.
   *
   * @param  {?{uid: string, provider: string, google: object}} firebaseUser firebase auth data
   */},{key:'authChangedHandler',value:function authChangedHandler(firebaseUser){var isLogged=firebaseUser&&firebaseUser.uid;var wasAlreadyLogged=isLogged&&this.firebaseUser&&this.firebaseUser.uid&&this.firebaseUser.uid;this.uid=firebaseUser&&firebaseUser.uid||null;this.firebaseUser=firebaseUser||null;if(!isLogged){this.resetUser(null);this.$rootScope.$emit(eventName,{firebaseUser:true});return;}this.patchUser();if(!wasAlreadyLogged){this.watchUser();}this.$rootScope.$emit(eventName,{firebaseUser:true});this.$rootScope.$applyAsync();}/**
   * Handle changes to the current user saved auth data.
   *
   * It should update the user and public properties and notify (event and
   * digest trigger) the changed state.
   *
   * The changes should cascade to the save profile data and to profile related
   * properties
   *
   * @param {?{publicId: string, displayName: string, gravatar: string}} user saved firebase auth data
   */},{key:'userChangedHandler',value:function userChangedHandler(user){var dataSaved=user!==null;var newPublicId=user&&user.publicId&&(!this.user||!this.user.publicId);this.publicId=user&&user.publicId||null;this.user=user;if(!dataSaved||!user.publicId){this.resetProfile(null);this.$rootScope.$emit(eventName,{user:true});return;}this.patchProfile();if(!this.$watchers.profile||newPublicId){this.watchProfile();}this.$rootScope.$emit(eventName,{user:true});this.$rootScope.$applyAsync();}/**
   * Handle changes to the current user saved auth data.
   *
   * update the profile. isAdmin and isPremium properties, and notify (event and
   * digest trigger) the changed state.
   *
   * @param  {?{isAdmin: boolean, isPremium: boolean}} profile profile data
   */},{key:'profileChangedHandler',value:function profileChangedHandler(profile){this.isAdmin=profile&&profile.isAdmin||false;this.isPremium=profile&&profile.isPremium||false;this.profile=profile;this.$rootScope.$emit(eventName,{profile:true});this.$rootScope.$applyAsync();}},{key:'watchUser',value:function watchUser(){var _this5=this;if(!this.firebaseUser||!this.firebaseUser.uid){this.resetUser(null);return;}var ref=this.userRef(this.firebaseUser.uid);var handler=function handler(snapshot){return _this5.userChangedHandler(snapshot.val());};var onError=function onError(err){_this5.$log.error(err);_this5.resetUser(null);};this.resetUser();this.$watchers.user=function(){return ref.off('value',handler);};ref.on('value',handler,onError);}},{key:'watchProfile',value:function watchProfile(){var _this6=this;if(!this.user||!this.user.publicId){this.resetProfile(null);return;}var ref=this.profileDetailsRef(this.user.publicId);var handler=function handler(snapshot){return _this6.profileChangedHandler(snapshot.val());};var onError=function onError(err){_this6.$log.error(err);_this6.resetProfile(null);};this.resetProfile();this.$watchers.profile=function(){return ref.off('value',handler);};ref.on('value',handler,onError);}/**
   * Extract the current user name and email from the auth data.
   *
   * Only support google and custom provided data.
   *
   * @return {?{name: string, email: string}}
   */},{key:'info',value:function info(){if(!this.firebaseUser||!this.firebaseUser.provider){return null;}if(this.firebaseUser.provider==='google'){return{email:this.firebaseUser.google.email,name:this.firebaseUser.google.displayName};}if(this.firebaseUser.provider==='custom'){return{email:'custom@example.com',name:'Custom User'};}throw new Error('Wrong provider: '+this.firebaseUser.provider);}/**
   * Return the gravatar url for an email.
   *
   * @param  {string} email email to calculate gravatar url for.
   * @return {string}
   */},{key:'gravatar',value:function gravatar(email){return gravatarBaseUrl+this.$spfCrypto.md5(email);}/**
   * Register a handler for any changes to the current user authentication state
   *
   * @param  {function} handler function run for any changed state.
   * @return {function}         function to register the hanlder.
   */},{key:'$watch',value:function $watch(handler){return this.$rootScope.$on(eventName,handler);}/**
   * Log user in.
   *
   * @return {Promise<void, Error>}
   */},{key:'login',value:function login(){return this.$spfAuth.login();}/**
   * Log user out.
   *
   * @return {void}
   */},{key:'logout',value:function logout(){return this.$spfAuth.logout();}/**
   * Register user's public id and display name (optional).
   *
   * @param  {{publicId: string, displayName: string}} options user chosen public id and display name.
   * @return {Promise<void, Error>}
   */},{key:'register',value:function register(options){var _this7=this;return new Promise(function(resolve,reject){var _patch;if(!_this7.uid){reject(new Error('You are not logged and cannot register.'));}if(_this7.publicId){reject(new Error('you are already registered as "'+_this7.publicId+'"'));}var publicId=options&&options.publicId;var displayName=options&&options.displayName;if(!publicId){reject(new Error('The public id was not provided.'));}var patch=(_patch={},_defineProperty(_patch,'publicIds/'+publicId,_this7.uid),_defineProperty(_patch,'usedPublicIds/'+publicId,true),_defineProperty(_patch,'users/'+_this7.uid+'/publicId',publicId),_patch);if(displayName){patch['users/'+_this7.uid+'/displayName']=displayName;}resolve(patch);}).then(function(patch){var ref=_this7.$authDb.ref('auth');return ref.update(patch);});}}]);return SpfCurrentUserService;}();SpfCurrentUserService.$inject=['$q','$timeout','$log','$rootScope','spfCrypto','firebaseApp','authFirebaseApp','spfAuth','spfProfilesPath'];spfAuthFactory.$inject=['$q','$route','$log','$firebaseAuth','authFirebaseApp','authProvider'];spfAuthDataFactory.$inject=['$q','$log','$firebaseObject','authFirebaseApp','spfAuth','spfCrypto'];spfSchoolsFactory.$inject=['$firebaseObject','firebaseApp'];run$2.$inject=['$log','spfProfilesPath'];datastore=Object.freeze({gravatarBaseUrl:gravatarBaseUrl,eventName:eventName,SpfCurrentUserService:SpfCurrentUserService,spfAuthFactory:spfAuthFactory,spfAuthDataFactory:spfAuthDataFactory,spfSchoolsFactory:spfSchoolsFactory,run:run$2});run$3.$inject=['$log','firebaseApp','authFirebaseApp','authProvider'];invalidChar=['.','#','$','/','[',']'];services={countries:list,icons:icons,crypto:crypto,routes:routeServices,datastore:datastore,firebase:{run:run$3}};spfEmptyFilterFactory.$inject=[];spfLengthFilterFactory.$inject=[];spfToArrayFilterFactory.$inject=[];loadingBar.$inject=['cfpLoadingBarProvider'];mdTheme.$inject=['$mdThemingProvider'];spfShared=angular$1.module('spf.shared',['angular-loading-bar','firebase','ngAnimate','ngMessages','ngRoute','ngMaterial']);//
// Register directives, services and filters.
//
// spfShared.factory('spfFirebase', services.firebase.spfFirebaseFactory);
// spfShared.provider('spfFirebaseRef', services.firebase.SpfFirebaseRefProvider);
spfShared.config(loadingBar);spfShared.config(mdTheme);spfShared.config(services.icons.config);spfShared.constant('authFirebaseApp',null);spfShared.constant('authProvider',null);spfShared.constant('firebaseApp',null);spfShared.constant('routes',services.routes.defaults);spfShared.constant('SPF_COUNTRIES',services.countries);spfShared.constant('spfCryptoHashKeySize',services.crypto.keySize);spfShared.constant('spfCryptoIteration',services.crypto.iterations);spfShared.constant('spfCryptoSaltSize',services.crypto.saltSize);spfShared.constant('spfProfilesPath',null);spfShared.controller('SpfSharedNavBarCtrl',components.navbar.SpfSharedNavBarCtrl);spfShared.directive('spfEditor',components.ace.spfEditorDirectiveFactory);spfShared.directive('spfSignForm',components.sign.spfSignFormDirectiveFactory);spfShared.directive('spfUniqPublicId',components.sign.spfUniqPublicIdFactory);spfShared.factory('spfAlert',components.alert.spfAlertFactory);spfShared.factory('spfAuth',services.datastore.spfAuthFactory);spfShared.factory('spfAuthData',services.datastore.spfAuthDataFactory);spfShared.factory('spfNavBarService',components.navbar.spfNavBarServiceFactory);spfShared.factory('spfSchools',services.datastore.spfSchoolsFactory);spfShared.factory('urlFor',services.routes.urlForFactory);spfShared.filter('spfEmpty',spfEmptyFilterFactory);spfShared.filter('spfLength',spfLengthFilterFactory);spfShared.filter('spfToArray',spfToArrayFilterFactory);spfShared.filter('urlFor',services.routes.urlForFilterFactory);spfShared.run(components.navbar.initNavBar);spfShared.run(services.datastore.run);spfShared.run(services.firebase.run);spfShared.run(services.icons.run);spfShared.run(services.routes.run);spfShared.service('spfCrypto',services.crypto.Service);spfShared.service('spfCurrentUser',services.datastore.SpfCurrentUserService);clmServicesFactory.$inject=['$firebaseObject','$log','$q','$timeout','firebaseApp'];clmDataStoreFactory.$inject=['$window','$location','$q','$log','$http','$timeout','firebaseApp','$firebaseObject','$firebaseArray','spfSchools','routes','spfAuth','spfAuthData','spfCurrentUser','spfCrypto','clmServices','clmServicesUrl'];cmTruncateFilterFactory.$inject=[];countConditionallyFilterFactory.$inject=[];cmTruncateFilterBooleanFactory.$inject=[];showSchoolFilterFactory.$inject=[];countObjKeysFactory.$inject=[];displayMentorshipFactory.$inject=[];cmContainsFactory.$inject=[];template="<md-content flex>\n\t<md-content class=\"md-padding\">\n\t\t<p>The IMDA <a target=\"_blank\" href=\"https://portal.imda.gov.sg/sub/talent/student-programmes/national-infocomm-competition\">2017 National Coding Championships</a> National Infocomm Competition will take place on April 30th, 2017.</p>\n\t\t<p>There will be a junior and senior category. The password to join all events is \"junior\" or \"senior\" unless a teacher from your school has requested to change the password. </p>\n<ol>\t    \n\t<li>Please login to ClassMentors.com by clicking the login button above.</li>\n    <li>If you are new to ClassMentors, you will need to enter a unique public ID after you login (example: chris123).</li>\n    <li>After you are logged-in and have completed registering, click on the junior or senior cohort below and then click on the event for your school.</li>\n\t<li>From the school event page, click the <b>Join</b> button, enter the password <b>ida</b>, and press enter. </li> \n\t<li>Once you have joined an event, go register for an account at <a href=\"https://codecombat.com/\">CodeCombat.com</a> and complete the first level. This should only take you about 5 minutes.</li>\n\t<li>Then come back to ClassMentors and update <a href=\"/#/profile/\">your profile</a> with your CodeCombat username. This will allow ClassMentors to see how many CodeCombat achievements you have completed.</li> \n</ol>\n\n\t    <p>If you see a school missing in the rankings below, please encoruage them to participate. If your school is not listed, you can join the <b>All Other Junior</b> or <b>All Other Senior</b> events.</p>\n\t\t<p>You can visit the <a href=\"https://www.facebook.com/aceofcoders\">Ace of Coders Facebook page</a> to leave comments, ask questions, and join in the conversation.</p>\n\t\t\t\nThank you!<br>\nClassMentors Team<br>\n\n<h3><a href=\"#/cohorts/-Kcg7BaTyz_APsldt_cX\">Junior Cohort</a> (Sec1, Sec2, Sec3, Sec4)</h3>\n<h3><a href=\"#/cohorts/-KcaRoBOXGyuBTG7nDyH\">Senior Cohort</a> (JC1, JC2, Poly)</h3>\n\n\t</md-content>\n<!--\n\t<md-toolbar md-scroll-shrink>\n\t\t<div class=\"md-toolbar-tools\">\n\t\t\t<h3><span>Junior Category Schools</span></h3>\n\t\t</div>\n\t</md-toolbar>\n\t<md-content class=\"md-padding\">\n\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<th>Rank</th> \n\t\t\t\t<th>Registerd Students</th>\n\t\t\t\t<th>School Event</th>\n\t\t\t\t<th></th> \n\t\t\t\t<th></th> \n\t\t\t</tr>\n\t\t\t<tr ng-repeat=\"school in $ctrl.stats.junior_ranking\" bgcolor=\"{{$index==11?'lightgreen':'white'}}\">\n\t\t\t\t<td>{{$index+1}}</td>\t\t\t\t\n\t\t\t\t<td>{{school.total}}</td>\n\t\t\t\t<td><a href=\"{{school.eventURL}}\">{{school.school}}</a></td>\n\t\t\t\t<td ng-if=\"school.name !== 'no second student'\"></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\n\t    </table>\n\t</md-content>\n\n\t<md-toolbar md-scroll-shrink>\n\t\t<div class=\"md-toolbar-tools\">\n\t\t\t<h3><span>Senior Category Schools</span></h3>\n\t\t</div>\n\t</md-toolbar>\n\t<md-content class=\"md-padding\">\n\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<th>Rank</th> \n\t\t\t\t<th>Registered Students</th>\n\t\t\t\t<th>School Event</th>\n\t\t\t\t<th></th> \n\t\t\t\t<th></th>\n\t\t\t</tr>\n\t\t\t<tr ng-repeat=\"school in $ctrl.stats.senior_ranking\"  bgcolor=\"{{$index==5?'lightgreen':'white'}}\">\n\t\t\t\t<td>{{$index+1}}</td>\n\t\t\t\t<td>{{school.total}}</td>\n\t\t\t\t<td><a href=\"{{school.eventURL}}\">{{school.school}}</a></td>\n\t\t\t\t<td ng-if=\"school.name !== 'no second student'\"></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t    </table>\n    </md-content>\n\t-->\n</md-content>";component={template:template,bindings:{// binds $ctrl.stats to the value of the stats attribute.
stats:'<'}};ACE_STATS_URL='https://singpath.firebaseio.com/classMentors/userProfiles/cboesch/user/displayName.json';getStats.$inject=['$http','aceStatsUrl'];configRoute.$inject=['$routeProvider','routes'];ace$2=Object.freeze({component:component,ACE_STATS_URL:ACE_STATS_URL,getStats:getStats,configRoute:configRoute});mcqTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"editMcq\" ng-submit=\"ctrl.save(ctrl.questions)\">\n        {{ctrl.data}}\n        <div align=\"center\">\n            <h3>Multiple Choice Question Details</h3>\n        </div>\n\n        <div ng-repeat=\"question in ctrl.questions\">\n           <md-toolbar layout=\"row\" class=\"md-hue-3\">\n                <span class=\"md-toolbar-tools\">\n                    Q{{$index +1}}: {{question.text}}\n                   <span ng-show=\"question.answers.length == 0 || question.answers == undefined\">\n                       <font size=\"3\"> (No Answer Selected)</font>\n                   </span>\n                </span>\n\n\n               <md-button class=\"md-warn\" ng-click=\"ctrl.removeQuestion($event,$index)\"\n                          ng-disabled=\"ctrl.questions.length == 1\">Delete\n               </md-button>\n\n               <md-button ng-click=\"hideDetails = !hideDetails\">Details\n               </md-button>\n            </md-toolbar>\n            <br>\n\n            <span ng-hide=\"hideDetails\">\n                <md-input-container layout=\"row\" >\n                    <label for=\"edit-question_{{$index}}\">Question {{$index + 1}}</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"edit-question_{{$index}}\"\n                           ng-change=\"ctrl.checkMCQValid(question.text)\"\n                           ng-model=\"question.text\"\n                           placeholer=\"Click here to set your question\"\n                    />\n                </md-input-container>\n\n                <md-input-container layout=\"row\">\n                    <md-button type=\"button\" class=\"md-raised\" id=\"addOptions\"\n                               ng-click=\"ctrl.addOption(question)\">Add option\n                    </md-button>\n                    <p ng-show=\"question.answers.length == 0 || question.answers == undefined\">\n                        <font color=\"red\" size=\"2\">You must select one or more options as answer(s).</font>\n                    </p>\n                </md-input-container>\n\n                <!--answer options-->\n                <span layout=\"row\" ng-repeat=\"option in question.options\">\n                    <md-input-container flex>\n                        <label for=\"q-option_{{$index}}\">Answer option {{$index + 1}}</label>\n                        <input type=\"text\" name=\"editQuestion\" id=\"q-option_{{$index}}\"\n                               ng-model=\"option.text\"\n                               placeholer=\"Options\"\n                               ng-change=\"ctrl.checkOptionValid(option.text)\"\n                        />\n                    </md-input-container>\n\n                    <md-input-container>\n                        <md-button ng-model=\"question.answers\"\n                                   ng-class=\"question.answers.indexOf($index) != -1 ? 'md-raised md-primary' : 'md-raised'\"\n                                   ng-click=\"ctrl.toggleOption(question, $index)\">Answer\n                        </md-button>\n\n                        <md-button class=\"md-accent\" ng-click=\"ctrl.removeOption(question,$index)\"\n                                   ng-disabled=\"question.options.length == 1\">Delete\n                        </md-button>\n                    </md-input-container>\n                </span>\n            </span>\n\n        </div>\n\n\n        <br>\n        <div align=\"center\">\n            <!--todo: can add new set of question-->\n            <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.addQuestion()\">Add question</md-button>\n        </div>\n\n        <br>\n\n        <div align=\"center\">\n            <md-button type=\"submit\" ng-disabled=\"!ctrl.isMcqValid || !ctrl.isTextFilled || !ctrl.isOptionValid\" class=\"md-raised md-primary\">Save\n            </md-button>\n            <md-button type=\"button\" class=\"md-accent\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n        </div>\n    </form>\n\n</md-content>";mcqEditTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"editMcq\" ng-submit=\"ctrl.save(ctrl.questions)\">\n        {{ctrl.data}}\n        <div align=\"center\">\n            <h3>Multiple Choice Question Details</h3>\n            <br><br>\n        </div>\n\n        <div ng-repeat=\"question in ctrl.questions\">\n            <h3>\n                Question {{$index + 1}}\n                <md-button class=\"md-raised\" ng-click=\"ctrl.removeQuestion($event,$index)\"\n                           ng-disabled=\"ctrl.questions.length == 1\">Delete this question\n                </md-button>\n            </h3>\n\n\n            <div layout=\"row\">\n                <md-input-container flex>\n                    <label for=\"edit-question_{{$index}}\">Click here to set your question</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"edit-question_{{$index}}\"\n                           ng-change=\"ctrl.checkMCQValid(question.text)\"\n                           ng-model=\"question.text\"\n                           placeholer=\"Click here to set your question\"\n                           value = \"{{question.text}}\"\n\n                    />\n\n                </md-input-container>\n            </div>\n\n            <md-input-container>\n                <md-button type=\"button\" class=\"md-raised md-primary\" id=\"addOptions\"\n                           ng-click=\"ctrl.addOption(question)\">Add option\n                </md-button>\n            </md-input-container>\n\n            <!--<p ng-show=\"!ctrl.isMcqValid\"><font color=\"red\">*One of the option must be an answer.</font></p>-->\n\n            <!--answer options-->\n            <div layout=\"row\" ng-repeat=\"option in question.options\">\n                <!--{{$index}}-->\n                <md-input-container flex>\n                    <label for=\"q-option_{{$index}}\">Click here to set your option</label>\n                    <input type=\"text\" name=\"editQuestion\" id=\"q-option_{{$index}}\"\n                           ng-model=\"option.text\"\n                           placeholer=\"Options\"\n                           ng-change=\"ctrl.checkOptionValid(option.text)\"\n                           value=\"{{option.text}}\"\n                    />\n                </md-input-container>\n\n                <!--todo: required at least one option to be the answer.-->\n                <md-input-container>\n                    <md-button ng-model=\"question.answers\"\n                               ng-class=\"question.answers.indexOf($index) != -1 ? 'md-raised md-primary' : 'md-raised'\"\n                               ng-click=\"ctrl.toggleOption(question, $index)\">Answer\n                    </md-button>\n                </md-input-container>\n\n                <md-input-container>\n                    <md-button class=\"md-raised\" ng-click=\"ctrl.removeOption(question,$index)\"\n                               ng-disabled=\"question.options.length == 1\">Delete option\n                    </md-button>\n                </md-input-container>\n            </div>\n\n        </div>\n\n\n        <br>\n        <div align=\"center\">\n            <!--todo: can add new set of question-->\n            <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.addQuestion()\">Add question</md-button>\n        </div>\n\n        <br>\n\n        <div align=\"center\">\n            <md-button type=\"submit\" ng-disabled=\"!ctrl.isMcqValid || !ctrl.isTextFilled || !ctrl.isOptionValid\" class=\"md-raised md-primary\">Save\n            </md-button>\n            <md-button type=\"button\" class=\"md-accent\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n        </div>\n    </form>\n\n</md-content>";mcqStart="<md-content flex class=\"md-padding\">\n\n  <div layout='column' align=\"left\">\n    <h3>{{ctrl.task.title}}</h3>\n    <p>{{ctrl.task.description}}</p>\n    <br>\n  </div>\n\n  <form name=\"startMcq\" ng-submit=\"ctrl.submit()\">\n    <div layout-align=\"column\">\n        <!------------------starting of questions--------------------------------------------->\n        <div flex ng-repeat=\"question in ctrl.questions\">\n          <div align=\"start\" layout=\"column\" >\n            <label><h2>Question {{$index + 1}}</h2></label>\n            <md-divider></md-divider>\n            <label><h4>{{question.text}}</h4></label>\n          </div>\n\n          <!--answer's options-->\n          \n            <!--Radio button inputs-->\n            <div ng-show=\"!ctrl.multipleAns[$index]\">\n                <md-radio-group ng-required=\"true\" ng-model=\"question.answers\" >\n                  <div layout=\"column\" ng-repeat=\"option in question.options\">\n                    <div layout=\"row\">\n                      <div flex=\"80\">\n                        <label>{{$index + 1}}) {{option.text}}</label>\n                      </div>\n                      <div flex=\"20\">\n                        <md-radio-button value={{$index}}></md-radio-button>\n                      </div>\n                    </div>\n                    <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                  </div>\n                </md-radio-group>\n            </div>\n            \n            <!--Checkbox inputs-->\n            <div ng-show=\"ctrl.multipleAns[$index]\">\n              <div layout=\"column\" ng-repeat=\"option in question.options\">\n                <div layout=\"row\">\n                  <div flex=\"80\">\n                    <label>{{$index + 1}}) {{option.text}}</label>\n                  </div>\n                  <div flex=\"20\">\n                    <md-checkbox ng-model=\"option.checked\" ng-required=\"question.answers.length == 0\" ng-click=\"ctrl.toggle(question.answers, $index)\"></md-checkbox>\n                  </div>\n                </div>\n                <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n              </div>\n            </div>\n        </div>\n      </div>\n    <br/>\n      <div layout=\"row\" layout-align=\"center center\">\n        <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"startMcq.$invalid\">Submit</md-button>\n        <md-button type=\"button\" class=\"md-accent\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n      </div>\n  </form>\n</md-content>";editMcqController.$inject=['initialData','spfNavBarService','challengeService','$filter','$mdDialog','urlFor','$location'];startMcqController.$inject=['initialData','challengeService','clmDataStore','$location','$mdDialog','urlFor','spfAlert','$scope','spfNavBarService'];newMcqController.$inject=['initialData','challengeService','$filter','$mdDialog','urlFor','$location','spfNavBarService'];surveyTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyTask\" ng-submit=\"ctrl.saveSurveyTask(ctrl.surveyType.name)\">\n        <div align=\"center\">\n            <h3>Survey Challenge</h3>\n        </div>\n        <div align=\"center\">\n            <p>\n                Choose the appropriate survey to be administered as your end of class survey.\n                <span ng-hide=\"ctrl.currentSelected == 0 || ctrl.currentSelected == undefined\"><br><br> Your previously selected survey is <b>{{ctrl.currentSelected}}</b></span>\n            </p>\n        </div>\n        <br>\n        <div align=\"center\" class=\"md-padding\">\n            <md-input-container align=\"center\">\n                <md-select ng-model=\"ctrl.surveyType\" style=\"width: 500px\" placeholder=\"Please select a survey template\" ng-change=\"ctrl.checkSurveyValid()\">\n                    <md-optgroup label=\"Upload Standard Template\">\n                        <md-option ng-value=\"survey\"\n                           ng-repeat=\"survey in ctrl.surveys\"\n                        >{{survey.name}}\n                        </md-option>\n                    </md-optgroup>\n                </md-select>\n            </md-input-container>\n        </div>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button class=\"md-raised \" ng-click=\"ctrl.showPreview(ctrl.surveyType)\" ng-disabled=\"!ctrl.hasSurveyTitle\">Preview Survey Template</md-button>\n        </div>\n        <br><br>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button ng-if=\"ctrl.currentSelected == 0 || ctrl.currentSelected == undefined\" type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"!ctrl.hasSurveyTitle\">Save</md-button>\n            <md-button ng-if=\"ctrl.currentSelected != undefined || ctrl.currentSelected == 0\" type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"!ctrl.hasSurveyTitle\">Save</md-button>\n            <md-button type=\"button\" class=\"md-accent\" ng-click=\"ctrl.discardChanges($event)\">Cancel</md-button>\n        </div>\n        <md-progress-circular ng-show=\"ctrl.loadPreview\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n    </form>\n</md-content>";schEngagePreview="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\" ng-submit=\"\">\n        <div>\n            <h1>Preview: School Engagement Scale</h1>\n        </div>\n        <div>\n            <h3>Please respond to the questions below using the following scale</h3>\n        </div>\n        <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.back()\">Back</md-button>\n        <br>\n        <hr style=\"background: #808080; border: 0; height: 3px\"/>\n        <md-input container flex>\n            <table ng-repeat=\"(key, value) in ctrl.questions[2]\" width=\"100%\">\n                <tr ng-if=\"key == 1\">\n                    <td>\n                        <h3>Behavioural Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-if=\"key == 5\">\n                    <td>\n                        <h3>Emotional Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-if=\"key == 11\">\n                    <td>\n                        <h3>Cognitive Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <td ng-if=\"key != '0'\" style=\"width: 600px\">\n                        {{key}}. {{value}}\n                    </td>\n                    <td ng-if=\"key != '0'\">\n                        <md-radio-group layout=\"row\" ng-model=\"$parent.ans\" required>\n                            <md-radio-button style=\"margin-right:20px\" class=\"md-primary\" ng-value=\"1\">Never\n                            </md-radio-button>\n                            <md-radio-button style=\"margin-right:20px\" class=\"md-primary\" ng-value=\"2\">On Occasion\n                            </md-radio-button>\n                            <md-radio-button style=\"margin-right:20px\" class=\"md-primary\" ng-value=\"3\">Some of the\n                                Time\n                            </md-radio-button>\n                            <md-radio-button style=\"margin-right:20px\" class=\"md-primary\" ng-value=\"4\">Most of the\n                                Time\n                            </md-radio-button>\n                            <md-radio-button style=\"margin-right:20px\" class=\"md-primary\" ng-value=\"5\">All of the Time\n                            </md-radio-button>\n                        </md-radio-group>\n                    </td>\n                </tr>\n            </table>\n            <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.back()\">Back</md-button>\n            <br>\n        </md-input>\n    </form>\n</md-content>";motiStratPreview="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\" ng-submit=\"\">\n        <div>\n            <h1>Preview: Motivated Strategies for Learning</h1>\n        </div>\n        <div>\n            <h3>Please respond to the questions below using the following scale:</h3>\n        </div>\n        <div><b>1= not at all true of me</b></div>\n        <div><b>7=very true of me</b></div>\n        <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.back()\">Back</md-button>\n        <br>\n        <hr style=\"background: #808080; border: 0; height: 3px\"/>\n        <br>\n        <md-input container flex>\n\n            <table ng-repeat=\"question in ctrl.questionsArr\" width=\"100%\">\n                <tr ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\" style=\"height: 50px\">\n                    <td style=\"width:50px\">\n                        {{question.qnid}}.\n                    </td>\n                    <td style=\"width:700px\">\n                        {{question.name}}\n                    </td>\n                    <td align=\"right\">\n                        <md-radio-group layout=\"row\" ng-model=\"ans\" ng-change=\"ctrl.motiResp[question.qnid] = ans\"\n                                        required>\n                            <div ng-repeat=\"ratingOption in ctrl.ratingOptions\">\n                                <md-radio-button style=\"margin-right:60px\" class=\"md-primary\"\n                                                 ng-value=\"ratingOption.id\">\n                                    {{ratingOption.id}}\n                                </md-radio-button>\n                            </div>\n                        </md-radio-group>\n                    </td>\n                </tr>\n            </table>\n            <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.back()\">Back</md-button>\n        </md-input>\n    </form>\n\n</md-content>\n";eduDissPreview="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\"\n          ng-submit=\"\">\n        <div>\n            <h1>Preview: Education vs Dissatisfaction with learning</h1>\n        </div>\n        <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.back()\">Back</md-button>\n\n        <table ng-repeat=\"(key, value) in ctrl.questions[0]\" width=\"100%\">\n            <tr>\n                <td><h3>{{value.title}}</h3></td>\n            </tr>\n\n            <tr ng-if=\"key =='11'\">\n                <td>\n                    <textarea placeholder=\"Share some of your most exciting moments here!\" type=\"text\" cols=\"80\"\n                              rows=\"5\" style=\"max-width:500px; max-height: 200px\"\n                              ng-model=\"$parent.$parent.bestResponse\"\n                              ng-change=\"ctrl.eduDissResp[value.title] = bestResponse\" required></textarea>\n                </td>\n            </tr>\n\n            <tr ng-if=\"key2 != 'title'\" ng-repeat=\"(key2, value2) in value\"\n                ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\" style=\"height:50px\">\n                <td style=\"width:800px\">\n                    {{value2}}\n                </td>\n\n                <td>\n                    <!--to generate radio button-->\n                    <md-radio-group ng-if=\"key != '6'\" layout=\"row\" ng-model=\"$parent.ansResp\"\n                                    ng-change=\"ctrl.eduDissResp[value.title][key2] = ansResp\" required>\n                        <div ng-repeat=\"ratingOption in ctrl.ratingOptions\">\n                            <md-radio-button style=\"margin-right:60px\" class=\"md-primary\" ng-value=\"ratingOption.id\">\n                                {{ratingOption.id}}\n                            </md-radio-button>\n                        </div>\n                    </md-radio-group>\n                    <div ng-if=\"key == '6'\">\n                        <div ng-if=\"key2 == '1'\">\n                            <input placeholder=\"State a valid age\" ng-model=\"$parent.$parent.age\" type=\"number\" min=\"3\"\n                                   style=\"width: 30%\" ng-change=\"ctrl.eduDissResp[value.title][key2] = age\" required/>\n                            years old\n                        </div>\n                        <div ng-if=\"key2 == '2'\">\n                            <table width=\"100%\">\n                                <tr>\n                                    <!--<td ng-repeat=\"family in ctrl.familyMembers track by $index\">-->\n                                    <md-checkbox>\n                                        Father\n                                    </md-checkbox>\n                                    <md-checkbox>\n                                        Mother\n                                    </md-checkbox>\n                                    <md-checkbox>\n                                        Sister(s)\n                                    </md-checkbox>\n                                    <md-checkbox>\n                                        Brother(s)\n                                    </md-checkbox>\n                                    <md-checkbox>\n                                        Relative(s)\n                                    </md-checkbox>\n                                    <md-checkbox>\n                                        Grandparent(s)\n                                    </md-checkbox>\n\n                                    <!--</td>-->\n                                </tr>\n                            </table>\n                        </div>\n                        <div ng-if=\"key2 == '3'\">\n                            <input placeholder=\"Number of siblings\" ng-model=\"$parent.$parent.sib\" type=\"number\" min=\"0\"\n                                   style=\"width: 30%\" ng-change=\"ctrl.eduDissResp[value.title][key2] = sib\" required/>\n                        </div>\n                        <div ng-if=\"key2 == '4'\">\n                            <md-input-container flex>\n                                <label>Month</label>\n                                <md-select ng-model=\"$parent.$parent.selectedMonth\"\n                                           ng-change=\"ctrl.eduDissResp[value.title][key2] = selectedMonth\" required>\n                                    <md-option ng-repeat=\"bday in ctrl.bdayMonth\" ng-value=\"bday.month\">\n                                        {{bday.month}}\n                                    </md-option>\n                                </md-select>\n                            </md-input-container>\n                        </div>\n                        <div ng-if=\"key2 == '5'\">\n                            <table width=\"100%\">\n                                <tr>\n                                    <td>\n                                        <md-checkbox>White</md-checkbox>\n                                        <md-checkbox>African American</md-checkbox>\n                                        <md-checkbox>Hispanic/Latino</md-checkbox>\n                                    </td>\n                                </tr>\n                                <tr>\n                                    <td>\n                                        <md-checkbox>Asian</md-checkbox>\n                                        <md-checkbox>Native Hawaii/Pacific Islander</md-checkbox>\n                                        <md-checkbox>Other</md-checkbox>\n                                    </td>\n                                </tr>\n                            </table>\n                        </div>\n                        <div ng-if=\"key2 == '6'\">\n                            <input type=\"text\" placeholder=\"State a valid country\" ng-model=\"$parent.$parent.country\"\n                                   ng-change=\"ctrl.eduDissResp[value.title][key2] = country\" required/>\n\n                        </div>\n                        <div ng-if=\"key2 == '7'\">\n                            <input type=\"text\" placeholder=\"State a valid language\"\n                                   ng-model=\"$parent.$parent.spokenLanguage\"\n                                   ng-change=\"ctrl.eduDissResp[value.title][key2] = spokenLanguage\" required/>\n                            for multiple languages, separate by a comma (,)\n                        </div>\n\n                    </div>\n                </td>\n            </tr>\n\n            <md-divider></md-divider>\n\n        </table>\n\n        <br>\n        <md-button type=\"button\" class=\"md-raised md-primary\" ng-click=\"ctrl.back()\">Back</md-button>\n\n    </form>\n</md-content>\n";noop$5=function noop(){return undefined;};showPreviewInitialData.$inject=['$q','$location','$route','firebaseApp','$firebaseArray','spfAuthData','clmDataStore'];showPreviewController.$inject=['spfNavBarService','$location','urlFor','initialData','$routeParams','clmDataStore','clmPagerOption','spfAlert','$scope','firebase','$route'];teamActivityCreateTmpl="<md-content flex class=\"md-padding\">\n    <div layout=\"column\" layout-align=\"center stretch\">\n        <form name=\"createTeamActivity\" ng-submit=\"ctrl.submit()\">\n\n            <h3>Title: {{ctrl.task.title}}</h3>\n            <h4>Description: {{ctrl.task.description}}</h4>\n\n            <md-divider></md-divider>\n            <br>\n\n            <div flex layout=\"column\" layout-align=\"center stretch\">\n                <h3>Select Activity Type</h3>\n\n                <!--Radio group for Activity Types-->\n                <md-input-container>\n                    <md-radio-group ng-model='ctrl.activityType' required>\n                        <md-radio-button value=\"gameShow\">IRAT:TRAT</md-radio-button>\n                        <md-radio-button value=\"indexCards\">Team Questions</md-radio-button>\n                        <md-radio-button value=\"collabSubmission\">Collaborative Submission</md-radio-button>\n                        <md-radio-button value=\"mentoring\">Mentoring</md-radio-button>\n                        <md-radio-button value=\"cooperative\">Cooperative Learning Activity</md-radio-button>\n                    </md-radio-group>\n                </md-input-container>\n            </div>\n\n            <!--team formation segment-->\n            <div flex layout=\"column\" layout-align=\"center stretch\" ng-if=\"ctrl.activityType!='mentoring'\">\n                <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                <h3>Team Formation</h3>\n                <!--{{ctrl.newExistingTeams}}-->\n                <div>\n                    <label for=\"newExistingTeams\">Select team formation method:</label><br>\n                    <md-input-container>\n                        <md-select aria-label=\"Team Formation Type\" ng-model=\"ctrl.newExistingTeams\"\n                                   id=\"newExistingTeams\" ng-disabled=\"true\">\n                            <!--<md-option value=\"existingTeams\" selected>From existing team formation</md-option>-->\n                            <md-option value=\"newTeams\" selected>Create new teams</md-option>\n                        </md-select>\n                    </md-input-container>\n                </div>\n\n                <!--if \"set new teams\" is checked-->\n                <div flex layout=\"column\" layout-align=\"center stretch\" ng-show=\"ctrl.newExistingTeams == 'newTeams'\">\n                    <br>\n                    <!--{{ctrl.teamFormationMethod}}-->\n                    <label>Select create new team method:</label>\n                    <md-input-container>\n                        <md-select aria-label=\"Team Formation Method\" ng-model=\"ctrl.teamFormationMethod\"\n                                   name=\"teamFormationMethod\">\n                            <md-option value=\"teamSize\">By Students Per Team</md-option>\n                            <md-option value=\"noOfTeams\" selected>By Number of Team(s)</md-option>\n                    </md-input-container>\n                </div>\n\n                <!--setting for team size/ number of teams-->\n\n                <div flex layout=\"column\" ng-show=\"ctrl.newExistingTeams == 'newTeams'\"\n                     ng-hide=\"ctrl.newExistingTeams == 'existingTeams'\">\n                    <md-input-container ng-required=\"true\">\n                        <label for='edit-teamFormationInput_${{index}}'>{{ctrl.teamFormationMethod === \"teamSize\" ?\n                            \"Maximum number of students per team\" : \"Number of Teams\"}}</label>\n                        <input type=\"number\" ng-model=\"ctrl.teamFormationParameter\"\n                               name=\"teamFormationInput\" min=\"1\"\n                               id='edit-teamFormationInput_${{index}}'\n                               ng-change=\"ctrl.calculateTeamMaximumStudent(ctrl.teamFormationParameter)\" required\n                        >\n                    </md-input-container>\n\n                    <!--added remarks to assist user.-->\n                    <label ng-show=\"ctrl.teamFormationMethod == 'noOfTeams'\"\n                           ng-hide=\"ctrl.teamFormationMethod == 'teamSize'\"><font color=\"red\"> A team may have maximum\n                        enrollment of <b>{{ctrl.calculationResult()}}</b> student(s).</font></label>\n                    <label ng-hide=\"ctrl.teamFormationMethod == 'noOfTeams'\"\n                           ng-show=\"ctrl.teamFormationMethod == 'teamSize'\"><font color=\"red\">You will have <b>{{ctrl.calculationResult()}}</b>\n                        team(s).</font></label>\n                    <br>\n                </div>\n            </div>\n\n                <!--if \"set new teams\" is unchecked-->\n                <!--<div ng-hide=\"ctrl.newExistingTeams == 'newTeams'\" ng-show=\"ctrl.newExistingTeams == 'existingTeams'\"-->\n                     <!--flex layout=\"column\" layout-align=\"center stretch\">-->\n\n                    <!--{{ctrl.teams}}-->\n                    <!--<label>Select from existing team activity challenges</label>-->\n                    <!--<md-input-container ng-disabled=\"ctrl.teams\">-->\n                        <!--<label ng-show=\"ctrl.teams\">Assign teams from previous team challenges</label>-->\n                        <!--<label ng-hide=\"ctrl.teams || ctrl.teams.length == 0\">No team challenges available</label>-->\n                        <!--<md-select ng-model=\"ctrl.selectedTeam\" ng-disabled=\"!ctrl.teams || ctrl.teams.length == 0\">-->\n                            <!--<md-option ng-repeat=\"team in ctrl.teams\" ng-value=\"team.name\"></md-option>-->\n                        <!--</md-select>-->\n                    <!--</md-input-container>-->\n                <!--</div>-->\n\n\n                <!--multiple choice segment-->\n                <div flex layout=\"column\" layout-align=\"center stretch\" ng-if=\"ctrl.activityType == 'gameShow'\">\n\n                    <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                    <h3>IRAT/TRAT Questions</h3>\n\n                    {{ctrl.selectedMCQ}}\n                    <!--<md-input-container>-->\n                        <!--<label for=\"q-timelimit\">Time limit for each question (in minutes)</label>-->\n                        <!--<input type=\"number\" ng-model=\"ctrl.questionTimeLimit\" id=\"q-timelimit\" required>-->\n                    <!--</md-input-container>-->\n\n                    <label>Create new multiple choice question</label>\n                    <md-input-container>\n                        <md-select aria-label=\"MCQ Type\" ng-model=\"ctrl.selectedMCQ\" ng-disabled=\"true\">\n                            <md-option ng-value=\"createMCQ\" selected>Create new MCQ</md-option>\n                            <!--<md-option ng-repeat=\"m in mcqs\" ng-value=\"$index\"></md-option>-->\n                        </md-select>\n                    </md-input-container>\n                </div>\n\n                <!--collab submission segment segment-->\n                <div flex layout=\"column\" layout-align=\"center stretch\"\n                     ng-if=\"ctrl.activityType == 'collabSubmission' || ctrl.activityType == 'cooperative'\">\n\n                    <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                    <label ng-if=\"ctrl.activityType == 'collabSubmission'\"><h3>Select Collaborative Submission Type</h3></label>\n                    <label ng-if=\"ctrl.activityType == 'cooperative'\"><h3>Select Cooperative Submission Type</h3></label>\n\n                    <md-input-container ng-if=\"ctrl.activityType=='collabSubmission'\">\n                        <md-select aria-label=\"ColSubType\" ng-model=\"ctrl.collabChallengeType\"\n                                   placeholder=\"Select Challenge to Submit Collaboratively\">\n                            <md-option value='textResponse'>Team Text Response</md-option>\n                            <md-option value='linkPattern'>Team Link Submission</md-option>\n                            <md-option value='code'>Team Code Challenge</md-option>\n                        </md-select>\n                    </md-input-container>\n\n                    <md-input-container ng-if=\"ctrl.activityType=='cooperative'\">\n                        <md-select aria-label=\"CoopSubType\" ng-model=\"ctrl.coopChallengeType\"\n                                   placeholder=\"Select Challenge to Submit Cooperatively\">\n                            <md-option value='textResponse'>Team Text Response</md-option>\n                            <md-option value='linkPattern'>Team Link Submission</md-option>\n                            <md-option value='code'>Team Code Challenge</md-option>\n                        </md-select>\n                    </md-input-container>\n\n\n                    <div ng-if=\"ctrl.collabChallengeType == 'linkPattern' || ctrl.coopChallengeType == 'linkPattern'\">\n                        <md-input-container>\n                            <label for=\"edit-link-pattern\">Link Pattern for Link Submissions</label>\n                            <input type=\"text\" name=\"editTaskLink\" id=\"edit-link-pattern\"\n                                   ng-value=\"ctrl.task.linkPattern\"\n                                   ng-model=\"ctrl.task.linkPattern\"\n                                   required=\"true\"\n                                   placeholer=\"Pattern\"\n                            />\n                            <span><font color=\"red\" size=\"2\">E.g. Only google doc submission, link pattern is: \"https://docs.google.com/\"</font></span>\n\n                            <div ng-messages=\"editTask.editTaskLink.$error\">\n                                <div ng-message=\"required\">Required.</div>\n                            </div>\n                        </md-input-container>\n                    </div>\n\n                    <div ng-if=\"ctrl.collabChallengeType == 'textResponse' || ctrl.coopChallengeType == 'textResponse'\" layout=\"row\">\n                        <md-input-container>\n\n                            <label for=\"edit-text-response\">Question</label>\n                            <textarea name=\"editTextResponse\" id=\"edit-text-response\"\n                                      ng-model=\"ctrl.task.textResponse\"\n                                      required\n                                      placeholder=\"Question\"\n                                      rows=\"2\" md-select-on-focus\n                            ></textarea>\n\n                            <div ng-messages=\"editTask.editTextResponse.$error\">\n                                <div ng-message=\"required\">Required.</div>\n                            </div>\n                        </md-input-container>\n                    </div>\n\n\n                    <div ng-if=\"ctrl.collabChallengeType == 'code' || ctrl.coopChallengeType == 'code'\" layout=\"row\">\n                        <md-input-container>\n                            <label for=\"edit-text-response\">Question</label>\n                            <textarea name=\"editCodeQuestion\" id=\"edit-code-question\"\n                                      ng-model=\"ctrl.task.textResponse\"\n                                      required\n                                      placeholder=\"Question\"\n                                      rows=\"2\" md-select-on-focus\n                            ></textarea>\n\n                            <div ng-messages=\"editTask.editCodeQuestion.$error\">\n                                <div ng-message=\"required\">Required.</div>\n                            </div>\n                        </md-input-container>\n                        <md-input-container flex layout=\"column\">\n                            <md-select flex name=\"editCodeLang\"\n                                       ng-model=\"ctrl.task.lang\" required placeholder=\"Select a Language\">\n                                <md-option ng-value=\"opt\" ng-repeat=\"opt in ['Java', 'Javascript', 'HTML', 'Python']\">\n                                    {{opt}}\n                                </md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n                </div>\n\n            <!--</div>-->\n\n            <div ng-if=\"ctrl.activityType=='mentoring'\">\n                <div flex layout=\"column\" layout-align=\"center stretch\">\n\n                    <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                    <label><h3>Select Mentoring Activity Type</h3></label>\n\n                    <md-input-container>\n                        <md-select aria-label=\"mentorChallengeType\" ng-model=\"ctrl.mentorChallengeType\"\n                                   placeholder=\"Select Challenge to do with Mentoring\">\n                            <md-option value='textResponse'>Text Response</md-option>\n                            <md-option value='linkPattern'>Link Submission</md-option>\n                            <md-option value='code'>Code Challenge</md-option>\n                        </md-select>\n                    </md-input-container>\n\n                    <div ng-if=\"ctrl.mentorChallengeType == 'linkPattern'\">\n                        <md-input-container>\n                            <label for=\"edit-link-pattern\">Link Pattern for Link Submissions</label>\n                            <input type=\"text\" name=\"editTaskLink\" id=\"select-link-pattern\"\n                                   ng-value=\"ctrl.task.linkPattern\"\n                                   ng-model=\"ctrl.task.linkPattern\"\n                                   required=\"true\"\n                                   placeholer=\"Pattern\"\n                            />\n                            <span><font color=\"red\" size=\"2\">E.g. Only google doc submission, link pattern is: \"https://docs.google.com/\"</font></span>\n\n                            <div ng-messages=\"editTask.editTaskLink.$error\">\n                                <div ng-message=\"required\">Required.</div>\n                            </div>\n                        </md-input-container>\n                    </div>\n\n                    <div ng-if=\"ctrl.mentorChallengeType == 'textResponse'\" layout=\"row\">\n                        <md-input-container flex>\n\n                            <label for=\"edit-text-response\">Question</label>\n                            <textarea name=\"editTextResponse\" id=\"select-text-response\"\n                                      ng-model=\"ctrl.task.textResponse\"\n                                      required\n                                      placeholder=\"Question\"\n                                      rows=\"2\" md-select-on-focus\n                            ></textarea>\n\n                            <div ng-messages=\"editTask.editTextResponse.$error\">\n                                <div ng-message=\"required\">Required.</div>\n                            </div>\n                        </md-input-container>\n                    </div>\n\n\n                    <div ng-if=\"ctrl.mentorChallengeType == 'code'\" layout=\"row\">\n                        <md-input-container>\n                            <label for=\"edit-text-response\">Question</label>\n                            <textarea name=\"editCodeQuestion\" id=\"select-code-question\"\n                                      ng-model=\"ctrl.task.textResponse\"\n                                      required\n                                      placeholder=\"Question\"\n                                      rows=\"2\" md-select-on-focus\n                            ></textarea>\n\n                            <div ng-messages=\"editTask.editCodeQuestion.$error\">\n                                <div ng-message=\"required\">Required.</div>\n                            </div>\n                        </md-input-container>\n                        <md-input-container flex layout=\"column\">\n                            <md-select flex name=\"editCodeLang\"\n                                       ng-model=\"ctrl.task.lang\" required placeholder=\"Select a Language\">\n                                <md-option ng-value=\"opt\" ng-repeat=\"opt in ['Java', 'Javascript', 'HTML', 'Python']\">\n                                    {{opt}}\n                                </md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n\n                    <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                    <label><h3>Select Mentor Allocation Method</h3></label>\n\n                    <md-input-container>\n                        <md-radio-group ng-model='ctrl.mentorAssignmentMethod' required>\n                            <md-radio-button value=\"random\" selected>Random</md-radio-button>\n                            <md-radio-button value=\"prevCompletion\">By previous challenge completion in the event\n                            </md-radio-button>\n                            <md-radio-button value=\"badges\" disabled>By number of badges</md-radio-button>\n                        </md-radio-group>\n                    </md-input-container>\n\n                </div>\n            </div>\n\n            <br>\n            <md-divider></md-divider>\n            <br>\n            <div layout=\"row\" ng-show=\"!createTeamActivity.$invalid\" layout-align=\"center center\" >\n                <span md-colors=\"{color:'primary'}\"> <md-icon class=\"material-icons\" md-colors=\"{color:'primary'}\">error_outline</md-icon> You cannot edit your team activity challenges afterwards. Click \"Save\" to confirm.</span>\n            </div>\n\n            <div align=\"center\">\n                <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"createTeamActivity.$invalid\">\n                    <span ng-if=\"ctrl.activityType=='gameShow'\">Continue</span>\n                    <span ng-if=\"ctrl.activityType !='gameShow' || ctrl.activityType == undefined\">Save</span>\n                </md-button>\n                <md-button type=\"button\" class=\"md-accent\" ng-click=\"ctrl.discardChanges($event)\">Cancel\n                </md-button>\n            </div>\n\n\n        </form>\n    </div>\n</md-content>";teamIRATTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"iratForm\" ng-submit=\"ctrl.submitIrat()\">\n        <table width=\"100%\">\n            <tr>\n                <td>\n                    <h2>Question 1</h2>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <hr>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <h3>What is the meaning of life?</h3>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <md-radio-group ng-model=\"radio1\">\n                        <md-radio-button value=\"1\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">1)</div>\n                            To be happy\n                        </md-radio-button>\n                        <md-radio-button value=\"2\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">2)</div>\n                            To get good grades\n                        </md-radio-button>\n                        <md-radio-button value=\"3\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">3)</div>\n                            To love\n                        </md-radio-button>\n                    </md-radio-group>\n\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <h2>Question 2</h2>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <hr>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <h3>What is 10x2?</h3>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <md-radio-group ng-model=\"radio2\">\n                        <md-radio-button value=\"1\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">1)</div>\n                            130\n                        </md-radio-button>\n                        <md-radio-button value=\"2\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">2)</div>\n                            120\n                        </md-radio-button>\n                        <md-radio-button value=\"3\" class=\"md-primary\">\n                            <div style=\"display:inline-block\">3)</div>\n                            150\n                        </md-radio-button>\n                    </md-radio-group>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <div>\n                        <md-button type=\"submit\" class=\"md-raised md-primary\" style=\"width: 150px;\">Submit</md-button>\n                    </div>\n                </td>\n            </tr>\n        </table>\n    </form>\n</md-content>";teamTRATTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"tratForm\">\n        <!--Remember to correct the the logic when done-->\n        <div ng-show=\"ctrl.question\" flex layout='row' layout-align='start stretch'>\n            <div flex-offset='2' flex='66' name='question_box'>\n                <h1 class='md-title'>Question {{ctrl.index + 1}} </h1>\n                <md-divider></md-divider>\n                <!------------------starting of questions--------------------------------------------->\n                <div align=\"start\" layout=\"column\">\n                    <label><h4>{{ctrl.question.text}}</h4></label>\n                </div>\n\n                <!------------------starting of questions--------------------------------------------->\n                <div ng-show=\"!ctrl.multipleAns[ctrl.index]\">\n                    <md-radio-group ng-required=\"true\" ng-model=\"ctrl.selected\" ng-required='true'\n                                    ng-change='ctrl.onChange()'>\n                        <div layout=\"column\" ng-repeat=\"option in ctrl.options\">\n                            <div layout=\"row\">\n                                <div flex=\"80\">\n                                    <label>{{$index + 1}}) {{option.text}}</label>\n                                </div>\n                                <div flex=\"20\">\n                                    <md-radio-button aria-label=\"{{option.text}}\" value={{$index}}>\n                                    </md-radio-button>\n                                </div>\n                            </div>\n                            <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                        </div>\n                    </md-radio-group>\n                </div>\n                <div ng-show=\"ctrl.multipleAns[ctrl.index]\">\n                    <div layout=\"column\" ng-repeat=\"option in ctrl.options\">\n                        <div layout=\"row\">\n                            <div flex=\"80\">\n                                <label>{{$index + 1}}) {{option.text}}</label>\n                            </div>\n                            <div flex=\"20\">\n                                <md-checkbox ng-model=\"option.checked\" ng-required=\"true\"\n                                             ng-click=\"ctrl.toggle(ctrl.multiAns, $index)\"></md-checkbox>\n                            </div>\n                        </div>\n                        <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n                    </div>\n                </div>\n\n            </div>\n            <!------------------log box--------------------------------------------->\n            <div style=\"width:30%;\" name='team_log' layout='column' class=\"md-whiteframe-2dp\" >\n                <md-tool-bar layout='row' md-colors=\"{background:'primary'}\">\n                    <div class='md-toolbar-tools'>\n                        <span>Team Log</span>\n                    </div>\n                </md-tool-bar>\n                <md-content>\n                    <!--{{ctrl.teamLog}}-->\n                    <!--<md-subheader class='md-no-sticky'>Last activity at: {{time}}</md-subheader>-->\n                    <md-virtual-repeat-container id=\"vertical-container\" style=\"width:100%;\">\n                        <table md-virtual-repeat=\"msg in ctrl.teamLog | orderBy: '-'\" width=\"auto\">\n                            <tr>\n                                <td>\n                                    <md-list-item class='md-3-line' ng-model='ctrl.teamLog'>\n                                        <table class=\"md-list-item-text\">\n                                            <tr>\n                                                <td>\n                                                    <h3 ng-style=\"{'color': msg.style}\"><b>{{ msg.status }}</b></h3>\n                                                </td>\n                                            </tr>\n                                            <tr>\n                                                <td>\n                                                    <h3><b>{{ msg.text }}</b></h3>\n                                                </td>\n                                            </tr>\n                                            <tr>\n                                                <td>\n                                                    <div ng-style=\"{'font-size': '10px', 'color': '#A9A9A9'}\"> at\n                                                        {{msg.timestamp | date: 'hh:mm:ss'}}\n                                                    </div>\n                                                </td>\n                                            </tr>\n                                        </table>\n                                    </md-list-item>\n                                </td>\n                            </tr>\n                            <tr>\n                                <td colspan=\"100%\">\n                                    <md-divider></md-divider>\n                                </td>\n                            </tr>\n                        </table>\n                    </md-virtual-repeat-container>\n                    <!--<md-list class='md-dense' flex>\n                        <md-list-item class='md-3-line' ng-model='ctrl.teamLog' ng-repeat=\"msg in ctrl.teamLog\">\n                            <div class=\"md-list-item-text\" layout=\"column\">\n                                <h3>{{ msg.user }}</h3>\n                                <h4>{{ msg.text }}</h4>\n                            </div>\n                        </md-list-item>\n                    </md-list>-->\n                </md-content>\n\n            </div>\n        </div>\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button class=\"md-raised md-primary\"\n                       ng-disabled=\"(ctrl.multiAns.length == 0 && ctrl.multipleAns[ctrl.index]) ||\n                    (ctrl.selected == null && !ctrl.multipleAns[ctrl.index])\"\n                       ng-click=\"ctrl.nextQuestion()\">Next\n            </md-button>\n        </div>\n    </form>\n</md-content>";teamFormationTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"teamFormation\" ng-submit=\"ctrl.save()\" layout-align=\"center center\">\n        <md-dialog-content class=\"sticky-container\">\n            <div flex layout='column'>\n                <div flex align='center'>\n                    <h1>Please join a team</h1>\n\n                </div>\n                <div>\n                    <md-input-container md-no-float>\n                        <md-radio-group ng-model=\"ctrl.selectedTeam\" ng-change=\"ctrl.teamChange(ctrl.selectedTeam)\">\n                            <md-radio-button ng-repeat=\"(teamId, member) in ctrl.teams\"\n                                             ng-value=\"teamId\" ng-disabled=\"member.currentSize == member.maxSize\">\n                                <!--<table>-->\n                                    <!--<tr>-->\n                                        <!--<td>Team {{$index + 1}} <font color=\"#A2A2A2\" size=\"2px\"><i>max: {{member.maxSize}}-->\n                                            <!--members</i></font></td>-->\n                                    <!--</tr>-->\n                                    <!--<tr>-->\n                                        <!--<td>-->\n                                            <!--<table>-->\n                                                <!--<tr>-->\n                                                    <!--<td ng-repeat=\"(key, value) in member\"-->\n                                                        <!--ng-if=\"key != 'maxSize' && key != 'currentSize' && key!='teamLeader'\">-->\n                                                        <!--<div>-->\n                                                            <!--({{value.displayName}})-->\n                                                        <!--</div>-->\n                                                    <!--</td>-->\n                                                <!--</tr>-->\n                                            <!--</table>-->\n                                        <!--</td>-->\n                                    <!--</tr>-->\n                                <!--</table>-->\n                                Team {{$index + 1}} <font color=\"#A2A2A2\" size=\"2px\"><i>max: {{member.maxSize}}\n                                members</i></font>\n                                <md-chips>\n                                    <md-chip ng-repeat=\"(key, value) in member\"\n                                             ng-if=\"key != 'maxSize' && key != 'currentSize' && key!='teamLeader'\">\n                                        {{value.displayName}}\n                                    </md-chip>\n                                </md-chips>\n                            </md-radio-button>\n                        </md-radio-group>\n                    </md-input-container>\n\n                    <!--<md-input-container md-no-float>-->\n                    <!--<md-radio-group ng-model=\"ctrl.selectedTeam\" ng-required='true'-->\n                    <!--ng-change=\"ctrl.onChange(ctrl.selectedTeam)\">-->\n                    <!--<md-radio-button ng-disabled='t.currentSize == t.maxSize'-->\n                    <!--ng-repeat='t in ctrl.teams'-->\n                    <!--ng-value=\"$index\">-->\n                    <!--<table>-->\n                    <!--<tr>-->\n                    <!--<td>-->\n                    <!--Team {{$index + 1}} <font color=\"#A2A2A2\" size=\"2px\"><i>max: {{t.maxSize}}-->\n                    <!--members</i></font>-->\n                    <!--</td>-->\n                    <!--</tr>-->\n                    <!--<tr>-->\n                    <!--<td colspan=\"2\">-->\n                    <!--<table>-->\n                    <!--<tr>-->\n                    <!--<td ng-repeat=\"(key, value) in t\"-->\n                    <!--ng-if=\"key != 'maxSize' && key != 'currentSize'\">-->\n                    <!--<div>-->\n                    <!--{{value.displayName}}-->\n                    <!--</div>-->\n                    <!--</td>-->\n                    <!--</tr>-->\n                    <!--</table>-->\n                    <!--</td>-->\n                    <!--</tr>-->\n                    <!--</table>-->\n                    <!--</md-radio-button>-->\n                    <!--</md-radio-group>-->\n                    <!--</md-input-container>-->\n                </div>\n                <!--ng-model=\"ctrl.selectedTeam\"\n                    ng-change=\"ctrl.onClick($index)\"-->\n                <!--{{ctrl.teams | json}}-->\n                <div flex align='row'>\n                    <md-button ng-click=\"ctrl.cancel()\" class=\"md-raised md-primary\" style=\"width: 150px;\">Done\n                    </md-button>\n                    <md-button ng-click=\"ctrl.leave(ctrl.selectedTeam)\" class=\"md-raised\" style=\"width: 150px;\">Leave\n                        Team\n                    </md-button>\n                </div>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>";TIMESTAMP={'.sv':'timestamp'};createTeamActivityInitialData.$inject=['$q','eventService','clmDataStore'];createTeamActivityController.$inject=['$q','initialData','clmDataStore','$location','urlFor','eventService','$mdDialog','spfAlert','firebaseApp','$firebaseObject','$firebaseArray','$log','spfNavBarService'];startTRATInitialData.$inject=['$q','spfAuthData','eventService','clmDataStore','firebaseApp','$firebaseObject','$firebaseArray','$route'];startTRATController.$inject=['$q','initialData','clmDataStore','$location','urlFor','firebaseApp','$firebaseObject','$firebaseArray','spfAlert','$scope','spfNavBarService'];mentorCreationTmpl="<h1>HELLLOOOOOO MENTOR!</h1>\n\n";createMentoringInitialData.$inject=[];createMentoringController.$inject=[];tratQuestionFactory.$inject=['$q','spfAuthData','eventService','clmDataStore'];configRoute$1.$inject=['$routeProvider','routes'];editMCQInitialData.$inject=['$q','eventService','clmDataStore'];startMCQInitialData.$inject=['$q','spfAuthData','eventService','clmDataStore','$route','firebaseApp','$firebaseObject'];createMCQInitialData.$inject=['$q','eventService'];challengeServiceFactory.$inject=['$q','$route','spfAuthData','clmDataStore','$log','spfAlert','$location','urlFor','firebaseApp','$firebaseArray','$firebaseObject'];surveyFormEvent.$inject=['$scope','clmSurvey','clmDataStore','$log','spfAlert','$location','urlFor','$mdDialog','spfNavBarService','$route'];getTaskSurveyEditValues.$inject=['$q','$route','spfAuthData','clmDataStore'];editsurveyFormEvent.$inject=['initialData','$scope','clmSurvey','clmDataStore','$log','spfAlert','$location','urlFor','spfNavBarService','eventService','$mdDialog'];getTaskSurveyValues.$inject=['clmSurvey','$q','$route','spfAuthData','clmDataStore'];challenges=Object.freeze({tratQuestionFactory:tratQuestionFactory,configRoute:configRoute$1,scrollBottom:scrollBottom,challengeServiceFactory:challengeServiceFactory});tmpl$3="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<md-sidenav md-component-id=\"left\" md-is-locked-open=\"$mdMedia('gt-md')\" class=\"md-whiteframe-z2\">\n    <md-toolbar>\n        <h1 class=\"md-toolbar-tools\">\n            <a href=\"#/\">Class Mentors</a>\n        </h1>\n    </md-toolbar>\n    <md-list flex>\n        <md-item>\n            <md-item-content>\n                <md-button ng-model=\"navAceOfCoders\"\n                           ng-click=\"ctrl.navClick('navAceOfCoders')\"\n                           ng-style=\"ctrl.navAceOfCoders\"\n                           class=\"md-padding\"\n                           href=\"#{{ 'aceOfCoders' | urlFor }}\">\n                    <md-icon class=\"material-icons\">text_format</md-icon>\n                    Ace of Coders\n                </md-button>\n            </md-item-content>\n            <md-item-content>\n                <md-button ng-model=\"navCohorts\"\n                        ng-click=\"ctrl.navClick('navCohorts')\"\n                           ng-style=\"ctrl.navCohorts\"\n                           class=\"md-padding\"\n                           href=\"#{{ 'cohorts' | urlFor }}\">\n                    <md-icon class=\"material-icons\">group</md-icon>\n                    Cohorts\n                </md-button>\n            </md-item-content>\n            <md-item-content>\n                <md-button ng-model=\"navEvents\"\n                        ng-click=\"ctrl.navClick('navEvents')\"\n                           ng-style=\"ctrl.navEvents\"\n                           class=\"md-padding\"\n                           href=\"#{{ 'events' | urlFor }}\">\n                    <md-icon class=\"material-icons\">storage</md-icon>\n                    Events\n                </md-button>\n            </md-item-content>\n            <md-item-content>\n                <md-button ng-model=\"navQQ\"\n                           ng-click=\"ctrl.navClick('navQQ')\"\n                           ng-style=\"ctrl.navQQ\" class=\"md-padding\" href=\"#{{ 'questionQueue' | urlFor }}\">\n                    <md-icon class=\"material-icons\">whatshot</md-icon>\n                    Questions\n                </md-button>\n            </md-item-content>\n            <md-item-content>\n                <md-button ng-model=\"navProfile\"\n                        ng-click=\"ctrl.navClick('navProfile')\"\n                           ng-style=\"ctrl.navProfile\"\n                           class=\"md-padding\"\n                           href=\"#{{ 'profile' | urlFor }}\">\n                    <md-icon class=\"material-icons\">person</md-icon>\n                    Profile\n                </md-button>\n            </md-item-content>\n            <md-item-content>\n                <md-button ng-model=\"navFeedback\"\n                        ng-click=\"ctrl.navClick('navFeedback')\"\n                           ng-style=\"ctrl.navFeedback\"\n                           class=\"md-padding\"\n                           href=\"#{{ 'feedback' | urlFor }}\">\n                    <md-icon class=\"material-icons\">question_answer</md-icon>\n                    Feedback\n                </md-button>\n            </md-item-content>\n        </md-item>\n    </md-list>\n</md-sidenav>\n\n<div layout=\"column\" role=\"main\" flex>\n    <md-toolbar class=\"md-hue-2\" layout=\"row\" ng-include=\"'shared/navbar-view.html'\"></md-toolbar>\n\n    <md-content flex class=\"main-view\" layout=\"column\">\n        <div ng-view=\"\" layout=\"column\" flex></div>\n    </md-content>\n</div>";component$1={template:tmpl$3,controller:sideNavController,controllerAs:'ctrl'};classmentors=Object.freeze({component:component$1,sideNavController:sideNavController});cohortTmpl="<md-content flex class=\"md-padding\">\n    <!--<md-content layout-align=\"center\">-->\n        <!--<h1>Hey there!</h1>-->\n        <!--<h2>Check back later for more cool stuff! (:</h2>-->\n    <!--</md-content>-->\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\" md-selected=\"1\">\n\n        <md-tab label=\"Featured Cohorts\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.featuredCohorts.length }} featured cohort(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"c in (ctrl.featuredCohorts | orderBy:'createdAt':true) track by c.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'viewCohort' | urlFor: {cohortId: c.$id} }}\">{{c.title}}</a>\n                            </h3>\n                            <h4>created by {{c.owner.displayName}} ({{c.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Created Cohorts\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.createdCohorts.length }} created cohort(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"c in (ctrl.createdCohorts | orderBy:'createdAt':true) track by c.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'viewCohort' | urlFor: {cohortId: c.$id} }}\">{{c.title}}</a>\n                            </h3>\n                            <h4>created by {{ctrl.currentUser.displayName}} ({{c.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Joined Cohorts\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.joinedCohorts.length }} joined cohort(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\" ng-repeat=\"c in (ctrl.joinedCohorts | orderBy:'createdAt':true) track by c.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'viewCohort' | urlFor: {cohortId: c.$id} }}\">{{c.title}}</a>\n                            </h3>\n                            <h4>created by {{c.owner.displayName}} ({{c.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n</md-content>";newCohortTmpl="<md-content class=\"md-padding\">\n    <form name=\"newCohortForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.newCohort.data, ctrl.selectedEvents, ctrl.featured)\">\n        <spf-sign-form current-user=\"ctrl.currentUser\" ng-if=\"ctrl.profileNeedsUpdate\"></spf-sign-form>\n\n        <md-input-container>\n            <label for=\"cohort-name\">Cohort Name</label>\n            <input name=\"cohortName\" type=\"text\" id=\"cohort-name\" ng-model=\"ctrl.newCohort.data.title\" ng-minlength=\"3\" ng-maxlength=\"60\" required/>\n            <div ng-messages=\"newCohortForm.cohortName.$error\">\n                <div ng-message=\"required\">A cohort must have a name.</div>\n                <div ng-message=\"minlength\">A cohort name shouldn't be shorter than 3 characters.</div>\n                <div ng-message=\"maxlength\">A cohort name shouldn't be longer than 60 characters.</div>\n            </div>\n            <md-switch class=\"md-primary\" ng-model=\"ctrl.featured\" aria-label=\"feature?\">\n                Feature cohort\n            </md-switch>\n        </md-input-container>\n        <md-switch class=\"md-primary\" ng-model=\"ctrl.includeCreated\" aria-label=\"includeCreated?\">\n            <md-tooltip>\n                Select only one at a time. Unselect both to view featured events\n            </md-tooltip>\n            Include created events\n        </md-switch>\n        <md-switch class=\"md-primary\" ng-model=\"ctrl.includeJoined\" aria-label=\"includeJoined?\">\n            <md-tooltip>\n                Select only one at a time. Unselect both to view featured events\n            </md-tooltip>\n            Include joined events\n        </md-switch>\n\n        <h3>Select events to add to your cohort</h3>\n        <md-input-container>\n            <md-list class=\"path-list\" ng-repeat=\"e in (ctrl.events | orderBy:'createdAt':true) track by e.$id\" ng-if=\"!ctrl.includeCreated && !ctrl.includeJoined\">\n                <md-checkbox ng-checked=\"ctrl.exists(e.$id, ctrl.selectedEvents)\" ng-click=\"ctrl.toggle(e.$id, e.title, ctrl.selectedEvents, ctrl.selectedEventsNames)\">\n                    {{e.title}}</br><div class=\"subhead\">created by {{e.owner.displayName}} ({{e.createdAt|date}})</div>\n                </md-checkbox>\n            </md-list>\n\n            <md-list class=\"path-list\" ng-repeat=\"e in (ctrl.createdEvents | orderBy:'createdAt':true) track by e.$id\" ng-if=\"ctrl.includeCreated && !ctrl.includeJoined\">\n                <md-checkbox ng-checked=\"ctrl.exists(e.$id, ctrl.selectedEvents)\" ng-click=\"ctrl.toggle(e.$id, e.title, ctrl.selectedEvents, ctrl.selectedEventsNames)\">\n                    {{e.title}}</br><div class=\"subhead\">created by {{e.owner.displayName}} ({{e.createdAt|date}})</div>\n                </md-checkbox>\n            </md-list>\n\n            <md-list ng-if=\"ctrl.includeJoined && !ctrl.includeCreated\" class=\"path-list\" ng-repeat=\"e in (ctrl.joinedEvents | orderBy:'createdAt':true) track by e.$id\">\n                <md-checkbox ng-checked=\"ctrl.exists(e.$id, ctrl.selectedEvents)\" ng-click=\"ctrl.toggle(e.$id, e.title, ctrl.selectedEvents, ctrl.selectedEventsNames)\">\n                    {{e.title}}</br><div class=\"subhead\">created by {{e.owner.displayName}} ({{e.createdAt|date}})</div>\n                </md-checkbox>\n            </md-list>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.creatingEvent\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n        <div flex=\"100\">\n            <h2 class=\"md-title\">Selected Events</h2>\n            <code style=\"display: block; padding: 8px;\">{{ctrl.selectedEventsNames | json}}</code>\n        </div>\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-primary\" ng-disabled=\"newCohortForm.$invalid || ctrl.creatingCohort\">Create</md-button>\n            <md-button type=\"reset\" ng-click=\"ctrl.reset(newCohortForm)\" ng-disabled=\"ctrl.creatingCohort || newCohortForm.$pristine\">Reset</md-button>\n        </div>\n    </form>\n</md-content>\n";cohortViewTmpl="<md-content flex class=\"md-padding\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\">\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\">\n\n        <md-tab label=\"Ranking\">\n            <md-content layout-padding>\n                <clm-cohorts-ranking-page\n                        cohort=\"ctrl.cohort\"\n                        profile=\"ctrl.profile\">\n                </clm-cohorts-ranking-page>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Announcements\">\n            <md-content layout-padding style=\"overflow-y: hidden;\">\n                <h4>Navigate to event(s) within this cohort: </h4>\n                <md-select flex ng-model=\"ctrl.selectedEvent\" name=\"selectEvent\" placeholder=\"View event(s) in cohort\">\n                    <md-option disabled ng-value=\"event\" ng-repeat=\"event in ctrl.cohort.events\">\n                        <a href=\"#{{ 'oneEvent' | urlFor: {eventId: event} }}\">{{ ctrl.events[event].title }}</a>\n                    </md-option>\n                </md-select>\n                <h4> Event(s) that I joined</h4>\n                <md-button aria-label=\"Child Event\" class=\"md-raised md-primary md-hue-1\" ng-repeat=\"event in ctrl.cohort.events\" ng-if=\"ctrl.joinedEvents[event]\" ng-href=\"#{{ 'oneEvent' | urlFor: {eventId: event} }}\">\n                    <md-tooltip md-direction=\"top\">Click to navigate to event</md-tooltip>\n                    {{ctrl.events[event].title}}\n                </md-button>\n\n                <h3>Featured Announcements</h3>\n                <md-card ng-repeat=\"a in ctrl.announcements\" ng-if=\"a.featured && a.visible\">\n                    <md-toolbar>\n                        <md-card-title>\n                            <md-card-title-text>\n                                <span class=\"md-headline\">{{a.title}}</span>\n                            </md-card-title-text>\n                        </md-card-title>\n                    </md-toolbar>\n                    <md-card-content>\n                        <p class=\"subhead\">By {{a.madeBy}} at {{a.madeAt|date:'yyyy-MM-dd HH:mm'}}</p>\n                        <div style=\"white-space: pre-wrap;\">{{(a.content | cmTruncated: 2000).content}}<md-button ng-if=\"(a.content | cmTruncated: 2000).truncated\" class=\"material-icons\" ng-click=\"ctrl.viewFullAnnouncement(a.content, a.title)\">visibility<md-tooltip>View full announcement</md-tooltip></md-button></div>\n                    </md-card-content>\n                </md-card>\n\n                <h3>Other Announcements</h3>\n                <!--<md-content layout=\"column\" layout-wrap>-->\n                    <md-card ng-repeat=\"a in ctrl.announcements\" ng-if=\"!a.featured && a.visible\" >\n                        <!--flex=\"49\" style=\"min-width: 400px;\"-->\n                        <!--<md-toolbar>-->\n                            <md-card-title>\n                                <md-card-title-text>\n                                    <span class=\"md-headline\">{{a.title}}</span>\n                                </md-card-title-text>\n                            </md-card-title>\n                        <!--</md-toolbar>-->\n                        <md-card-content>\n                            <p class=\"subhead\">By {{a.madeBy}} at {{a.madeAt|date:'yyyy-MM-dd HH:mm'}}<md-button ng-if=\"(a.content | cmTruncated: 300).truncated\" class=\"material-icons\" ng-click=\"ctrl.viewFullAnnouncement(a.content, a.title)\">visibility<md-tooltip>View full announcement</md-tooltip></md-button></p>\n                            <div style=\"white-space: pre-wrap;\">{{(a.content | cmTruncated: 140).content}}</div>\n                        </md-card-content>\n                    </md-card>\n                <!--</md-content>-->\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Stats\" ng-if=\"true || ctrl.isOwner\">\n            <md-content layout-padding>\n                <clm-cohorts-stats-page\n                        cohort=\"ctrl.cohort\"\n                        profile=\"ctrl.profile\"\n                        events=\"ctrl.events\">\n                </clm-cohorts-stats-page>\n            </md-content>\n        </md-tab>\n        <md-tab label=\"Manage\" ng-if=\"ctrl.isOwner\">\n            <md-content layout-padding class=\"md-padding\">\n                <md-button ng-click=\"ctrl.selectedAction='dupChallenges'\" ng-class=\"{false:'md-raised md-hue-1', true:'md-raised md-primary md-hue-1'}[ctrl.selectedAction=='dupChallenges']\">\n                    Duplicate event's challenges\n                    <md-icon class=\"material-icons\">content_copy</md-icon>\n                </md-button>\n                <md-button ng-click=\"ctrl.startManageAsst()\" ng-class=\"{false:'md-raised md-hue-1', true:'md-raised md-primary md-hue-1'}[ctrl.selectedAction=='cohortAsst']\">\n                    Manage Assistants\n                    <md-icon class=\"material-icons\">supervisor_account</md-icon>\n                </md-button>\n                <div ng-if=\"ctrl.selectedAction=='dupChallenges'\">\n                    <h4>Select event that the challenge you wish to duplicate is in</h4>\n                    <md-select ng-model=\"ctrl.selectedEvent\" aria-label=\"select_event\" required placeholder=\"Events in cohorts and other events you created\" ng-change=\"ctrl.loadEventChallenges()\">\n                        <h4>Cohort Events</h4>\n                        <md-option ng-value=\"e\" ng-repeat=\"e in ctrl.cohort.events\">\n                            {{ctrl.events[e].title}}\n                        </md-option>\n                        <h4>Your Events</h4>\n                        <md-option ng-value=\"e.$id\" ng-repeat=\"e in ctrl.createdEvents\">\n                            {{ctrl.events[e.$id].title}}\n                        </md-option>\n                    </md-select>\n                    <div ng-if=\"ctrl.selectedEvent\">\n                        <!--<i>You have selected {{ctrl.selectedEvent}}.</i>-->\n\n                        <h4>Select the challenge you wish to duplicate</h4>\n                        <md-select ng-model=\"ctrl.selectedChallenge\" aria-label=\"select_challenge\" required placeholder=\"Challenges in event\" >\n                            <md-option ng-value=\"c\" ng-repeat=\"c in ctrl.eventChallenges\">\n                                {{c.title}}\n                            </md-option>\n                        </md-select>\n                    </div>\n\n                    <div ng-if=\"ctrl.selectedChallenge\">\n                       <!--You are duplicating <b>{{ctrl.selectedChallenge.title}}</b> from event <b>{{ctrl.events[ctrl.selectedEvent].title}}.</b><br>-->\n\n                        <h4>Select events to duplicate the selected challenge to</h4>\n                        <md-select ng-model=\"ctrl.selectedEvents\"\n                                   data-md-container-class=\"selectdemoSelectHeader\"\n                                   multiple aria-label=\"select_events\">\n                            <md-select-header class=\"demo-select-header\">\n                                <input ng-model=\"searchTerm\"\n                                       type=\"search\"\n                                       placeholder=\"Select the event(s) below\"\n                                       class=\"demo-header-searchbox md-text\">\n                            </md-select-header>\n                            <md-optgroup >\n                                <md-option ng-value=\"e\" ng-repeat=\"e in ctrl.cohort.events |\n              filter:searchTerm\" ng-if=\"e != ctrl.selectedEvent\">{{ctrl.events[e].title}}</md-option>\n                            </md-optgroup>\n                        </md-select>\n                    </div>\n\n                    <br>\n                    <div ng-if=\"ctrl.selectedEvents\">\n                        <h3>Review</h3>\n                        You are duplicating <b>{{ctrl.selectedChallenge.title}}</b> challenge into\n                        <md-chips class=\"md-padding\">\n                            <md-chip ng-repeat = \"reviewSelected in ctrl.selectedEvents\">{{ctrl.events[reviewSelected].title}}</md-chip>\n                        </md-chips>\n                    </div>\n\n                    <div layout=\"row\" layout-align=\"center center\">\n                        <md-button class=\"md-raised md-primary\" ng-if=\"ctrl.selectedEvents\" ng-click=\"ctrl.duplicateChallenges()\">\n                            Duplicate\n                        </md-button>\n                    </div>\n                </div>\n                <div ng-if=\"ctrl.selectedAction=='cohortAsst'\">\n                    <md-input-container>\n                        <label for=\"findUser\">Find a User</label>\n                        <input name=\"findUser\" type=\"text\" id=\"findUser\" ng-model=\"ctrl.userQuery\"/>\n                    </md-input-container>\n                    <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.findUsers()\">\n                        Find User\n                    </md-button>\n                    <div ng-if=\"ctrl.foundUsers\">\n                        Found {{ctrl.foundUsers.length}} user(s)\n                        <md-list>\n                            <md-list-item ng-repeat=\"user in ctrl.foundUsers\">\n                                <span flex>{{user.user.displayName}}</span>\n                                <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.assignCohortAssistant(user)\">Make Cohort Assistant</md-button>\n                            </md-list-item>\n                        </md-list>\n                        <md-divider></md-divider>\n                    </div>\n                </div>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n</md-content>";cohortEditTmpl="<md-content flex class=\"md-padding\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\">\n    <h2 hide show-sm>\n        {{ ctrl.event.title }}\n    </h2>\n\n    <form name=\"editCohortForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.cohort, editCohortForm)\">\n        <md-input-container>\n            <label for=\"cohort-title\">Cohort Name</label>\n            <input flex name=\"cohortTitle\" type=\"text\" id=\"cohort-title\" ng-model=\"ctrl.cohort.title\" ng-minlength=\"3\" ng-maxlength=\"60\" required/>\n            <div ng-messages=\"editCohortForm.cohortTitle.$error\">\n                <div ng-message=\"required\">A cohort must have a name.</div>\n                <div ng-message=\"minlength\">A cohort name shouldn't be shorter than 3 characters.</div>\n                <div ng-message=\"maxlength\">A cohort name shouldn't be longer than 60 characters.</div>\n            </div>\n            <md-switch class=\"md-primary\" ng-model=\"ctrl.cohort.featured\" aria-label=\"feature?\">\n                Feature cohort\n            </md-switch>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.savingCohort\" md-mode=\"indeterminate\" style=\"margin: 16px auto\"></md-progress-circular>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"editCohortForm.$pristine || editCohortForm.$invalid || ctrl.savingCohort\">Save</md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.reset(editCohortForm)\" ng-disabled=\"ctrl.savingCohort || editCohortForm.$pristine\">Reset</md-button>\n        </div>\n    </form>\n\n    <br>\n    <md-divider></md-divider>\n\n    <md-subheader >\n        <md-button ng-click=\"ctrl.toggleEvents()\">\n            Cohort Events\n            <md-tooltip ng-if=\"!ctrl.showingEvents\">Click to view and edit cohort events</md-tooltip>\n            <md-tooltip ng-if=\"ctrl.showingEvents\">Click to hide cohort events</md-tooltip></md-button>\n    </md-subheader>\n\n    <div class=\" collapsable\" ng-class=\"{'showMe' : ctrl.showingEvents}\">\n        <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.addEvent()\" aria-label=\"addEvent\">\n            Add New Event\n        </md-button>\n    </div>\n\n    <form name=\"addEventForm\" ng-submit=\"ctrl.saveAddedEvent(ctrl.cohort.$id)\">\n        <md-card ng-if=\"ctrl.addingEvent\" class=\"md-padding\">\n            <md-card-content>\n                <md-autocomplete flex required ng-if=\"ctrl.addingEvent\"\n                                 md-input-name=\"eventName\"\n                                 md-input-minlength=\"1\"\n                                 md-input-maxlength=\"64\"\n                                 md-no-cache=\"true\"\n                                 md-selected-item=\"ctrl.selectedEvent\"\n                                 md-search-text=\"ctrl.searchEvent\"\n                                 md-items=\"event in ctrl.querySearch(ctrl.searchEvent)\"\n                                 md-item-text=\"event.title\"\n                                 placeholder=\"Select event\">\n                    <md-item-template>\n                        <span md-highlight-text=\"ctrl.searchEvent\">{{event.title}}</span>\n                    </md-item-template>\n                    <div ng-messages=\"addEventForm.eventName.$error\" ng-if=\"addEventForm.eventName.$touched\">\n                        <div ng-message=\"required\">You <b>must</b> select an event.</div>\n                    </div>\n                    <md-not-found>\n                        No events matching \"{{ctrl.searchEvent}}\" were found.\n                    </md-not-found>\n                </md-autocomplete>\n            </md-card-content>\n            <md-card-actions layout=\"row\" layout-align=\"start center\">\n                <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"addEventForm.$pristine || addEventForm.$invalid || !ctrl.selectedEvent\">Add Event</md-button>\n                <md-button class=\"md-accent\" ng-click=\"ctrl.closeAddingEvent()\">Cancel</md-button>\n            </md-card-actions>\n        </md-card>\n    </form>\n\n    <div class=\" md-padding collapsable\" ng-class=\"{'showMe' : ctrl.showingEvents}\" ng-style=\"ctrl.eventStyle\">\n        <md-list>\n            <md-list-item ng-repeat=\"e in ctrl.cohort.events\" ng-if=\"ctrl.events[e]\">\n                {{ctrl.events[e].title}}\n                <span flex></span>\n                <md-button ng-click=\"ctrl.removeCohortEvent(e, ctrl.cohort.events.indexOf(e))\">\n                    <md-icon class=\"material-icons\">clear</md-icon>\n                    <md-tooltip md-direction=\"left\">\n                        Remove event\n                    </md-tooltip>\n                </md-button>\n                <md-divider ng-if=\"!$last\"></md-divider>\n            </md-list-item>\n        </md-list>\n    </div>\n    <!--</div>-->\n\n    <md-divider></md-divider>\n\n    <md-subheader>\n        <md-button ng-click=\"ctrl.toggleAnnouncements()\">\n            Cohort Announcements\n            <md-tooltip ng-if=\"!ctrl.showingAnnouncements\">\n                Click to view and edit cohort announcements\n            </md-tooltip>\n            <md-tooltip ng-if=\"ctrl.showingAnnouncements\">\n                Click to hide cohort announcements\n            </md-tooltip>\n        </md-button>\n    </md-subheader>\n\n    <div class=\"collapsable\" ng-class=\"{'showMe' : ctrl.showingAnnouncements}\">\n        <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.createNewAnnouncement()\">\n            New Announcement\n        </md-button>\n\n    </div>\n        <form name=\"addAnnouncementForm\" ng-submit=\"ctrl.saveAnnouncement(ctrl.cohort.$id)\">\n            <md-card ng-if=\"ctrl.creatingNewAnnouncement\" class=\"md-padding\">\n                <md-input-container>\n                    <input aria-label=\"Announcement title\" required placeholder=\"Announcement title\" type=\"text\" ng-model=\"ctrl.newAnnouncement.title\" id=\"new-announcement-title\" name=\"newAnnouncementTitle\">\n                    <div ng-messages=\"addAnnouncementForm.newAnnouncementTitle.$error\">\n                        <div ng-message=\"required\">An announcement must have a title.</div>\n                    </div>\n                </md-input-container>\n                <textarea aria-label=\"Announcement content\" required placeholder=\"Announcement content\" name=\"newAnnouncementContent\" id=\"new-announcement-content\"\n                          ng-model=\"ctrl.newAnnouncement.content\" rows=\"3\">\n                </textarea>\n                <md-switch ng-model=\"ctrl.newAnnouncement.featured\" aria-label=\"Featured?\">\n                    Pin announcement at the top: {{ ctrl.newAnnouncement.featured }}\n                </md-switch>\n                <md-switch ng-model=\"ctrl.newAnnouncement.visible\" aria-label=\"Visibility\">\n                    Make announcement visible to participants: {{ ctrl.newAnnouncement.visible }}\n                </md-switch>\n                <md-card-actions layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"md-raised md-primary\" type=\"submit\" ng-disabled=\"addAnnouncementForm.$pristine || addAnnouncementForm.$invalid\">Save Announcement</md-button>\n                    <md-button class=\"md-accent\" ng-click=\"ctrl.closeNewAnnouncement()\">Cancel</md-button>\n                </md-card-actions>\n            </md-card>\n        </form>\n\n    <div class=\" md-padding collapsable\" ng-class=\"{'showMe' : ctrl.showingAnnouncements}\" ng-style=\"ctrl.announcementStyle\">\n        <md-list>\n            <md-list-item ng-repeat=\"a in ctrl.announcements\">\n                {{a.title}}\n                <span flex></span>\n                <md-button ng-if=\"!a.featured\" ng-click=\"ctrl.featureAnnouncement(ctrl.cohort.$id, a.$id)\">\n                    <md-icon class=\"material-icons\">leak_remove</md-icon>\n                    <md-tooltip md-direction=\"top\">\n                    Feature\n                    </md-tooltip>\n                </md-button>\n                <md-button ng-if=\"a.featured\" ng-click=\"ctrl.unfeatureAnnouncement(ctrl.cohort.$id, a.$id)\">\n                    <md-icon class=\"material-icons\">leak_add</md-icon>\n                    <md-tooltip md-direction=\"top\">\n                        Un-Feature\n                    </md-tooltip>\n                </md-button>\n                <md-button ng-if=\"!a.visible\" ng-click=\"ctrl.showAnnouncement(ctrl.cohort.$id, a.$id)\">\n                    <md-icon class=\"material-icons\">visibility_off</md-icon>\n                    <md-tooltip md-direction=\"top\">\n                        Show announcement\n                    </md-tooltip>\n                </md-button>\n                <md-button ng-if=\"a.visible\" ng-click=\"ctrl.hideAnnouncement(ctrl.cohort.$id, a.$id)\">\n                    <md-icon class=\"material-icons\">visibility</md-icon>\n                    <md-tooltip md-direction=\"top\">\n                        Hide announcement\n                    </md-tooltip>\n                </md-button>\n                <md-divider ng-if=\"!$last\"></md-divider>\n            </md-list-item>\n        </md-list>\n    </div>\n</md-content>\n";cohortStatsPageTmpl="<md-content flex class=\"md-padding\">\n\n    <!--<link href=\"../../../jspm_packages/graphing/c3.min.css\" rel=\"stylesheet\" type=\"text/css\">-->\n    <!--<script src=\"../../../jspm_packages/graphing/d3.min.js\"></script>-->\n    <script src=\"../../../jspm_packages/npm/c3@0.4.11/c3.css\"></script>\n\n    <md-button class=\"md-raised md-primary\" ng-click=\"ctrl.generateReportCard()\" ng-disabled=\"ctrl.loadRequest\">\n        View Badges Count\n    </md-button>\n\n    <div ng-if=\"ctrl.loadRequest && ctrl.loadingAchievements\" layout=\"column\" layout-sm=\"column\" layout-align=\"center-center\">\n        <i>Please hold on while we crunch some data ...</i>\n        <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n        <p>{{ctrl.numLoaded}} / {{ctrl.numParticipants}} users checked</p>\n    </div>\n\n    <div ng-if=\"ctrl.badgesCount.codeCombatA.length > 0\">\n        <h3>Code Combat Badges</h3>\n        <md-virtual-repeat-container id=\"codeCombat-container\">\n            <div md-virtual-repeat=\"a in ctrl.badgesCount.codeCombatA\"\n                 class=\"repeated-item\" flex>\n                {{a.name}}: <b>{{a.count}}</b>\n            </div>\n        </md-virtual-repeat-container>\n    </div>\n    <div ng-if=\"ctrl.badgesCount.freeCodeCampA.length > 0\">\n        <h3>Free Code Camp Badges</h3>\n        <md-virtual-repeat-container id=\"freeCodeCamp-container\">\n            <div md-virtual-repeat=\"a in ctrl.badgesCount.freeCodeCampA\"\n                 class=\"repeated-item\" flex>\n                {{a.name}}: <b>{{a.count}}</b>\n            </div>\n        </md-virtual-repeat-container>\n    </div>\n    <div ng-if=\"ctrl.badgesCount.pivotalExpertA.length > 0\">\n        <h3>Pivotal Expert Badges</h3>\n        <md-virtual-repeat-container id=\"pivotalExpert-container\">\n            <div md-virtual-repeat=\"a in ctrl.badgesCount.pivotalExpertA\"\n                 class=\"repeated-item\" flex>\n                {{a.name}}: <b>{{a.count}}</b>\n            </div>\n        </md-virtual-repeat-container>\n    </div>\n    <div ng-if=\"ctrl.badgesCount.codeSchoolA.length > 0\">\n        <h3>Code School Badges</h3>\n        <md-virtual-repeat-container id=\"codeSchool-container\">\n            <div md-virtual-repeat=\"a in ctrl.badgesCount.codeSchoolA\"\n                 class=\"repeated-item\" flex>\n                {{a.name}}: <b>{{a.count}}</b>\n            </div>\n        </md-virtual-repeat-container>\n    </div>\n\n    <md-select flex ng-model=\"ctrl.selectedStatistic\" name=\"selectStatistic\" placeholder=\"Select statistic to view\" ng-change=\"ctrl.renderDashboard()\" ng-if=\"ctrl.cohort.owner.publicId == ctrl.profile.$id\">\n        <md-option ng-repeat=\"statistic in ['Submission time series', 'Ordering']\">\n            {{statistic}}\n        </md-option>\n    </md-select>\n\n    <div id=\"chart\" align=\"center\"></div>\n</md-content>";cohortRankingPageTmpl="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n<div ng-if=\"!ctrl.loading\">\n    <md-content class=\"md-padding\">\n        <!--<timer interval=\"1000\">{{hhours}} hour{{hhoursS}}, {{mminutes}} minute{{minutesS}}, {{sseconds}} second{{secondsS}}.</timer>-->\n        <md-switch ng-model=\"ctrl.showFilteredRanking\" aria-label=\"showFilter?\" ng-change=\"ctrl.filterRanking()\" ng-init=\"ctrl.showFilteredRanking=true\">\n            Show Filtered Rankings: {{ ctrl.showFilteredRanking }}\n        </md-switch>\n        <table class=\"events ranking\">\n            <thead>\n            <tr>\n                <th>\n                    <md-button>Rank</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button>Qualified</md-button>\n                </th>\n                <th>\n                    <md-button>Registered ({{ctrl.cohortTotalParticipants.length}})</md-button>\n                </th>\n                <th>\n                    <md-button>Event</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">1st</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">2nd</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">3rd</md-button>\n                </th>\n                <th ng-if=\"ctrl.showFilteredRanking\">\n                    <md-button ng-disabled=\"true\">4th</md-button>\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n                <tr ng-if=\"!ctrl.showFilteredRanking\" ng-repeat=\"event in ctrl.cohortEventData | orderBy:'-participants'\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                     {{$index+1}}\n                    </th>\n                    <td>{{ event.participants.length }}</td>\n                    <td><a href=\"#{{ 'oneEvent' | urlFor: {eventId: event.id} }}\">{{ event.title }}</a></td>\n                </tr>\n                <tr ng-if=\"ctrl.showFilteredRanking && ctrl.cohort.title.toLowerCase().indexOf('junior') < 0\" ng-repeat=\"event in ctrl.cohortEventData | orderBy:'-qualifiedParticipants'\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                        {{$index+1}}\n                    </th>\n                    <td>{{ event.qualifiedParticipants.length }}</td>\n                    <td>{{ event.participants.length }} <i> ({{event.qualifiedParticipants.length/event.participants.length*100| number: 0}}%)</i></td>\n                    <td><a href=\"#{{ 'oneEvent' | urlFor: {eventId: event.id} }}\">{{ event.title }}</a></td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<6 && event.qualifiedParticipants[0]\">{{event.qualifiedParticipants[0].displayName }} ({{event.qualifiedParticipants[0].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<6 && event.qualifiedParticipants[1]\">{{event.qualifiedParticipants[1].displayName }} ({{event.qualifiedParticipants[1].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<2 && event.qualifiedParticipants[2]\">{{event.qualifiedParticipants[2].displayName }} ({{event.qualifiedParticipants[2].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<2 && event.qualifiedParticipants[3]\">{{event.qualifiedParticipants[3].displayName }} ({{event.qualifiedParticipants[3].score}})</td>\n                </tr>\n                <tr ng-if=\"ctrl.showFilteredRanking && ctrl.cohort.title.toLowerCase().indexOf('junior') >= 0\" ng-repeat=\"event in ctrl.cohortEventData | orderBy:'-qualifiedParticipants'\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                        {{$index+1}}\n                    </th>\n                    <td>{{ event.qualifiedParticipants.length }}</td>\n                    <td>{{ event.participants.length }} <i> ({{event.qualifiedParticipants.length/event.participants.length*100| number: 0}}%)</i></td>\n                    <td><a href=\"#{{ 'oneEvent' | urlFor: {eventId: event.id} }}\">{{ event.title }}</a></td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<12 && event.qualifiedParticipants[0]\">{{event.qualifiedParticipants[0].displayName }} ({{event.qualifiedParticipants[0].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<12 && event.qualifiedParticipants[1]\">{{event.qualifiedParticipants[1].displayName }} ({{event.qualifiedParticipants[1].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<4 && event.qualifiedParticipants[2]\">{{event.qualifiedParticipants[2].displayName }} ({{event.qualifiedParticipants[2].score}})</td>\n                    <td ng-if=\"ctrl.showFilteredRanking && $index<4 && event.qualifiedParticipants[3]\">{{event.qualifiedParticipants[3].displayName }} ({{event.qualifiedParticipants[3].score}})</td>\n                </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOpts\" class=\"md-padding\"></clm-pager>\n</div>";noop$6=function noop(){return undefined;};component$2={controller:ViewCohortCtrl};configRoute$2.$inject=['$routeProvider','routes'];ClmListCohorts.$inject=['initialData','spfNavBarService','urlFor','spfAuthData'];classMentorsCohortResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];NewCohortCtrl.$inject=['$q','$location','initialData','urlFor','spfAuthData','spfAlert','spfNavBarService','clmDataStore'];newCohortCtrlInitialData.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];viewCohortCtrlInitialData.$inject=['$q','$route','spfAuth','spfAuthData','clmDataStore'];ViewCohortCtrl.$inject=['$log','$scope','initialData','$document','$mdDialog','$route','$firebaseObject','spfAlert','urlFor','firebaseApp','spfAuthData','spfNavBarService','clmDataStore','$firebaseArray'];editCohortCtrlInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];EditCohortCtrl.$inject=['initialData','spfNavBarService','urlFor','spfAlert','clmDataStore'];ClmCohortStatsPageCtrl.$inject=['$scope','$q','$log','$mdDialog','$document','$firebaseArray','urlFor','spfAlert','firebaseApp','clmServicesUrl','clmDataStore','$firebaseObject'];ClmCohortRankPageCtrl.$inject=['$q','$scope','$log','firebaseApp','$firebaseObject','$firebaseArray','clmDataStore','clmPagerOption'];cohorts=Object.freeze({component:component$2,configRoute:configRoute$2,clmCohortsStatsPageFactory:clmCohortsStatsPageFactory,clmCohortRankPageFactory:clmCohortRankPageFactory});editTmpl="<md-content flex class=\"md-padding\">\n    <link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\">\n    <h2 hide show-sm>\n        {{ ctrl.event.title }}\n    </h2>\n\n    <form name=\"editEventForm\" ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.event, ctrl.newPassword, editEventForm)\">\n        <md-input-container>\n            <label for=\"event-title\">Event Name</label>\n            <input name=\"eventTitle\" type=\"text\" id=\"event-title\" ng-model=\"ctrl.event.title\" ng-minlength=\"3\"\n                   ng-maxlength=\"60\" required=\"true\"/>\n            <div ng-messages=\"editEventForm.eventTitle.$error\">\n                <div ng-message=\"required\">An event should have a name.</div>\n                <div ng-message=\"minlength\">An event name shouldn't be shorter than 3 characters.</div>\n                <div ng-message=\"maxlength\">An event name shouldn't be longer than 60 characters.</div>\n            </div>\n        </md-input-container>\n\n        <md-input-container>\n            <label for=\"event-pw\">New Password</label>\n            <input name=\"eventPw\" type=\"text\" id=\"event-pw\" ng-model=\"ctrl.newPassword\"/>\n            <div ng-messages=\"editEventForm.eventPw.$error\">\n            </div>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.savingEvent\" md-mode=\"indeterminate\"\n                              style=\"margin: 16px auto\"></md-progress-circular>\n\n        <div class=\"information\">Created by {{ctrl.event.owner.displayName}} on ({{ctrl.event.createdAt|date}})</div>\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-raised md-primary\"\n                       ng-disabled=\"editEventForm.$pristine || editEventForm.$invalid || ctrl.savingEvent || !ctrl.isOwner\">\n                Save\n            </md-button>\n            <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.reset(editEventForm)\"\n                       ng-disabled=\"ctrl.savingEvent || editEventForm.$pristine\">Reset\n            </md-button>\n        </div>\n    </form>\n    <md-checkbox ng-model=\"featureEvent\" ng-checked=\"ctrl.featureEvent\" ng-click=\"ctrl.toggle()\"> Feature this event\n    </md-checkbox>\n    <!--<md-divider></md-divider>-->\n    <hr style=\"background:#D9D9D9; border: 0; height: 1px\"/>\n    <table>\n        <tr>\n            <td>\n                <md-subheader><font size=\"4\">Event Assistant(s)</font></td></md-subheader>\n            <td>\n                <md-button class=\"md-raised\" style=\"height:10px\" ng-click=\"ctrl.toggleAssistants()\">\n                    {{ctrl.eventAssistantBttnText}}\n                    <md-tooltip ng-if=\"!ctrl.showingAssistants\">Click to view and edit event assistants</md-tooltip>\n                    <md-tooltip ng-if=\"ctrl.showingAssistants\">Click to hide event assistants</md-tooltip>\n                </md-button>\n            </td>\n        </tr>\n    </table>\n    <!--<div ng-if=\"ctrl.showingAssistants\">-->\n\n    <div class=\"information collapsable\" ng-class=\"{showMe: ctrl.showingAssistants}\">\n\n        <md-button ng-click=\"ctrl.addAssistant()\">\n            <md-icon md-svg-icon=\"add\"></md-icon>\n            <md-tooltip>\n                Add Assistant\n            </md-tooltip>\n            Add Assistant\n        </md-button>\n    </div>\n\n    <form name=\"addAssistantForm\" ng-submit=\"ctrl.saveNewAssistant(ctrl.event.$id)\">\n        <md-card ng-if=\"ctrl.addingNewAssistant\">\n            <md-card-content>\n                <md-autocomplete flex required\n                                 md-input-name=\"assistantName\"\n                                 md-input-minlength=\"1\"\n                                 md-input-maxlength=\"64\"\n                                 md-no-cache=\"true\"\n                                 md-selected-item=\"ctrl.selectedUser\"\n                                 md-search-text=\"ctrl.searchUser\"\n                                 md-items=\"user in ctrl.querySearch(ctrl.searchUser)\"\n                                 md-item-text=\"user.displayName\"\n                                 placeholder=\"Select assistant profile\">\n                    <md-item-template>\n                        <span md-highlight-text=\"ctrl.searchUser\">{{user.displayName}}</span>\n                    </md-item-template>\n                    <div ng-messages=\"addAssistantForm.assistantName.$error\"\n                         ng-if=\"addAssistantForm.assistantName.$touched\">\n                        <div ng-message=\"required\">You <b>must</b> select a user.</div>\n                    </div>\n                    <md-not-found>\n                        No users matching \"{{ctrl.searchUser}}\" were found.\n                    </md-not-found>\n                </md-autocomplete>\n\n                <md-switch ng-model=\"ctrl.newAssistant.canEdit\" aria-label=\"canEdit?\">\n                    Can Edit Events: {{ ctrl.newAssistant.canEdit }}\n                </md-switch>\n                <md-switch ng-model=\"ctrl.newAssistant.canReview\" aria-label=\"canReview?\">\n                    Can Review Event Submissions: {{ ctrl.newAssistant.canReview }}\n                </md-switch>\n            </md-card-content>\n            <md-card-actions layout=\"row\" layout-align=\"start center\">\n                <md-button class=\"md-raised md-primary\" type=\"submit\"\n                           ng-disabled=\"addAssistantForm.$pristine || addAssistantForm.$invalid || !ctrl.selectedUser\">\n                    Approve Assistant\n                </md-button>\n                <md-button class=\"md-accent\" ng-click=\"ctrl.closeNewAssistant()\">Cancel</md-button>\n            </md-card-actions>\n        </md-card>\n    </form>\n\n    <div class=\" md-padding collapsable\" id=\"testingCollapse\" ng-class=\"{'showMe2' : ctrl.showingAssistants}\"\n         ng-style=\"ctrl.divStyle\">\n        <md-list>\n            <h4 class=\"md-no-sticky\">{{ ctrl.assistants | spfLength }} assistant(s)</h4>\n            <md-list-item ng-repeat=\"asst in ctrl.assistants track by asst.$id\">\n                {{ asst.name }}\n                <span flex></span>\n                <md-button ng-click=\"ctrl.disableReview(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"asst.canReview\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Disable reviewing of event task submissions\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Reviewing\n                </md-button>\n                <md-button ng-click=\"ctrl.enableReview(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"!asst.canReview\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Enable reviewing of event task submissions\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"done\"></md-icon>\n                    Reviewing\n                </md-button>\n                <md-button ng-click=\"ctrl.disableEdit(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"asst.canEdit\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Disable editing of event\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Editing\n                </md-button>\n                <md-button ng-click=\"ctrl.enableEdit(ctrl.event.$id, asst.$id, asst.name)\"\n                           ng-if=\"!asst.canEdit\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Enable editing of event\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"done\"></md-icon>\n                    Editing\n                </md-button>\n                <md-button ng-click=\"ctrl.removeAssistant(ctrl.event.$id, asst.$id, asst.name)\"\n                           layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                           aria-label=\"open\"\n                >\n                    <md-tooltip>\n                        Remove user as event assistant\n                    </md-tooltip>\n                    <md-icon md-svg-icon=\"clear\"></md-icon>\n                    Remove\n                </md-button>\n                <md-divider ng-if=\"!$last\"></md-divider>\n            </md-list-item>\n        </md-list>\n    </div>\n    <!--</div>-->\n\n    <!--<md-divider></md-divider>-->\n    <hr style=\"background:#D9D9D9; border: 0; height: 1px\"/>\n\n    <table>\n        <tr>\n            <td>\n                <md-subheader><font size=\"4\" >Event Challenge(s)</font></md-subheader>\n            </td>\n            <td>\n                <md-button class=\"md-raised\" style=\"height:10px\" ng-click=\"ctrl.toggleTaskEditView()\">\n                    {{ctrl.eventChallengeBttnText}}\n                    <md-tooltip ng-if=\"!ctrl.showingTasks\">Click to view and edit event challenges</md-tooltip>\n                    <md-tooltip ng-if=\"ctrl.showingTasks\">Click to hide event challenges</md-tooltip>\n                </md-button>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <md-subheader class=\"md-no-sticky\">{{ ctrl.tasks | spfLength }} challenge(s)</md-subheader>\n            </td>\n        </tr>\n    </table>\n\n    <div class=\"information collapsableTask \" ng-class=\"{'showMe' : ctrl.showingTasks}\" ng-style=\"ctrl.taskStyle\" >\n        <md-list>\n            <md-list-item ng-repeat=\"task in ctrl.tasks track by task.$id\" ng-if=\"!task.archived\" class=\"md-padding\">\n                    <div class=\"md-list-item-text\" flex>\n                        <h3>\n                            {{ task.title }}\n                            <span ng-if=\"task.closedAt\">(Closed)</span>\n                            <span ng-if=\"task.openedAt\">(Open)</span>\n                        </h3>\n                        <p>{{ task.description |limitTo:80 }}...</p>\n                        <p ng-if=\"task.badge.id\">{{ task.badge.name}}</p>\n                    </div>\n\n                <!--<div layout=\"row\">-->\n                    <md-button ng-href=\"#{{ 'editEventTask'|urlFor: {eventId: ctrl.event.$id, taskId: task.$id} }}\" layout\n                               layout-align=\"center center\" class=\"md-raised md-primary\" aria-label=\"Edit\">\n                        <md-icon md-svg-icon=\"create\"></md-icon>\n                        Edit\n                    </md-button>\n                    <md-button ng-click=\"ctrl.openTask(ctrl.event.$id, task)\"\n                               ng-if=\"task.closedAt\"\n                               layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                               aria-label=\"open\"\n                    >\n                        <md-icon md-svg-icon=\"done\"></md-icon>\n                        Open\n                    </md-button>\n                    <md-button ng-click=\"ctrl.closeTask(ctrl.event.$id, task)\"\n                               ng-if=\"task.openedAt\"\n                               layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                               aria-label=\"open\"\n                    >\n                        <md-icon md-svg-icon=\"clear\"></md-icon>\n                        Close\n                    </md-button>\n                    <md-button ng-click=\"ctrl.showTask(ctrl.event.$id, task.$id)\"\n                               ng-if=\"task.hidden\"\n                               layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                               aria-label=\"open\"\n                    >\n                        <md-icon md-svg-icon=\"done\"></md-icon>\n                        Show\n                    </md-button>\n                    <md-button ng-click=\"ctrl.hideTask(ctrl.event.$id, task.$id)\"\n                               ng-if=\"!task.hidden\"\n                               layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                               aria-label=\"open\"\n                    >\n                        <md-icon md-svg-icon=\"clear\"></md-icon>\n                        Hide\n                    </md-button>\n                    <md-button ng-click=\"ctrl.archiveTask(ctrl.event.$id, task.$id)\"\n                               layout layout-align=\"center center\" class=\"md-raised md-primary\"\n                               aria-label=\"open\"\n                    >\n                        <md-icon md-svg-icon=\"clear\"></md-icon>\n                        Archive\n                    </md-button>\n                <!--</div>-->\n                <md-divider ng-if=\"!$last\"></md-divider>\n            </md-list-item>\n        </md-list>\n    </div>\n\n\n</md-content>\n";eventTableParticipantsTmpl="<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n\n<div ng-if=\"!ctrl.loading\">\n    <span ng-show=\"ctrl.visibleTasks.length != 0\">Scroll right to see more challenges <i class=\"material-icons\">fast_forward</i></span>\n\n    <md-content class=\"md-padding\" >\n        <table class=\"events tasks\">\n            <thead>\n            <tr ng-class=\"{'reversed': ctrl.orderOptions.reversed}\">\n                <th rowspan=\"4\" ng-class=\"{orderer: !ctrl.orderOptions.key}\">\n                    <md-button ng-click=\"ctrl.orderBy()\">Participants</md-button>\n                </th>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\">\n                    <em>No challenge available</em>\n                </th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\"\n                    ng-class=\"{orderer: ctrl.orderOptions.key == task.$id}\"\n                >\n                    <md-button ng-click=\"ctrl.orderBy(task.$id)\">{{ task.title }}</md-button>\n                </th>\n            </tr>\n            <tr>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\"></th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    {{ task.description }}\n                </th>\n            </tr>\n            <tr>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\"></th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    <a ng-href=\"{{task.link}}\" ng-if=\"task.link\" target=\"_blank\"\n                       ng-click=\"ctrl.logClick(task.$id, task.link)\">More details</a>\n                </th>\n            </tr>\n            <tr>\n                <th ng-if=\"ctrl.visibleTasks.length == 0\"></th>\n                <th ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    {{ctrl.taskCompletion[task.$id] | number: 0}} %\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr ng-if=\"ctrl.currentUserParticipant\">\n                <th layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"name-button\"\n                               ng-href=\"#{{ 'profile' | urlFor:{'publicId': ctrl.currentUserParticipant.$id} }}\">\n                        Yourself\n                    </md-button>\n\n                    <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Update\"\n                               ng-click=\"ctrl.update(ctrl.event, ctrl.tasks, ctrl.currentUserSolutions, ctrl.profile)\">\n                        <md-icon md-svg-icon=\"loop\"></md-icon>\n                    </md-button>\n\n                </th>\n\n                <td ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    <div ng-if=\"task.mcqQuestions && !task.teamFormationMethod\">\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                            Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                        </span>\n\n                        <!--added one more contraint to change the button to Start IRAT-->\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                            <md-button ng-if=\"!task.teamFormationMethod\" class=\"md-raised md-primary\"\n                                       ng-click=\"ctrl.startMCQ(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       target=\"_blank\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Start MCQ\"\n                            >Start MCQ\n                            </md-button>\n                        </span>\n                    </div>\n\n                    <div ng-if=\"task.teamFormationMethod\">\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id] && task.mcqQuestions\">\n                            <md-button class=\"md-raised md-primary\" ng-if=\"task.startIRAT\"\n                                       ng-click=\"ctrl.startMCQ(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       target=\"_blank\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Start IRAT\"\n                            >Start IRAT\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id] && task.mcqQuestions\">\n                            Completed\n                        </span>\n\n\n                        <md-button class=\"md-raised md-primary\"\n                                   ng-if=\"task.formationPattern && !ctrl.currentUserSolutions[task.$id]\"\n                                   ng-click=\"ctrl.promptForTeamFormation(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   target=\"_blank\"\n                                   ng-disabled=\"task.closedAt\"\n                                   aria-label=\"Start form team\"\n                        >Join a Team\n                        </md-button>\n\n                        <div ng-if=\"task.formationPattern && ctrl.currentUserSolutions[task.$id]\">\n                            {{ctrl.currentUserSolutions[task.$id]}}\n                            <md-button class=\"md-icon-button md-primary small-icon\"\n                                       ng-click=\"ctrl.promptForTeamFormation(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       target=\"_blank\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Change form team\"\n                            >\n                                <md-icon md-svg-icon=\"create\"></md-icon>\n                            </md-button>\n                        </div>\n\n                        <!--prompt for collaborative submission-->\n                        <span ng-if=\"!task.coopSubmission && !ctrl.currentUserSolutions[task.$id] && !task.formationPattern && !task.mcqQuestions\">\n                            <md-button class=\"md-raised md-primary\"\n                                       ng-if=\"task.type == 'textResponse' && ctrl.team[task.teamFormationRef].teamLeader && ctrl.team[task.teamFormationRef].teamLeader == ctrl.currentUserParticipant.$id\"\n                                       ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Collab Text Response\"\n                            >Submit Response\n                            </md-button>\n\n                            <md-button class=\"md-raised md-primary\"\n                                       ng-if=\"task.type == 'code' && ctrl.team[task.teamFormationRef].teamLeader && ctrl.team[task.teamFormationRef].teamLeader == ctrl.currentUserParticipant.$id\"\n                                       ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Collab Code Challenge\"\n                            >Submit Code\n                            </md-button>\n\n                            <md-button class=\"md-raised md-primary\"\n                                       ng-if=\"task.type == 'linkPattern' && ctrl.team[task.teamFormationRef].teamLeader && ctrl.team[task.teamFormationRef].teamLeader == ctrl.currentUserParticipant.$id\"\n                                       ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Collab Link Pattern\"\n                            >Submit Link\n                            </md-button>\n\n                            <label ng-show=\"task.teamFormationRef && ctrl.checkUser(task.teamFormationRef, ctrl.currentUserParticipant.$id) && ctrl.team[task.teamFormationRef].teamLeader != ctrl.currentUserParticipant.$id && task.openedAt\">\n                                Your team leader is: {{ctrl.team[task.teamFormationRef][ctrl.team[task.teamFormationRef].teamLeader].displayName}}\n                             </label>\n                        </span>\n\n                        <!--prompt for cooperative submission-->\n                        <span ng-if=\"task.coopSubmission && !ctrl.currentUserSolutions[task.$id] && !task.formationPattern && !task.mcqQuestions\">\n                            <md-button class=\"md-raised md-primary\" ng-if=\"task.type == 'textResponse'\"\n                                       ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Cooperative Text Response\"\n                            >Submit Response\n                            </md-button>\n\n                            <md-button class=\"md-raised md-primary\" ng-if=\"task.type == 'code'\"\n                                       ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Cooperative Code Challenge\"\n                            >Submit Code\n                            </md-button>\n\n                            <md-button class=\"md-raised md-primary\" ng-if=\"task.type == 'linkPattern'\"\n                                       ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Cooperative Link Pattern\"\n                            >Submit Link\n                            </md-button>\n\n                        </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                            <md-button class=\"md-raised md-primary\" ng-if=\"task.startTRAT\"\n                                       ng-hide=\"ctrl.checkUser(task.teamFormationRef, ctrl.currentUserParticipant.$id) && ctrl.team[task.teamFormationRef].teamLeader != ctrl.currentUserParticipant.$id && ctrl.team[task.teamFormationRef].teamLeader != undefined\"\n                                       ng-click=\"ctrl.startTRAT(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant)\"\n                                       target=\"_blank\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Start trat\"\n                            >Start TRAT\n                            </md-button>\n\n                            <label ng-show=\"task.startTRAT && task.teamFormationRef && ctrl.checkUser(task.teamFormationRef, ctrl.currentUserParticipant.$id) && (ctrl.team[task.teamFormationRef].teamLeader != undefined && ctrl.team[task.teamFormationRef].teamLeader != ctrl.currentUserParticipant.$id) && task.openedAt\">\n                                Your team leader is: {{ctrl.team[task.teamFormationRef][ctrl.team[task.teamFormationRef].teamLeader].displayName}}\n                             </label>\n                        </span>\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id] && !task.formationPattern && task.type == 'indexCards'\">\n                            Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                        </span>\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id] && !task.formationPattern && task.type == 'linkPattern'\">\n                            Completed\n                            <md-button class=\"md-icon-button md-primary small-icon\"\n                                       aria-label=\"Update link\"\n                                       ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-if=\"task.coopSubmission || (task.openedAt && ctrl.checkUser(task.teamFormationRef, ctrl.currentUserParticipant.$id) && ctrl.team[task.teamFormationRef].teamLeader == ctrl.currentUserParticipant.$id)\"\n                            >\n                                <md-icon md-svg-icon=\"create\"></md-icon>\n                            </md-button>\n                        </span>\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id] && !task.formationPattern && task.type == 'textResponse'\">\n                            Completed\n                            <md-button class=\"md-icon-button md-primary small-icon\"\n                                                aria-label=\"Update link\"\n                                                ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                                ng-if=\"task.coopSubmission || (task.openedAt && ctrl.checkUser(task.teamFormationRef, ctrl.currentUserParticipant.$id) && ctrl.team[task.teamFormationRef].teamLeader == ctrl.currentUserParticipant.$id)\"\n                        >\n                                <md-icon md-svg-icon=\"create\"></md-icon>\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id] && !task.formationPattern && task.type == 'code'\">\n                            Completed\n                            <md-button class=\"md-icon-button md-primary small-icon\"\n                                       aria-label=\"Update link\"\n                                       ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                       ng-if=\"task.coopSubmission || (task.openedAt && ctrl.checkUser(task.teamFormationRef, ctrl.currentUserParticipant.$id) && ctrl.team[task.teamFormationRef].teamLeader == ctrl.currentUserParticipant.$id)\"\n                            >\n                                <md-icon md-svg-icon=\"create\"></md-icon>\n                            </md-button>\n                        </span>\n                    </div>\n\n                    <div ng-if=\"task.serviceId && !task.teamFormationMethod\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                            </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button class=\"md-raised md-primary\"\n                                           ng-href=\"{{ctrl.startLink(task, ctrl.profile)}}\"\n                                           target=\"_blank\"\n                                           ng-disabled=\"task.closedAt\"\n                                           aria-label=\"Start Challenge\"\n                                >\n                                    <span ng-switch on=\"ctrl.mustRegister(task, ctrl.profile)\">\n                                        <span class=\"md-raised md-primary\" ng-switch-when=\"true\">Register</span>\n                                        <span class=\"md-raised md-primary\" ng-switch-default>Start</span>\n                                    </span>\n\n                                </md-button>\n                        </span>\n                    </div>\n\n                    <div ng-if=\"task.activityType=='indexCards' && task.textResponse\">\n                      <span ng-if='ctrl.currentUserSolutions[task.$id]'>\n                        {{ ctrl.currentUserSolutions[task.$id] | cmTruncate: 10 }}<span\n                              ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                        <md-button class=\"md-icon-button md-primary small-icon\"\n                                   aria-label=\"Update response\"\n                                   ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   ng-disabled=\"task.closedAt\"\n                        >\n                            <md-icon md-svg-icon=\"create\"></md-icon>\n                        </md-button>\n                      </span>\n\n                      <span ng-if='!ctrl.currentUserSolutions[task.$id]'>\n                        <md-button class=\"md-raised md-primary\"\n                                   ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   ng-disabled=\"task.closedAt\"\n                                   aria-label=\"Collab Text Response\"\n                        >Submit Response\n                        </md-button>\n                      </span>\n                    </div>\n\n                    <div ng-if=\"task.type == 'voteQuestions'\">\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                          <md-button class=\"md-raised md-primary\"\n                                     aria-label=\"Update response\"\n                                     ng-click=\"ctrl.promptForVoteQuestion(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                     ng-disabled=\"task.closedAt\"\n\n                          > Edit Vote\n                          </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                            <md-button class=\"md-raised md-primary\"\n                                       target=\"_blank\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Vote Questions\"\n                                       ng-click=\"ctrl.promptForVoteQuestion(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                            >\n                            Vote\n                            </md-button>\n                        </span>\n                    </div>\n\n                    <div ng-if=\"task.type == 'reflectionQuestion'\">\n                        <!--{{task}}-->\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id] && !task.formationPattern\">\n                            Completed <span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                        </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                            <md-button class=\"md-raised md-primary\"\n                                       target=\"_blank\"\n                                       ng-disabled=\"task.closedAt\"\n                                       aria-label=\"Review Question\"\n                                       ng-click=\"ctrl.promptForReviewQuestion(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                            > Review Question\n                            </md-button>\n                        </span>\n                    </div>\n\n                    <div ng-if=\"task.textResponse && !task.lang && !task.toEdit && !task.teamFormationMethod\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                {{ ctrl.currentUserSolutions[task.$id] | cmTruncate: 10 }}<span\n                                    ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                                <md-button class=\"md-icon-button md-primary small-icon\"\n                                           aria-label=\"Update response\"\n                                           ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-if=\"task.openedAt\"\n                                >\n                                    <md-icon md-svg-icon=\"create\"></md-icon>\n                                </md-button>\n                            </span>\n\n                            <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                    <md-button class=\"md-raised md-primary\"\n                                               aria-label=\"Submit response\"\n                                               ng-click=\"ctrl.promptForTextResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                               ng-disabled=\"task.closedAt\"\n                                    > Submit Response\n                                    </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.textResponse && task.lang && !task.teamFormationMethod\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                {{ ctrl.currentUserSolutions[task.$id] | cmTruncate: 10 }}<span\n                                    ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                                <md-button class=\"md-icon-button md-primary small-icon\"\n                                           aria-label=\"Update response\"\n                                           ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-if=\"task.openedAt\"\n                                >\n                                    <md-icon md-svg-icon=\"create\"></md-icon>\n                                </md-button>\n                            </span>\n\n                        <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                <md-button class=\"md-raised md-primary\"\n                                           aria-label=\"Submit response\"\n                                           ng-click=\"ctrl.promptForCodeResponse(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-disabled=\"task.closedAt\"\n                                >\n                                    Submit Code\n                                </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.linkPattern && !task.teamFormationMethod\">\n                            <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                                <a ng-href=\"{{ctrl.currentUserSolutions[task.$id]}}\" target=\"_blank\">Completed<span\n                                        ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span></a>\n                                <md-button class=\"md-icon-button md-primary small-icon\"\n                                           aria-label=\"Update link\"\n                                           ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                           ng-if=\"task.openedAt\"\n                                >\n                                    <md-icon md-svg-icon=\"create\"></md-icon>\n                                </md-button>\n                            </span>\n\n                            <span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                                    <md-button class=\"md-raised md-primary\"\n                                               aria-label=\"Submit link\"\n                                               ng-click=\"ctrl.promptForLink(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                               ng-disabled=\"task.closedAt\"\n                                    >\n                                        Submit Link\n                                    </md-button>\n                            </span>\n                    </div>\n\n                    <div ng-if=\"task.survey && !task.teamFormationMethod\">\n                        <span ng-if=\"ctrl.currentUserSolutions[task.$id]\">\n                            Completed\n                            <span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>\n                        </span>\n\n                        <md-button class=\"md-raised md-primary\"\n                                   aria-label=\"Submit survey\"\n                                   ng-click=\"ctrl.promptForSurvey(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\"\n                                   ng-disabled=\"task.closedAt\" ng-if=\"!ctrl.currentUserSolutions[task.$id]\">\n                            Start Survey\n                        </md-button>\n                    </div>\n\n                    <div ng-if=\"task.toEdit && !task.teamFormationMethod\">\n                        <div ng-if=\"ctrl.profile.user.school\">\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update_profile\"\n                                       ng-click=\"ctrl.editProfileInfo(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant)\"\n                                       ng-disabled=\"task.closedAt\">\n                                Update Profile\n                            </md-button>\n                        </div>\n\n                        <div ng-if=\"!ctrl.profile.user.school\">\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Enter_profile_info\"\n                                       ng-click=\"ctrl.editProfileInfo(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant)\"\n                                       ng-disabled=\"task.closedAt\">\n                                Update Profile\n                            </md-button>\n                        </div>\n                    </div>\n\n                    <span ng-if=\"task.type=='mentorAssignment'\">\n                        {{ctrl.solutions[ctrl.currentUserParticipant.$id][task.$id] | displayMentorship}}\n                    </span>\n                </td>\n                <!--team activity challenge button!\n                <td ng-if=\"ctrl.currentUserParticipant\">\n                    <md-button class=\"md-raised md-primary\" align=\"middle\"\n                               ng-href=\"#{{'viewIRAT' | urlFor:{'publicId': participant.$id} }}\">\n                        Start IRAT\n                    </md-button>\n                </td>\n                <td ng-if=\"ctrl.currentUserParticipant\">\n                    <md-button class=\"md-raised md-primary\" align=\"middle\"\n                               ng-click=\"ctrl.promptForTeamFormation(ctrl.event.$id, task.$id, task, ctrl.currentUserParticipant, ctrl.currentUserSolutions)\">\n                        Join Team\n                    </md-button>\n                </td>\n                <td ng-if=\"ctrl.currentUserParticipant\">\n                    <md-button class=\"md-raised md-primary\" align=\"middle\"\n                               ng-href=\"#{{'viewTRAT' | urlFor:{'publicId': participant.$id} }}\">\n                        Start TRAT\n                    </md-button>\n                </td>-->\n            </tr>\n\n            <tr ng-repeat=\"participant in ctrl.participantsView track by participant.$id\"\n                ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n\n                <th layout=\"row\" layout-align=\"start center\">\n                    <md-button class=\"name-button\" ng-href=\"#{{ 'profile' | urlFor:{'publicId': participant.$id} }}\">\n                        {{ participant.user.displayName }}\n                    </md-button>\n\n                    <span ng-if=\"ctrl.profile.$id == ctrl.event.owner.publicId && participant.$id != ctrl.profile.$id\">\n                            <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Delete\"\n                                       ng-click=\"ctrl.removeParticipant($event, ctrl.event, participant)\">\n                                <md-icon md-svg-icon=\"clear\"></md-icon>\n                            </md-button>\n                        </span>\n                </th>\n\n                <td ng-repeat=\"task in ctrl.visibleTasks track by task.$id\">\n                    <div ng-if=\"ctrl.progress[participant.$id][task.$id].completed && task.showProgress\">\n                        <!--<span ng-if=\"(!task.textResponse && !task.linkPattern) || !ctrl.isReviewSuperUser\">-->\n                        <!--Completed-->\n                        <!--</span>-->\n\n                        <span ng-if=\"task.showLinks\">\n                            <span ng-if=\"task.linkPattern\">\n                                <a ng-href=\"{{ctrl.solutions[participant.$id][task.$id]}}\"\n                                   target=\"_blank\"> Completed</a>\n                            </span>\n\n                            <span ng-if=\"task.textResponse && !task.lang && !task.linkPattern && !task.toEdit\">\n                                <md-menu>\n                                    <md-button ng-click=\"$mdOpenMenu()\">\n                                        {{ ctrl.solutions[participant.$id][task.$id] | cmTruncate: 10 }}\n                                    </md-button>\n\n                                    <md-menu-content>\n                                        <div style=\"white-space: pre-wrap;\">{{ ctrl.solutions[participant.$id][task.$id]}}</div>\n                                    </md-menu-content>\n                                </md-menu>\n                                <!--<md-tooltip ng-if=\"(ctrl.solutions[participant.$id][task.$id] | cmTruncated: 10).truncated\">-->\n                                <!--<div style=\"white-space: pre-wrap;\">{{ ctrl.solutions[participant.$id][task.$id]}}</div>-->\n                                <!--</md-tooltip>-->\n                            </span>\n\n                            <span ng-if=\"task.lang\">\n                                <md-button aria-label=\"viewCode\"\n                                           ng-click=\"ctrl.viewCodeResponse(task, ctrl.solutions[participant.$id][task.$id])\">\n                                    View Code\n                                </md-button>\n                            </span>\n\n                            <span ng-if=\"task.toEdit\">\n                                <div>{{ctrl.solutions[participant.$id][task.$id] | showSchool}}</div>\n                            </span>\n                        </span>\n\n                        <span ng-if=\"!task.showLinks\">\n                            <span ng-if=\"task.type=='formTeam' && ctrl.solutions[participant.$id][task.$id]\">\n                                {{ctrl.solutions[participant.$id][task.$id]}}\n                            </span>\n                            <span ng-if=\"task.type!='formTeam' && !task.coopSubmission && task.type!='mentorAssignment' && ctrl.solutions[participant.$id][task.$id]\">\n                                Completed\n                            </span>\n                        </span>\n\n                        <span ng-if=\"task.type=='mentorAssignment'\">\n                            {{ctrl.solutions[participant.$id][task.$id] | displayMentorship}}\n                            <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Update\"\n                                       ng-click=\"ctrl.reassignMentorPairing(task.taskFrom, task.$id, ctrl.solutions[participant.$id][task.$id], task.mentorAssignmentMethod)\"\n                                       ng-if=\"ctrl.profile.$id == ctrl.event.owner.publicId && participant.$id != ctrl.profile.$id\">\n                                <md-icon md-svg-icon=\"loop\"></md-icon>\n                            </md-button>\n                        </span>\n                    </div>\n\n                    <div>\n                        <span ng-if=\"task.coopSubmission && task.type!='formTeam'\">\n                            <label ng-show=\"ctrl.showTeamComplete(participant.$id, task.$id,ctrl.event.$id, task)\"><div ng-if=\"ctrl.coopTeam[task.teamFormationRef][ctrl.teamId[task.teamFormationRef][participant.$id]].status[0]\">{{ctrl.solutions[participant.$id][task.teamFormationRef]}} : {{ctrl.coopTeam[task.teamFormationRef][ctrl.teamId[task.teamFormationRef][participant.$id]].status[1]}} / {{ctrl.coopTeam[task.teamFormationRef][ctrl.teamId[task.teamFormationRef][participant.$id]].status[0]}}</div></label>\n                        </span>\n                    </div>\n                </td>\n            </tr>\n\n            <tr ng-if=\"ctrl.participantsView | spfEmpty\">\n                <td>No<span ng-if=\"ctrl.ctrl.currentUserParticipant\"> other</span> participants</td>\n            </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOptions\" class=\"md-padding\"></clm-pager>\n</div>\n";eventTableRankTmpl="<div ng-if=\"ctrl.loading\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n<div ng-if=\"!ctrl.loading\">\n    <md-content class=\"md-padding\">\n        <button ng-show=\"ctrl.event.owner.publicId==ctrl.profile.$id\" type=\"submit\" ng-click=\"ctrl.updateAllParticipantUserProfiles()\">Update All User Achievements</button>\n        <table class=\"events ranking\">\n            <thead>\n                <tr ng-class=\"{'reversed': ctrl.orderOpts[0].reversed, secondaryReversed: ctrl.orderOpts[1].reversed}\">\n                    <th></th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == '$user.displayName', secondaryOrderer: ctrl.orderOpts[1].key == '$user.displayName'}\">\n                        <md-button ng-click=\"ctrl.orderBy('$user.displayName')\">Participants</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == '$user.school.name', secondaryOrderer: ctrl.orderOpts[1].key == '$user.school.name'}\" ng-if=\"ctrl.event.schoolEvent\">\n                        <md-button ng-click=\"ctrl.orderBy('$user.school.name')\">School</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == '$rankInSchool', secondaryOrderer: ctrl.orderOpts[1].key == '$rankInSchool'}\" ng-if=\"ctrl.event.schoolEvent\">\n                        <md-button ng-click=\"ctrl.orderBy('$rankInSchool')\">Rank in School</md-button>\n                    </th>\n                    <th ng-class=\"{orderer: ctrl.orderOpts[0].key == '$total', secondaryOrderer: ctrl.orderOpts[1].key == '$total'}\">\n                        <md-button ng-click=\"ctrl.orderBy('$total')\">Total</md-button>\n                    </th>\n                    <!-- add from rankedServices list -->\n                    <th ng-repeat=\"service in ctrl.rankedServices\" ng-class=\"{orderer: ctrl.orderOpts[0].key == service.id, secondaryOrderer: ctrl.orderOpts[1].key == service.id}\">\n                        <md-button ng-click=\"ctrl.orderBy(service.id)\">{{service.name}}</md-button>\n                    </th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <th colspan=\"5\" ng-if=\"(ctrl.rankingView|spfEmpty)\">\n                        No participants\n                    </th>\n                </tr>\n\n                <tr ng-repeat=\"participant in ctrl.rankingView\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <th>\n                        {{$index+1}}\n                    </th>\n                    <th>\n                        <!-- spfToArray adds the $$hashKey property to every element in the object -->\n                        <md-button class=\"name-button\"\n                            ng-href=\"#{{ 'profile' | urlFor:{'publicId': participant.$id} }}\"\n                            ng-attr-aria-label=\"profile of {{participant.$user.displayName}}\"\n                        >\n                            <span ng-if=\"participant.$id != ctrl.profile.$id\">{{ participant.$user.displayName }}</span>\n                            <span ng-if=\"participant.$id == ctrl.profile.$id\">Yourself</span>\n                        </md-button>\n                    </th>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ participant.$user.school.name }}</td>\n                    <td ng-if=\"ctrl.event.schoolEvent\">{{ participant.$rankInSchool || 'N/A'}}</td>\n                    <td>{{ participant.$total }}</td>\n\n                    <td ng-repeat=\"service in ctrl.rankedServices\">{{ participant[service.id] }}</td>\n                </tr>\n\n            </tbody>\n        </table>\n    </md-content>\n\n</div>\n";eventTableResultsTmpl="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<div ng-if=\"ctrl.loading || ctrl.loadingTeams\" layout=\"row\" layout-align=\"space-around\" class=\"md-padding\">\n    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n</div>\n\n<div ng-if=\"!ctrl.loading && !ctrl.selected.teamFormationRef && ctrl.selected.type!='voteQuestions'\">\n\n    <md-content class=\"md-padding\">\n        <table class=\"events tasks\">\n            <thead>\n            <tr ng-class=\"{'reversed': ctrl.orderOptions.reversed}\">\n                <th rowspan=\"4\" ng-class=\"{orderer: !ctrl.orderOptions.key}\">\n                    <md-button ng-click=\"ctrl.orderBy()\">Participants</md-button>\n                </th>\n                <th rowspan=\"8\">\n                    Submission\n                    {{ctrl.taskCompletion[ctrl.selected.$id] | number: 0}} %\n                </th>\n                <th rowspan=\"8\" ng-class=\"{orderer: ctrl.orderOptions.key == ctrl.selected.$id}\">\n                    <md-button ng-click=\"ctrl.orderBy(ctrl.selected.$id)\">Allocated Points</md-button>\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n\n            <tr ng-repeat=\"participant in ctrl.participantsView track by participant.$id\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                <th layout=\"row\" layout-align=\"start center\" ng-if=\"ctrl.currentUserParticipant.$id === participant.$id\">\n                    <md-button class=\"name-button\" ng-href=\"#{{ 'profile' | urlFor:{'publicId': ctrl.currentUserParticipant.$id} }}\">\n                        Yourself\n                    </md-button>\n\n                    <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Update\" ng-click=\"ctrl.update(ctrl.event, ctrl.tasks, ctrl.currentUserSolutions, ctrl.profile)\">\n                        <md-icon md-svg-icon=\"loop\"></md-icon>\n                    </md-button>\n                </th>\n\n                <th layout=\"row\" layout-align=\"start center\" ng-if=\"ctrl.currentUserParticipant.$id !== participant.$id\">\n                    <md-button class=\"name-button\" ng-href=\"#{{ 'profile' | urlFor:{'publicId': participant.$id} }}\">\n                        {{ participant.user.displayName }}\n                    </md-button>\n\n                    <span ng-if=\"ctrl.profile.$id == ctrl.event.owner.publicId &amp;&amp; participant.$id != ctrl.profile.$id\">\n                            <md-button class=\"md-icon-button md-primary small-icon\" aria-label=\"Delete\" ng-click=\"ctrl.removeParticipant($event, ctrl.event, participant)\">\n                                <md-icon md-svg-icon=\"clear\"></md-icon>\n                            </md-button>\n                        </span>\n                </th>\n\n                <td>\n                    <!--<div ng-if=\"ctrl.selected.serviceId\">-->\n                            <!--<span ng-if=\"ctrl.currentUserSolutions[task.$id]\">-->\n                                <!--Completed<span ng-if=\"!ctrl.currentUserProgress[task.$id].completed\"></span>-->\n                            <!--</span>-->\n                        <!--<span ng-if=\"!ctrl.currentUserSolutions[task.$id]\">-->\n                                <!--<md-button class=\"md-raised md-primary\"-->\n                                           <!--ng-href=\"{{ctrl.startLink(task, ctrl.profile)}}\"-->\n                                           <!--target=\"_blank\"-->\n                                           <!--ng-disabled=\"task.closedAt\"-->\n                                           <!--aria-label=\"Start challenge\"-->\n                                <!--&gt;-->\n                                    <!--<span ng-switch on=\"ctrl.mustRegister(task, ctrl.profile)\">-->\n                                        <!--<span ng-switch-when=\"true\">Register</span>-->\n                                        <!--<span ng-switch-default>Start challenge</span>-->\n                                    <!--</span>-->\n                                <!--</md-button>-->\n                            <!--</span>-->\n                    <!--</div>-->\n                    \n                    <div ng-if=\"ctrl.selected.mcqQuestions && ctrl.selected.startTRAT\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"View MCQ\"\n                                       ng-click=\"ctrl.viewMultipleChoiceResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                                       ng-disabled='true'\n                            >Currently Unavailable\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n                    \n                    <div ng-if=\"ctrl.selected.mcqQuestions && !ctrl.selected.startTRAT\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"View MCQ\"\n                                       ng-click=\"ctrl.viewMultipleChoiceResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >View Submission\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n\n                    <div ng-if=\"ctrl.selected.textResponse && !ctrl.selected.lang\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            {{ ctrl.solutions[participant.$id][ctrl.selected.$id] | cmTruncate: 140 }}<br>\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update response\"\n                                       ng-click=\"ctrl.viewTextResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >View Response\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n\n                    <div ng-if=\"ctrl.selected.textResponse && ctrl.selected.lang\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            {{ ctrl.solutions[participant.$id][ctrl.selected.$id] | cmTruncate: 140 }}<br>\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update response\"\n                                       ng-click=\"ctrl.viewCodeResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n                            >View Code\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            No Submission\n                        </span>\n                    </div>\n\n                    <div ng-if=\"ctrl.selected.linkPattern\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                            <a href={{ctrl.solutions[participant.$id][ctrl.selected.$id]}} target=\"_blank\">\n                                {{ ctrl.solutions[participant.$id][ctrl.selected.$id] | cmTruncate: 50 }}\n                            </a>\n                            <br>\n                            <md-button class=\"md-raised md-primary\"\n                                       aria-label=\"Update link\"\n                                       ng-click=\"ctrl.viewLink(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.solutions[participant.$id])\"\n                                       ng-if=\"ctrl.selected.openedAt\"\n\n                            >\n                                View Link\n                            </md-button>\n                        </span>\n\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                                No Submission\n                        </span>\n                    </div>\n                    <div ng-if=\"ctrl.selected.type=='reflectionQuestion'\">\n                        <span ng-if=\"ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                                {{ctrl.solutions[participant.$id][ctrl.selected.$id]}}\n                        </span>\n                        <span ng-if=\"!ctrl.solutions[participant.$id][ctrl.selected.$id]\">\n                                No Submission\n                        </span>\n                    </div>\n                </td>\n                <td>\n                    <!--{{ctrl.scores[participant.$id][ctrl.selected.$id]}}-->\n                    <md-input-container flex ng-disabled=\"ctrl.selected.mcqQuestions\">\n                        <label for=\"edit-task-score\">Score</label>\n                        <input ng-disabled=\"ctrl.selected.mcqQuestions\" type=\"number\" name=\"editTaskScore\" id=\"edit-task-score\"\n                               ng-model=\"ctrl.scores[participant.$id][ctrl.selected.$id]\"\n                               min=\"0\" step=\"1\"\n                               placeholder=\"Allocate task score\"\n                        />\n                        <div ng-messages=\"editTask.editTaskScore.$error\" ng-if=\"editTask.editTaskScore.$error\">\n                            <div ng-message=\"number\">The score should be a positive number.</div>\n                        </div>\n                    </md-input-container>\n                    <md-button ng-show=\"!ctrl.selected.mcqQuestions\" class=\"md-raised md-primary\"\n                               aria-label=\"Save Score\"\n                               ng-click=\"ctrl.saveAllocatedPoints(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, participant, ctrl.scores[participant.$id][ctrl.selected.$id])\"\n                    >Save\n                    </md-button>\n                </td>\n            </tr>\n\n            <tr ng-if=\"ctrl.participantsView | spfEmpty\">\n                <td>No<span ng-if=\"ctrl.ctrl.currentUserParticipant\"> other</span> participants</td>\n            </tr>\n            </tbody>\n        </table>\n    </md-content>\n\n    <clm-pager options=\"ctrl.pagerOptions\" class=\"md-padding\"></clm-pager>\n</div>\n\n<div ng-if=\"!ctrl.loading && ctrl.selected.teamFormationRef && !ctrl.loadingTeams\">\n    <md-content class=\"md-padding\">\n        <md-button class=\"md-raised md-primary\"\n                   aria-label=\"View MCQ\"\n                   ng-click=\"ctrl.viewMultipleChoiceResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, team.teamLeader, ctrl.solutions[team.teamLeader])\"\n                   ng-if=\"ctrl.selected.openedAt && ctrl.selected.mcqQuestions\"\n        >Show Model Answer\n        </md-button>\n        <table class=\"events tasks\">\n            <thead>\n            <tr>\n                <th rowspan=\"4\">\n                    <md-button>Teams</md-button>\n                </th>\n                <th rowspan=\"8\">\n                    <md-button>Members</md-button>\n                </th>\n                <th rowspan=\"8\">\n                    <md-button>Submission</md-button>\n                </th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr ng-repeat=\"team in ctrl.teams | orderBy:'-score'\" ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                <th rowspan=\"team.currentSize\" layout-align=\"center center\">\n                    <md-button disbaled>Team {{team.number}}</md-button>\n                </th>\n                <td layout-align=\"start center\">\n                    <ul>\n                        <li ng-repeat=\"item in team\" ng-if=\"item.displayName\">\n                            {{item.displayName}}\n                        </li>\n                    </ul>\n                </td>\n                <td>\n                    <div ng-if=\"ctrl.selected.mcqQuestions\">{{ctrl.scores[team.teamLeader][ctrl.selected.$id]}} / {{ctrl.selected.numQns}}</div>\n                    <md-button class=\"md-raised md-primary\" ng-if=\"ctrl.selected.type=='textResponse'\" ng-click=\"ctrl.viewTextResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, team[team.teamLeader], ctrl.solutions[team.teamLeader])\">View Submission</md-button>\n                    <md-button class=\"md-raised md-primary\" ng-if=\"ctrl.selected.type=='linkPattern'\" ng-click=\"ctrl.viewLink(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, team[team.teamLeader], ctrl.solutions[team.teamLeader])\">View Submission</md-button>\n                    <md-button class=\"md-raised md-primary\" ng-if=\"ctrl.selected.type=='code'\" ng-click=\"ctrl.viewCodeResponse(ctrl.event.$id, ctrl.selected.$id, ctrl.selected, team[team.teamLeader], ctrl.solutions[team.teamLeader])\">View Submission</md-button>\n                </td>\n            </tr>\n            <tr ng-if=\"ctrl.participantsView | spfEmpty\">\n                <td>No<span ng-if=\"ctrl.ctrl.currentUserParticipant\"> other</span> participants</td>\n            </tr>\n            </tbody>\n        </table>\n    </md-content>\n</div>\n\n<div ng-if=\"ctrl.selected.type=='voteQuestions'\">\n    <!--<div ng-repeat=\"p in ctrl.participants\">-->\n        <!--{{ctrl.solutions[p.$id][ctrl.selected.$id]}}<br>-->\n    <!--</div>-->\n    <md-card ng-repeat=\"team in ctrl.teams\">\n        <md-card-title layout=\"row\">\n            <md-card-title-text>\n                <span class=\"md-title\">Team {{team.number}} Questions</span>\n                <span class=\"md-subhead\">Rank: {{team.qnState + 1}}</span>\n                <span class=\"md-subhead\">Asked By: {{team.questions[team.qnState].askedBy}}</span>\n            </md-card-title-text>\n            <md-card-actions layout=\"row\" layout-align=\"end center\">\n                <md-button class=\"md-icon-button launch\" aria-label=\"Favorite\" ng-show=\"team.qnState > 0\" ng-click=\"team.qnState = team.qnState - 1\">\n                    <md-icon style=\"font-size: 35px\">undo</md-icon>\n                </md-button>\n                <md-button class=\"md-icon-button launch\" aria-label=\"Favorite\" ng-show=\"team.qnState < team.questions.length-1\" ng-click=\"team.qnState = team.qnState + 1\">\n                    <md-icon style=\"font-size: 35px\">redo</md-icon>\n                </md-button>\n            </md-card-actions>\n        </md-card-title>\n        <md-divider></md-divider>\n        <md-card-content layout=\"row\">\n            <p style=\"max-width: 650px; white-space: pre-wrap; word-wrap: break-word; overflow: auto; font-size: 15px;\" layout-wrap>\n                {{team.questions[team.qnState].question}}\n            </p>\n        </md-card-content>\n    </md-card>\n</div>";eventTaskFormTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"editTask\" ng-submit=\"ctrl.saveTask(ctrl.event, ctrl.taskId, ctrl.task, ctrl.taskType, ctrl.isOpen, editTask)\">\n        <div>\n            <div layout=\"row\">\n                <md-input-container flex>\n                    <label for=\"edit-task-name\">Name</label>\n                    <input type=\"text\" name=\"editTaskTitle\" id=\"edit-task-name\"\n\n                        ng-model=\"ctrl.task.title\"\n                        required=\"required\" ng-minLength=\"3\" md-maxLength=\"30\"\n                        placeholder=\"Challenge name\"\n\n                    />\n\n                    <div ng-messages=\"editTask.editTaskTitle.$error\">\n                        <div ng-message=\"required\">A challenge needs a name.</div>\n                        <div ng-message=\"minlength\">The name is too short.</div>\n                        <div ng-message=\"md-maxlength\">The name is too long.</div>\n                    </div>\n                </md-input-container>\n                <md-input-container flex>\n                    <label for=\"edit-task-priority\">Priority</label>\n                    <input type=\"number\" name=\"editTaskPriority\" id=\"edit-task-priority\"\n\n                        ng-model=\"ctrl.task.priority\"\n                        min=\"0\" step=\"1\"\n                        placeholer=\"Challenge priority\"\n\n                    />\n                    <div ng-messages=\"editTask.editTaskPriority.$error\">\n                        <div ng-message=\"number\">The priority should be a positive number.</div>\n                    </div>\n                </md-input-container>\n            </div>\n        </div>\n\n        <div>\n            <md-input-container class=\"md-block\" flex>\n                <label for=\"edit-task-desc\">Description</label>\n                <textarea name=\"editTaskDesc\" id=\"edit-task-desc\"\n                    ng-model=\"ctrl.task.description\"\n                    required=\"required\" ng-minLength=\"3\" md-maxLength=\"200\"\n                    placeholder=\"Challenge description\"\n                >{{ctrl.task.description}}</textarea>\n\n\n                <div ng-messages=\"editTask.editTaskDesc.$error\">\n                    <div ng-message=\"required\">A challenge needs a description.</div>\n                    <div ng-message=\"minlength\">The description is too short.</div>\n                    <div ng-message=\"md-maxlength\">The description is too long.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div>\n            <md-input-container>\n                <!--pattern=\"^((https|http)?://.+|#/).+$\"-->\n                <label for=\"edit-task-link\">Help Link</label>\n                <input type=\"text\" name=\"editTaskLink\" id=\"edit-task-link\"\n\n                    ng-model=\"ctrl.task.link\"\n                    pattern =\"^(((https|http)://|www.).+|#/).+$\"\n                    placeholder=\"URL to a challenge help page\"\n\n                />\n                <div ng-messages=\"editTask.editTaskLink.$error\">\n                    <div ng-message=\"pattern\">Wrong format for an absolute or relative URL. Enter URL that starts with https://, http:// or www.</div>\n                </div>\n            </md-input-container>\n        </div>\n        <div>\n            <h3>Challenge Options</h3>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.isOpen\" aria-label=\"closed?\">\n                    <span ng-hide=\"!ctrl.isOpen\">Challenge Open</span>\n                    <span ng-hide=\"ctrl.isOpen\">Challenge Close</span>\n                </md-switch>\n\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.hidden\" aria-label=\"hidden?\">\n                    <span ng-hide=\"!ctrl.task.hidden\">Challenge Hidden</span>\n                    <span ng-hide=\"ctrl.task.hidden\">Challenge Shown</span>\n                </md-switch>\n\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.archived\" aria-label=\"Archived?\">\n                    <span ng-hide=\"!ctrl.task.archived\">Challenge Archive</span>\n                    <span ng-hide=\"ctrl.task.archived\">Challenge Available</span>\n                </md-switch>\n\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.showProgress\" aria-label=\"show progress?\">\n                    <span ng-hide=\"!ctrl.task.showProgress\">Participants' Progress Shown to All</span>\n                    <span ng-hide=\"ctrl.task.showProgress\">Participants' Progress Hidden to All</span>\n                </md-switch>\n\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.task.showLinks\" aria-label=\"closed?\">\n                    <span ng-hide=\"!ctrl.task.showLinks\">Participants' Solutions Shown to All</span>\n                    <span ng-hide=\"ctrl.task.showLinks\">Participants' Solutions Hidden to All</span>\n                </md-switch>\n        </div>\n\n        <div>\n            <h3>Task Type</h3>\n            <md-radio-group ng-model=\"ctrl.taskType\">\n                <table>\n                    <tr>\n                        <td style=' padding-bottom:50px;'>\n                            <md-radio-button value=\"service\" ng-disabled='ctrl.edit' class=\"md-primary\">Service / Badge / Problem</md-radio-button>\n                            <md-radio-button value=\"linkPattern\" ng-disabled='ctrl.edit' class=\"md-primary\">Link Pattern</md-radio-button>\n                            <md-radio-button value=\"textResponse\" ng-disabled='ctrl.edit' class=\"md-primary\">Text Response</md-radio-button>\n                            <md-radio-button ng-disabled='ctrl.edit' value=\"multipleChoice\" class=\"md-primary\">Multiple Choice</md-radio-button>\n\n                        </td>\n                        <td style='padding-left:30px; padding-bottom:50px;'>\n                            <md-radio-button value=\"code\" ng-disabled='ctrl.edit' class=\"md-primary\">Code<md-tooltip md-direction=\"right\">Submit code in a native code editor</md-tooltip></md-radio-button>\n                            <md-radio-button value=\"profileEdit\" ng-disabled='ctrl.edit' class=\"md-primary\">Profile Update</md-radio-button>\n                            <!--<md-radio-button ng-disabled=\"!ctrl.enableBeta\" value=\"journalling\" class=\"md-primary\">Journalling*</md-radio-button>-->\n                            <md-radio-button  ng-disabled='ctrl.edit' value=\"survey\" class=\"md-primary\">Survey</md-radio-button>\n                            <md-radio-button ng-disabled='ctrl.edit' value=\"teamActivity\" class=\"md-primary\">Team Activity</md-radio-button>\n                        </td>\n                    </tr>\n                </table>\n            </md-radio-group>\n        </div>\n        <div layout=\"row\" ng-if=\"ctrl.taskType == 'service'\">\n            <md-input-container flex layout=\"column\">\n                <md-select flex name=\"editTaskServiceId\"\n                           ng-model=\"ctrl.task.serviceId\" required placeholder=\"Select a Service\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ['codeSchool', 'codeCombat', 'treeHouse', 'singPath']\">\n                        {{opt}}\n                    </md-option>\n                </md-select>\n                <div ng-messages=\"editTask.editTaskServiceId.$error\">\n                    <div ng-message=\"required\">A challenge needs a service id.</div>\n                </div>\n            </md-input-container>\n            <md-input-container flex layout=\"column\" ng-if=\"ctrl.task.serviceId &amp;&amp; ctrl.task.serviceId != 'singPath'\">\n                <md-select flex name=\"editTaskBadge\"\n                           ng-model=\"ctrl.task.badge\"\n                           placeholder=\"Select a badge (optional)\"\n                >\n                    <md-option ng-value=\"badge\" ng-repeat=\"badge in ctrl.badges[ctrl.task.serviceId]\">\n                        {{badge.name}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n        </div>\n\n        <div layout=\"row\" ng-if=\"ctrl.task.serviceId == 'singPath'\">\n            <md-input-container flex layout=\"column\">\n                <md-select flex name=\"editTaskSingPathPath\"\n                           ng-model=\"ctrl.task.singPathProblem.path\"\n                           placeholder=\"Select a Path (optional)\"\n                >\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.singPath.paths\">\n                        {{opt.title}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n            <md-input-container flex layout=\"column\" ng-if=\"ctrl.task.singPathProblem.path\">\n                <md-select flex name=\"editTaskSingPathLevel\"\n                           ng-model=\"ctrl.task.singPathProblem.level\"\n                           required\n                           md-on-open=\"ctrl.loadLevels(ctrl.task.singPathProblem)\"\n                           placeholder=\"Select a Level\"\n                >\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.singPath.levels\">\n                        {{opt.title}}\n                    </md-option>\n                </md-select>\n                <div ng-messages=\"editTask.editTaskSingPathLevel.$error\">\n                    <div ng-message=\"required\">A challenge needs a service id.</div>\n                </div>\n            </md-input-container>\n            <md-input-container flex layout=\"column\" ng-if=\"ctrl.task.singPathProblem.level\">\n                <md-select flex name=\"editTaskSingPathProblem\"\n                           ng-model=\"ctrl.task.singPathProblem.problem\"\n                           required\n                           md-on-open=\"ctrl.loadProblems(ctrl.task.singPathProblem)\"\n                           placeholder=\"Select a Problem\"\n                >\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.singPath.problems\">\n                        {{opt.title}}\n                    </md-option>\n                </md-select>\n                <div ng-messages=\"editTask.editTaskSingPathProblem.$error\">\n                    <div ng-message=\"required\">A challenge needs a service id.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'linkPattern'\">\n            <md-input-container>\n                <label for=\"edit-link-pattern\">Link Pattern for Link Submissions</label>\n                <input type=\"text\" name=\"editTaskLink\" id=\"edit-link-pattern\"\n                    ng-value=\"ctrl.task.linkPattern\"\n                    ng-model=\"ctrl.task.linkPattern\"\n                    required=\"true\"\n                    placeholer=\"Pattern\"\n                />\n                <span><font color=\"red\" size=\"2\">E.g. Only google doc submission, link pattern is: \"https://docs.google.com/\"</font></span>\n\n                <div ng-messages=\"editTask.editTaskLink.$error\">\n                    <div ng-message=\"required\">Required.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n        <div ng-if=\"ctrl.taskType == 'textResponse'\">\n            <md-input-container>\n\n                <label for=\"edit-text-response\">Question</label>\n                <textarea name=\"editTextResponse\" id=\"edit-text-response\"\n                    ng-model=\"ctrl.task.textResponse\"\n                    required\n                    placeholder=\"Question\"\n                    rows=\"2\" md-select-on-focus\n                ></textarea>\n\n                <div ng-messages=\"editTask.editTextResponse.$error\">\n                    <div ng-message=\"required\">Required.</div>\n                </div>\n            </md-input-container>\n        </div>\n\n\n        <div ng-if=\"ctrl.taskType == 'code'\">\n            <md-input-container>\n                <label for=\"edit-text-response\">Question</label>\n                <textarea name=\"editCodeQuestion\" id=\"edit-code-question\"\n                       ng-model=\"ctrl.task.textResponse\"\n                       required\n                       placeholder=\"Question\"\n                       rows=\"2\" md-select-on-focus\n                ></textarea>\n\n                <div ng-messages=\"editTask.editCodeQuestion.$error\">\n                    <div ng-message=\"required\">Required.</div>\n                </div>\n            </md-input-container>\n            <md-input-container flex layout=\"column\">\n                <md-select flex name=\"editCodeLang\"\n                           ng-model=\"ctrl.task.lang\" required placeholder=\"Select a Language\">\n                    <md-option ng-value=\"opt\" ng-repeat=\"opt in ['Java', 'Javascript', 'HTML', 'Python']\">\n                        {{opt}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n        </div>\n\n        <!--<div ng-if=\"ctrl.taskType == 'journalling'\">-->\n            <!--<md-input-container>-->\n                <!--Journalling-->\n            <!--</md-input-container>-->\n        <!--</div>-->\n\n        <div ng-if=\"ctrl.taskType == 'profileEdit'\">\n            Select fields for participants to edit:\n            <md-list  ng-repeat=\"metaData in ['Year of Birth', 'School']\">\n                <md-checkbox ng-checked=\"ctrl.exists(metaData, ctrl.selectedMetaData)\" ng-click=\"ctrl.toggle(metaData, ctrl.selectedMetaData)\">\n                    {{metaData}}</br>\n                </md-checkbox>\n            </md-list>\n        </div>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <!--TODO: 1. Create continue button controller to route to other views depending on challenge type-->\n\n            <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"editTask.$invalid || !ctrl.taskType ||ctrl.savingTask\">{{ ctrl.challengeRouteProvider(ctrl.taskType, ctrl.task, ctrl.isOpen)}}</md-button>\n            <md-button type=\"button\" class=\"md-accent\" ng-click=\"ctrl.discardChanges($event)\">Back</md-button>\n\n        </div>\n    </form>\n</md-content>\n";eventTmpl="<md-content flex class=\"md-padding\">\n    <h3>\n        {{ctrl.event.message.comment}}\n    </h3>\n    <div ng-hide=\"ctrl.profile.joinedEvents[ctrl.event.$id]\">\n        Click +JOIN from the menu above to join this event. \n        <span ng-if=\"ctrl.event.message.password\">\n            The password is <b>{{ctrl.event.message.password}}</b>.\n        </span>\n    </div>\n    <!-- Users must finish registering before joining events -->\n    <md-content ng-if=\"ctrl.currentUser &amp;&amp; !ctrl.profile\" layout-padding>\n        <md-divider></md-divider>\n        <p>To join this event, you first need to finish registering:</p>\n\n        <form name=\"registerForm\" ng-submit=\"ctrl.register(ctrl.currentUser, registerForm)\">\n            <spf-sign-form current-user=\"ctrl.currentUser\"></spf-sign-form>\n\n            <div layout=\"row\" layout-align=\"center center\">\n                <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"registerForm.$invalid\">\n                    Save\n                </md-button>\n            </div>\n        </form>\n    </md-content>\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\" md-selected=\"1\">\n\n        <md-tab label=\"Ranking\">\n            <md-content layout-padding>\n                <clm-event-rank-table\n                    event=\"ctrl.event\"\n                    profile=\"ctrl.profile\"\n                    assistants=\"ctrl.asstArr\"\n                ></clm-event-rank-table>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Challenges\" ng-disabled=\"!ctrl.participants\">\n            <md-content layout-padding>\n                <clm-event-table\n                    ng-if=\"ctrl.canView\"\n                    event=\"ctrl.event\"\n                    participants=\"ctrl.participants\"\n                    tasks=\"ctrl.tasks\"\n                    progress=\"ctrl.progress\"\n                    solutions=\"ctrl.solutions\"\n                    profile=\"ctrl.profile\"\n                >\n                </clm-event-table>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Results\" ng-if=\"ctrl.participants && ctrl.isReviewSuperUser\">\n            <md-content layout-padding>\n                <md-switch class=\"md-primary\" ng-model=\"ctrl.viewArchived\" aria-label=\"ViewArchived?\">\n                    View archived challenges\n                </md-switch>\n                <md-input-container flex layout=\"column\">\n                    <md-select flex name=\"selectChallengeResult\"\n                               ng-model=\"ctrl.selected\" required placeholder=\"Select a challenge to view results\" ng-change=\"ctrl.loadSolutions()\">\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"task.startIRAT && !task.formationPattern && !task.survey && (!task.archived || ctrl.viewArchived)\">\n                            {{task.title}} (IRAT)\n                        </md-option>\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"task.startTRAT && !task.formationPattern && !task.survey && (!task.archived || ctrl.viewArchived)\">\n                            {{task.title}} (TRAT)\n                        </md-option>\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"task.type=='voteQuestions'\">\n                            {{task.title}} (Voted Cards)\n                        </md-option>\n                        <!--<md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"task.type=='reflectionQuestion'\">-->\n                            <!--{{task.title}} (Reflection Cards)-->\n                        <!--</md-option>-->\n                        <md-option ng-value=\"task\" ng-repeat=\"task in ctrl.tasks\" ng-if=\"!task.startTRAT && !task.startIRAT && !task.formationPattern && !task.survey && (!task.archived || ctrl.viewArchived) && !task.teamFormationParameter\">\n                            {{task.title}}\n                        </md-option>\n                    </md-select>\n                </md-input-container>\n                <div ng-if=\"ctrl.selected\">\n                    <div ng-if=\"!ctrl.loadingSolutions\">\n                        <h2 align=\"center\">Showing Results for {{ctrl.selected.title}}</h2>\n                        <div align=\"center\">Description: {{ctrl.selected.description}}</div></br>\n                        <div ng-if=\"ctrl.selected.textResponse\" align=\"center\">Question: {{ctrl.selected.textResponse}}</div>\n                        </br></br>\n                        Event Answers:\n                        <md-content layout-padding>\n                            <clm-event-results-table\n                                    ng-if=\"ctrl.canView\"\n                                    event=\"ctrl.event\"\n                                    participants=\"ctrl.participants\"\n                                    tasks=\"ctrl.tasks\"\n                                    progress=\"ctrl.progress\"\n                                    solutions=\"ctrl.solutions\"\n                                    profile=\"ctrl.profile\"\n                                    selected=\"ctrl.selected\"\n                                    scores=\"ctrl.scores\"\n                                    teams=\"ctrl.teams\"\n                            >\n                            </clm-event-results-table>\n                        </md-content>\n                    </div>\n                    <div ng-if=\"ctrl.loadingSolutions\">\n                        Loading solutions...\n                    </div>\n                </div>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Submissions\" ng-if=\"ctrl.hasSubmissions\">\n            <md-content>\n                Search for Submissions by Challenge Title:\n                <md-input-container>\n                    <input ng-model=\"ctrl.taskQuery\" ng-change=\"ctrl.filterTaskSearch()\">\n                </md-input-container>\n                <md-list>\n                    <md-list-item class='md-4-line' ng-repeat=\"task in ctrl.filteredTasks | orderBy:['-closedAt', '-openedAt']\" ng-if=\"ctrl.solutions[ctrl.profile.$id][task.$id] && !task.survey && !task.toEdit && task.type!='formTeam' && task.type!='mentorAssignment'\" ng-click=\"ctrl.submissionRouter(ctrl.event.$id, task.$id, task, ctrl.participant, ctrl.solutions[ctrl.profile.$id])\">\n                        <div flex>\n                            <b>{{task.title}}</b>\n                            <small>Last edited at: {{task.openedAt || task.closedAt | date}}</small><br>\n                            <a ng-if=\"task.link\" href={{task.link}} target=\"_blank\">Help link</a><br>\n                            {{task.description}}<br>\n                            <i>{{task.textResponse}}</i>\n                        </div>\n                        <!--<div layout=\"column\" layout-align=\"center center\">-->\n                            <!--<md-button class=\"material-icons\" ng-click=\"ctrl.submissionRouter(ctrl.event.$id, task.$id, task, ctrl.participant, ctrl.solutions[ctrl.profile.$id])\">visibility-->\n                                <!--<md-tooltip>View Submission</md-tooltip>-->\n                            <!--</md-button>-->\n                        <!--</div>-->\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n\n</md-content>";listTmpl="<md-content flex class=\"md-padding\">\n    <md-tabs md-dynamic-height=\"true\" md-border-bottom=\"true\" md-selected=\"0\">\n        <md-tab label=\"Featured Events\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.events.length }} featured event(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\"\n                                  ng-repeat=\"e in (ctrl.events | orderBy:'createdAt':true) track by e.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'oneEvent' | urlFor: {eventId: e.$id} }}\">{{e.title}}</a>\n                            </h3>\n                            <h4>created by {{e.owner.displayName}} ({{e.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Created Events\" ng-disabled=\"!ctrl.currentUser\" >\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.createdEvents.length }} created event(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\"\n                                  ng-repeat=\"e in (ctrl.createdEvents | orderBy:'createdAt':true) track by e.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'oneEvent' | urlFor: {eventId: e.$id} }}\">{{e.title}}</a>\n                            </h3>\n                            <h4>created by {{ctrl.currentUser.displayName}} ({{e.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n        <md-tab label=\"Joined Events\" ng-disabled=\"!ctrl.currentUser\">\n            <md-content>\n                <md-list class=\"path-list\">\n                    <md-subheader class=\"md-no-sticky\">{{ ctrl.joinedEvents.length }} joined event(s)</md-subheader>\n                    <md-list-item class=\"md-2-line\"\n                                  ng-repeat=\"e in (ctrl.joinedEvents | orderBy:'createdAt':true) track by e.$id\">\n                        <div class=\"md-list-item-text\">\n                            <h3>\n                                <a href=\"#{{ 'oneEvent' | urlFor: {eventId: e.$id} }}\">{{e.title}}</a>\n                            </h3>\n                            <h4>created by {{e.owner.displayName}} ({{e.createdAt|date}})</h4>\n                        </div>\n                        <md-divider ng-if=\"!$last\"></md-divider>\n                    </md-list-item>\n                </md-list>\n            </md-content>\n        </md-tab>\n\n    </md-tabs>\n\n</md-content>\n";newTmpl="<md-content class=\"md-padding\">\n    <form name=\"newEventForm\"\n          ng-submit=\"ctrl.save(ctrl.currentUser, ctrl.newEvent.data, ctrl.newEvent.password, ctrl.featureEvent, newEventForm)\">\n        <spf-sign-form current-user=\"ctrl.currentUser\" ng-if=\"ctrl.profileNeedsUpdate\"></spf-sign-form>\n\n        <md-input-container>\n            <label for=\"event-title\">Event Name</label>\n            <input name=\"eventTitle\" type=\"text\" id=\"event-title\" ng-model=\"ctrl.newEvent.data.title\" ng-minlength=\"3\"\n                   ng-maxlength=\"60\" required=\"true\"/>\n            <div ng-messages=\"newEventForm.eventTitle.$error\">\n                <div ng-message=\"required\">An event should have a name.</div>\n                <div ng-message=\"minlength\">An event name shouldn't be shorten than 3 characters.</div>\n                <div ng-message=\"maxlength\">An event name shouldn't be longer than 60 characters.</div>\n            </div>\n        </md-input-container>\n\n        <md-input-container>\n            <label for=\"event-pw\">Event Password</label>\n            <input name=\"eventPw\" type=\"text\" id=\"event-pw\" required ng-model=\"ctrl.newEvent.password\"/>\n            <div ng-messages=\"newEventForm.eventPw.$error\">\n                <div ng-message=\"required\">An event should have a password.</div>\n            </div>\n        </md-input-container>\n\n        <md-progress-circular ng-show=\"ctrl.creatingEvent\" md-mode=\"indeterminate\"\n                              style=\"margin: 16px auto\"></md-progress-circular>\n\n        <br><md-checkbox ng-model=\"featureEvent\" ng-checked=\"ctrl.featureEvent\" ng-click=\"ctrl.toggle()\"> Feature this event\n        </md-checkbox>\n\n        <div layout=\"row\" layout-align=\"center center\">\n            <md-button type=\"submit\" class=\"md-primary md-raised\" ng-disabled=\"newEventForm.$invalid || ctrl.creatingEvent\">\n                Create\n            </md-button>\n            <md-button type=\"reset\" ng-click=\"ctrl.reset(newEventForm)\"\n                       ng-disabled=\"ctrl.creatingEvent || newEventForm.$pristine\">Reset\n            </md-button>\n        </div>\n    </form>\n</md-content>\n";pagerTmpl="<md-content layout=\"row\" layout-align=\"start center\">\n    <span flex></span>\n\n    <span class=\"label md-padding\">Row per page: </span>\n    <md-select ng-model=\"ctrl.rowPerPage.value\" ng-change=\"ctrl.rowPerPage.set(ctrl.rowPerPage.value)\" aria-label=\"row per page\">\n        <md-option ng-value=\"opt\" ng-repeat=\"opt in ctrl.rowPerPage.options\">{{opt}}</md-option>\n    </md-select>\n\n    <span class=\"md-padding\">\n        {{ ctrl.options.range.start }} - {{ ctrl.options.range.end }} of\n        {{ ctrl.options.rowCount }}\n    </span>\n\n    <md-button title=\"First page\" aria-label=\"first page\" class=\"md-icon-button\" ng-click=\"ctrl.firstPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.start == 0\">\n        <md-icon md-svg-icon=\"arrow-back\"></md-icon>\n    </md-button>\n\n    <md-button title=\"Previous page\" aria-label=\"previous page\" class=\"md-icon-button\" ng-click=\"ctrl.prevPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.start == 0\">\n        <md-icon md-svg-icon=\"keyboard-arrow-left\"></md-icon>\n    </md-button>\n    \n    <md-button title=\"Next page\" aria-label=\"next page\" class=\"md-icon-button\" ng-click=\"ctrl.nextPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.end >= ctrl.options.rowCount\">\n        <md-icon md-svg-icon=\"keyboard-arrow-right\"></md-icon>\n    </md-button>\n\n    <md-button title=\"Last page\" aria-label=\"last page\" class=\"md-icon-button\" ng-click=\"ctrl.lastPage(ctrl.options)\" ng-disabled=\"ctrl.options.range.end >= ctrl.options.rowCount\">\n        <md-icon md-svg-icon=\"arrow-forward\"></md-icon>\n    </md-button>\n</md-content>";passwordTmpl="<md-dialog aria-label=\"Prompt password\">\n    <form name=\"promptPassword\" ng-submit=\"ctrl.join(ctrl.pw)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">Event password</md-subheader>\n            <div>\n                <md-input-container>\n                    <label for=\"edit-task-name\">Password</label>\n                    <input type=\"password\" name=\"editTaskTitle\" id=\"edit-task-name\"\n                        ng-model=\"ctrl.pw\"\n                        required=\"required\"\n                        placeholer=\"Event password\"\n                        />\n                </md-input-container>\n            </div>\n    \n            <div class=\"md-dialog-actions\">\n                <md-button type=\"submit\" class=\"md-raised md-primary\">\n                    Ok\n                </md-button>\n                <md-button ng-click=\"ctrl.closeDialog()\" type=\"button\" class=\"md-accent\">\n                    Cancel\n                </md-button>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>";linkTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" ng-class=\"{false:'enlarged-dialog', true:'link-dialog'}[!ctrl.review]\">\n    <form name=\"provideLinkForm\" ng-submit=\"ctrl.save(ctrl.solution)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <div ng-if=\"!ctrl.review\">\n                <p>{{ctrl.task.description}}</p>\n                <md-input-container class=\"md-block\" flex>\n                    <label for=\"edit-solution-link\">Solution Link</label>\n                    <input type=\"text\" name=\"linkSolution\" id=\"edit-solution-link\"\n                        ng-model=\"ctrl.solution\"\n                        required\n                        cm-contains=\"ctrl.task.linkPattern\"\n                        placeholder=\"URL to provide\"\n                    >\n                    <div ng-messages=\"provideLinkForm.linkSolution.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                        <div ng-message=\"cmContains\">Invalid pattern. Submit link that starts with <b>{{ctrl.task.linkPattern}}</b></div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div ng-if=\"ctrl.review\" layout-align=\"center\">\n                Submitted Link by {{ctrl.participant.user.displayName}}: <br>\n                <a href={{ctrl.solution}} target=\"_blank\">{{ctrl.solution}}</a>\n                <div class=\"box\" flex>\n                <iframe ng-src=\"{{ctrl.solution}}\" target=\"_parent\" width = \"800px\" height = \"700px\"></iframe>\n                </div>\n            </div>\n            <div class=\"md-dialog-actions\" align=\"center\">\n                <md-button type=\"submit\" class=\"md-primary md-raised\" ng-if=\"!ctrl.review\" ng-disabled=\"!provideLinkForm.$valid\">\n                    Save\n                </md-button>\n                <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>";responseTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"provideResponseForm\" ng-submit=\"ctrl.save(ctrl.solution)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <div>\n                <p>{{ctrl.task.description}}</p>\n                <md-input-container class=\"md-block\" ng-show=\"!ctrl.viewOnly\">\n                    <label for=\"edit-solution-response\">{{ctrl.task.textResponse}}</label>\n                    <textarea name=\"solution\" id=\"edit-solution-response\"\n                              ng-model=\"ctrl.solution\"\n                              required md-select-on-focus>\n                    </textarea>\n                    <div ng-messages=\"provideResponseForm.linkSolution.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div ng-show=\"ctrl.viewOnly\">\n                <md-divider></md-divider>\n                <!--<md-input-container class=\"md-block\">-->\n                    <!--<label for=\"view-solution-response\">{{ctrl.task.textResponse}}</label><br><br>-->\n                    <!--<textarea name=\"linkSolution\" id=\"view-solution-response\"-->\n                              <!--ng-model=\"ctrl.solution\"-->\n                              <!--required rows=\"3\" readonly>-->\n                    <!--</textarea>-->\n                <!--</md-input-container>-->\n                <div style=\"white-space: pre-wrap;\">{{ctrl.solution}}</div>\n                <md-divider></md-divider>\n            </div>\n            <div class=\"md-dialog-actions\" align=\"center\">\n                <md-button type=\"submit\" class=\"md-primary md-raised\" ng-hide=\"ctrl.viewOnly\" ng-disabled=\"!provideResponseForm.$valid\">\n                    Save\n                </md-button>\n                <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n            </div>\n        </md-dialog-content>\n\n    </form>\n</md-dialog>\n";editProfileTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"editProfileForm\" ng-submit=\"ctrl.save()\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <p>{{ctrl.task.description}}</p>\n            <!--<div ng-repeat=\"toEdit in ctrl.task.toEdit\" ng-if=\"!ctrl.participantInfo[ctrl.camelText(toEdit)]\">-->\n            <div ng-repeat=\"toEdit in ctrl.task.toEdit\">\n                <!--Enter your {{toEdit | lowercase}}-->\n                <div ng-if=\"ctrl.camelText(toEdit)==='yearOfBirth'\">\n                    <br>You are born in the year <b>{{ctrl.userData.yearOfBirth}}</b>.\n                    <md-select ng-model=\"ctrl.userData.yearOfBirth\" aria-label=\"select_yob\" required placeholder=\"Select your year of birth\">\n                        <md-option ng-value=\"year\" ng-repeat=\"year in ctrl.yearOpts\">\n                            {{year}}\n                        </md-option>\n                    </md-select>\n                </div>\n                <!--<div ng-if=\"ctrl.camelText(toEdit)==='country'\">-->\n                    <!--Editing Country.-->\n                <!--</div>-->\n                <div ng-if=\"ctrl.camelText(toEdit)==='school'\">\n                    <br> Your secondary school is <b>{{ctrl.userData.school.name}}</b>.\n                    <md-select ng-model=\"ctrl.userData.school\" aria-label=\"select_school\" required placeholder=\"Select your school\">\n                        <md-option ng-value=\"school\" ng-repeat=\"school in ctrl.schools\">\n                            {{school.name}}\n                        </md-option>\n                    </md-select>\n                </div>\n            </div>\n\n            <md-dialog-actions layout=\"row\" layout-align=\"center end\">\n                <div>\n                    <md-button type=\"submit\" class=\"md-primary md-raised\" ng-hide=\"ctrl.viewOnly\" ng-disabled=\"!editProfileForm.$valid\">\n                        Save\n                    </md-button>\n                </div>\n                <div>\n                    <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n                </div>\n            </md-dialog-actions>\n        </md-dialog-content>\n    </form>\n</md-dialog>";codeTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"enlarged-dialog\">\n    <form name=\"provideResponseForm\" ng-submit=\"ctrl.save()\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.task.title}}</md-subheader>\n            <div>\n                <p>{{ctrl.task.description}}</p>\n                <p>{{ctrl.task.textResponse}}</p>\n                <p>Language: {{ctrl.task.lang}}</p>\n                <div layout=\"row\" layout-sm=\"column\" layout-align=\"space-around\" ng-if=\"ctrl.checkEditor()\">\n                    <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n                </div>\n                <div id=\"editor\" ng-show=\"!ctrl.checkEditor()\">{{ctrl.solution}}</div>\n            </div>\n            <md-dialog-actions layout=\"row\" layout-align=\"center end\">\n                <div>\n                    <md-button type=\"submit\" class=\"md-primary md-raised\" ng-hide=\"ctrl.viewOnly\" ng-disabled=\"!provideResponseForm.$valid || ctrl.saveDisabled\">\n                        Save\n                    </md-button>\n                </div>\n                <div>\n                    <md-button ng-click=\"ctrl.cancel()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n                </div>\n            </md-dialog-actions>\n        </md-dialog-content>\n    </form>\n</md-dialog>";mcqTmpl$1="<md-dialog flex layout-padding aria-label=\"{{ctrl.task.title}}\">\n    <md-dialog-content>\n        <div layout='column' align=\"center\">\n    <h3>Multiple Choice</h3>\n    <h4>Title: {{ctrl.task.title}}</h4>\n    <h4>Description: {{ctrl.task.description}}</h4>\n    <br>\n  </div>\n\n  <form name=\"startMcq\" ng-submit=\"ctrl.submit()\">\n  <div layout-align=\"column\">\n\n      <!------------------starting of questions--------------------------------------------->\n      <div flex ng-repeat=\"question in ctrl.questions\">\n        <div align=\"start\" layout=\"column\" >\n          <label><h2>Question {{$index + 1}}</h2></label>\n          <md-divider></md-divider>\n          <label><h4>{{question.text}}</h4></label>\n        </div>\n\n        <!--answer's options-->\n        <div ng-show=\"!ctrl.show(question.answers)\">\n          <md-radio-group ng-model=\"question.answers\">\n            <div layout=\"column\" ng-repeat=\"option in question.options\">\n              <div layout=\"row\">\n                <div flex=\"80\">\n                  <label>{{$index + 1}}) {{option.text}}</label>\n                </div>\n                <div flex=\"20\">\n                  <md-radio-button aria-label=\"Is Selected\" ng-disabled=\"true\" value={{$index}} ng-checked=\"ctrl.isChecked(question.answers, $index)\"></md-radio-button>\n                </div>\n              </div>\n              <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n            </div>\n          </md-radio-group>\n        </div>\n\n        <div ng-show=\"ctrl.show(question.answers)\">\n          <div layout=\"column\" ng-repeat=\"option in question.options\">\n            <div layout=\"row\">\n              <div flex=\"80\">\n                <label>{{$index + 1}}) {{option.text}}</label>\n              </div>\n              <div flex=\"20\">\n                <md-checkbox aria-label=\"Is Checked\" ng-disabled=\"true\" ng-checked=\"ctrl.isChecked(question.answers, $index)\"></md-checkbox>\n              </div>\n            </div>\n            <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n          </div>\n        </div>\n        <!--<div align=\"center\" layout=\"row\" ng-repeat=\"option in question.options\" >-->\n          <!--&lt;!&ndash;single answer or no?&ndash;&gt;-->\n          <!--<div flex align=\"left\">-->\n            <!--<h4>{{option.text}}</h4>-->\n          <!--</div>-->\n          <!--<div flex=\"20\">-->\n          <!--<md-button ng-model=\"question.answers\" ng-class=\"question.answers.indexOf($index) != -1 ? 'md-raised md-primary' : 'md-raised'\"-->\n                     <!--ng-click=\"ctrl.toggleOption(question, $index)\">Answer</md-button>-->\n          <!--</div>-->\n          <!--<div flex=\"20\" ng-show=\"ctrl.multipleAns[$parent.$index]\">-->\n\n          <!--</div>-->\n          <!--<div flex=\"20\" ng-show=\"!ctrl.multipleAns[$parent.$index]\">-->\n            <!--<input type=\"radio\" name=\"answer\" value=\"$index\"/>-->\n          <!--</div>-->\n            <!--<md-divider ng-if=\"!$last\"></md-divider>-->\n        <!--</div>-->\n      </div>\n\n\n  </div>\n  <br/>\n  <div layout=\"row\" layout-align=\"center center\">\n      <!--todo: check if this page is used.-->\n    <md-button type=\"reset\" class=\"md-accent\" ng-click=\"ctrl.cancel()\">Cancel</md-button>\n  </div>\n  </form>\n    </md-dialog-content>\n</md-dialog>\n";voteQuestionTmpl="<md-dialog aria-label=\"{{ctrl.task.title}}\" class=\"md-padding enlarged-dialog\">\n  <form name='voteQuestion' ng-submit='ctrl.submit()'>\n    <md-dialog-content class=\"sticky-container\">\n      <div name='voteDialog' layout-align='column start' >\n          <div name='title'>\n              <h2>{{ctrl.title}}</h2>\n          </div>\n          <div name='desc'><label>{{ctrl.desc}}</label></div>\n          <div name='voting'>\n              <h4>Your question ranking:</h4>\n              <md-content class='md-padding autocomplete' layout='column'>\n                  <md-chips required ng-model='ctrl.rankedQuestions' md-require-match=\"true\" md-transform-chip='ctrl.validateChip($chip)'>\n                    <md-chip-template>\n                      <span>\n                        <strong>#{{$chip.rank}} {{$chip.member}}</strong>\n                      </span>\n                    </md-chip-template>\n                    <md-autocomplete\n                      md-search-text=\"ctrl.searchText\"\n                      md-autofocus='true'\n                      md-items='item in ctrl.queryMembers(ctrl.searchText)'\n                      placeholder='Rank Questions By User'\n                      md-match-case-insensitive='true'\n                      md-item-text='item.member'\n                      md-select-on-match='true'\n                      md-autoselect='true'\n                    >\n                    <md-item-template>\n                      <span md-highlight-text=\"searchText\">{{item.member}}</span>\n                    </md-item-template>\n                  </md-autocomplete>\n                  </md-chips>\n                  <span ng-show='ctrl.rankedQuestions.length != ctrl.allMemberAnswers.length'>\n                    You need to vote for all questions\n                  </span>\n              </md-content>\n              <md-content>\n                <md-list>\n                  <md-list-item class=\"md-3-line\" ng-repeat=\"item in ctrl.allMemberAnswers\" ng-click=\"ctrl.select(item)\">\n                    <div class=\"md-list-item-text\">\n                      <h3>{{item.member}}</h3>\n                      <p>{{item.answer}}</p>\n                      <p><i>Click here to vote for this question</i></p>\n                    </div>\n                    <md-divider ng-if=\"!$last\"></md-divider>\n                  </md-list-item>\n                </md-list>\n              </md-content>\n          </div>\n      </div>\n      <div layout='row' layout-align=\"center center\">\n          <md-button type='submit' ng-disabled=\"ctrl.rankedQuestions.length != ctrl.allMemberAnswers.length\" class=\"md-raised md-primary\" style=\"width: 150px;\">Submit and close\n          </md-button>\n          <md-button class=\"md-raised\" ng-click=\"ctrl.cancel()\" class=\" md-accent\" style=\"width: 150px;\">\n              Cancel\n          </md-button>\n      </div>\n    </md-dialog-content>\n  </form>\n</md-dialog>\n";reviewQuestionTmpl="<md-dialog class=\"md-padding \" >\n  <form name='submitReview' ng-submit=\"ctrl.submit()\">\n    <md-dialog-content class=\"sticky-container\">\n      <div>\n        <h3>Your Question:</h3>\n        <h4>{{ctrl.userQuestion}}</h4>\n      </div>\n      <div>\n        <label><h5>Select the appropriate response below for your question.</h5></label>\n        <md-content>\n          <md-radio-group ng-required=\"true\" ng-model=\"ctrl.answer\">\n            <div layout=\"column\" ng-repeat=\"option in ctrl.options\">\n              <div layout=\"row\">\n                <div flex=\"80\">\n                  <label>{{$index + 1}}) {{option.text}}</label>\n                </div>\n                <div flex=\"20\">\n                  <md-radio-button value={{$index}}></md-radio-button>\n                </div>\n              </div>\n              <md-divider layout-padding ng-if=\"!$last\"></md-divider>\n            </div>\n          </md-radio-group>\n        </md-content>\n      </div>\n      <br>\n      <div layout=\"row\" layout-align=\"center center\">\n        <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"submitReview.$invalid\" style=\"width: 150px;\">Done</md-button>\n        <md-button ng-click=\"ctrl.cancel()\" class=\" md-accent\" style=\"width: 150px;\">Cancel</md-button>\n\n      </div>\n    </md-dialog-content>\n  </form>\n</md-dialog>\n";schEngageScaleTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\" ng-submit=\"ctrl.submitSchEngageResponse(ctrl.schEngageResp)\">\n        <div>\n            <h1>School Engagement Scale</h1>\n        </div>\n        <div>\n            <h3>Please respond to the questions below using the following scale</h3>\n        </div>\n\n        <br>\n        <hr style=\"background: #808080; border: 0; height: 3px\"/>\n        <md-input container flex>\n            <table ng-repeat=\"(key, value) in ctrl.questions[2]\" width=\"100%\">\n                <tr ng-if=\"key == 1\">\n                    <td>\n                        <h3>Behavioural Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-if=\"key == 5\">\n                    <td>\n                        <h3>Emotional Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-if=\"key == 11\">\n                    <td>\n                        <h3>Cognitive Engagement</h3>\n                    </td>\n                </tr>\n                <tr ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\">\n                    <td ng-if=\"key != '0'\" style=\"width: 600px\">\n                        {{key}}. {{value}}\n                    </td>\n                    <td ng-if=\"key != '0'\">\n                        <md-radio-group layout=\"row\" ng-model=\"$parent.ans\" ng-change=\"ctrl.schEngageResp[key] = ans\" required>\n                            <div ng-repeat=\"(key2, value2) in ctrl.responseRating\">\n                                <md-radio-button style=\"margin-right:20px\" class=\"md-primary\"\n                                                 ng-value=\"value2.option\">\n                                    {{value2.option}}\n                                </md-radio-button>\n                            </div>\n                        </md-radio-group>\n                    </td>\n                </tr>\n\n            </table>\n            <br>\n        </md-input>\n\n        <div align=\"center\">\n            <md-button type=\"submit\" ng-disabled=\"surveyForm.$invalid\" class=\"md-raised md-primary\" style=\"width: 150px;\">Submit</md-button>\n            <md-button ng-click=\"ctrl.backToChallenge()\" class=\"md-accent\" style=\"width: 150px;\">\n                Discard\n            </md-button>\n        </div>\n    </form>\n</md-content>";motiStratLearnTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\" ng-submit=\"ctrl.submitMotiStratResponse(ctrl.motiResp)\">\n\n        <div>\n            <h1>Motivated Strategies for Learning</h1>\n        </div>\n        <div>\n            <h3>Please respond to the questions below using the following scale:</h3>\n        </div>\n        <div><b>1= not at all true of me</b></div>\n        <div><b>7=very true of me</b></div>\n        <br>\n        <hr style=\"background: #808080; border: 0; height: 3px\"/>\n        <br>\n        <md-input container flex>\n\n            <table ng-repeat=\"question in ctrl.questionsArr\" width=\"100%\">\n                <tr ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\" style=\"height: 50px\">\n                    <!--<div  style=\"height: 80px\">-->\n                    <td style=\"width:50px\">\n                        {{question.qnid}}.\n                    </td>\n                    <td style=\"width:700px\">\n                        {{question.name}}\n                    </td>\n                    <!--ng-change=\"ctrl.motiResp.push(ans)\"-->\n                    <td align=\"right\">\n                        <md-radio-group layout=\"row\" ng-model=\"ans\" ng-change=\"ctrl.motiResp[question.qnid] = ans\" required>\n                            <div ng-repeat=\"ratingOption in ctrl.ratingOptions\">\n                                <md-radio-button style=\"margin-right:60px\" class=\"md-primary\"\n                                                 ng-value=\"ratingOption.id\">\n                                    {{ratingOption.id}}\n                                </md-radio-button>\n                            </div>\n                        </md-radio-group>\n                    </td>\n                </tr>\n            </table>\n            <!--<clm-pager options=\"ctrl.pagerOpts\" class=\"md-padding\"></clm-pager>-->\n            <!--<pagination-->\n            <!--ng-model=\"currentPage\"-->\n            <!--total-items=\"questions.length\"-->\n            <!--max-size=\"maxSize\"-->\n            <!--boundary-links=\"true\">-->\n            <!--</pagination>-->\n\n        </md-input>\n\n        <div align=\"center\">\n            <md-button type=\"submit\" ng-disabled=\"surveyForm.$invalid\" class=\"md-primary md-raised\" style=\"width: 150px;\">Submit</md-button>\n            <md-button ng-click=\"ctrl.backToChallenge()\" class=\"md-accent\" style=\"width: 150px;\">\n                Discard\n            </md-button>\n        </div>\n    </form>\n\n</md-content>\n";eduDisLearnTmpl="<md-content flex class=\"md-padding\">\n    <form name=\"surveyForm\"\n          ng-submit=\"ctrl.submitEduDissResponse(ctrl.eduDissResp, ctrl.selectedFamily, ctrl.selectedRaceEthnicity)\">\n        <div>\n            <h1>Education vs Dissatisfaction with learning</h1>\n        </div>\n\n\n        <table ng-repeat=\"(key, value) in ctrl.questions[0]\" width=\"100%\">\n            <tr>\n                <td><h3>{{value.title}}</h3></td>\n            </tr>\n\n            <tr ng-if=\"key =='11'\">\n                <td>\n                    <textarea placeholder=\"Share some of your most exciting moments here!\" type=\"text\" cols=\"80\"\n                              rows=\"5\" style=\"max-width:500px; max-height: 200px\"\n                              ng-model=\"$parent.$parent.bestResponse\"\n                              ng-change=\"ctrl.eduDissResp[value.title] = bestResponse\" required></textarea>\n                </td>\n            </tr>\n\n            <!--to generate questions-->\n            <tr ng-if=\"key2 != 'title'\" ng-repeat=\"(key2, value2) in value\"\n                ng-class=\"'index-' + $index + ' ' + ($odd ? 'odd' : 'even')\" style=\"height:50px\">\n                <td style=\"width:800px\">\n                    {{value2}}\n                </td>\n\n                <td>\n                    <!--to generate radio button-->\n                    <md-radio-group ng-if=\"key != '6'\" layout=\"row\" ng-model=\"$parent.ansResp\"\n                                    ng-change=\"ctrl.eduDissResp[value.title][key2] = ansResp\" required>\n                        <div ng-repeat=\"ratingOption in ctrl.ratingOptions\">\n                            <md-radio-button style=\"margin-right:60px\" class=\"md-primary\" ng-value=\"ratingOption.id\">\n                                {{ratingOption.id}}\n                            </md-radio-button>\n                        </div>\n                    </md-radio-group>\n                    <div ng-if=\"key == '6'\">\n                        <div ng-if=\"key2 == '1'\">\n                            <input placeholder=\"State a valid age\" ng-model=\"$parent.$parent.age\" type=\"number\" min=\"3\"\n                                   style=\"width: 30%\" ng-change=\"ctrl.eduDissResp[value.title][key2] = age\" required /> years old\n                        </div>\n                        <div ng-if=\"key2 == '2'\">\n                            <table width=\"100%\">\n                                <tr>\n                                    <td ng-repeat=\"family in ctrl.familyMembers track by $index\">\n                                        <md-checkbox value=\"{{family.name}}\"\n                                                     ng-click=\"ctrl.toggle(family, ctrl.selectedFamily)\"\n                                                     ng-checked=\"ctrl.exists(family, ctrl.selectedFamily)\" required>\n                                            {{family.name}}\n                                        </md-checkbox>\n                                    </td>\n                                </tr>\n                            </table>\n                        </div>\n                        <div ng-if=\"key2 == '3'\">\n                            <input placeholder=\"Number of siblings\" ng-model=\"$parent.$parent.sib\" type=\"number\" min=\"0\"\n                                   style=\"width: 30%\" ng-change=\"ctrl.eduDissResp[value.title][key2] = sib\" required/>\n                        </div>\n                        <div ng-if=\"key2 == '4'\">\n                            <md-input-container flex>\n                                <label>Month</label>\n                                <md-select ng-model=\"$parent.$parent.selectedMonth\"\n                                           ng-change=\"ctrl.eduDissResp[value.title][key2] = selectedMonth\" required>\n                                    <md-option ng-repeat=\"bday in ctrl.bdayMonth\" ng-value=\"bday.month\">\n                                        {{bday.month}}\n                                    </md-option>\n                                </md-select>\n                            </md-input-container>\n                        </div>\n                        <div ng-if=\"key2 == '5'\">\n                            <table width=\"100%\">\n                                <tr>\n                                    <td ng-if=\"ethnic.firstRow\" ng-repeat=\"ethnic in ctrl.ethnicity track by $index\">\n                                        <md-checkbox ng-click=\"ctrl.toggle(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     ng-checked=\"ctrl.exists(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     value=\"{{ethnic.firstRow}}\">\n                                            {{ethnic.firstRow}}\n                                        </md-checkbox>\n                                    </td>\n                                </tr>\n                                <tr>\n                                    <td ng-if=\"ethnic.secondRow\" ng-repeat=\"ethnic in ctrl.ethnicity track by $index\">\n                                        <md-checkbox ng-click=\"ctrl.toggle(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     ng-checked=\"ctrl.exists(ethnic, ctrl.selectedRaceEthnicity)\"\n                                                     value=\"{{ethnic.secondRow}}\">\n                                            {{ethnic.secondRow}}\n                                        </md-checkbox>\n                                    </td>\n                                </tr>\n                            </table>\n                        </div>\n                        <div ng-if=\"key2 == '6'\">\n                            <input type=\"text\" placeholder=\"State a valid country\" ng-model=\"$parent.$parent.country\"\n                                   ng-change=\"ctrl.eduDissResp[value.title][key2] = country\" required/>\n\n                        </div>\n                        <div ng-if=\"key2 == '7'\">\n                            <input type=\"text\" placeholder=\"State a valid language\"\n                                   ng-model=\"$parent.$parent.spokenLanguage\"\n                                   ng-change=\"ctrl.eduDissResp[value.title][key2] = spokenLanguage\" required />\n                            for multiple languages, separate by a comma (,)\n                        </div>\n\n                    </div>\n                </td>\n            </tr>\n\n            <md-divider></md-divider>\n\n        </table>\n\n        <br>\n        <div align=\"center\">\n            <md-button ng-disabled=\"surveyForm.$invalid || ctrl.selectedRaceEthnicity.length == 0 || ctrl.selectedFamily.length == 0\" type=\"submit\" class=\"md-raised md-primary\"\n                       style=\"width: 150px;\">Submit\n            </md-button>\n            <md-button ng-click=\"ctrl.backToChallenge()\" class=\"md-accent\" style=\"width: 150px;\">\n                Discard\n            </md-button>\n        </div>\n\n    </form>\n</md-content>\n";noop$7=function noop(){return undefined;};TIMESTAMP$1={'.sv':'timestamp'};configRoute$3.$inject=['$routeProvider','routes'];eventServiceFactory.$inject=['$q','$route','spfAuthData','clmDataStore','$log','spfAlert'];classMentorsEventResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];ClmListEvent.$inject=['initialData','spfNavBarService','urlFor'];newEventCtrlInitialData.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];NewEventCtrl.$inject=['$q','$location','initialData','urlFor','spfAuthData','spfAlert','spfNavBarService','clmDataStore'];viewEventCtrlInitialData.$inject=['$q','$route','spfAuth','spfAuthData','clmDataStore'];ViewEventCtrl.$inject=['$scope','initialData','$document','$mdDialog','$route','spfAlert','urlFor','spfAuthData','spfNavBarService','clmDataStore','$sce'];editEventCtrllInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];EditEventCtrl.$inject=['initialData','spfNavBarService','urlFor','spfAlert','clmDataStore','firebaseApp','$firebaseArray','$mdDialog','$location'];addEventTaskCtrlInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];AddEventTaskCtrl.$inject=['initialData','$location','$log','spfAlert','urlFor','spfNavBarService','clmDataStore','$mdDialog','$scope','eventService','clmSurvey'];editEventTaskCtrlInitialData.$inject=['$q','$route','spfAuthData','clmDataStore'];EditEventTaskCtrl.$inject=['initialData','spfAlert','urlFor','spfNavBarService','clmDataStore','eventService','$mdDialog','$location','clmSurvey'];ClmEventTableCtrl.$inject=['$scope','$q','$log','$mdDialog','$document','urlFor','spfAlert','clmServicesUrl','clmDataStore','clmPagerOption','eventService','$location','routes','$route','spfAuthData','authFirebaseApp','firebaseApp','$firebaseArray','$firebaseObject','$routeParams'];addSurveyEventTaskCtrlInitialData.$inject=['$q','$route','firebaseApp','$firebaseArray','spfAuthData','clmDataStore'];SurveyFormFillCtrl.$inject=['spfNavBarService','$location','urlFor','initialData','$routeParams','clmDataStore','clmPagerOption','spfAlert','$scope','firebase'];ClmEventRankTableCtrl.$inject=['$log','$q','$filter','firebaseApp','$firebaseObject','$firebaseArray','clmDataStore'];ClmEventResultsTableCtrl.$inject=['$scope','$q','$log','$mdDialog','$document','urlFor','spfAlert','clmServicesUrl','clmDataStore','clmPagerOption','$sce','firebaseApp','$firebaseObject'];clmRowPerPageFactory.$inject=['$log'];clmPagerOptionFactory.$inject=['$log','clmRowPerPage'];ClmPagerCtrl.$inject=['clmRowPerPage'];events=Object.freeze({configRoute:configRoute$3,eventServiceFactory:eventServiceFactory,clmSurveyTaskFactory:clmSurveyTaskFactory,clmEventTableFactory:clmEventTableFactory,clmEventRankTableFactory:clmEventRankTableFactory,clmEventResultsTableFactory:clmEventResultsTableFactory,clmPagerFactory:clmPagerFactory,clmRowPerPageFactory:clmRowPerPageFactory,clmPagerOptionFactory:clmPagerOptionFactory});editTmpl$1="<md-content flex class=\"md-padding\">\n\n    <div ng-if=\"!ctrl.profile || ctrl.profileNeedsUpdate\">\n        <h1>Profile Setup</h1>\n\n        <form name=\"publicIdForm\" ng-submit=\"ctrl.setPublicId(ctrl.currentUser)\">\n            <spf-sign-form current-user=\"ctrl.currentUser\"></spf-sign-form>\n\n            <div layout=\"row\" layout-align=\"center center\">\n                <md-button type=\"submit\" class=\"md-raised md-primary\" ng-disabled=\"publicIdForm.$invalid || ctrl.settingPublicId\">\n                    Save\n                </md-button>\n                <md-button class=\"md-accent\" ng-click=\"ctrl.goBack()\">\n                    Back\n                </md-button>\n            </div>\n\n        </form>\n    </div>\n\n    <div ng-if=\"ctrl.profile && !ctrl.profileNeedsUpdate\" layout=\"row\" layout-wrap>\n        <div class=\"profile\" flex=\"33\" flex-sm=\"100\">\n            <div class=\"avatar\" md-whiteframe=\"1\">\n                <img ng-src=\"{{ctrl.profile.user.gravatar}}?s=200&amp;r=g&amp;d=mm\" alt=\"user avatar\">\n                <h2>\n                    {{ctrl.profile.user.displayName}}\n                </h2>\n                <h3 ng-if=\"ctrl.profile.user.school &amp;&amp; ctrl.profile.user.school.type != 'Other'\" layout=\"row\" layout-wrap layout-align=\"center center\">\n                    <span flex-gt-md=\"33\" flex=\"100\" ng-if=\"ctrl.profile.user.school.iconUrl\">\n                        <img ng-src=\"{{ctrl.profile.user.school.iconUrl}}\" alt=\"user school crest\">\n                    </span>\n                    <span flex-gt-md=\"66\" flex=\"100\">{{ctrl.profile.user.school.name}}</span>\n                </h3>\n            </div>\n        </div>\n\n        <div flex=\"66\" flex-sm=\"100\">\n\n            <clm-service-card service-id=\"freeCodeCamp\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://www.freecodecamp.com/{{name}}\"\n            >\n                <clm-description>\n                    <a href=\"https://www.freecodecamp.com\" target=\"_blank\">FreeCodeCamp</a>\n                    is an open source community of busy people who learn to code and help nonprofits.\n                </clm-description>\n            </clm-service-card>\n\n            <clm-service-card service-id=\"pivotalExpert\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://pivotal-expert.firebaseapp.com/#/profile/{{name}}\"\n            >\n                <clm-description>\n                   <a href=\"https://pivotal-expert.firebaseapp.com\" target=\"_blank\">Pivotal Expert</a>\n                   helps you to learn just enough programming to make yourself a more productive professional.\n                </clm-description>\n            </clm-service-card>\n\n            <clm-service-card service-id=\"codeCombat\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://codecombat.com/user/{{name}}\"\n            >\n                <clm-description>\n                    <a href=\"http://codecombat.com/\" target=\"_blank\">Code Combat</a>,\n                    learn to Code JavaScript by Playing a Game.\n                </clm-description>\n            </clm-service-card>\n\n        </div>\n    </div>\n\n</md-content>\n\n";showTmpl="<md-content flex class=\"md-padding\" layout=\"row\">\n    <div class=\"profile\" flex=\"33\">\n        <div class=\"avatar\" md-whiteframe=\"1\">\n            <img ng-src=\"{{ctrl.profile.user.gravatar}}?s=200&amp;r=g&amp;d=mm\" alt=\"user avatar\">\n            <h2>\n                {{ctrl.profile.user.displayName}}\n            </h2>\n            <h3 ng-if=\"ctrl.profile.user.school\" layout=\"row\" layout-align=\"center center\">\n                <span flex=\"33\"><img ng-src=\"{{ctrl.profile.user.school.iconUrl}}\" alt=\"user school crest\"></span>\n                <span flex=\"66\">{{ctrl.profile.user.school.name}}</span>\n            </h3>\n        </div>\n    </div>\n\n    <div flex=\"66\">\n\n        <clm-service-card service-id=\"freeCodeCamp\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n                profile-template=\"https://www.freecodecamp.com/{{name}}\"\n        >\n            <clm-description>\n                <a href=\"https://www.freecodecamp.com\" target=\"_blank\">FreeCodeCamp</a>\n                is an open source community of busy people who learn to code and help nonprofits.\n            </clm-description>\n        </clm-service-card>\n\n        <clm-service-card service-id=\"pivotalExpert\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n          profile-template=\"https://pivotal-expert.firebaseapp.com/#/profile/{{name}}\"\n        >\n            <clm-description>\n                <a href=\"https://pivotal-expert.firebaseapp.com\" target=\"_blank\">Pivotal Expert</a>\n                helps you to learn just enough programming to make yourself a more productive professional.\n            </clm-description>\n        </clm-service-card>\n\n        <clm-service-card service-id=\"codeCombat\" public-id=\"ctrl.profile.$id\" disable-refresh=\"ctrl.refreshTimeout\"\n          profile-template=\"https://codecombat.com/user/{{name}}\"\n        >\n            <!--<div ng-if=\"{{name}}\">Invalid name</div>-->\n            <clm-description>\n                <a href=\"http://codecombat.com/\" target=\"_blank\">Code Combat</a>,\n                learn to Code JavaScript by Playing a Game.\n            </clm-description>\n\n        </clm-service-card>\n\n    </div>\n\n</md-content>\n\n";noop$8=function noop(){return undefined;};configServices.$inject=['clmServices'];configRoute$4.$inject=['$routeProvider','routes'];clmEditProfileInitialDataResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];clmShowProfileInitialDataResolver.$inject=['$q','$route','spfAuth','spfAuthData','clmDataStore'];ClmProfileCtrl.$inject=['$log','$q','$timeout','$route','spfAuthData','spfNavBarService','initialData','clmDataStore','spfAlert','clmRefreshTimout'];profiles=Object.freeze({configServices:configServices,configRoute:configRoute$4});template$1="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<md-content flex class=\"md-padding\">\n    <md-content layout-align=\"center\">\n        <p>Classmentors is a small portal with big dreams. We want to change how educators conduct their classes and help students realise their potential through team activities and peer learning.</p>\n        <p>Your feedback would be greatly appreciated for the Classmentors team to continue making improvements to the site. Feedback here comes in two forms. You may choose to highlight an issue that you have found, such as a break or a functional issue, or simply provide your opinion on what you liked / disliked about the site.</p>\n        <md-content layout=\"row\" layout-align=\"center\">\n            <md-button ng-click=\"ctrl.toggleFeedbackType('issue')\" ng-class=\"{false:'md-raised', true:'md-raised md-primary'}[ctrl.feedbackType=='issue']\">\n                <md-icon class=\"material-icons\">report_problem</md-icon>\n                Identify Issue\n            </md-button>\n            <md-button ng-click=\"ctrl.toggleFeedbackType('general')\" ng-class=\"{false:'md-raised', true:'md-raised md-primary'}[ctrl.feedbackType=='general']\">\n                <md-icon class=\"material-icons\">thumbs_up_down</md-icon>\n                General Feedback\n            </md-button>\n            <md-button ng-if=\"ctrl.currentUser.$id=='HTIc4MVi5CWC4I9rsbM6x0AarN52' || ctrl.currentUser.$id=='google:113933988995739437762'\" ng-click=\"ctrl.toggleFeedbackType('view')\" ng-class=\"{false:'md-raised', true:'md-raised md-primary'}[ctrl.feedbackType=='view']\">\n                <md-icon class=\"material-icons\">thumbs_up_down</md-icon>\n                Raw Feedback\n            </md-button>\n        </md-content>\n        <br>\n        <md-divider></md-divider>\n        <br>\n        <div ng-if=\"ctrl.feedbackType=='issue'\">\n            <form name=\"issueForm\" ng-submit=\"ctrl.saveFeedback()\">\n                <md-switch ng-model=\"ctrl.anonimity\">Remain Anonymous? {{ctrl.anonimity ? \"Yes\":\"No\"}}</md-switch>\n                <md-input-container class=\"md-block\">\n                    <label>Issue Name</label>\n                    <input ng-model=\"ctrl.feedback.name\" md-maxlength=\"50\" required>\n                </md-input-container>\n                Please select the issue severity\n                <md-radio-group ng-model=\"ctrl.feedback.severity\" layout=\"row\" required>\n                    <md-radio-button value=1>1</md-radio-button>\n                    <md-radio-button value=2>2</md-radio-button>\n                    <md-radio-button value=3>3</md-radio-button>\n                    <md-radio-button value=4>4</md-radio-button>\n                    <md-radio-button value=5>5</md-radio-button>\n                </md-radio-group>\n                <md-input-container class=\"md-block\">\n                    <label>Issue Description</label>\n                    <textarea ng-model=\"ctrl.feedback.description\" md-maxlength=\"1000\" rows=\"3\" md-select-on-focus required placeholder=\"If possible, please describe the steps you took that eventually allowed you to arrive at discovering this issue.\"></textarea>\n                </md-input-container>\n                <div layout=\"row\" layout-align=\"center center\">\n                    <md-button type=\"submit\" class=\"md-raised md-primary\"\n                               ng-disabled=\"issueForm.$pristine || issueForm.$invalid\">\n                        Save\n                    </md-button>\n                    <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.reset()\"\n                               ng-disabled=\"issueForm.$pristine\">Reset\n                    </md-button>\n                </div>\n            </form>\n        </div>\n        <div ng-if=\"ctrl.feedbackType=='general'\">\n            <form name=\"generalForm\" ng-submit=\"ctrl.saveFeedback()\">\n                <md-switch ng-model=\"ctrl.anonimity\">Remain Anonymous? {{ctrl.anonimity ? \"Yes\":\"No\"}}</md-switch>\n                <md-input-container class=\"md-block\">\n                    <label>Feedback Title</label>\n                    <input ng-model=\"ctrl.feedback.name\" md-maxlength=\"50\" required>\n                </md-input-container>\n                Please classify your feedback. This helps us with estimating user sentiment.\n                <md-radio-group ng-model=\"ctrl.feedback.severity\" layout=\"row\" required>\n                    <md-radio-button value=\"+\">Positive</md-radio-button>\n                    <md-radio-button value=\"-\">Negative</md-radio-button>\n                </md-radio-group>\n                <md-input-container class=\"md-block\">\n                    <label>Feedback Description</label>\n                    <textarea ng-model=\"ctrl.feedback.description\" md-maxlength=\"1000\" rows=\"3\" md-select-on-focus required></textarea>\n                </md-input-container>\n                <div layout=\"row\" layout-align=\"center center\">\n                    <md-button type=\"submit\" class=\"md-raised md-primary\"\n                               ng-disabled=\"issueForm.$pristine || issueForm.$invalid\">\n                        Save\n                    </md-button>\n                    <md-button type=\"reset\" class=\"md-raised\" ng-click=\"ctrl.reset()\"\n                               ng-disabled=\"issueForm.$pristine\">Reset\n                    </md-button>\n                </div>\n            </form>\n        </div>\n        <div ng-if=\"ctrl.feedbackType=='view'\">\n            {{ctrl.allFeedback}};\n        </div>\n    </md-content>\n</md-content>";feedbackController.$inject=['initialData','spfNavBarService','urlFor','firebaseApp','spfAlert','$firebaseObject'];component$3={template:template$1,controller:feedbackController};configRoute$5.$inject=['$routeProvider','routes'];clmFeedbackResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];feedback=Object.freeze({component:component$3,configRoute:configRoute$5});qqHome="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<md-content class=\"md-padding\" layout-xs=\"column\" layout-align=\"center\">\n        <md-subheader>Events that I joined</md-subheader>\n        <div layout=\"row\" layout-wrap layout-align=\"center left\">\n            <md-card ng-repeat=\"event in ctrl.joinedEvents| orderBy:'-closedForum'\" flex=\"30\">\n                <md-card-title>\n                    <md-card-title-text>\n                        <span class=\"md-headline\">{{ event.title }}</span>\n                    </md-card-title-text>\n                </md-card-title>\n                <md-card-content>\n                    This question forum is <b><i ng-if=\"event.closedForum\">Closed</i><i ng-if=\"!event.closedForum\">Open</i></b>.\n                    <!--the chips goes here-->\n                    <br>\n                    <md-chips>\n                        <md-chip>{{(event.questions | countConditionally: ['answeredBy', false])}} open</md-chip>\n                        <md-chip class=\"md-accent\">{{(event.questions | countConditionally: ['answeredBy', true])}} closed</md-chip>\n                        <md-chip class=\"md-raised md-primary\">{{event.questions | countConditionally: ['flagged', true]}} instructor attention</md-chip>\n                    </md-chips>\n\n                </md-card-content>\n\n                <md-card-actions layout=\"row\" layout-align=\"end center\">\n\n                    <md-button class=\"md-icon-button\" aria-label=\"Go to Forum\" ng-href=\"#{{ 'eventQueue' | urlFor:{'eventId': event.$id} }}\">\n                        <md-tooltip md-direction=\"right\">\n                            Go to question forum\n                        </md-tooltip>\n                        <md-icon class=\"material-icons\" >open_in_new</md-icon>\n                    </md-button>\n                </md-card-actions>\n            </md-card>\n        </div>\n\n        <md-divider></md-divider>\n        <md-subheader>Events that I created</md-subheader>\n        <div layout=\"row\" layout-wrap layout-align=\"center left\">\n            <md-card ng-repeat=\"event in ctrl.createdEvents | orderBy:'-closedForum'\" flex=\"30\">\n                <md-card-title>\n                    <md-card-title-text>\n                        <span class=\"md-headline\">{{ event.title }}</span>\n                    </md-card-title-text>\n                </md-card-title>\n                <md-card-content>\n                    This question forum is <b><i ng-if=\"event.closedForum\">Closed</i><i ng-if=\"!event.closedForum\">Open</i></b>.\n                    <!--the chips goes here-->\n                    <br>\n                    <md-chips>\n                        <md-chip>{{(event.questions | countConditionally: ['answeredBy', false])}} open</md-chip>\n                        <md-chip class=\"md-accent\">{{(event.questions | countConditionally: ['answeredBy', true])}} closed</md-chip>\n                        <md-chip class=\"md-raised md-primary\">{{event.questions | countConditionally: ['flagged', true]}} instructor attention</md-chip>\n                    </md-chips>\n\n                </md-card-content>\n\n                <md-card-actions layout=\"row\" layout-align=\"end center\">\n                    <md-button class=\"md-icon-button\" aria-label=\"Go to Forum\" ng-href=\"#{{ 'eventQueue' | urlFor:{'eventId': event.$id} }}\">\n                        <md-tooltip md-direction=\"right\">\n                            Go to question forum\n                        </md-tooltip>\n                        <md-icon class=\"material-icons\">open_in_new</md-icon>\n                    </md-button>\n                </md-card-actions>\n            </md-card>\n        </div>\n\n        <md-divider></md-divider>\n\n        <md-subheader>Events that I am an assistant of</md-subheader>\n        <div layout=\"row\" layout-wrap layout-align=\"center left\">\n            <md-card ng-repeat=\"event in ctrl.asstEvents | orderBy:'-closedForum'\" flex=\"30\">\n                <md-card-title>\n                    <md-card-title-text>\n                        <span class=\"md-headline\">{{ event.title }}</span>\n                    </md-card-title-text>\n                </md-card-title>\n                <md-card-content>\n                    This question forum is <b><i ng-if=\"event.closedForum\"><font color=\"red\"> Closed</font></i><i ng-if=\"!event.closedForum\">Open</i></b>.\n                    <!--the chips goes here-->\n                    <br>\n                    <md-chips>\n                        <md-chip>{{(event.questions | countConditionally: ['answeredBy', false])}} open</md-chip>\n                        <md-chip class=\"md-accent\">{{(event.questions | countConditionally: ['answeredBy', true])}} closed</md-chip>\n                        <md-chip class=\"md-raised md-primary\">{{event.questions | countConditionally: ['flagged', true]}} instructor attention</md-chip>\n                    </md-chips>\n\n                </md-card-content>\n\n                <md-card-actions layout=\"row\" layout-align=\"end center\">\n                    <md-button class=\"md-icon-button\" aria-label=\"Go to Forum\" ng-href=\"#{{ 'eventQueue' | urlFor:{'eventId': event.$id} }}\">\n                        <md-tooltip md-direction=\"right\">\n                            Go to question forum\n                        </md-tooltip>\n                        <md-icon class=\"material-icons\" >open_in_new</md-icon>\n                    </md-button>\n                </md-card-actions>\n            </md-card>\n        </div>\n</md-content>";eventQ="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<md-content flex class=\"md-padding\">\n    <div layout=\"row\">\n        <md-chips>\n            <md-chip>{{(ctrl.questions | countConditionally: ['answeredBy', false])}} open</md-chip>\n            <md-chip class=\"md-accent\">{{(ctrl.questions | countConditionally: ['answeredBy', true])}} closed</md-chip>\n            <md-chip class=\"md-raised md-primary\">{{ctrl.questions | countConditionally: ['flagged', true]}} instructor attention</md-chip>\n        </md-chips>\n    </div>\n    <br>\n    <md-button ng-if=\"ctrl.event.owner.publicId != ctrl.currentUser.publicId && !ctrl.event.closedForum\" class=\"md-raised md-primary\" ng-click=\"ctrl.askNewQuestion(ctrl.event, ctrl.currentUser)\">Post Question</md-button>\n    <md-button disabled=\"\" ng-if=\"ctrl.event.owner.publicId != ctrl.currentUser.publicId && ctrl.event.closedForum\" class=\"md-raised md-primary\">Questions Disabled</md-button>\n    <md-checkbox ng-if=\"ctrl.event.owner.publicId == ctrl.currentUser.publicId\" ng-model=\"ctrl.event.closedForum\" ng-change=\"ctrl.toggleForumStatus()\">Close Event's Question Forum</md-checkbox>\n    <md-list>\n        <md-subheader class=\"md-no-sticky\">My posted questions</md-subheader>\n        <md-list-item ng-repeat=\"question in ctrl.questions | orderBy:'-'\" ng-if=\"question.owner.publicId == ctrl.currentUser.publicId\">\n            <div layout=\"column\" layout-align=\"end center\">\n                <md-button class=\"md-icon-button launch\" aria-label=\"Flag\" ng-disabled=\"question.owner.publicId != ctrl.currentUser.publicId\" ng-click=\"ctrl.toggleQnFlag(question)\">\n                    <md-icon ng-if=\"!question.flagged\" style=\"font-size: 30px\">error_outline</md-icon>\n                    <md-icon ng-if=\"question.flagged\" style=\"font-size: 30px; color: #F44336\">error_outline</md-icon>\n                </md-button>\n                <div style=\"font-size: 12px\" >Alert</div>\n                <div style=\"font-size: 12px\" >Educator</div>\n            </div>\n            <div layout=\"column\" layout-align=\"end center\">\n                <md-button class=\"md-icon-button launch\" aria-label=\"Vote\" ng-click=\"ctrl.toggleVote(question, question.$id)\">\n                    <md-icon ng-if=\"!question.upVotes || !question.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 30px\">thumb_up</md-icon>\n                    <md-icon ng-if=\"question.upVotes && question.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 30px; color: #FFC107;\">thumb_up</md-icon>\n                </md-button><div style=\"font-size: 12px\" >{{question.upVotes | countObjKeys}} vote(s)</div>\n            </div>\n            <div layout=\"column\" layout-align=\"end start\" class=\"md-list-item-text\" flex>\n                <div style=\"font-size: 20px\" ng-if=\"question.answeredBy\">{{question.title}} (Closed)</div>\n                <div style=\"font-size: 20px\" ng-if=\"!question.answeredBy\">{{question.title}} (Open)</div>\n                <div style=\"font-size: 10px; color:grey;\">Posted by {{question.owner.displayName}} ({{question.createdAt | date:'dd/MM/yy hh:mma'}})</div>\n            </div>\n            <md-button class=\"md-padding\" ng-href=\"#{{ 'oneQuestion' | urlFor:{'eventId': ctrl.event.$id, 'questionId': question.$id} }}\">\n                <md-icon style=\"font-size: 30px\">sms</md-icon>\n                <div>View {{question.respondedBy | countObjKeys}} answer(s)</div>\n            </md-button>\n            <md-divider ng-if=\"!$last\"></md-divider>\n            <div ng-if=\"!$last\"></div>\n        </md-list-item>\n        <!--<md-button class=\"md-raised\" ng-click=\"ctrl.expandMyQns()\">Show More</md-button>-->\n        <!--<md-button ng-if=\"ctrl.myQnLimit > 1\" class=\"md-accent\" ng-click=\"ctrl.collapseMyQns()\">Show Less</md-button>-->\n    </md-list>\n\n    <md-list>\n        <md-subheader class=\"md-no-sticky\">All questions (Ranked by # votes)</md-subheader>\n        <md-list-item ng-repeat=\"question in ctrl.questions | orderBy:['-upVotes | countObjKeys', '-createdAt']\">\n            <div layout=\"column\" layout-align=\"end center\">\n                <md-button class=\"md-icon-button launch\" aria-label=\"Flag\" ng-disabled=\"question.owner.publicId != ctrl.currentUser.publicId\" ng-click=\"ctrl.toggleQnFlag(question)\">\n                    <md-icon ng-if=\"!question.flagged\" style=\"font-size: 30px\">error_outline</md-icon>\n                    <md-icon ng-if=\"question.flagged\" style=\"font-size: 30px; color: #F44336\">error_outline</md-icon>\n                </md-button>\n                <div style=\"font-size: 12px\" >Alert</div>\n                <div style=\"font-size: 12px\" >Educator</div>\n            </div>\n            <div layout=\"column\" layout-align=\"end center\">\n                <md-button class=\"md-icon-button launch\" aria-label=\"Vote\" ng-click=\"ctrl.toggleVote(question, question.$id)\">\n                    <md-icon ng-if=\"!question.upVotes || !question.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 30px\">thumb_up</md-icon>\n                    <md-icon ng-if=\"question.upVotes && question.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 30px; color: #FFC107;\">thumb_up</md-icon>\n                </md-button><div style=\"font-size: 12px\" >{{question.upVotes | countObjKeys}} vote(s)</div>\n            </div>\n            <div layout=\"column\" layout-align=\"end start\" class=\"md-list-item-text\" flex>\n                <div style=\"font-size: 20px\" ng-if=\"question.answeredBy\">{{question.title}} (Closed)</div>\n                <div style=\"font-size: 20px\" ng-if=\"!question.answeredBy\">{{question.title}} (Open)</div>\n                <div style=\"font-size: 10px; color:grey;\">Posted by {{question.owner.displayName}} ({{question.createdAt | date:'dd/MM/yy hh:mma'}})</div>\n            </div>\n            <md-button class=\"md-padding\" ng-href=\"#{{ 'oneQuestion' | urlFor:{'eventId': ctrl.event.$id, 'questionId': question.$id} }}\">\n                <md-icon style=\"font-size: 30px\">sms</md-icon>\n                <div>View {{question.respondedBy | countObjKeys}} answer(s)</div>\n            </md-button>\n            <md-divider ng-if=\"!$last\"></md-divider>\n            <div ng-if=\"!$last\"></div>\n        </md-list-item>\n        <!--<md-button class=\"md-raised\" ng-click=\"ctrl.expandVoteQns()\">Show More</md-button>-->\n        <!--<md-button ng-if=\"ctrl.voteQnLimit > 1\" class=\"md-accent\" ng-click=\"ctrl.collapseVoteQns()\">Show Less</md-button>-->\n    </md-list>\n</md-content>";oneQn="<link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\">\n<md-content flex class=\"md-padding\">\n    <div layout=\"row\">\n        <div layout=\"column\" layout-align=\"end center\">\n            <md-button class=\"md-icon-button launch\" aria-label=\"Flag\" ng-click=\"ctrl.toggleQnFlag()\" ng-disabled=\"ctrl.question.owner.publicId != ctrl.currentUser.publicId\">\n                <md-icon ng-if=\"!ctrl.question.flagged\" style=\"font-size: 30px\">error_outline</md-icon>\n                <md-icon ng-if=\"ctrl.question.flagged\" style=\"font-size: 30px; color: #F44336\">error_outline</md-icon>\n            </md-button>\n            <div style=\"font-size: 12px\" >Alert</div>\n            <div style=\"font-size: 12px\" >Educator</div>\n        </div>\n        <div layout=\"column\" layout-align=\"center center\" flex=\"10\">\n            <md-button class=\"md-icon-button launch\" aria-label=\"Vote\" ng-click=\"ctrl.toggleQnVote(ctrl.question, ctrl.question.$id)\">\n                <md-icon ng-if=\"!ctrl.question.upVotes || !ctrl.question.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 35px\">thumb_up</md-icon>\n                <md-icon ng-if=\"ctrl.question.upVotes && ctrl.question.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 35px; color: #FFC107;\">thumb_up</md-icon>\n            </md-button>\n            <div style=\"font-size: 15px\" >{{ctrl.question.upVotes | countObjKeys}} vote(s)</div>\n        </div>\n        <div layout=\"column\" flex>\n            <div style=\"font-size: 20px\">{{ctrl.question.title}}</div>\n            <div style=\"font-size: 10px; color:grey;\">Posted by {{ctrl.question.owner.displayName}} ({{ctrl.question.createdAt | date:'dd/MM/yy hh:mma'}})</div>\n            <div style=\"font-size: 15px;\">{{ctrl.question.body}}</div>\n        </div>\n        <md-button ng-if=\"!ctrl.question.answeredBy\" class=\"md-raised md-primary\" ng-click=\"ctrl.answerQuestion(ctrl.event.$id, ctrl.question.$id, ctrl.currentUser)\">Post a Response</md-button>\n        <md-button ng-if=\"ctrl.question.answeredBy\" class=\"md-raised\" ng-disabled=\"true\">Question closed</md-button>\n    </div>\n\n    <!--<md-list>-->\n        <!--<md-list-item ng-repeat=\"answer in ctrl.answers | orderBy:['acceptedAt', '-upVotes | countObjKeys', '-createdAt']\" layout=\"row\">-->\n            <!--<div layout=\"column\" layout-align=\"center center\" ng-show=\"ctrl.question.owner.publicId == ctrl.currentUser.publicId\">-->\n                <!--<md-button class=\"md-icon-button launch\" ng-if=\"!answer.acceptedAt\" ng-click=\"ctrl.toggleAskerChoice(answer.$id, false, answer)\">-->\n                    <!--<md-icon ng-style=\"{'font-size': '30px'}\">star_rate</md-icon>-->\n                <!--</md-button>-->\n                <!--<md-button class=\"md-icon-button launch\" ng-if=\"answer.acceptedAt\" ng-click=\"ctrl.toggleAskerChoice(answer.$id, true, answer)\">-->\n                    <!--<md-icon ng-style=\"{'font-size': '30px', color: 'orange'}\">star_rate</md-icon>-->\n                <!--</md-button>-->\n                <!--<div style=\"font-size: 15px\" ng-if=\"answer.acceptedAt\">Asker's</div>-->\n                <!--<div style=\"font-size: 15px\" ng-if=\"answer.acceptedAt\">Choice</div>-->\n            <!--</div>-->\n            <!--<div layout=\"column\" layout-align=\"center center\" ng-show=\"answer.acceptedAt && ctrl.question.owner.publicId != ctrl.currentUser.publicId\">-->\n                <!--<md-icon ng-style=\"{color: 'yellow', 'font-size': '30px'}\">star_rate</md-icon>-->\n                <!--<div style=\"font-size: 15px\" >Asker's</div>-->\n                <!--<div style=\"font-size: 15px\" >Choice</div>-->\n            <!--</div>-->\n            <!--<div layout=\"column\" layout-align=\"center center\" flex=\"10\">-->\n                <!--<md-button class=\"md-icon-button launch\" aria-label=\"Vote\" ng-click=\"ctrl.toggleAnsVote(ctrl.question.$id, answer)\">-->\n                    <!--<md-icon ng-if=\"!answer.upVotes || !answer.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 35px\">thumb_up</md-icon>-->\n                    <!--<md-icon ng-if=\"answer.upVotes && answer.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 35px; color: orange;\">thumb_up</md-icon>-->\n                <!--</md-button>-->\n                <!--<div style=\"font-size: 15px\" >{{answer.upVotes | countObjKeys}} vote(s)</div>-->\n            <!--</div>-->\n            <!--<div layout=\"column\" flex>-->\n                <!--<div style=\"font-size: 10px; color:grey;\">Posted by {{answer.owner.displayName}} ({{ctrl.question.createdAt | date:'dd/MM/yy hh:mma'}})</div>-->\n                <!--<div style=\"white-space: pre-wrap; font-size: 15px;\">{{answer.body}}</div>-->\n            <!--</div>-->\n    <!--</md-list-item>-->\n    <!--</md-list>-->\n    <md-content layout=\"row\" layout-wrap>\n        <md-card ng-repeat=\"answer in ctrl.answers | orderBy:['acceptedAt', '-upVotes | countObjKeys', '-createdAt']\" flex=\"49\">\n            <md-card-title>\n                <md-card-title-text>\n                    <span class=\"md-subhead\">Posted by {{answer.owner.displayName}} ({{ctrl.question.createdAt | date:'dd/MM/yy hh:mma'}})</span>\n                </md-card-title-text>\n            </md-card-title>\n            <md-card-content layout=\"row\" layout-align=\"space-between\">\n                <p style=\"max-width: 360px; white-space: pre-wrap; word-wrap: break-word; overflow: auto; font-size: 15px;\" layout-wrap>{{answer.body}}</p>\n\n                <md-card-actions layout=\"column\">\n                    <div layout=\"column\" layout-align=\"center center\" ng-show=\"ctrl.question.owner.publicId == ctrl.currentUser.publicId\">\n                        <md-button class=\"md-icon-button launch\" ng-if=\"!answer.acceptedAt\" ng-click=\"ctrl.toggleAskerChoice(answer.$id, false, answer)\">\n                            <md-icon ng-style=\"{'font-size': '30px'}\">star_rate</md-icon>\n                        </md-button>\n                        <md-button class=\"md-icon-button launch\" ng-if=\"answer.acceptedAt\" ng-click=\"ctrl.toggleAskerChoice(answer.$id, true, answer)\">\n                            <md-icon ng-style=\"{'font-size': '30px', color: '#FFEB3B'}\">star_rate</md-icon>\n                        </md-button>\n                        <div style=\"font-size: 15px\" ng-if=\"answer.acceptedAt\">Asker's</div>\n                        <div style=\"font-size: 15px\" ng-if=\"answer.acceptedAt\">Choice</div>\n                    </div>\n                    <div layout=\"column\" layout-align=\"center center\" ng-show=\"answer.acceptedAt && ctrl.question.owner.publicId != ctrl.currentUser.publicId\">\n                        <md-icon ng-style=\"{color: '#FFEB3B', 'font-size': '30px'}\">star_rate</md-icon>\n                        <div style=\"font-size: 15px\" >Asker's</div>\n                        <div style=\"font-size: 15px\" >Choice</div>\n                    </div>\n                    <md-button class=\"md-icon-button launch\" aria-label=\"Vote\" ng-click=\"ctrl.toggleAnsVote(ctrl.question.$id, answer)\">\n                        <md-icon ng-if=\"!answer.upVotes || !answer.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 35px\">thumb_up</md-icon>\n                        <md-icon ng-if=\"answer.upVotes && answer.upVotes[ctrl.currentUser.publicId]\" style=\"font-size: 35px; color: #FFC107;\">thumb_up</md-icon>\n                    </md-button>\n                    <div style=\"font-size: 15px\">{{answer.upVotes | countObjKeys}} vote(s)</div>\n                </md-card-actions>\n            </md-card-content>\n        </md-card>\n    </md-content>\n</md-content>";askQnTmpl="<md-dialog aria-label=\"askQuestion\" class=\"question-dialog\">\n    <form name=\"newQuestionForm\" ng-submit=\"ctrl.postQn()\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">{{ctrl.event.title}}</md-subheader>\n            <div>\n                <md-input-container class=\"md-block\">\n                    <label for=\"question-title\">Title</label>\n                    <input type=\"text\" name=\"qnTitle\" id=\"question-title\"\n                              ng-model=\"ctrl.question.title\"\n                              required md-select-on-focus>\n                    </input>\n                    <div ng-messages=\"newQuestionForm.question-title.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div>\n                <md-input-container class=\"md-block\">\n                    <label for=\"question-body\">Question</label>\n                    <textarea name=\"qnBody\" id=\"question-body\"\n                           ng-model=\"ctrl.question.body\"\n                           required md-select-on-focus md-maxlength=\"300\" rows=\"3\">\n                    </textarea>\n                    <div ng-messages=\"newQuestionForm.question-body.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div class=\"md-dialog-actions\" align=\"center\">\n                <md-button type=\"submit\" class=\"md-primary md-raised\" ng-disabled=\"!newQuestionForm.$valid\">\n                    Post\n                </md-button>\n                <md-button ng-click=\"ctrl.closeDialog()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>\n";ansQnTmpl="<md-dialog aria-label=\"askQuestion\" class=\"question-dialog\">\n    <form name=\"answerForm\" ng-submit=\"ctrl.answerQn(ctrl.event.$id, ctrl.question.$id, ctrl.currentUser)\">\n        <md-dialog-content class=\"sticky-container\">\n            <md-subheader class=\"md-sticky-no-effect\">Question Queue - Response</md-subheader>\n            <div>\n                <md-input-container class=\"md-block\">\n                    <label for=\"answer-body\">Your Response</label>\n                    <textarea name=\"ansBody\" id=\"answer-body\"\n                              ng-model=\"ctrl.answer.body\"\n                              required md-select-on-focus md-maxlength=\"500\" rows=\"3\">\n                    </textarea>\n                    <div ng-messages=\"answerForm.answer-body.$error\">\n                        <div ng-message=\"required\">Required.</div>\n                    </div>\n                </md-input-container>\n            </div>\n            <div class=\"md-dialog-actions\" align=\"center\">\n                <md-button type=\"submit\" class=\"md-primary md-raised\" ng-disabled=\"!answerForm.$valid\">\n                    Post\n                </md-button>\n                <md-button ng-click=\"ctrl.closeDialog()\" type=\"button\" class=\"md-accent\">Cancel</md-button>\n            </div>\n        </md-dialog-content>\n    </form>\n</md-dialog>\n";qqController.$inject=['initialData','spfNavBarService','urlFor','firebaseApp','spfAlert','$firebaseObject','clmDataStore','$q'];eventQController.$inject=['initialData','spfNavBarService','urlFor','firebaseApp','spfAlert','$firebaseObject','$mdDialog','$document','clmDataStore'];oneQnController.$inject=['initialData','spfNavBarService','urlFor','firebaseApp','spfAlert','$firebaseObject','$document','clmDataStore','$mdDialog'];configRoute$6.$inject=['$routeProvider','routes'];clmQQResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore'];eventQResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore','$route'];oneQnResolver.$inject=['$q','spfAuth','spfAuthData','clmDataStore','$route'];questionQueue=Object.freeze({configRoute:configRoute$6});template$2="<md-content flex layout-padding>\n\n    <p ng-if=\"$ctrl.loading\">Loading...</p>\n\n    <div ng-messages=\"$ctrl.errors\" role=\"alert\">\n    <p ng-message=\"login\">You need to be logged in to edit the application settings.</p>\n    <p ng-message=\"register\">You need to be registered in to edit the application settings.</p>\n    <p ng-message=\"admin\">You need to be registered in to edit the application settings.</p>\n    <p ng-message=\"admin\">You need to be registered in to edit the application settings.</p>\n    <p ng-message=\"loading\">Failed to load this view.</p>\n  </div>\n\n    <div id=\"settings\" ng-if=\"$ctrl.loaded\">\n\n        <div id=\"settings-switches\">\n            <h2 class=\"md-title\">Switches</h2>\n\n            <p ng-if=\"$ctrl.switches.length == 0\">No setting to switch.</p>\n          \n          <md-switch\n              ng-repeat=\"setting in $ctrl.switches track by setting.$id\"\n              ng-model=\"setting.value\"\n              ng-disabled=\"!$ctrl.currentUser.isAdmin\"\n              ng-change=\"$ctrl.settings.$save(setting)\"\n          >\n              {{setting.title}}.\n          </md-switch>\n        </div>\n\n        <div id=\"settings-input\">\n            <h2 class=\"md-title\">Other settings</h2>\n\n            <p ng-if=\"$ctrl.inputs.length == 0\">No setting to edit.</p>\n            \n            <md-input-container class=\"md-block\"\n                ng-repeat=\"setting in $ctrl.inputs track by setting.$id\"\n            >\n          <label>{{setting.title}}</label>\n          <input\n            ng-model=\"setting.value\"\n            ng-disabled=\"!$ctrl.currentUser.isAdmin\"\n            ng-change=\"$ctrl.settings.$save(setting)\"\n          />\n        </md-input-container>\n        </div>\n     </div>\n \n </md-content>";AdminCtrl=function(){function AdminCtrl($q,$log,spfNavBarService,spfCurrentUser,clmDataStore){var _this=this;_classCallCheck(this,AdminCtrl);this.$log=$log;this.$clmDataStore=clmDataStore;this.$watchers=[];this.errors={};this.loading=true;this.loaded=false;this.currentUser=spfCurrentUser;this.settings=this.$clmDataStore.settings.get();this.switches=[];this.inputs=[];spfNavBarService.update('Application Settings');$q.all([this.settings.$loaded(),this.currentUser.$loaded()]).then(function(){return _this.ready();}).catch(function(err){return _this.failed(err);});}_createClass(AdminCtrl,[{key:'ready',value:function ready(){var _this2=this;this.loading=false;this.loaded=true;this.checkAccess(this.currentUser);this.filterSettings();this.$watchers.push(this.currentUser.$watch(function(){return _this2.checkAccess(_this2.currentUser);}));this.$watchers.push(this.settings.$watch(function(){return _this2.filterSettings();}));}},{key:'failed',value:function failed(err){this.loading=false;this.loaded=false;this.errors.loading=true;this.$log.error(err);}},{key:'checkAccess',value:function checkAccess(user){this.errors.register=false;this.errors.admin=false;this.errors.login=user.uid===null;if(!user.uid){return;}this.errors.register=user.publicId===null;if(!user.publicId){return;}this.errors.admin=!user.isAdmin;}},{key:'filterSettings',value:function filterSettings(){var _this3=this;this.switches=[];this.inputs=[];this.settings.forEach(function(setting){if(setting.type==='boolean'){_this3.switches.push(setting);}else{_this3.inputs.push(setting);}});}},{key:'$onDestroy',value:function $onDestroy(){var _this4=this;this.$watchers.forEach(function(fn){try{fn();}catch(e){_this4.$log.error(e);}});}}]);return AdminCtrl;}();AdminCtrl.$inject=['$q','$log','spfNavBarService','spfCurrentUser','clmDataStore'];component$4={template:template$2,controller:AdminCtrl};configRoute$7.$inject=['$routeProvider','routes'];/**
 * Default export holds object to register with the Angular API.
 *
 * @type {Object}
 */admin={component:component$4,configRoute:configRoute$7};formTemplate="<md-dialog aria-label=\"Link service profile\" layout-padding style=\"min-width: 50%\">\n\n    <md-dialog-content>\n        <form name=\"service-dialog-form\" ng-submit=\"$ctrl.save($ctrl.name)\">\n\n            <h3 class=\"md-title\">Link your {{$ctrl.$card.service.name}} profile</h3>\n            <h4 class=\"md-subhead\"><a ng-href=\"{{$ctrl.profileUrl}}\">{{$ctrl.profileUrl}}</a></h4>\n\n            <div layout>\n                <md-input-container flex>\n                    <label>\n                        Your {{$ctrl.service.name}} username\n                    </label>\n                    <input name=\"userName\" ng-model=\"$ctrl.name\" required ng-change=\"$ctrl.onNameChanged()\">\n                </md-input-container>\n            </div>\n\n        </form>\n\n    </md-dialog-content>\n\n    <md-dialog-actions>\n        <md-button ng-click=\"$ctrl.save($ctrl.name)\" class=\"md-primary\">Save</md-button>\n        <!--// class of button-->\n        <md-button ng-click=\"$ctrl.close()\" class=\"md-accent\">Close</md-button>\n    </md-dialog-actions>\n\n</md-dialog>\n";template$3="<md-card ng=\"$ctrl.canEdit || $ctrl.data.details.id\" ng-attr-id=\"{{$ctrl.serviceId}}-service-card\">\n\n    <div ng-transclude=\"serviceForm\" style=\"visibility: hidden\">\n        <clm-service-form class=\"md-dialog-container\"></clm-service-form>\n    </div>\n\n    <md-card-header>\n        <md-card-header-text>\n            <span class=\"md-headline\">{{$ctrl.service.name}}</span>\n            <span class=\"md-subhead\" ng-if=\"$ctrl.data.details.id\">\n                Registered as\n                <a ng-href=\"{{$ctrl.profileUrl}}\" target=\"_blank\">{{$ctrl.data.details.name}}</a>\n            </span>\n        </md-card-header-text>\n    </md-card-header>\n\n    <md-card-content ng-if=\"$ctrl.canEdit && !$ctrl.data.details.id\">\n\n        <p ng-transclude=\"description\"><i>Service description...</i></p>\n\n    </md-card-content>\n\n    <md-card-content ng-if=\"$ctrl.data.details.id\">\n        <p>{{$ctrl.data.totalAchievements || 0}}  achievements</p>\n    </md-card-content>\n\n    <md-card-actions layout=\"row\" layout-align=\"end center\" ng-if=\"$ctrl.canEdit\">\n        <md-button  type=\"button\"\n            class=\"md-raised md-primary\"\n            ng-if=\"!$ctrl.data.details.id\"\n            ng-click=\" $ctrl.showAddDialog($event, '#' + $ctrl.serviceId + '-service-card .md-dialog-container')\"\n        >\n            Add My {{$ctrl.service.name}} profile\n        </md-button>\n        <md-button type=\"button\"\n            class=\"md-primary\"\n            ng-if=\"$ctrl.data.details.id\"\n            ng-click=\"$ctrl.refresh()\"\n            ng-disabled=\"!$ctrl.canRefresh\"\n            ng-switch=\"$ctrl.canRefresh\"\n            aria-label=\"Refresh Achievements\"\n        >\n            <!--\n                We allow to send a refresh request even if the service data is\n                still updating (the last request might have been lost).\n            -->\n            <span ng-switch-when=\"true\">Refresh Achievements</span>\n            <span ng-switch-default ng-switch=\"$ctrl.updating\">\n                <span ng-switch-when=\"true\">Updating...</span>\n                <span ng-switch-default>Wait to refresh again...</span>\n            </span>\n        </md-button>\n        <md-button type=\"button\" class=\"md-warn\" ng-if=\"$ctrl.data.details.id\" ng-click=\"$ctrl.remove()\">Remove</md-button>\n    </md-card-actions>\n\n</md-card>\n";noop$9=function noop(){return undefined;};ServiceCardCtrl=function(){/**
   * clm-service-card controller constructor
   *
   * @param {$compile.directive.Attributes} $attrs Controllers normalized DOM element attributes .
   * @param {jqLite}   $document       JqLite wrapper for the window document.
   * @param {function} $firebaseObject AngularFire sync. object factory
   * @param {function} $interpolate    Angular template compiler.
   * @param {object}   $log            Angular logging service.
   * @param {object}   $mdDialog       Angular Material dialog service.
   * @param {function} $q              Angular promise service.
   * @param {function} $timeout        Angular timeout service.
   * @param {object}   clmServices     List 3rd party services.
   * @param {object}   spfAlert        singpath-core alert service.
   * @param {object}   spfCurrentUser  currentUser data.
   */function ServiceCardCtrl($attrs,$document,$firebaseObject,$interpolate,$log,$mdDialog,$q,$timeout,clmServices,spfAlert,spfCurrentUser,clmRefreshTimout){var _this=this;_classCallCheck(this,ServiceCardCtrl);/**
     * singpath-core alert service.
     * @type {object}
     * @private
     */this.$alert=spfAlert;/**
     * Angular Material dialog service.
     * @type {object}
     * @private
     */this.$dialog=$mdDialog;/**
     * jqLite reference to the `document`.
     * @type {array}
     * @private
     */this.$document=$document;/**
     * AngularFire synchronized object service.
     * @type {function(ref: firebase.database.Reference)}
     * @private
     */this.$firebaseObject=$firebaseObject;/**
     * Angular logger service.
     * @type {object}
     * @private
     */this.$log=$log;/**
     * Angular promise service.
     * @type {function}
     * @private
     */this.$q=$q;/**
     * List of 3rd party service manager.
     * @type {Map<string,Service>}
     * @private
     */this.$services=clmServices;/**
     * Angular timeout service.
     * @type {function}
     */this.$timeout=$timeout;/**
     * Current user service
     * @type {{publicId: string, $watch: function(handler: function): function(): void}}
     */this.currentUser=spfCurrentUser;/**
     * The ctrl will stop watching for user changes when this function is called.
     *
     * Should be called when the component is destroyed.
     *
     * @type {function}
     * @private
     */this.$unwatchUser=this.currentUser.$watch(function(){return _this.watchData();});/**
     * Third party service "service" - used to interact with the user data for
     * that service.
     *
     * @type {?{
     *         dataRef: function(publicId: string): firebase.database.Reference,
     *         requestUpdate: function(publicId: string): Promise<void, Error>,
     *         saveDetails: function(publicId: string, data: {id: string, name: string}): Promise<void, Error>
     *       }}
     */this.service=undefined;/**
     * The user service data.
     *
     * @type {?{
     *         lastUpdate: number,
     *         lastUpdateRequest: number,
     *         details: {id: string, name: string, registeredBefore: string},
     *         totalAchievements: number
     *       }}
     */this.data=undefined;/**
     * The ctrl will stop watching for data when this function is called.
     *
     * Should be called on a publicId or serviceId changes
     * @type {function}
     * @private
     */this.$unwatchData=noop$9;/**
     * URL to the user profile for that service
     * @type {?string}
     */this.profileUrl=undefined;/**
     * Build a profile url using the user service details.
     *
     * We retrieve the URL template from the component "profile-template" html
     * attribute before Angular interpolate it. We need to interpolate it
     * ourself and provide the user service details.
     *
     * @type {function(scope: object): string}
     */this.$profileUrlTemplate=$interpolate($attrs.profileTemplate,false,undefined,true);// flags
/**
     * Should set true while the controller is loading resources.
     * @type {Boolean}
     */this.loading=false;/**
     * Should set the true if the profile owner is the current user.
     *
     * @todo should admin or premium users be allowed to edit
     * @type {Boolean}
     */this.canEdit=false;/**
     * Should be set to true during a pending refresh request.
     * @type {Boolean}
     */this.updating=false;/**
     * Should be set false while the last refresh request is too recent.
     * @type {Boolean}
     */this.canRefresh=false;/**
     * Timer for the resfresh button
     * @type {?Promise<void,Error>}
     */this.$disableRefresh=undefined;/**
     * Timer delay
     * @type {number}
     */this.$timoutDelay=clmRefreshTimout;}/* Angular Controller hooks *//* see https://docs.angularjs.org/api/ng/service/$compile#life-cycle-hooks *//**
   * Called by angular when component bindings changes.
   *
   * Should reset flags, `service` and `data` related properties.
   *
   * @param {object} changes list of changes.
   */_createClass(ServiceCardCtrl,[{key:'$onChanges',value:function $onChanges(changes){if(changes.publicId||changes.serviceId){this.watchData();}if(changes.disableRefresh){this.setCanRefresh();}}/**
   * Called when the componet is getting removed from the DOM.
   *
   * Should stop watching for current user or profile user service data changes,
   * and release the data synchronized object.
   */},{key:'$onDestroy',value:function $onDestroy(){this.$unwatchData();this.$unwatchUser();if(this.data&&this.data.$destroy){this.data.$destroy();}if(this.$disableRefresh){this.$timeout.cancel(this.$disableRefresh);this.$disableRefresh=undefined;}}/* private methodes *//**
   * Create the service profile synchronized object and listen for changes.
   *
   * Changes should update flag properties.
   *
   * @private
   */},{key:'watchData',value:function watchData(){var _this2=this;this.service=this.$services[this.serviceId];this.loading=true;this.updating=false;this.profileUrl=undefined;this.canEdit=Boolean(this.currentUser.publicId&&this.publicId===this.currentUser.publicId);this.$unwatchData();if(this.data&&this.data.$destroy){this.data.$destroy();}var ref=this.service.dataRef(this.publicId);this.data=this.$firebaseObject(ref);this.$unwatchData=this.data.$watch(function(){return _this2.onDataChanged();});}/**
   * Service data change (details, lastUpdate or lastUpdateRequest) handler.
   *
   * @private
   */},{key:'onDataChanged',value:function onDataChanged(){this.loading=false;if(!this.data||this.data.$value===null||!this.data.details){this.updating=false;this.profileUrl=undefined;return;}this.setProfileUrl();this.setUpdating();}/**
   * Update `canRefresh` propety.
   *
   * @private
   * @return {Promise<void>}
   */},{key:'setCanRefresh',value:function setCanRefresh(){var _this3=this;var timers=[this.disableRefresh,this.$disableRefresh].filter(function(t){return t&&t.then!==undefined;});this.canRefresh=false;return this.$q.all(timers).then(function(){_this3.canRefresh=true;_this3.$disableRefresh=undefined;});}/**
   * Update 'updating' property.
   *
   * Service data are updating they have no lastUpdate property of it's lower
   * than the lastUpdateRequest.
   *
   * @private
   */},{key:'setUpdating',value:function setUpdating(){var lastUpdateRequest=this.data.lastUpdateRequest||0;var lastUpdate=this.data.lastUpdate||0;this.updating=lastUpdate<lastUpdateRequest;}/**
   * Update profileUrl property.
   *
   * @private
   */},{key:'setProfileUrl',value:function setProfileUrl(){this.profileUrl=this.$profileUrlTemplate(this.data&&this.data.details);}/* public methodes *//**
   * Show the form to add a user's service user name.
   *
   * @param  {Object} $event   Click event.
   * @param  {string} selector Selector to find the the dialog form.
   * @return {Promise<void, any>}
   */},{key:'showAddDialog',value:function showAddDialog($event,selector){return this.$dialog.show({targetEvent:$event,contentElement:selector,parent:this.$document.find('body'),clickOutsideToClose:true});}/**
   * Request a service profile update.
   *
   * @return {Promise<void>}
   */},{key:'refresh',value:function refresh(){var _this4=this;if(!this.canRefresh){return Promise.reject(new Error('Refresh is currently disable.'));}this.canRefresh=false;return this.service.requestUpdate(this.publicId).then(function(){_this4.$disableRefresh=_this4.$timeout(_this4.$timoutDelay);_this4.setCanRefresh();}).catch(function(err){_this4.canRefresh=true;_this4.$log.error(err);_this4.$alert.error('Failed to request a '+_this4.service.name+' profile update.');});}/**
   * Removed the user service profile.
   *
   * @return {Promise<void>}
   */},{key:'remove',value:function remove(){var _this5=this;return this.service.removeDetails(this.publicId).then(function(){return _this5.$alert.success('Unliked '+_this5.service.name+' profile.');}).catch(function(err){_this5.$log.error(err);_this5.$alert.error('Failed to unlink your '+_this5.service.name+' profile.');});}}]);return ServiceCardCtrl;}();ServiceCardCtrl.$inject=['$attrs','$document','$firebaseObject','$interpolate','$log','$mdDialog','$q','$timeout','clmServices','spfAlert','spfCurrentUser','clmRefreshTimout'];/**
 * "clm-service-card" component settings.
 *
 * @example
 * <!-- using default form -->
 * <clm-service-card public-id="$ctrl.publicId" service-id="myService" disable-refresh="$ctrl.refreshTimeout">
 *   <clm-description>myService let you gain achievements...</clm-description>
 * </clm-service-card>
 *
 * @example
 *  <!-- using custom dialog form -->
 *  <clm-service-card public-id="$ctrl.publicId" service-id="myService" disable-refresh="$ctrl.refreshTimeout">
 *    <clm-description>myService let you gain achievements...</clm-description>
 *    <clm-service-form>
 *      <md-dialog aria-label="Link service profile" layout-padding style="min-width: 50%">
 *        <md-dialog-content>
 *          <form name="service-dialog-form" ng-submit="$ctrl.save($ctrl.newName)">
 *            <md-input-container flex>
 *              <label>
 *                Your username
 *              </label>
 *              <input name="userName" ng-model="$ctrl.newName" required">
 *            </md-input-container>
 *          </form>
 *        </md-dialog-content>
 *        <md-dialog-actions>
 *          <md-button ng-click="$ctrl.createService($ctrl.newName)" class="md-primary">Save</md-button>
 *          <md-button ng-click="$ctrl.closeDialog()">Close</md-button>
 *        </md-dialog-actions>
 *      </md-dialog>
 *    </clm-service-form>
 *  </clm-service-card>
 *
 * @type {Object}
 */component$5={template:template$3,// `transclude` allows to pass some HTML content which the component can
// include in its internal DOM. Note that the  HTML content will be
// interpolated using the outer scope, not the component scope.
transclude:{// angular will clone the child "clm-description" element to insert
// it inside the component (using
// `<div ng-transclude-slot="description"></div>` in the service-card
// template).
description:'clmDescription',// angular will clone the child "clm-service-form" element to insert
// it inside the component (using
// `<div ng-transclude-slot="serviceForm"></div>` in the service-card
// template).
serviceForm:'?clmServiceForm'},// component attributes (`public-id` and `service-id`) bound and synchronized
// to the component controller instance as (`publicId` and `serviceId`
// properties).
bindings:{publicId:'<',serviceId:'@',disableRefresh:'<'},// controller which an instance will accessible as `$ctrl` in the component
// template.
controller:ServiceCardCtrl};GenericServiceFormCtrl=function(){/**
   * clm-service-form controller contructor.
   *
   * Expect a $card property referencing the parent "clm-service-card"
   * controller instance.
   *
   * @param  {object} $log       Angular logging service.
   * @param  {object} $mdDialog  Angular Material dialog service.
   * @param  {object} spfAlert   singpath-core alert service.
   */function GenericServiceFormCtrl($log,$mdDialog,spfAlert){_classCallCheck(this,GenericServiceFormCtrl);/**
     * Angular logging service.
     * @type {{error: function(msg: string): void}}
     * @private
     */this.$log=$log;/**
     * Angular Material dialog service.
     * @type {{hide: function(result: any): Promise}, cancel: function(result: any): Promise}}
     * @private
     */this.$dialog=$mdDialog;/**
     * Singpath Core alert service
     * @type {{sucess: function(msg: string): void, error: function(msg: string): void}}
     * @private
     */this.$alert=spfAlert;/**
     * The user name for that service
     * @type {?string}
     */this.name=undefined;/**
     * The URL to that profile
     * @type {string}
     */this.profileUrl=undefined;}/* Angular Controller hook(s) *//* see https://docs.angularjs.org/api/ng/service/$compile#life-cycle-hooks *//**
   * Called once bindings are setup.
   *
   * Should set the default profileUrl.
   */_createClass(GenericServiceFormCtrl,[{key:'$onInit',value:function $onInit(){this.setProfileUrl();}/* private method(s) */},{key:'setProfileUrl',value:function setProfileUrl(){this.profileUrl=this.$card.$profileUrlTemplate({id:this.name||'<user-name>',name:this.name||'<user-name>'});}/* public methods *//**
   * Update the ctrl state after changes to the name property.
   *
   * Should update the default profileUrl.
   */},{key:'onNameChanged',value:function onNameChanged(){// console.log("Service card info:", this.$card.service.name);
// console.log("Selected ID: ", this.name);
if(this.$card.service.name=='Code Combat'){this.name=this.name.toLowerCase().replace(" ","-");}// console.log("New ID: ", this.name);
this.setProfileUrl();}/**
   * Save the user details for that service.
   *
   * @param  {string} name The user name for that service.
   * @return {Promise<void, Error>}
   */},{key:'save',value:function save(name){var _this6=this;return this.$card.service.saveDetails(this.$card.publicId,{id:name,name:name}).then(function(){_this6.$alert.success(_this6.$card.service.name+' profile linked.');return _this6.$dialog.hide();},function(err){_this6.$alert.error('Failed to link your '+_this6.$card.service.name+' profile.');return Promise.reject(err);}).catch(function(err){_this6.$log.error(err);return Promise.reject(err);});}/**
   * Close the dialog without saving the details.
   *
   * @return {Promise<void>}
   */},{key:'close',value:function close(){return this.$dialog.cancel();}}]);return GenericServiceFormCtrl;}();GenericServiceFormCtrl.$inject=['$log','$mdDialog','spfAlert'];/**
 * "clm-service-form" component definition.
 *
 * Used for the default service name form dialog. Can be used as an example
 * or a base for more advance linking process.
 *
 * @type {Object}
 */serviceForm={template:formTemplate,// The parent clm-service-card controller will be added as a "$card" property
// to this component controller.
require:{$card:'^^clmServiceCard'},controller:GenericServiceFormCtrl};serviceCard={component:component$5,serviceForm:{component:serviceForm}};components$1={ace:ace$2,admin:admin,challenges:challenges,classmentors:classmentors,cohorts:cohorts,events:events,profiles:profiles,serviceCard:serviceCard,feedback:feedback,questionQueue:questionQueue};_export('module',module$1=angular$1.module('clm',['angular-loading-bar','firebase','ngAnimate','ngMessages','ngRoute','timer',spfShared.name]));module$1.value('clmServicesUrl',{backend:'http://api.singpath.com/',singPath:'http://www.singpath.com/',codeCombat:'https://codecombat.com',codeSchool:'https://www.codeschool.com'});// module.component('challenges', components.challenges.component);
module$1.component('ace',components$1.ace.component);module$1.component('classmentors',components$1.classmentors.component);module$1.component('clmAdmin',components$1.admin.component);module$1.component('clmServiceCard',components$1.serviceCard.component);module$1.component('clmServiceForm',components$1.serviceCard.serviceForm.component);module$1.config(components$1.ace.configRoute);module$1.config(components$1.admin.configRoute);module$1.constant('aceStatsUrl',components$1.ace.ACE_STATS_URL);module$1.constant('clmRefreshTimout',60000);module$1.constant('spfProfilesPath','classMentors/userProfiles');module$1.directive('clmCohortsRankingPage',components$1.cohorts.clmCohortRankPageFactory);module$1.directive('clmCohortsStatsPage',components$1.cohorts.clmCohortsStatsPageFactory);module$1.directive('clmEventRankTable',components$1.events.clmEventRankTableFactory);module$1.directive('clmEventResultsTable',components$1.events.clmEventResultsTableFactory);module$1.directive('clmEventTable',components$1.events.clmEventTableFactory);module$1.directive('clmPager',components$1.events.clmPagerFactory);module$1.directive('cmContains',cmContainsFactory);module$1.directive('scrollBottom',components$1.challenges.scrollBottom);module$1.factory('aceStats',components$1.ace.factory);module$1.factory('challengeService',components$1.challenges.challengeServiceFactory);module$1.factory('clmDataStore',clmDataStoreFactory);module$1.factory('clmPagerOption',components$1.events.clmPagerOptionFactory);module$1.factory('clmRowPerPage',components$1.events.clmRowPerPageFactory);module$1.factory('clmServices',clmServicesFactory);module$1.factory('eventService',components$1.events.eventServiceFactory);module$1.filter('cmTruncate',cmTruncateFilterFactory);module$1.filter('cmTruncated',cmTruncateFilterBooleanFactory);module$1.filter('showSchool',showSchoolFilterFactory);module$1.filter('showTeamMembers',showTeamMembersFilterFactory);module$1.filter('countObjKeys',countObjKeysFactory);module$1.filter('displayMentorship',displayMentorshipFactory);module$1.filter('countConditionally',countConditionallyFilterFactory);// module.filter('reverseArray', filters.reverseArray);
//for page controls in trat
module$1.run(components$1.profiles.configServices);module$1.factory('quizFactory',components$1.challenges.tratQuestionFactory);// TODO: convert those view controller/template to component and move them above
module$1.config(components$1.cohorts.configRoute);module$1.config(components$1.feedback.configRoute);module$1.config(components$1.questionQueue.configRoute);module$1.config(components$1.events.configRoute);module$1.config(components$1.profiles.configRoute);module$1.config(components$1.challenges.configRoute);// module.config(components.challenges.teamActivity.configRoute);
// added new survey factory for tryout purpose
module$1.factory('clmSurvey',components$1.events.clmSurveyTaskFactory);//no back list:
noBackList={"/events/:eventId/challenges/:taskId/mcq/start":true,'/events/:eventId/challenges/:taskId/TRAT/start':true};thisCurrentRoute=null;thisTaskId=null;routeChangeStartListener=function routeChangeStartListener(event,nextRoute,currentRoute){var nextRoutePath=nextRoute.$$route.originalPath;var nextTaskId=nextRoute.params.taskId;if(noBackList[nextRoutePath]&&nextTaskId==thisTaskId){event.preventDefault();window.history.forward();}};routeChangeSuccessListener=function routeChangeSuccessListener(event,nextRoute,currentRoute){thisCurrentRoute=currentRoute.$$route.originalPath;thisTaskId=currentRoute.params.taskId;};;routeProtection.$inject=['$rootScope','$location'];// Passing callback for routeProtection
module$1.run(routeProtection);/**
 * Label route paths.
 *
 * Required for singpath-core/services/routes.js and its "urlFor" service and
 * filter.
 *
 * Should be used to configure $routeProvider.
 *
 */module$1.constant('routes',{home:'/ace-of-coders',// The default route
aceOfCoders:'/ace-of-coders',nationalCodingChampionships:'/ncc',// Not yet implemented
admin:'/admin',events:'/events',newEvent:'/new-event',oneEvent:'/events/:eventId',editEvent:'/events/:eventId/edit',editEventTask:'/events/:eventId/task/:taskId',addEventTask:'/events/:eventId/new-task',profile:'/profile/:publicId',editProfile:'/profile/',cohorts:'/cohorts',newCohort:'/new-cohort',viewCohort:'/cohorts/:cohortId',editCohort:'/cohorts/:cohortId/edit',viewMcq:'/challenges/mcq',startMcq:'/events/:eventId/challenges/:taskId/mcq/start',editMcq:'/challenges/mcq/edit',viewSurvey:'/challenges/survey/:eventTitle/:eventId/:task',editSurvey:'/challenges/editSurvey/:eventId/:taskId/:task',createTeamActivity:'/challenges/team-activity/create',viewIRAT:'/challenges/IRAT',viewTRAT:'/events/:eventId/challenges/:taskId/TRAT/start',feedback:'/feedback',questionQueue:'/question-queue',eventQueue:'/question-queue/:eventId',oneQuestion:'/question-queue/:eventId/questions/:questionId',indexCard:'/challenges/team-activity/indexCard',viewMentorCreation:'/challenges/mentoring-activity/create',viewSchEngagePreview:'/challenges/survey1/:eventTitle/:eventId/:task/:surveyType',viewMotiStratPreview:'/challenges/survey2/:eventTitle/:eventId/:task/:surveyType',viewEduDissPreview:'/challenges/survey3/:eventTitle/:eventId/:task/:surveyType'});_export('module',module$1);_export('bootstrap',bootstrap);}};});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[a](d.createTextNode(c));})
("/*! \n * angular-loading-bar v0.8.0\n * https://chieffancypants.github.io/angular-loading-bar\n * Copyright (c) 2015 Wes Cruver\n * License: MIT\n */#loading-bar,#loading-bar-spinner{pointer-events:none;-webkit-pointer-events:none;-webkit-transition:all .35s linear;transition:all .35s linear}#loading-bar-spinner.ng-enter,#loading-bar-spinner.ng-leave.ng-leave-active,#loading-bar.ng-enter,#loading-bar.ng-leave.ng-leave-active{opacity:0}#loading-bar-spinner.ng-enter.ng-enter-active,#loading-bar-spinner.ng-leave,#loading-bar.ng-enter.ng-enter-active,#loading-bar.ng-leave{opacity:1}#loading-bar .bar{-webkit-transition:width .35s;transition:width .35s;background:#29d;position:fixed;z-index:10002;top:0;left:0;width:100%;height:2px;border-bottom-right-radius:1px;border-top-right-radius:1px}#loading-bar .peg{position:absolute;width:70px;right:0;top:0;height:2px;opacity:.45;-ms-box-shadow:#29d 1px 0 6px 1px;box-shadow:1px 0 6px 1px #29d;border-radius:100%}#loading-bar-spinner{display:block;position:fixed;z-index:10002;top:10px;left:10px}#loading-bar-spinner .spinner-icon{width:14px;height:14px;border:2px solid transparent;border-top-color:#29d;border-left-color:#29d;border-radius:50%;-webkit-animation:loading-bar-spinner .4s linear infinite;animation:loading-bar-spinner .4s linear infinite}@-webkit-keyframes loading-bar-spinner{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes loading-bar-spinner{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}body p,html p{line-height:1.25}#loading-bar .bar{background:#ffc107;height:5px;border-bottom-right-radius:2px;border-top-right-radius:2px}#loading-bar .peg{height:5px;-ms-box-shadow:#ffc107 1px 0 6px 1px;box-shadow:1px 0 6px 1px #ffc107}.md-button{margin:16px 8px;padding:0 8px;line-height:36px}.md-button.md-icon-button.small-icon{height:36px;width:36px;line-height:36px;margin:0}.small-icon md-icon{line-height:18px;height:18px;width:18px}.md-accent md-icon g{fill:rgba(0,0,0,.87)}md-sidenav md-list .md-button{color:inherit;font-weight:500;text-align:left;width:100%;padding:16px;margin:0;line-height:normal}md-toolbar .separator{width:48px;height:28px}md-icon:focus{outline:none}.even{background-color:#eee}table .md-button{margin:4px}@media (max-width:600px){.responsive-button{min-width:0;padding:0 12px}}thead th{vertical-align:top}spf-editor-container label{color:#000;color:rgba(0,0,0,.258824);cursor:default;padding:20px 0 5px 2px}spf-editor-container div[ng-message],spf-editor-container label{display:block;font-family:RobotoDraft,Roboto,Helvetica Neue,sans-serif}spf-editor-container div[ng-message]{color:#000;color:rgba(0,0,0,.870588);font-size:12px;height:24px;line-height:24px}spf-editor-container.is-invalid.had-focus div[ng-message],spf-editor-container.is-invalid.had-focus label,spf-editor-container.is-invalid.has-focus div[ng-message],spf-editor-container.is-invalid.has-focus label{color:#ff5722}spf-editor-container.has-focus label,spf-editor-container:not(.is-empty) label{-webkit-transition:-webkit-transform .25s cubic-bezier(.25,.8,.25,1);transition:-webkit-transform .25s cubic-bezier(.25,.8,.25,1);transition:transform .25s cubic-bezier(.25,.8,.25,1);transition:transform .25s cubic-bezier(.25,.8,.25,1),-webkit-transform .25s cubic-bezier(.25,.8,.25,1);-webkit-transform:translate3d(0,4px,0) scale(.75);transform:translate3d(0,4px,0) scale(.75);-webkit-transform-origin:left bottom;transform-origin:left bottom}spf-editor-container.is-valid div[ng-message],spf-editor-container.is-valid label{color:#000;color:rgba(0,0,0,.541176)}.spf-ace-editor{height:200px}.nav-parent>*{font-size:inherit}.menu-item.ng-enter,.menu-item.ng-leave,.menu-item.ng-move{-webkit-transition:all .3s linear;transition:all .3s linear}.menu-item.ng-enter,.menu-item.ng-leave.ng-leave-active,.menu-item.ng-move{max-width:0;min-width:0;margin:16px 0;padding:0;overflow:hidden}.menu-item.ng-enter.ng-enter-active,.menu-item.ng-leave,.menu-item.ng-move.ng-move-active{margin:16px 8px;padding:0 8px;max-width:150px;min-width:24px}#vertical-container{height:292px;width:100%;max-width:400px}classmentors{height:100%;width:100%}md-sidenav.md-locked-open{width:250px;min-width:250px;max-width:250px}md-icon.material-icons{font-size:22px}.c3 svg{font:10px sans-serif;-webkit-tap-highlight-color:transparent}.c3 line,.c3 path{fill:none;stroke:#000}.c3 text{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.c3-bars path,.c3-event-rect,.c3-legend-item-tile,.c3-xgrid-focus,.c3-ygrid{shape-rendering:crispEdges}.c3-chart-arc path{stroke:#fff}.c3-chart-arc text{fill:#fff;font-size:13px}.c3-grid line{stroke:#aaa}.c3-grid text{fill:#aaa}.c3-xgrid,.c3-ygrid{stroke-dasharray:3 3}.c3-text.c3-empty{fill:gray;font-size:2em}.c3-line{stroke-width:1px}.c3-circle._expanded_{stroke-width:1px;stroke:#fff}.c3-selected-circle{fill:#fff;stroke-width:2px}.c3-bar{stroke-width:0}.c3-bar._expanded_{fill-opacity:.75}.c3-target.c3-focused{opacity:1}.c3-target.c3-focused path.c3-line,.c3-target.c3-focused path.c3-step{stroke-width:2px}.c3-target.c3-defocused{opacity:.3!important}.c3-region{fill:#4682b4;fill-opacity:.1}.c3-brush .extent{fill-opacity:.1}.c3-legend-item{font-size:12px}.c3-legend-item-hidden{opacity:.15}.c3-legend-background{opacity:.75;fill:#fff;stroke:#d3d3d3;stroke-width:1}.c3-title{font:14px sans-serif}.c3-tooltip-container{z-index:10}.c3-tooltip{border-collapse:collapse;border-spacing:0;background-color:#fff;empty-cells:show;box-shadow:7px 7px 12px -9px #777;opacity:.9}.c3-tooltip tr{border:1px solid #ccc}.c3-tooltip th{background-color:#aaa;font-size:14px;padding:2px 5px;text-align:left;color:#fff}.c3-tooltip td{font-size:13px;padding:3px 6px;background-color:#fff;border-left:1px dotted #999}.c3-tooltip td>span{display:inline-block;width:10px;height:10px;margin-right:6px}.c3-tooltip td.value{text-align:right}.c3-area{stroke-width:0;opacity:.2}.c3-chart-arcs-title{dominant-baseline:middle;font-size:1.3em}.c3-chart-arcs .c3-chart-arcs-background{fill:#e0e0e0;stroke:none}.c3-chart-arcs .c3-chart-arcs-gauge-unit{fill:#000;font-size:16px}.c3-chart-arcs .c3-chart-arcs-gauge-max,.c3-chart-arcs .c3-chart-arcs-gauge-min{fill:#777}.c3-chart-arc .c3-gauge-value{fill:#000}.collapsable{display:inline-block;overflow:hidden;height:0;width:100%;transition:height 1s;-webkit-transition:height 1s;-moz-transition:height 1s;-o-transition:height 1s}div.subhead{font-style:italic;font-size:10px}div.information{font-style:italic;font-size:15px}md-dialog.announcement-dialog{max-width:70%;max-height:85%;width:70%;height:85%;border-radius:0}.selectdemoSelectHeader .demo-header-searchbox{border:none;outline:none;height:100%;width:100%;padding:0}.selectdemoSelectHeader .demo-select-header{box-shadow:0 1px 0 0 rgba(0,0,0,.1),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);padding-left:10.667px;height:48px;cursor:pointer;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:auto}.selectdemoSelectHeader md-content._md{max-height:240px}md-virtual-repeat-container{height:292px;width:100%}div.repeated-item{border-bottom:1px solid #ddd;box-sizing:border-box;height:40px;padding-top:10px}.virtualRepeatdemoInfiniteScroll md-content{margin:16px}md-virtual-repeat-container{border:1px solid grey}md-virtual-repeat-container .md-virtual-repeat-offsetter div{padding-left:16px}md-tooltip ._md-content{height:auto}.events td,.events th{text-align:center;padding:0 10px}.tasks tbody th:first-child{text-align:left;padding-left:0}.reversed th.orderer .md-button:after,.secondaryReversed th.secondaryOrderer .md-button:after{content:\" \\25BC\";font-size:12px}th.orderer .md-button:after,th.secondaryOrderer .md-button:after{content:\" \\25B2\";font-size:12px}th.secondaryOrderer .md-button:after{color:#ddd}.name-button{text-align:left;width:100%}#editor{top:0;right:0;bottom:0;left:0;height:400px;width:15000px;max-height:90%;max-width:100%}md-dialog.enlarged-dialog{max-width:70%;max-height:90%;width:70%;height:90%;border-radius:0}md-dialog.link-dialog{max-width:70%;max-height:50%;width:70%;height:50%;border-radius:0}.collapsable,.collapsableTask{display:inline-block;overflow:hidden;height:0;transition:height 1s;-webkit-transition:height 1s;-moz-transition:height 1s;-o-transition:height 1s}.collapsableTask{width:100%;word-wrap:break-word}.showMe,.showMe2{height:auto}.profile{text-align:center;padding:8px}.profile .avatar{background-color:#fff;padding:8px}.badge img,.profile img{max-width:100%;height:auto;display:inline-block}.register-service,.service-card,.spf-card{padding:8px 16px;margin:16px 0}.badges img,.courses img,.language svg{text-align:center;position:relative;-webkit-box-reflect:below 0 -webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(70%,transparent),to(hsla(0,0%,100%,.2)));-webkit-transition:top .5s ease-out;-moz-transition:top .5s ease-out;-o-transition:top .5s ease-out}.badges{background-color:transparent;border:none;box-shadow:none}.badges img:hover{cursor:pointer;top:-5px;-webkit-box-reflect:below 10px -webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(70%,transparent),to(hsla(0,0%,100%,.2)))}.spf-card .language{margin:16px 0}.spf-card md-icon{height:30px;width:55px}md-dialog.question-dialog{max-width:60%;max-height:50%;width:60%;height:50%;border-radius:0}\n/*# sourceMappingURL=__.css.map */");
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define(["angular-animate","angular-messages","angular-route","angular","angular-material","angularfire","firebase","d3"], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory(require("angular-animate"), require("angular-messages"), require("angular-route"), require("angular"), require("angular-material"), require("angularfire"), require("firebase"), require("d3"));
  else
    classmentors = factory(angular, angular, angular, angular, angular, angular, firebase, d3);
});